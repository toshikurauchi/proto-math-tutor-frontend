// modules are defined as an array
// [ module function, map of requires ]
//
// map of requires is short require name -> numeric require
//
// anything defined in a previous bundle is accessed via the
// orig method which is the require for previous bundles

(function (modules, entry, mainEntry, parcelRequireName, globalName) {
  /* eslint-disable no-undef */
  var globalObject =
    typeof globalThis !== 'undefined'
      ? globalThis
      : typeof self !== 'undefined'
      ? self
      : typeof window !== 'undefined'
      ? window
      : typeof global !== 'undefined'
      ? global
      : {};
  /* eslint-enable no-undef */

  // Save the require from previous bundle to this closure if any
  var previousRequire =
    typeof globalObject[parcelRequireName] === 'function' &&
    globalObject[parcelRequireName];

  var cache = previousRequire.cache || {};
  // Do not use `require` to prevent Webpack from trying to bundle this call
  var nodeRequire =
    typeof module !== 'undefined' &&
    typeof module.require === 'function' &&
    module.require.bind(module);

  function newRequire(name, jumped) {
    if (!cache[name]) {
      if (!modules[name]) {
        // if we cannot find the module within our internal map or
        // cache jump to the current global require ie. the last bundle
        // that was added to the page.
        var currentRequire =
          typeof globalObject[parcelRequireName] === 'function' &&
          globalObject[parcelRequireName];
        if (!jumped && currentRequire) {
          return currentRequire(name, true);
        }

        // If there are other bundles on this page the require from the
        // previous one is saved to 'previousRequire'. Repeat this as
        // many times as there are bundles until the module is found or
        // we exhaust the require chain.
        if (previousRequire) {
          return previousRequire(name, true);
        }

        // Try the node require function if it exists.
        if (nodeRequire && typeof name === 'string') {
          return nodeRequire(name);
        }

        var err = new Error("Cannot find module '" + name + "'");
        err.code = 'MODULE_NOT_FOUND';
        throw err;
      }

      localRequire.resolve = resolve;
      localRequire.cache = {};

      var module = (cache[name] = new newRequire.Module(name));

      modules[name][0].call(
        module.exports,
        localRequire,
        module,
        module.exports,
        this
      );
    }

    return cache[name].exports;

    function localRequire(x) {
      var res = localRequire.resolve(x);
      return res === false ? {} : newRequire(res);
    }

    function resolve(x) {
      var id = modules[name][1][x];
      return id != null ? id : x;
    }
  }

  function Module(moduleName) {
    this.id = moduleName;
    this.bundle = newRequire;
    this.exports = {};
  }

  newRequire.isParcelRequire = true;
  newRequire.Module = Module;
  newRequire.modules = modules;
  newRequire.cache = cache;
  newRequire.parent = previousRequire;
  newRequire.register = function (id, exports) {
    modules[id] = [
      function (require, module) {
        module.exports = exports;
      },
      {},
    ];
  };

  Object.defineProperty(newRequire, 'root', {
    get: function () {
      return globalObject[parcelRequireName];
    },
  });

  globalObject[parcelRequireName] = newRequire;

  for (var i = 0; i < entry.length; i++) {
    newRequire(entry[i]);
  }

  if (mainEntry) {
    // Expose entry point to Node, AMD or browser globals
    // Based on https://github.com/ForbesLindesay/umd/blob/master/template.js
    var mainExports = newRequire(mainEntry);

    // CommonJS
    if (typeof exports === 'object' && typeof module !== 'undefined') {
      module.exports = mainExports;

      // RequireJS
    } else if (typeof define === 'function' && define.amd) {
      define(function () {
        return mainExports;
      });

      // <script>
    } else if (globalName) {
      this[globalName] = mainExports;
    }
  }
})({"5bbJ7":[function(require,module,exports) {
var global = arguments[3];
var HMR_HOST = null;
var HMR_PORT = 1234;
var HMR_SECURE = false;
var HMR_ENV_HASH = "916932b22e4085ab";
module.bundle.HMR_BUNDLE_ID = "351e34124edb8180";
"use strict";
/* global HMR_HOST, HMR_PORT, HMR_ENV_HASH, HMR_SECURE, chrome, browser, globalThis, __parcel__import__, __parcel__importScripts__, ServiceWorkerGlobalScope */ /*::
import type {
  HMRAsset,
  HMRMessage,
} from '@parcel/reporter-dev-server/src/HMRServer.js';
interface ParcelRequire {
  (string): mixed;
  cache: {|[string]: ParcelModule|};
  hotData: mixed;
  Module: any;
  parent: ?ParcelRequire;
  isParcelRequire: true;
  modules: {|[string]: [Function, {|[string]: string|}]|};
  HMR_BUNDLE_ID: string;
  root: ParcelRequire;
}
interface ParcelModule {
  hot: {|
    data: mixed,
    accept(cb: (Function) => void): void,
    dispose(cb: (mixed) => void): void,
    // accept(deps: Array<string> | string, cb: (Function) => void): void,
    // decline(): void,
    _acceptCallbacks: Array<(Function) => void>,
    _disposeCallbacks: Array<(mixed) => void>,
  |};
}
interface ExtensionContext {
  runtime: {|
    reload(): void,
    getURL(url: string): string;
    getManifest(): {manifest_version: number, ...};
  |};
}
declare var module: {bundle: ParcelRequire, ...};
declare var HMR_HOST: string;
declare var HMR_PORT: string;
declare var HMR_ENV_HASH: string;
declare var HMR_SECURE: boolean;
declare var chrome: ExtensionContext;
declare var browser: ExtensionContext;
declare var __parcel__import__: (string) => Promise<void>;
declare var __parcel__importScripts__: (string) => Promise<void>;
declare var globalThis: typeof self;
declare var ServiceWorkerGlobalScope: Object;
*/ var OVERLAY_ID = "__parcel__error__overlay__";
var OldModule = module.bundle.Module;
function Module(moduleName) {
    OldModule.call(this, moduleName);
    this.hot = {
        data: module.bundle.hotData,
        _acceptCallbacks: [],
        _disposeCallbacks: [],
        accept: function(fn) {
            this._acceptCallbacks.push(fn || function() {});
        },
        dispose: function(fn) {
            this._disposeCallbacks.push(fn);
        }
    };
    module.bundle.hotData = undefined;
}
module.bundle.Module = Module;
var checkedAssets, acceptedAssets, assetsToAccept /*: Array<[ParcelRequire, string]> */ ;
function getHostname() {
    return HMR_HOST || (location.protocol.indexOf("http") === 0 ? location.hostname : "localhost");
}
function getPort() {
    return HMR_PORT || location.port;
} // eslint-disable-next-line no-redeclare
var parent = module.bundle.parent;
if ((!parent || !parent.isParcelRequire) && typeof WebSocket !== "undefined") {
    var hostname = getHostname();
    var port = getPort();
    var protocol = HMR_SECURE || location.protocol == "https:" && !/localhost|127.0.0.1|0.0.0.0/.test(hostname) ? "wss" : "ws";
    var ws = new WebSocket(protocol + "://" + hostname + (port ? ":" + port : "") + "/"); // Web extension context
    var extCtx = typeof chrome === "undefined" ? typeof browser === "undefined" ? null : browser : chrome; // Safari doesn't support sourceURL in error stacks.
    // eval may also be disabled via CSP, so do a quick check.
    var supportsSourceURL = false;
    try {
        (0, eval)('throw new Error("test"); //# sourceURL=test.js');
    } catch (err) {
        supportsSourceURL = err.stack.includes("test.js");
    } // $FlowFixMe
    ws.onmessage = async function(event) {
        checkedAssets = {} /*: {|[string]: boolean|} */ ;
        acceptedAssets = {} /*: {|[string]: boolean|} */ ;
        assetsToAccept = [];
        var data = JSON.parse(event.data);
        if (data.type === "update") {
            // Remove error overlay if there is one
            if (typeof document !== "undefined") removeErrorOverlay();
            let assets = data.assets.filter((asset)=>asset.envHash === HMR_ENV_HASH); // Handle HMR Update
            let handled = assets.every((asset)=>{
                return asset.type === "css" || asset.type === "js" && hmrAcceptCheck(module.bundle.root, asset.id, asset.depsByBundle);
            });
            if (handled) {
                console.clear(); // Dispatch custom event so other runtimes (e.g React Refresh) are aware.
                if (typeof window !== "undefined" && typeof CustomEvent !== "undefined") window.dispatchEvent(new CustomEvent("parcelhmraccept"));
                await hmrApplyUpdates(assets);
                for(var i = 0; i < assetsToAccept.length; i++){
                    var id = assetsToAccept[i][1];
                    if (!acceptedAssets[id]) hmrAcceptRun(assetsToAccept[i][0], id);
                }
            } else fullReload();
        }
        if (data.type === "error") {
            // Log parcel errors to console
            for (let ansiDiagnostic of data.diagnostics.ansi){
                let stack = ansiDiagnostic.codeframe ? ansiDiagnostic.codeframe : ansiDiagnostic.stack;
                console.error("\uD83D\uDEA8 [parcel]: " + ansiDiagnostic.message + "\n" + stack + "\n\n" + ansiDiagnostic.hints.join("\n"));
            }
            if (typeof document !== "undefined") {
                // Render the fancy html overlay
                removeErrorOverlay();
                var overlay = createErrorOverlay(data.diagnostics.html); // $FlowFixMe
                document.body.appendChild(overlay);
            }
        }
    };
    ws.onerror = function(e) {
        console.error(e.message);
    };
    ws.onclose = function() {
        console.warn("[parcel] \uD83D\uDEA8 Connection to the HMR server was lost");
    };
}
function removeErrorOverlay() {
    var overlay = document.getElementById(OVERLAY_ID);
    if (overlay) {
        overlay.remove();
        console.log("[parcel] ✨ Error resolved");
    }
}
function createErrorOverlay(diagnostics) {
    var overlay = document.createElement("div");
    overlay.id = OVERLAY_ID;
    let errorHTML = '<div style="background: black; opacity: 0.85; font-size: 16px; color: white; position: fixed; height: 100%; width: 100%; top: 0px; left: 0px; padding: 30px; font-family: Menlo, Consolas, monospace; z-index: 9999;">';
    for (let diagnostic of diagnostics){
        let stack = diagnostic.frames.length ? diagnostic.frames.reduce((p, frame)=>{
            return `${p}
<a href="/__parcel_launch_editor?file=${encodeURIComponent(frame.location)}" style="text-decoration: underline; color: #888" onclick="fetch(this.href); return false">${frame.location}</a>
${frame.code}`;
        }, "") : diagnostic.stack;
        errorHTML += `
      <div>
        <div style="font-size: 18px; font-weight: bold; margin-top: 20px;">
          🚨 ${diagnostic.message}
        </div>
        <pre>${stack}</pre>
        <div>
          ${diagnostic.hints.map((hint)=>"<div>\uD83D\uDCA1 " + hint + "</div>").join("")}
        </div>
        ${diagnostic.documentation ? `<div>📝 <a style="color: violet" href="${diagnostic.documentation}" target="_blank">Learn more</a></div>` : ""}
      </div>
    `;
    }
    errorHTML += "</div>";
    overlay.innerHTML = errorHTML;
    return overlay;
}
function fullReload() {
    if ("reload" in location) location.reload();
    else if (extCtx && extCtx.runtime && extCtx.runtime.reload) extCtx.runtime.reload();
}
function getParents(bundle, id) /*: Array<[ParcelRequire, string]> */ {
    var modules = bundle.modules;
    if (!modules) return [];
    var parents = [];
    var k, d, dep;
    for(k in modules)for(d in modules[k][1]){
        dep = modules[k][1][d];
        if (dep === id || Array.isArray(dep) && dep[dep.length - 1] === id) parents.push([
            bundle,
            k
        ]);
    }
    if (bundle.parent) parents = parents.concat(getParents(bundle.parent, id));
    return parents;
}
function updateLink(link) {
    var newLink = link.cloneNode();
    newLink.onload = function() {
        if (link.parentNode !== null) // $FlowFixMe
        link.parentNode.removeChild(link);
    };
    newLink.setAttribute("href", link.getAttribute("href").split("?")[0] + "?" + Date.now()); // $FlowFixMe
    link.parentNode.insertBefore(newLink, link.nextSibling);
}
var cssTimeout = null;
function reloadCSS() {
    if (cssTimeout) return;
    cssTimeout = setTimeout(function() {
        var links = document.querySelectorAll('link[rel="stylesheet"]');
        for(var i = 0; i < links.length; i++){
            // $FlowFixMe[incompatible-type]
            var href = links[i].getAttribute("href");
            var hostname = getHostname();
            var servedFromHMRServer = hostname === "localhost" ? new RegExp("^(https?:\\/\\/(0.0.0.0|127.0.0.1)|localhost):" + getPort()).test(href) : href.indexOf(hostname + ":" + getPort());
            var absolute = /^https?:\/\//i.test(href) && href.indexOf(location.origin) !== 0 && !servedFromHMRServer;
            if (!absolute) updateLink(links[i]);
        }
        cssTimeout = null;
    }, 50);
}
function hmrDownload(asset) {
    if (asset.type === "js") {
        if (typeof document !== "undefined") {
            let script = document.createElement("script");
            script.src = asset.url + "?t=" + Date.now();
            if (asset.outputFormat === "esmodule") script.type = "module";
            return new Promise((resolve, reject)=>{
                var _document$head;
                script.onload = ()=>resolve(script);
                script.onerror = reject;
                (_document$head = document.head) === null || _document$head === void 0 || _document$head.appendChild(script);
            });
        } else if (typeof importScripts === "function") {
            // Worker scripts
            if (asset.outputFormat === "esmodule") return import(asset.url + "?t=" + Date.now());
            else return new Promise((resolve, reject)=>{
                try {
                    importScripts(asset.url + "?t=" + Date.now());
                    resolve();
                } catch (err) {
                    reject(err);
                }
            });
        }
    }
}
async function hmrApplyUpdates(assets) {
    global.parcelHotUpdate = Object.create(null);
    let scriptsToRemove;
    try {
        // If sourceURL comments aren't supported in eval, we need to load
        // the update from the dev server over HTTP so that stack traces
        // are correct in errors/logs. This is much slower than eval, so
        // we only do it if needed (currently just Safari).
        // https://bugs.webkit.org/show_bug.cgi?id=137297
        // This path is also taken if a CSP disallows eval.
        if (!supportsSourceURL) {
            let promises = assets.map((asset)=>{
                var _hmrDownload;
                return (_hmrDownload = hmrDownload(asset)) === null || _hmrDownload === void 0 ? void 0 : _hmrDownload.catch((err)=>{
                    // Web extension bugfix for Chromium
                    // https://bugs.chromium.org/p/chromium/issues/detail?id=1255412#c12
                    if (extCtx && extCtx.runtime && extCtx.runtime.getManifest().manifest_version == 3) {
                        if (typeof ServiceWorkerGlobalScope != "undefined" && global instanceof ServiceWorkerGlobalScope) {
                            extCtx.runtime.reload();
                            return;
                        }
                        asset.url = extCtx.runtime.getURL("/__parcel_hmr_proxy__?url=" + encodeURIComponent(asset.url + "?t=" + Date.now()));
                        return hmrDownload(asset);
                    }
                    throw err;
                });
            });
            scriptsToRemove = await Promise.all(promises);
        }
        assets.forEach(function(asset) {
            hmrApply(module.bundle.root, asset);
        });
    } finally{
        delete global.parcelHotUpdate;
        if (scriptsToRemove) scriptsToRemove.forEach((script)=>{
            if (script) {
                var _document$head2;
                (_document$head2 = document.head) === null || _document$head2 === void 0 || _document$head2.removeChild(script);
            }
        });
    }
}
function hmrApply(bundle, asset) {
    var modules = bundle.modules;
    if (!modules) return;
    if (asset.type === "css") reloadCSS();
    else if (asset.type === "js") {
        let deps = asset.depsByBundle[bundle.HMR_BUNDLE_ID];
        if (deps) {
            if (modules[asset.id]) {
                // Remove dependencies that are removed and will become orphaned.
                // This is necessary so that if the asset is added back again, the cache is gone, and we prevent a full page reload.
                let oldDeps = modules[asset.id][1];
                for(let dep in oldDeps)if (!deps[dep] || deps[dep] !== oldDeps[dep]) {
                    let id = oldDeps[dep];
                    let parents = getParents(module.bundle.root, id);
                    if (parents.length === 1) hmrDelete(module.bundle.root, id);
                }
            }
            if (supportsSourceURL) // Global eval. We would use `new Function` here but browser
            // support for source maps is better with eval.
            (0, eval)(asset.output);
             // $FlowFixMe
            let fn = global.parcelHotUpdate[asset.id];
            modules[asset.id] = [
                fn,
                deps
            ];
        } else if (bundle.parent) hmrApply(bundle.parent, asset);
    }
}
function hmrDelete(bundle, id) {
    let modules = bundle.modules;
    if (!modules) return;
    if (modules[id]) {
        // Collect dependencies that will become orphaned when this module is deleted.
        let deps = modules[id][1];
        let orphans = [];
        for(let dep in deps){
            let parents = getParents(module.bundle.root, deps[dep]);
            if (parents.length === 1) orphans.push(deps[dep]);
        } // Delete the module. This must be done before deleting dependencies in case of circular dependencies.
        delete modules[id];
        delete bundle.cache[id]; // Now delete the orphans.
        orphans.forEach((id)=>{
            hmrDelete(module.bundle.root, id);
        });
    } else if (bundle.parent) hmrDelete(bundle.parent, id);
}
function hmrAcceptCheck(bundle, id, depsByBundle) {
    if (hmrAcceptCheckOne(bundle, id, depsByBundle)) return true;
     // Traverse parents breadth first. All possible ancestries must accept the HMR update, or we'll reload.
    let parents = getParents(module.bundle.root, id);
    let accepted = false;
    while(parents.length > 0){
        let v = parents.shift();
        let a = hmrAcceptCheckOne(v[0], v[1], null);
        if (a) // If this parent accepts, stop traversing upward, but still consider siblings.
        accepted = true;
        else {
            // Otherwise, queue the parents in the next level upward.
            let p = getParents(module.bundle.root, v[1]);
            if (p.length === 0) {
                // If there are no parents, then we've reached an entry without accepting. Reload.
                accepted = false;
                break;
            }
            parents.push(...p);
        }
    }
    return accepted;
}
function hmrAcceptCheckOne(bundle, id, depsByBundle) {
    var modules = bundle.modules;
    if (!modules) return;
    if (depsByBundle && !depsByBundle[bundle.HMR_BUNDLE_ID]) {
        // If we reached the root bundle without finding where the asset should go,
        // there's nothing to do. Mark as "accepted" so we don't reload the page.
        if (!bundle.parent) return true;
        return hmrAcceptCheck(bundle.parent, id, depsByBundle);
    }
    if (checkedAssets[id]) return true;
    checkedAssets[id] = true;
    var cached = bundle.cache[id];
    assetsToAccept.push([
        bundle,
        id
    ]);
    if (!cached || cached.hot && cached.hot._acceptCallbacks.length) return true;
}
function hmrAcceptRun(bundle, id) {
    var cached = bundle.cache[id];
    bundle.hotData = {};
    if (cached && cached.hot) cached.hot.data = bundle.hotData;
    if (cached && cached.hot && cached.hot._disposeCallbacks.length) cached.hot._disposeCallbacks.forEach(function(cb) {
        cb(bundle.hotData);
    });
    delete bundle.cache[id];
    bundle(id);
    cached = bundle.cache[id];
    if (cached && cached.hot && cached.hot._acceptCallbacks.length) cached.hot._acceptCallbacks.forEach(function(cb) {
        var assetsToAlsoAccept = cb(function() {
            return getParents(module.bundle.root, id);
        });
        if (assetsToAlsoAccept && assetsToAccept.length) // $FlowFixMe[method-unbinding]
        assetsToAccept.push.apply(assetsToAccept, assetsToAlsoAccept);
    });
    acceptedAssets[id] = true;
}

},{}],"lFcwH":[function(require,module,exports) {
var _equationNode = require("./equation-node");
function onLoad() {
    const history = document.getElementById("equation-history");
    (0, _equationNode.createEquationNode)(history, question);
    (0, _equationNode.createEditableNode)(history, question);
}
if (document.readyState !== "loading") onLoad();
else document.addEventListener("DOMContentLoaded", onLoad);

},{"./equation-node":"l1JBt"}],"l1JBt":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "createEquationNode", ()=>createEquationNode);
parcelHelpers.export(exports, "createEditableNode", ()=>createEditableNode);
var _mathlive = require("mathlive");
function createEquationNode(history, equation, feedback) {
    createNodeLink(history);
    const node = document.createElement("div");
    node.classList.add("equation-node");
    if (equation) node.innerHTML = (0, _mathlive.convertLatexToMarkup)(equation);
    history.appendChild(node);
    addFeedbackToNode(feedback, node);
    return node;
}
function createEditableNode(history, prevAnswer) {
    const node = createEquationNode(history);
    const label = document.createElement("span");
    label.textContent = "Modifique o campo abaixo com o pr\xf3ximo passo:";
    node.appendChild(label);
    const mfe = new (0, _mathlive.MathfieldElement)({
        virtualKeyboardMode: "manual"
    });
    mfe.value = prevAnswer;
    node.appendChild(mfe);
    const testButton = document.createElement("button");
    testButton.classList.add("test-equation-btn");
    testButton.textContent = "Testar";
    testButton.addEventListener("click", ()=>{
        const answer = mfe.value;
        const success = false; // TODO: THIS SHOULD BE COMPUTED SOMEWHERE ELSE;
        node.innerHTML = (0, _mathlive.convertLatexToMarkup)(answer);
        addFeedbackToNode("Resolva primeiro as pot\xeancias", node);
        const editableNode = createEditableNode(history, answer);
        // Postpone scrollIntoView so the node has time to be initialized
        setTimeout(()=>{
            editableNode.scrollIntoView({
                behavior: "smooth"
            });
        }, 0);
    });
    node.appendChild(testButton);
    mfe.addEventListener("input", ()=>{
        prevAnswer;
    });
    return node;
}
function createNodeLink(history) {
    const prevNodes = history.getElementsByClassName("equation-node");
    if (prevNodes.length === 0) return;
    const link = document.createElement("div");
    link.classList.add("equation-link");
    history.appendChild(link);
}
function addFeedbackToNode(feedback, node) {
    if (feedback) {
        const feedbackNode = document.createElement("span");
        feedbackNode.textContent = feedback;
        feedbackNode.classList.add("equation-feedback");
        node.appendChild(feedbackNode);
    }
}

},{"mathlive":"6GL7y","@parcel/transformer-js/src/esmodule-helpers.js":"5oERU"}],"6GL7y":[function(require,module,exports) {
/** MathLive 0.85.1 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "ComputeEngine", ()=>ld);
parcelHelpers.export(exports, "MathfieldElement", ()=>tm);
parcelHelpers.export(exports, "autoRenderMathInElement", ()=>dm);
parcelHelpers.export(exports, "convertLatexToMarkup", ()=>bm);
parcelHelpers.export(exports, "convertLatexToMathMl", ()=>xm);
parcelHelpers.export(exports, "convertLatexToSpeakableText", ()=>km);
parcelHelpers.export(exports, "debug", ()=>Lm);
parcelHelpers.export(exports, "getVars", ()=>Qs);
parcelHelpers.export(exports, "globalMathLive", ()=>gm);
parcelHelpers.export(exports, "isEnvironmentEntry", ()=>Lr);
parcelHelpers.export(exports, "isFunctionEntry", ()=>_r);
parcelHelpers.export(exports, "isInfixEntry", ()=>Sr);
parcelHelpers.export(exports, "isMatchfixEntry", ()=>wr);
parcelHelpers.export(exports, "isPostfixEntry", ()=>Nr);
parcelHelpers.export(exports, "isPrefixEntry", ()=>Mr);
parcelHelpers.export(exports, "isSymbolEntry", ()=>kr);
parcelHelpers.export(exports, "makeSharedVirtualKeyboard", ()=>ym);
parcelHelpers.export(exports, "renderMathInDocument", ()=>Sm);
parcelHelpers.export(exports, "renderMathInElement", ()=>Mm);
parcelHelpers.export(exports, "serializeMathJsonToLatex", ()=>wm);
parcelHelpers.export(exports, "validateLatex", ()=>vm);
parcelHelpers.export(exports, "version", ()=>Nm);
function e1(e1) {
    return Array.isArray(e1);
}
function t() {
    return "window" in globalThis && "document" in globalThis;
}
function i() {
    if (!t()) throw new Error("<math-field> is an interactive component that needs to run in a browser environment\nIf you are using nextjs, see https://nextjs.org/docs/advanced-features/dynamic-import#with-no-ssr");
}
function n() {
    return !!t() && ("matchMedia" in globalThis ? globalThis.matchMedia("(any-pointer: coarse)").matches : "ontouchstart" in globalThis || navigator.maxTouchPoints > 0);
}
function r() {
    return t() && "function" == typeof navigator.vibrate;
}
function o() {
    var e1, i;
    if (!t()) return "other";
    const n = null !== (i = null === (e1 = navigator.userAgentData) || void 0 === e1 ? void 0 : e1.platform) && void 0 !== i ? i : navigator.platform;
    return /^mac/i.test(n) ? 5 === navigator.maxTouchPoints ? "ios" : "macos" : /^win/i.test(n) ? "windows" : /android/i.test(navigator.userAgent) ? "android" : /iphone|ipod|ipad/i.test(navigator.userAgent) ? "ios" : /\bcros\b/i.test(navigator.userAgent) ? "chromeos" : "other";
}
function a() {
    if (!t()) return !0;
    if (/firefox/i.test(navigator.userAgent)) {
        const e1 = navigator.userAgent.match(/firefox\/(\d+)/i);
        return !!e1 && parseInt(e1[1]) >= 78;
    }
    if (/trident/i.test(navigator.userAgent)) return !1;
    if (/edge/i.test(navigator.userAgent)) {
        const e2 = navigator.userAgent.match(/edg\/(\d+)/i);
        return !!e2 && parseInt(e2[1]) >= 79;
    }
    return !0;
}
const s = {
    strings: {
        en: {
            "keyboard.tooltip.functions": "Functions",
            "keyboard.tooltip.symbols": "Symbols",
            "keyboard.tooltip.greek": "Greek Letters",
            "keyboard.tooltip.command": "LaTeX Command Mode",
            "keyboard.tooltip.numeric": "Numeric",
            "keyboard.tooltip.roman": "Roman Letters",
            "tooltip.copy to clipboard": "Copy to Clipboard",
            "tooltip.redo": "Redo",
            "tooltip.toggle virtual keyboard": "Toggle Virtual Keyboard",
            "tooltip.undo": "Undo",
            "menu.insert matrix": "Insert Matrix",
            "menu.insert vector": "Insert Vector",
            "submenu.array.matrix delimiters": "Matrix Delimiters",
            "menu.array.add row above": "Add Row After",
            "menu.array.add row below": "Add Row Before",
            "menu.array.add column after": "Add Column After",
            "menu.array.add column before": "Add Column Before",
            "menu.array.delete row": "Delete Row",
            "menu.array.delete rows": "Delete Selected Rows",
            "menu.array.delete column": "Delete Column",
            "menu.array.delete columns": "Delete Selected Columns",
            "submenu.array.insert separator": "Insert Separator",
            "menu.insert table": "Insert Table",
            "submenu.table style": "Table Style"
        },
        ar: {
            "keyboard.tooltip.functions": "مهام",
            "keyboard.tooltip.symbols": "حرف او رمز",
            "keyboard.tooltip.greek": "حروف يونانية",
            "keyboard.tooltip.command": "حالة تلقي الأوامر اللاتك",
            "keyboard.tooltip.numeric": "الرقمية",
            "keyboard.tooltip.roman": "رموز الاحرف الرومانية",
            "tooltip.copy to clipboard": "نسخ إلى الحافظة",
            "tooltip.redo": "الإعادة",
            "tooltip.toggle virtual keyboard": "تبديل لوحة المفاتيح الإفتراضية",
            "tooltip.undo": "إلغاء",
            "menu.insert matrix": "أدخل المصفوفة",
            "menu.insert vector": "أدخل متجه",
            "submenu.array.matrix delimiters": "محددات المصفوفة",
            "menu.array.add row above": "أضف صفًا بعد ذلك",
            "menu.array.add row below": "أضف الصف قبل",
            "menu.array.add column after": "أضف العمود بعد ذلك",
            "menu.array.add column before": "أضف العمود قبل",
            "menu.array.delete row": "احذف صف",
            "menu.array.delete rows": "حذف الصفوف المحددة",
            "menu.array.delete column": "حذف العمود",
            "menu.array.delete columns": "حذف الأعمدة المحددة",
            "submenu.array.insert separator": "أدخل فاصل",
            "menu.insert table": "إدراج جدول",
            "submenu.table style": "نمط الجدول"
        },
        bg: {
            "keyboard.tooltip.functions": "Функции",
            "keyboard.tooltip.symbols": "Символи",
            "keyboard.tooltip.greek": "Гръцки букви",
            "keyboard.tooltip.command": "Команден режим на латекс",
            "keyboard.tooltip.numeric": "Числови",
            "keyboard.tooltip.roman": "Римски букви",
            "tooltip.copy to clipboard": "Копиране в клипборда",
            "tooltip.redo": "Повторно",
            "tooltip.toggle virtual keyboard": "Превключване на виртуална клавиатура",
            "tooltip.undo": "Отмяна",
            "menu.insert matrix": "Вмъкване на матрица",
            "menu.insert vector": "Вмъкване на вектор",
            "submenu.array.matrix delimiters": "Матрични разделители",
            "menu.array.add row above": "Добавяне на ред след",
            "menu.array.add row below": "Добавяне на ред преди",
            "menu.array.add column after": "Добавяне на колона след",
            "menu.array.add column before": "Добавяне на колона преди",
            "menu.array.delete row": "Изтриване на реда",
            "menu.array.delete rows": "Изтриване на избраните редове",
            "menu.array.delete column": "Изтриване на колона",
            "menu.array.delete columns": "Изтриване на избраните колони",
            "submenu.array.insert separator": "Поставете разделител",
            "menu.insert table": "Вмъкване на таблица",
            "submenu.table style": "Табличен стил"
        },
        bs: {
            "keyboard.tooltip.functions": "Funkcije",
            "keyboard.tooltip.symbols": "Simboli",
            "keyboard.tooltip.greek": "Grčka slova",
            "keyboard.tooltip.command": "LaTeX naredbeni način",
            "keyboard.tooltip.numeric": "Numerički",
            "keyboard.tooltip.roman": "Rimska slova",
            "tooltip.copy to clipboard": "Kopirati u clipboard",
            "tooltip.redo": "Ponovi",
            "tooltip.toggle virtual keyboard": "Uključi / isključi virtualnu tipkovnicu",
            "tooltip.undo": "Poništi",
            "menu.insert matrix": "Umetni matricu",
            "menu.insert vector": "Umetni vektor",
            "submenu.array.matrix delimiters": "Matrični razdjelnici",
            "menu.array.add row above": "Dodaj redak nakon",
            "menu.array.add row below": "Dodaj red prije",
            "menu.array.add column after": "Dodaj stupac nakon",
            "menu.array.add column before": "Dodaj stupac prije",
            "menu.array.delete row": "Izbriši red",
            "menu.array.delete rows": "Izbriši odabrane redove",
            "menu.array.delete column": "Izbriši stupac",
            "menu.array.delete columns": "Izbriši odabrane stupce",
            "submenu.array.insert separator": "Umetni separator",
            "menu.insert table": "Ubaci tabelu",
            "submenu.table style": "Stil tabele"
        },
        cs: {
            "keyboard.tooltip.functions": "Funkce",
            "keyboard.tooltip.symbols": "Symboly",
            "keyboard.tooltip.greek": "Řeck\xe9 dopisy",
            "keyboard.tooltip.command": "Př\xedkazov\xfd režim LaTeX",
            "keyboard.tooltip.numeric": "Č\xedseln\xe9",
            "keyboard.tooltip.roman": "Ř\xedmsk\xe9 dopisy",
            "tooltip.copy to clipboard": "Zkop\xedrovat do schr\xe1nky",
            "tooltip.redo": "Předělat",
            "tooltip.toggle virtual keyboard": "Přepnout virtu\xe1ln\xed kl\xe1vesnici",
            "tooltip.undo": "Vr\xe1tit",
            "menu.insert matrix": "Vložte matici",
            "menu.insert vector": "Vložit vektor",
            "submenu.array.matrix delimiters": "Oddělovače matic",
            "menu.array.add row above": "Přidat ř\xe1dek za",
            "menu.array.add row below": "Přidat ř\xe1dek před",
            "menu.array.add column after": "Přidat sloupec za",
            "menu.array.add column before": "Přidat sloupec dř\xedve",
            "menu.array.delete row": "Odstranit ř\xe1dek",
            "menu.array.delete rows": "Odstranit vybran\xe9 ř\xe1dky",
            "menu.array.delete column": "Odstranit sloupec",
            "menu.array.delete columns": "Odstranit vybran\xe9 sloupce",
            "submenu.array.insert separator": "Vložte oddělovač",
            "menu.insert table": "Vložit tabulku",
            "submenu.table style": "Styl tabulky"
        },
        da: {
            "keyboard.tooltip.functions": "Funktioner",
            "keyboard.tooltip.symbols": "Symboler",
            "keyboard.tooltip.greek": "Gr\xe6ske bogstaver",
            "keyboard.tooltip.command": "LaTeX kommandotilstand",
            "keyboard.tooltip.numeric": "Numerisk",
            "keyboard.tooltip.roman": "Romerske breve",
            "tooltip.copy to clipboard": "Kopier til udklipsholder",
            "tooltip.redo": "Gentag igen",
            "tooltip.toggle virtual keyboard": "Skift virtuelt tastatur",
            "tooltip.undo": "Fortryd",
            "menu.insert matrix": "Inds\xe6t matrix",
            "menu.insert vector": "Inds\xe6t vektor",
            "submenu.array.matrix delimiters": "Matrixafgr\xe6nsere",
            "menu.array.add row above": "Tilf\xf8j r\xe6kke efter",
            "menu.array.add row below": "Tilf\xf8j r\xe6kke f\xf8r",
            "menu.array.add column after": "Tilf\xf8j kolonne efter",
            "menu.array.add column before": "Tilf\xf8j kolonne f\xf8r",
            "menu.array.delete row": "Slet r\xe6kke",
            "menu.array.delete rows": "Slet valgte r\xe6kker",
            "menu.array.delete column": "Slet kolonne",
            "menu.array.delete columns": "Slet valgte kolonner",
            "submenu.array.insert separator": "Inds\xe6t separator",
            "menu.insert table": "Inds\xe6t tabel",
            "submenu.table style": "Tabelstil"
        },
        de: {
            "keyboard.tooltip.functions": "Funktionen",
            "keyboard.tooltip.symbols": "Symbole",
            "keyboard.tooltip.greek": "Griechische Buchstaben",
            "keyboard.tooltip.command": "LaTeX-Befehlsmodus",
            "keyboard.tooltip.numeric": "Numerisch",
            "keyboard.tooltip.roman": "R\xf6mische Buchstaben",
            "tooltip.copy to clipboard": "In die Zwischenablage kopieren",
            "tooltip.redo": "Wiederholen",
            "tooltip.toggle virtual keyboard": "Virtuelle Tastatur umschalten",
            "tooltip.undo": "Widerrufen",
            "menu.insert matrix": "Matrix einf\xfcgen",
            "menu.insert vector": "Vektor einf\xfcgen",
            "submenu.array.matrix delimiters": "Matrixtrennzeichen",
            "menu.array.add row above": "Zeile hinzuf\xfcgen nach",
            "menu.array.add row below": "Zeile hinzuf\xfcgen vor",
            "menu.array.add column after": "Spalte hinzuf\xfcgen nach",
            "menu.array.add column before": "Spalte hinzuf\xfcgen vor",
            "menu.array.delete row": "Zeile l\xf6schen",
            "menu.array.delete rows": "Ausgew\xe4hlte Zeilen l\xf6schen",
            "menu.array.delete column": "Spalte l\xf6schen",
            "menu.array.delete columns": "Ausgew\xe4hlte Spalten l\xf6schen",
            "submenu.array.insert separator": "Trennzeichen einf\xfcgen",
            "menu.insert table": "Tabelle einf\xfcgen",
            "submenu.table style": "Tabellenstil"
        },
        el: {
            "keyboard.tooltip.functions": "συναρτήσεις",
            "keyboard.tooltip.symbols": "σύμβολα",
            "keyboard.tooltip.greek": "ελληνικά γράμματα",
            "keyboard.tooltip.command": "Λειτουργία εντολών LaTeX",
            "keyboard.tooltip.numeric": "Αριθμητικός",
            "keyboard.tooltip.roman": "Ρωμαϊκά γράμματα",
            "tooltip.copy to clipboard": "Αντιγραφή στο πρόχειρο",
            "tooltip.redo": "Ξανακάνω",
            "tooltip.toggle virtual keyboard": "Εναλλαγή εικονικού πληκτρολογίου",
            "tooltip.undo": "Ξεκάνω",
            "menu.insert matrix": "Εισαγωγή Matrix",
            "menu.insert vector": "Εισαγωγή διανύσματος",
            "submenu.array.matrix delimiters": "Οριοθέτες Matrix",
            "menu.array.add row above": "Προσθήκη σειράς μετά",
            "menu.array.add row below": "Προσθήκη σειράς πριν",
            "menu.array.add column after": "Προσθήκη στήλης μετά",
            "menu.array.add column before": "Προσθήκη στήλης πριν",
            "menu.array.delete row": "Διαγραφή σειράς",
            "menu.array.delete rows": "Διαγραφή επιλεγμένων σειρών",
            "menu.array.delete column": "Διαγραφή στήλης",
            "menu.array.delete columns": "Διαγραφή επιλεγμένων στηλών",
            "submenu.array.insert separator": "Εισαγωγή διαχωριστικού",
            "menu.insert table": "Εισαγωγή πίνακα",
            "submenu.table style": "Στυλ πίνακα"
        },
        es: {
            "keyboard.tooltip.functions": "Funciones",
            "keyboard.tooltip.symbols": "S\xedmbolos",
            "keyboard.tooltip.greek": "Letras griegas",
            "keyboard.tooltip.command": "Modo Comando LaTeX",
            "keyboard.tooltip.numeric": "Num\xe9rico",
            "keyboard.tooltip.roman": "Letras romanas",
            "tooltip.copy to clipboard": "Copiar al portapapeles",
            "tooltip.redo": "Rehacer",
            "tooltip.toggle virtual keyboard": "Alternar teclado virtual",
            "tooltip.undo": "Deshacer",
            "menu.insert matrix": "A\xf1adir Matriz",
            "menu.insert vector": "A\xf1adir vector",
            "submenu.array.matrix delimiters": "Delimitadores de Matriz",
            "menu.array.add row above": "A\xf1adir L\xednea Antes",
            "menu.array.add row below": "A\xf1adir L\xednea Despues",
            "menu.array.add column after": "A\xf1adir Columna Despues",
            "menu.array.add column before": "A\xf1adir Columna Antes",
            "menu.array.delete row": "Borrar L\xednea",
            "menu.array.delete rows": "Borrar L\xedneas Seleccionadas",
            "menu.array.delete column": "Borrar Columna",
            "menu.array.delete columns": "Borrar Columnas Seleccionadas",
            "submenu.array.insert separator": "Insertar un Separador",
            "menu.insert table": "Insertar Tabla",
            "submenu.table style": "Estilo de Tabla"
        },
        et: {
            "keyboard.tooltip.functions": "Funktsioonid",
            "keyboard.tooltip.symbols": "S\xfcmbolid",
            "keyboard.tooltip.greek": "Kreeka kirjad",
            "keyboard.tooltip.command": "LaTeXi k\xe4surežiim",
            "keyboard.tooltip.numeric": "Numbriline",
            "keyboard.tooltip.roman": "Rooma kirjad",
            "tooltip.copy to clipboard": "Kopeerida l\xf5ikelauale",
            "tooltip.redo": "Tee uuesti",
            "tooltip.toggle virtual keyboard": "L\xfclitage sisse virtuaalne klaviatuur",
            "tooltip.undo": "V\xf5ta tagasi",
            "menu.insert matrix": "Sisesta maatriks",
            "menu.insert vector": "Sisesta vektor",
            "submenu.array.matrix delimiters": "Maatriksi eraldajad",
            "menu.array.add row above": "Lisa rida p\xe4rast",
            "menu.array.add row below": "Lisa rida enne",
            "menu.array.add column after": "Lisa veerg p\xe4rast",
            "menu.array.add column before": "Lisa veerg enne",
            "menu.array.delete row": "Kustuta rida",
            "menu.array.delete rows": "Kustuta valitud read",
            "menu.array.delete column": "Kustuta veerg",
            "menu.array.delete columns": "Kustuta valitud veerud",
            "submenu.array.insert separator": "Sisestage eraldaja",
            "menu.insert table": "Sisesta tabeli",
            "submenu.table style": "Tabeli stiilis"
        },
        fa: {
            "keyboard.tooltip.functions": "توابع",
            "keyboard.tooltip.symbols": "نمادها",
            "keyboard.tooltip.greek": "حروف یونانی",
            "keyboard.tooltip.command": "حالت دستور لاتک",
            "keyboard.tooltip.numeric": "عددی",
            "keyboard.tooltip.roman": "حروف رومی",
            "tooltip.copy to clipboard": "کپی به کلیپبورد",
            "tooltip.redo": "بازگشت به بعد",
            "tooltip.toggle virtual keyboard": "نمایش/نهفتن کیبورد مجازی",
            "tooltip.undo": "بازگشت به قبل",
            "menu.insert matrix": "ماتریس را وارد کنید",
            "menu.insert vector": "درج بردار",
            "submenu.array.matrix delimiters": "مرزهای ماتریس",
            "menu.array.add row above": "بعد از آن ردیف اضافه کنید",
            "menu.array.add row below": "ردیف را قبل اضافه کنید",
            "menu.array.add column after": "اضافه کردن ستون بعد",
            "menu.array.add column before": "ستون قبل را اضافه کنید",
            "menu.array.delete row": "ردیف را حذف کنید",
            "menu.array.delete rows": "ردیف های انتخاب شده را حذف کنید",
            "menu.array.delete column": "حذف ستون",
            "menu.array.delete columns": "ستون های انتخاب شده را حذف کنید",
            "submenu.array.insert separator": "درج جدا کننده",
            "menu.insert table": "قرار دادن جدول",
            "submenu.table style": "سبک میز"
        },
        fi: {
            "keyboard.tooltip.functions": "Toiminnot",
            "keyboard.tooltip.symbols": "Symbolit",
            "keyboard.tooltip.greek": "Kreikkalaiset kirjeet",
            "keyboard.tooltip.command": "LaTeX-komentotila",
            "keyboard.tooltip.numeric": "Numeerinen",
            "keyboard.tooltip.roman": "Roomalaiset kirjeet",
            "tooltip.copy to clipboard": "Kopioi leikep\xf6yd\xe4lle",
            "tooltip.redo": "Tee uudelleen",
            "tooltip.toggle virtual keyboard": "Vaihda virtuaalin\xe4pp\xe4imist\xf6",
            "tooltip.undo": "Kumoa",
            "menu.insert matrix": "Lis\xe4\xe4 matriisi",
            "menu.insert vector": "Lis\xe4\xe4 vektori",
            "submenu.array.matrix delimiters": "Matriisin erottimet",
            "menu.array.add row above": "Lis\xe4\xe4 rivi j\xe4lkeen",
            "menu.array.add row below": "Lis\xe4\xe4 rivi ennen",
            "menu.array.add column after": "Lis\xe4\xe4 sarake j\xe4lkeen",
            "menu.array.add column before": "Lis\xe4\xe4 sarake ennen",
            "menu.array.delete row": "Poista rivi",
            "menu.array.delete rows": "Poista valitut rivit",
            "menu.array.delete column": "Poista sarake",
            "menu.array.delete columns": "Poista valitut sarakkeet",
            "submenu.array.insert separator": "Aseta erotin",
            "menu.insert table": "Lis\xe4\xe4 taulukko",
            "submenu.table style": "Taulukon tyyli"
        },
        fr: {
            "keyboard.tooltip.functions": "Fonctions",
            "keyboard.tooltip.symbols": "Symboles",
            "keyboard.tooltip.greek": "Lettres grecques",
            "keyboard.tooltip.command": "Mode de commandes LaTeX",
            "keyboard.tooltip.numeric": "Num\xe9rique",
            "keyboard.tooltip.roman": "Lettres romaines",
            "tooltip.copy to clipboard": "Copier dans le presse-papiers",
            "tooltip.redo": "R\xe9tablir",
            "tooltip.toggle virtual keyboard": "Afficher/Masquer le clavier virtuel",
            "tooltip.undo": "Annuler",
            "menu.insert matrix": "Ins\xe9rer une Matrice",
            "menu.insert vector": "Ins\xe9rer un Vecteur",
            "submenu.array.matrix delimiters": "D\xe9limiteurs de la Matrice",
            "menu.array.add row above": "Ajouter une Ligne Avant",
            "menu.array.add row below": "Ajouter une Ligne Apr\xe8s",
            "menu.array.add column before": "Ajouter une Colonne Avant",
            "menu.array.add column after": "Ajouter une Colonne Apr\xe8s",
            "menu.array.delete row": "Enlever une Ligne",
            "menu.array.delete rows": "Enlever les Lignes S\xe9lection\xe9es",
            "menu.array.delete column": "Enlever une Colone",
            "menu.array.delete columns": "Enlever les Colonnes S\xe9lection\xe9es",
            "submenu.array.insert separator": "Ins\xe9rer un S\xe9parateur",
            "menu.insert table": "Ins\xe9rer une Table",
            "submenu.table style": "Style de la  Table"
        },
        ga: {
            "keyboard.tooltip.functions": "Feidhmeanna",
            "keyboard.tooltip.symbols": "Siombail\xed",
            "keyboard.tooltip.greek": "Litreacha na Gr\xe9ige",
            "keyboard.tooltip.command": "M\xf3d Ord\xfa LaTeX",
            "keyboard.tooltip.numeric": "Uimhri\xfail",
            "keyboard.tooltip.roman": "Litreacha R\xf3mh\xe1nacha",
            "tooltip.copy to clipboard": "C\xf3ipe\xe1il chuig an Ghearrthaisce",
            "tooltip.redo": "Athdh\xe9an",
            "tooltip.toggle virtual keyboard": "M\xe9archl\xe1ir F\xedor\xfail a Fh\xe1il",
            "tooltip.undo": "Cealaigh",
            "menu.insert matrix": "Cuir isteach Maitr\xeds",
            "menu.insert vector": "Cuir isteach Veicteoir",
            "submenu.array.matrix delimiters": "Delimiters Maitr\xeds",
            "menu.array.add row above": "Cuir Rae Tar \xe9is",
            "menu.array.add row below": "Cuir Rae Roimh",
            "menu.array.add column after": "Cuir Col\xfan Tar \xe9is",
            "menu.array.add column before": "Cuir Col\xfan Roimh",
            "menu.array.delete row": "Scrios Rae",
            "menu.array.delete rows": "Scrios Sraitheanna Roghnaithe",
            "menu.array.delete column": "Scrios Col\xfan",
            "menu.array.delete columns": "Scrios Col\xfain Roghnaithe",
            "submenu.array.insert separator": "Cuir Deighilteoir isteach",
            "menu.insert table": "Ions\xe1igh T\xe1bla",
            "submenu.table style": "St\xedl T\xe1bla"
        },
        he: {
            "keyboard.tooltip.functions": "פונקציות",
            "keyboard.tooltip.symbols": "סמלים",
            "keyboard.tooltip.greek": "אותיות יווניות",
            "keyboard.tooltip.command": "מצב פקודה לטקס",
            "keyboard.tooltip.numeric": "מספרי",
            "keyboard.tooltip.roman": "מכתבים רומיים",
            "tooltip.copy to clipboard": "העתק ללוח",
            "tooltip.redo": "לַעֲשׂוֹת שׁוּב",
            "tooltip.toggle virtual keyboard": "החלף את המקלדת הווירטואלית",
            "tooltip.undo": "לבטל",
            "menu.insert matrix": "הכנס מטריקס",
            "menu.insert vector": "הכנס וקטור",
            "submenu.array.matrix delimiters": "מפרידי מטריקס",
            "menu.array.add row above": "הוסף שורה אחרי",
            "menu.array.add row below": "הוסף שורה לפני",
            "menu.array.add column after": "הוסף עמודה אחרי",
            "menu.array.add column before": "הוסף עמודה לפני",
            "menu.array.delete row": "מחק שורה",
            "menu.array.delete rows": "מחק שורות שנבחרו",
            "menu.array.delete column": "מחק עמודה",
            "menu.array.delete columns": "מחק עמודות שנבחרו",
            "submenu.array.insert separator": "הכנס מפריד",
            "menu.insert table": "הכנס טבלה",
            "submenu.table style": "טבלה סִגְנוֹן"
        },
        hr: {
            "keyboard.tooltip.functions": "Funkcije",
            "keyboard.tooltip.symbols": "Simboli",
            "keyboard.tooltip.greek": "Grčka slova",
            "keyboard.tooltip.command": "LaTeX naredbeni način",
            "keyboard.tooltip.numeric": "Numerički",
            "keyboard.tooltip.roman": "Rimska slova",
            "tooltip.copy to clipboard": "Kopirati u međuspremnik",
            "tooltip.redo": "Ponovi",
            "tooltip.toggle virtual keyboard": "Uključi / isključi virtualnu tipkovnicu",
            "tooltip.undo": "Poništi",
            "menu.insert matrix": "Umetni matricu",
            "menu.insert vector": "Umetni vektor",
            "submenu.array.matrix delimiters": "Matrični razdjelnici",
            "menu.array.add row above": "Dodaj redak nakon",
            "menu.array.add row below": "Dodaj redak prije",
            "menu.array.add column after": "Dodaj stupac nakon",
            "menu.array.add column before": "Dodaj stupac prije",
            "menu.array.delete row": "Izbriši redak",
            "menu.array.delete rows": "Izbriši odabrane retke",
            "menu.array.delete column": "Izbriši stupac",
            "menu.array.delete columns": "Izbriši odabrane stupce",
            "submenu.array.insert separator": "Umetni separator",
            "menu.insert table": "Umetni tablicu",
            "submenu.table style": "Stil tabele"
        },
        id: {
            "keyboard.tooltip.functions": "Fungsi",
            "keyboard.tooltip.symbols": "Simbol",
            "keyboard.tooltip.greek": "Huruf Yunani",
            "keyboard.tooltip.command": "Mode Perintah LaTeX",
            "keyboard.tooltip.numeric": "Numerik",
            "keyboard.tooltip.roman": "Surat Romawi",
            "tooltip.copy to clipboard": "Menyalin ke clipboard",
            "tooltip.redo": "Mengulangi",
            "tooltip.toggle virtual keyboard": "Alihkan Keyboard Virtual",
            "tooltip.undo": "Membuka",
            "menu.insert matrix": "Sisipkan Matriks",
            "menu.insert vector": "Sisipkan Vektor",
            "submenu.array.matrix delimiters": "Pembatas Matriks",
            "menu.array.add row above": "Tambahkan Baris Setelah",
            "menu.array.add row below": "Tambahkan Baris Sebelumnya",
            "menu.array.add column after": "Tambahkan Kolom Setelah",
            "menu.array.add column before": "Tambahkan Kolom Sebelumnya",
            "menu.array.delete row": "Hapus Baris",
            "menu.array.delete rows": "Hapus Baris yang Dipilih",
            "menu.array.delete column": "Hapus Kolom",
            "menu.array.delete columns": "Hapus Kolom yang Dipilih",
            "submenu.array.insert separator": "Sisipkan Pemisah",
            "menu.insert table": "Sisipkan Tabel",
            "submenu.table style": "Gaya Tabel"
        },
        hi: {
            "keyboard.tooltip.functions": "कार्यों",
            "keyboard.tooltip.symbols": "प्रतीक",
            "keyboard.tooltip.greek": "ग्रीक अक्षर",
            "keyboard.tooltip.command": "लाटेक्स कमांड मोड",
            "keyboard.tooltip.numeric": "संख्यात्मक",
            "keyboard.tooltip.roman": "रोमन पत्र",
            "tooltip.copy to clipboard": "क्लिपबोर्ड पर कॉपी करें",
            "tooltip.redo": "फिर से करें",
            "tooltip.toggle virtual keyboard": "वर्चुअल कीबोर्ड टॉगल करें",
            "tooltip.undo": "पूर्ववत",
            "menu.insert matrix": "मैट्रिक्स डालें",
            "menu.insert vector": "वेक्टर डालें",
            "submenu.array.matrix delimiters": "मैट्रिक्स सीमांकक",
            "menu.array.add row above": "बाद में पंक्ति जोड़ें",
            "menu.array.add row below": "पहले पंक्ति जोड़ें",
            "menu.array.add column after": "बाद में कॉलम जोड़ें",
            "menu.array.add column before": "पहले कॉलम जोड़ें",
            "menu.array.delete row": "पंक्ति को हटाएं",
            "menu.array.delete rows": "चयनित पंक्तियों को हटाएं",
            "menu.array.delete column": "कॉलम हटाएं",
            "menu.array.delete columns": "चयनित कॉलम हटाएं",
            "submenu.array.insert separator": "विभाजक डालें",
            "menu.insert table": "टेबल इंसर्ट करें",
            "submenu.table style": "टेबल स्टाइल"
        },
        hu: {
            "keyboard.tooltip.functions": "Funkci\xf3k",
            "keyboard.tooltip.symbols": "Szimb\xf3lumok",
            "keyboard.tooltip.greek": "G\xf6r\xf6g levelek",
            "keyboard.tooltip.command": "LaTeX Parancs m\xf3d",
            "keyboard.tooltip.numeric": "Numerikus",
            "keyboard.tooltip.roman": "R\xf3mai levelek",
            "tooltip.copy to clipboard": "M\xe1solja a v\xe1g\xf3lapra",
            "tooltip.redo": "\xdajra",
            "tooltip.toggle virtual keyboard": "V\xe1lt\xe1s a virtu\xe1lis billentyűzetre",
            "tooltip.undo": "Visszavon\xe1s",
            "menu.insert matrix": "Helyezze be a M\xe1trixot",
            "menu.insert vector": "Vektor besz\xfar\xe1sa",
            "submenu.array.matrix delimiters": "M\xe1trixhat\xe1rol\xf3k",
            "menu.array.add row above": "Sor hozz\xe1ad\xe1sa ut\xe1n",
            "menu.array.add row below": "Add Add Sor előtt",
            "menu.array.add column after": "Oszlop hozz\xe1ad\xe1sa ut\xe1n",
            "menu.array.add column before": "Add oszlop előtt",
            "menu.array.delete row": "Sor t\xf6rl\xe9se",
            "menu.array.delete rows": "Kijel\xf6lt sorok t\xf6rl\xe9se",
            "menu.array.delete column": "Oszlop t\xf6rl\xe9se",
            "menu.array.delete columns": "A kijel\xf6lt oszlopok t\xf6rl\xe9se",
            "submenu.array.insert separator": "Helyezze be az elv\xe1laszt\xf3t",
            "menu.insert table": "Helyezze be a t\xe1bl\xe1zatot",
            "submenu.table style": "T\xe1bl\xe1zatos st\xedlus"
        },
        it: {
            "keyboard.tooltip.functions": "Funzioni",
            "keyboard.tooltip.symbols": "Simboli",
            "keyboard.tooltip.greek": "Lettere greche",
            "keyboard.tooltip.command": "Modalit\xe0 di comando LaTeX",
            "keyboard.tooltip.numeric": "Numerico",
            "keyboard.tooltip.roman": "Lettere romane",
            "tooltip.copy to clipboard": "Copia negli appunti",
            "tooltip.redo": "Rifare",
            "tooltip.toggle virtual keyboard": "Attiva / disattiva la tastiera virtuale",
            "tooltip.undo": "Disfare",
            "menu.insert matrix": "Inserisci una Matrice",
            "menu.insert vector": "Inserisci Vettore",
            "submenu.array.matrix delimiters": "Delimitatori di Matrice",
            "menu.array.add row above": "Aggiungi una Riga Prima",
            "menu.array.add row below": "Aggiungi una Riga Dopo",
            "menu.array.add column before": "Aggiungi una Colonna Prima",
            "menu.array.add column after": "Aggiungi una Colonna Dopo",
            "menu.array.delete row": "Rimuovi una Riga",
            "menu.array.delete rows": "Rimuovi le Righe Selezionate",
            "menu.array.delete column": "Rimuovi una Colonna",
            "menu.array.delete columns": "Rimuovi le Colonne Selezionate",
            "submenu.array.insert separator": "Inserisci un Separatore",
            "menu.insert table": "Inserisci Tabella",
            "submenu.table style": "Stile tabella"
        },
        is: {
            "keyboard.tooltip.functions": "A\xf0ger\xf0ir",
            "keyboard.tooltip.symbols": "T\xe1kn",
            "keyboard.tooltip.greek": "Gr\xedsk br\xe9f",
            "keyboard.tooltip.command": "LaTeX stj\xf3rnunarstilling",
            "keyboard.tooltip.numeric": "T\xf6lulegt",
            "keyboard.tooltip.roman": "R\xf3mversk br\xe9f",
            "tooltip.copy to clipboard": "Afrita\xf0u \xe1 klemmuspjald",
            "tooltip.redo": "Endurtaka",
            "tooltip.toggle virtual keyboard": "Skiptu um s\xfdndarlyklabor\xf0",
            "tooltip.undo": "Afturkalla",
            "menu.insert matrix": "Settu fylki inn",
            "menu.insert vector": "Settu inn Vector",
            "submenu.array.matrix delimiters": "Matrix afm\xf6rkun",
            "menu.array.add row above": "B\xe6ta vi\xf0 r\xf6\xf0 \xe1 eftir",
            "menu.array.add row below": "B\xe6ta vi\xf0 r\xf6\xf0 \xe1\xf0ur",
            "menu.array.add column after": "B\xe6ta vi\xf0 d\xe1lki \xe1 eftir",
            "menu.array.add column before": "B\xe6ta vi\xf0 d\xe1lki \xe1\xf0ur",
            "menu.array.delete row": "Ey\xf0a r\xf6\xf0",
            "menu.array.delete rows": "Ey\xf0a v\xf6ldum l\xednum",
            "menu.array.delete column": "Ey\xf0a d\xe1lki",
            "menu.array.delete columns": "Ey\xf0a v\xf6ldum d\xe1lkum",
            "submenu.array.insert separator": "Settu skiljuna \xed",
            "menu.insert table": "Settu inn t\xf6flu",
            "submenu.table style": "T\xf6flu st\xedl"
        },
        ja: {
            "keyboard.tooltip.functions": "関数",
            "keyboard.tooltip.symbols": "シンボル",
            "keyboard.tooltip.greek": "ギリシャ文字",
            "keyboard.tooltip.command": "ラテックスコマンドモード",
            "keyboard.tooltip.numeric": "数値",
            "keyboard.tooltip.roman": "ローマ字",
            "tooltip.copy to clipboard": "クリップボードにコピー",
            "tooltip.redo": "やり直し",
            "tooltip.toggle virtual keyboard": "仮想キーボードの切り替え",
            "tooltip.undo": "元に戻す",
            "menu.insert matrix": "マトリックスを挿入",
            "menu.insert vector": "ベクトルを挿入",
            "submenu.array.matrix delimiters": "行列区切り文字",
            "menu.array.add row above": "後に行を追加",
            "menu.array.add row below": "前に行を追加",
            "menu.array.add column after": "後に列を追加",
            "menu.array.add column before": "前に列を追加",
            "menu.array.delete row": "行を削除",
            "menu.array.delete rows": "選択した行を削除する",
            "menu.array.delete column": "列を削除",
            "menu.array.delete columns": "選択した列を削除する",
            "submenu.array.insert separator": "セパレーターを挿入",
            "menu.insert table": "テーブルを挿入",
            "submenu.table style": "テーブルスタイル"
        },
        ko: {
            "keyboard.tooltip.functions": "기능",
            "keyboard.tooltip.symbols": "기호",
            "keyboard.tooltip.greek": "그리스 문자",
            "keyboard.tooltip.command": "유액 명령 모드",
            "keyboard.tooltip.numeric": "숫자",
            "keyboard.tooltip.roman": "로마 문자",
            "tooltip.copy to clipboard": "클립 보드에 복사",
            "tooltip.redo": "다시 하다",
            "tooltip.toggle virtual keyboard": "가상 키보드 전환",
            "tooltip.undo": "실행 취소",
            "menu.insert matrix": "매트릭스 삽입",
            "menu.insert vector": "벡터 삽입",
            "submenu.array.matrix delimiters": "행렬 구분 기호",
            "menu.array.add row above": "뒤에 행 추가",
            "menu.array.add row below": "앞에 행 추가",
            "menu.array.add column after": "뒤에 열 추가",
            "menu.array.add column before": "앞에 열 추가",
            "menu.array.delete row": "행 삭제",
            "menu.array.delete rows": "선택한 행 삭제",
            "menu.array.delete column": "열 삭제",
            "menu.array.delete columns": "선택한 열 삭제",
            "submenu.array.insert separator": "구분자 삽입",
            "menu.insert table": "표 삽입",
            "submenu.table style": "테이블 스타일"
        },
        lv: {
            "keyboard.tooltip.functions": "Funkcijas",
            "keyboard.tooltip.symbols": "Simboli",
            "keyboard.tooltip.greek": "Grieķu burti",
            "keyboard.tooltip.command": "LaTeX komandu režīms",
            "keyboard.tooltip.numeric": "Ciparu skaitlis",
            "keyboard.tooltip.roman": "Romiešu vēstules",
            "tooltip.copy to clipboard": "Kopēt starpliktuvē",
            "tooltip.redo": "Pārtaisīt",
            "tooltip.toggle virtual keyboard": "Pārslēgt virtuālo tastatūru",
            "tooltip.undo": "Atsaukt",
            "menu.insert matrix": "Ievietojiet matricu",
            "menu.insert vector": "Ievietot vektoru",
            "submenu.array.matrix delimiters": "Matricas norobežotāji",
            "menu.array.add row above": "Pievienot rindu pēc",
            "menu.array.add row below": "Pievienot rindu pirms",
            "menu.array.add column after": "Pievienot kolonnu pēc",
            "menu.array.add column before": "Pievienot kolonnu pirms",
            "menu.array.delete row": "Dzēst rindu",
            "menu.array.delete rows": "Dzēst atlasītās rindas",
            "menu.array.delete column": "Dzēst kolonnu",
            "menu.array.delete columns": "Dzēst atlasītās kolonnas",
            "submenu.array.insert separator": "Ievietojiet atdalītāju",
            "menu.insert table": "Ievietojiet tabulu",
            "submenu.table style": "Galda stils"
        },
        lt: {
            "keyboard.tooltip.functions": "Funkcijos",
            "keyboard.tooltip.symbols": "Simboliai",
            "keyboard.tooltip.greek": "Graikiškos raidės",
            "keyboard.tooltip.command": "LaTeX komandų režimas",
            "keyboard.tooltip.numeric": "Skaitmeninis",
            "keyboard.tooltip.roman": "Romos laiškai",
            "tooltip.copy to clipboard": "Nukopijuoti į iškarpinę",
            "tooltip.redo": "Perdaryti",
            "tooltip.toggle virtual keyboard": "Perjungti virtualiąją klaviatūrą",
            "tooltip.undo": "Atšaukti",
            "menu.insert matrix": "Ievietojiet matricu",
            "menu.insert vector": "Ievietot vektoru",
            "submenu.array.matrix delimiters": "Matricas norobežotāji",
            "menu.array.add row above": "Pievienot rindu pēc",
            "menu.array.add row below": "Pievienot rindu pirms",
            "menu.array.add column after": "Pievienot kolonnu pēc",
            "menu.array.add column before": "Pievienot kolonnu pirms",
            "menu.array.delete row": "Dzēst rindu",
            "menu.array.delete rows": "Dzēst atlasītās rindas",
            "menu.array.delete column": "Dzēst kolonnu",
            "menu.array.delete columns": "Dzēst atlasītās kolonnas",
            "submenu.array.insert separator": "Ievietojiet atdalītāju",
            "menu.insert table": "Ievietojiet tabulu",
            "submenu.table style": "Tabulas stili"
        },
        lu: {
            "keyboard.tooltip.functions": "Funktiounen",
            "keyboard.tooltip.symbols": "Symboler",
            "keyboard.tooltip.greek": "Griichesch Br\xe9iwer",
            "keyboard.tooltip.command": "LaTeX Kommando Modus",
            "keyboard.tooltip.numeric": "Numeresch",
            "keyboard.tooltip.roman": "R\xe9imesch Br\xe9iwer",
            "tooltip.copy to clipboard": "Kop\xe9iert op Clipboard",
            "tooltip.redo": "Nees nei maachen",
            "tooltip.toggle virtual keyboard": "Wiesselt Virtuell Tastatur",
            "tooltip.undo": "Undoen",
            "menu.insert matrix": "Matrix asetzen",
            "menu.insert vector": "Insert Vector",
            "submenu.array.matrix delimiters": "Matrix Ofgrenzer",
            "menu.array.add row above": "Dob\xe4izemaachen Rei No",
            "menu.array.add row below": "F\xfc\xfcgt Rei vir",
            "menu.array.add column after": "Dob\xe4izemaachen Kolonn No",
            "menu.array.add column before": "Kolonn derb\xe4i Virun",
            "menu.array.delete row": "Rad l\xe4schen",
            "menu.array.delete rows": "L\xe4scht Ausgewielte Reien",
            "menu.array.delete column": "L\xe4scht Kolonn",
            "menu.array.delete columns": "L\xe4scht Ausgewielte Kolonnen",
            "submenu.array.insert separator": "Insert Separator",
            "menu.insert table": "D\xebsch anzeginn",
            "submenu.table style": "D\xebsch Style"
        },
        nl: {
            "keyboard.tooltip.functions": "Functies",
            "keyboard.tooltip.symbols": "Symbolen",
            "keyboard.tooltip.greek": "Griekse letters",
            "keyboard.tooltip.command": "LaTeX commando mode",
            "keyboard.tooltip.numeric": "Numeriek",
            "keyboard.tooltip.roman": "Romeinse letters",
            "tooltip.copy to clipboard": "Kopi\xebren naar klembord",
            "tooltip.redo": "Opnieuw",
            "tooltip.toggle virtual keyboard": "Schakel naar virtueel toetsenbord",
            "tooltip.undo": "Ongedaan maken",
            "menu.insert matrix": "Matrix invoegen",
            "menu.insert vector": "Vector invoegen",
            "submenu.array.matrix delimiters": "Matrixscheidingstekens",
            "menu.array.add row above": "Rij toevoegen na",
            "menu.array.add row below": "Rij toevoegen eerder",
            "menu.array.add column after": "Kolom toevoegen na",
            "menu.array.add column before": "Kolom toevoegen voor",
            "menu.array.delete row": "Verwijder rij",
            "menu.array.delete rows": "Geselecteerde rijen verwijderen",
            "menu.array.delete column": "Kolom verwijderen",
            "menu.array.delete columns": "Geselecteerde kolommen verwijderen",
            "submenu.array.insert separator": "Scheidingsteken invoegen",
            "menu.insert table": "Tabel invoegen",
            "submenu.table style": "Tabelstijl"
        },
        no: {
            "keyboard.tooltip.functions": "Funksjoner",
            "keyboard.tooltip.symbols": "Symboler",
            "keyboard.tooltip.greek": "Greske bokstaver",
            "keyboard.tooltip.command": "LaTeX kommandomodus",
            "keyboard.tooltip.numeric": "Numerisk",
            "keyboard.tooltip.roman": "Romerske bokstaver",
            "tooltip.copy to clipboard": "Kopiere til utklippstavle",
            "tooltip.redo": "Gj\xf8re om",
            "tooltip.toggle virtual keyboard": "Bytt virtuelt tastatur",
            "tooltip.undo": "Angre",
            "menu.insert matrix": "Sett inn matrise",
            "menu.insert vector": "Sett inn vektor",
            "submenu.array.matrix delimiters": "Matrix avgrensere",
            "menu.array.add row above": "Legg til rad etter",
            "menu.array.add row below": "Legg til rad f\xf8r",
            "menu.array.add column after": "Legg til kolonne etter",
            "menu.array.add column before": "Legg til kolonne f\xf8r",
            "menu.array.delete row": "Slett rad",
            "menu.array.delete rows": "Slett valgte rader",
            "menu.array.delete column": "Slett kolonne",
            "menu.array.delete columns": "Slett valgte kolonner",
            "submenu.array.insert separator": "Sett inn skilletegn",
            "menu.insert table": "Sett inn tabell",
            "submenu.table style": "Tabellstil"
        },
        mk: {
            "keyboard.tooltip.functions": "Функции",
            "keyboard.tooltip.symbols": "Симболи",
            "keyboard.tooltip.greek": "Грчки букви",
            "keyboard.tooltip.command": "Режим на команда во латекс",
            "keyboard.tooltip.numeric": "Нумерички",
            "keyboard.tooltip.roman": "Римски писма",
            "tooltip.copy to clipboard": "Копирајте во клипборд",
            "tooltip.redo": "Повторно",
            "tooltip.toggle virtual keyboard": "Вклучете ја виртуелната тастатура",
            "tooltip.undo": "Врати",
            "menu.insert matrix": "Вметнете матрица",
            "menu.insert vector": "Вметни вектор",
            "submenu.array.matrix delimiters": "Разграничувачи на матрица",
            "menu.array.add row above": "Додадете ред после",
            "menu.array.add row below": "Додади ред пред тоа",
            "menu.array.add column after": "Додадете колона после",
            "menu.array.add column before": "Додадете колона пред тоа",
            "menu.array.delete row": "Избриши го редот",
            "menu.array.delete rows": "Избришете ги избраните редови",
            "menu.array.delete column": "Избриши ја колоната",
            "menu.array.delete columns": "Избриши ја колоната",
            "submenu.array.insert separator": "Вметнете сепаратор",
            "menu.insert table": "Вметни табела",
            "submenu.table style": "Табела стил"
        },
        pl: {
            "keyboard.tooltip.functions": "Funkcje",
            "keyboard.tooltip.symbols": "Symbolika",
            "keyboard.tooltip.greek": "Litery greckie",
            "keyboard.tooltip.command": "Tryb poleceń LaTeX",
            "keyboard.tooltip.numeric": "Numeryczne",
            "keyboard.tooltip.roman": "Litery rzymskie",
            "tooltip.copy to clipboard": "Kopiuj do Schowka",
            "tooltip.redo": "Przywr\xf3ć",
            "tooltip.toggle virtual keyboard": "Przełącz wirtualną klawiaturę",
            "tooltip.undo": "Cofnij",
            "menu.insert matrix": "Wstaw macierz",
            "menu.insert vector": "Wstaw wektor",
            "submenu.array.matrix delimiters": "Ograniczniki macierzy",
            "menu.array.add row above": "Dodaj wiersz po",
            "menu.array.add row below": "Dodaj wiersz przed",
            "menu.array.add column after": "Dodaj kolumnę po",
            "menu.array.add column before": "Dodaj kolumnę przed",
            "menu.array.delete row": "Usuń wiersz",
            "menu.array.delete rows": "Usuń wybrane wiersze",
            "menu.array.delete column": "Usuń kolumnę",
            "menu.array.delete columns": "Usuń wybrane kolumny",
            "submenu.array.insert separator": "Wstaw separator",
            "menu.insert table": "Wypełnij tabelę",
            "submenu.table style": "Styl tabelę"
        },
        pt: {
            "keyboard.tooltip.functions": "Functions",
            "keyboard.tooltip.symbols": "S\xedmbolos",
            "keyboard.tooltip.greek": "Letras gregas",
            "keyboard.tooltip.command": "Modo de Comando LaTeX",
            "keyboard.tooltip.numeric": "Num\xe9rico",
            "keyboard.tooltip.roman": "Letras romanas",
            "tooltip.copy to clipboard": "Copiar para \xe1rea de transfer\xeancia",
            "tooltip.redo": "Refazer",
            "tooltip.toggle virtual keyboard": "Alternar teclado virtual",
            "tooltip.undo": "Desfazer",
            "menu.insert matrix": "Inserir Matriz",
            "menu.insert vector": "Inserir vetor",
            "submenu.array.matrix delimiters": "Delimitadores de matriz",
            "menu.array.add row above": "Adicionar linha depois",
            "menu.array.add row below": "Adicionar linha antes",
            "menu.array.add column after": "Adicionar coluna depois",
            "menu.array.add column before": "Adicionar coluna antes",
            "menu.array.delete row": "Excluir linha",
            "menu.array.delete rows": "Excluir linhas selecionadas",
            "menu.array.delete column": "Apagar Coluna",
            "menu.array.delete columns": "Excluir Colunas Selecionadas",
            "submenu.array.insert separator": "Inserir Separador",
            "menu.insert table": "Insira a tabela",
            "submenu.table style": "Estilo tabela"
        },
        ro: {
            "keyboard.tooltip.functions": "Funcții",
            "keyboard.tooltip.symbols": "Simboluri",
            "keyboard.tooltip.greek": "Scrisori grecești",
            "keyboard.tooltip.command": "Modul de comandă latex",
            "keyboard.tooltip.numeric": "Numeric",
            "keyboard.tooltip.roman": "Scrisori romane",
            "tooltip.copy to clipboard": "Copiați \xeen clipboard",
            "tooltip.redo": "A reface",
            "tooltip.toggle virtual keyboard": "Comutați tastatura virtuală",
            "tooltip.undo": "Anula",
            "menu.insert matrix": "Introduceți Matrix",
            "menu.insert vector": "Inserați Vector",
            "submenu.array.matrix delimiters": "Delimitatori de matrice",
            "menu.array.add row above": "Adăugați r\xe2ndul după",
            "menu.array.add row below": "Adăugați r\xe2ndul \xeenainte",
            "menu.array.add column after": "Adăugați o coloană după",
            "menu.array.add column before": "Adăugați o coloană \xeenainte",
            "menu.array.delete row": "Ștergeți r\xe2ndul",
            "menu.array.delete rows": "Ștergeți r\xe2ndurile selectate",
            "menu.array.delete column": "Ștergeți coloana",
            "menu.array.delete columns": "Ștergeți coloanele selectate",
            "submenu.array.insert separator": "Introduceți separatorul",
            "menu.insert table": "Introduceți tabelul",
            "submenu.table style": "Table style"
        },
        ru: {
            "keyboard.tooltip.functions": "Функции",
            "keyboard.tooltip.symbols": "Символы",
            "keyboard.tooltip.greek": "Греческие буквы",
            "keyboard.tooltip.command": "Режим командной строки Латекс",
            "keyboard.tooltip.numeric": "числовой",
            "keyboard.tooltip.roman": "Латинские буквы",
            "tooltip.copy to clipboard": "Скопировать в буфер обмена",
            "tooltip.redo": "переделывать",
            "tooltip.toggle virtual keyboard": "Переключить виртуальную клавиатуру",
            "tooltip.undo": "расстегивать",
            "menu.insert matrix": "Вставить матрицу",
            "menu.insert vector": "Вставить вектор",
            "submenu.array.matrix delimiters": "Матричные разделители",
            "menu.array.add row above": "Добавить строку после",
            "menu.array.add row below": "Добавить строку перед",
            "menu.array.add column after": "Добавить столбец после",
            "menu.array.add column before": "Добавить столбец перед",
            "menu.array.delete row": "Удалить строку",
            "menu.array.delete rows": "Удалить выбранные строки",
            "menu.array.delete column": "Удалить столбец",
            "menu.array.delete columns": "Удалить выбранные столбцы",
            "submenu.array.insert separator": "Вставить разделитель",
            "menu.insert table": "Вставить таблицу",
            "submenu.table style": "Табличный стиль"
        },
        sk: {
            "keyboard.tooltip.functions": "Functions",
            "keyboard.tooltip.symbols": "Symboly",
            "keyboard.tooltip.greek": "Gr\xe9cke listy",
            "keyboard.tooltip.command": "Pr\xedkazov\xfd režim LaTeX",
            "keyboard.tooltip.numeric": "Numerick\xe9",
            "keyboard.tooltip.roman": "R\xedmske listy",
            "tooltip.copy to clipboard": "Skop\xedrovať do schr\xe1nky",
            "tooltip.redo": "Znova",
            "tooltip.toggle virtual keyboard": "Prepn\xfať virtu\xe1lnu kl\xe1vesnicu",
            "tooltip.undo": "Vr\xe1tenie sp\xe4ť",
            "menu.insert matrix": "Vložte maticu",
            "menu.insert vector": "Vložte vektor",
            "submenu.array.matrix delimiters": "Oddeľovače mat\xedc",
            "menu.array.add row above": "Pridajte riadok za",
            "menu.array.add row below": "Pridajte riadok pred",
            "menu.array.add column after": "Pridať stĺpec za",
            "menu.array.add column before": "Pridajte stĺpec predt\xfdm",
            "menu.array.delete row": "Odstr\xe1niť riadok",
            "menu.array.delete rows": "Odstr\xe1niť vybrat\xe9 riadky",
            "menu.array.delete column": "Odstr\xe1niť stĺpec",
            "menu.array.delete columns": "Odstr\xe1niť vybrat\xe9 stĺpce",
            "submenu.array.insert separator": "Vložte oddeľovač",
            "menu.insert table": "Vložte tabuľku",
            "submenu.table style": "Št\xfdl tabuľky"
        },
        sl: {
            "keyboard.tooltip.functions": "Funkcije",
            "keyboard.tooltip.symbols": "Simboli",
            "keyboard.tooltip.greek": "Grška pisma",
            "keyboard.tooltip.command": "Ukazni način LaTeX",
            "keyboard.tooltip.numeric": "Številsko",
            "keyboard.tooltip.roman": "Rimska pisma",
            "tooltip.copy to clipboard": "Kopirati v odložišče",
            "tooltip.redo": "Ponovi",
            "tooltip.toggle virtual keyboard": "Preklop navidezne tipkovnice",
            "tooltip.undo": "Razveljavi",
            "menu.insert matrix": "Vstavi matrico",
            "menu.insert vector": "Vstavi vektor",
            "submenu.array.matrix delimiters": "Matrični ločevalniki",
            "menu.array.add row above": "Dodaj vrstico po",
            "menu.array.add row below": "Dodaj vrstico prej",
            "menu.array.add column after": "Dodaj stolpec po",
            "menu.array.add column before": "Dodaj stolpec prej",
            "menu.array.delete row": "Izbriši vrstico",
            "menu.array.delete rows": "Izbriši izbrane vrstice",
            "menu.array.delete column": "Izbriši stolpec",
            "menu.array.delete columns": "Izbriši izbrane stolpce",
            "submenu.array.insert separator": "Vstavi ločilo",
            "menu.insert table": "Vstavi tabelo",
            "submenu.table style": "Tabela slog"
        },
        sq: {
            "keyboard.tooltip.functions": "Funksione",
            "keyboard.tooltip.symbols": "Simbolet",
            "keyboard.tooltip.greek": "Letrat Greke",
            "keyboard.tooltip.command": "Modaliteti i komand\xebs latex",
            "keyboard.tooltip.numeric": "Numerike",
            "keyboard.tooltip.roman": "Letrat romake",
            "tooltip.copy to clipboard": "Kopjoni n\xeb Clipboard",
            "tooltip.redo": "Riparo",
            "tooltip.toggle virtual keyboard": "Aktivizo tastier\xebn virtuale",
            "tooltip.undo": "Zhb\xebj",
            "menu.insert matrix": "Vendosni Matric\xebn",
            "menu.insert vector": "Vendos vektorin",
            "submenu.array.matrix delimiters": "P\xebrcaktuesit e matric\xebs",
            "menu.array.add row above": "Shto Rreshtin Pas",
            "menu.array.add row below": "Shto Rreshtin Para",
            "menu.array.add column after": "Shto kolon\xebn pas",
            "menu.array.add column before": "Shto kolon\xebn para",
            "menu.array.delete row": "Fshi Rreshtin",
            "menu.array.delete rows": "Fshi rreshtat e zgjedhur",
            "menu.array.delete column": "Fshi kolon\xebn",
            "menu.array.delete columns": "Fshi kolonat e zgjedhura",
            "submenu.array.insert separator": "Vendos Ndar\xebsin",
            "menu.insert table": "Vendos tabel\xebn",
            "submenu.table style": "Stili tabel\xebn"
        },
        sr: {
            "keyboard.tooltip.functions": "Функције",
            "keyboard.tooltip.symbols": "Симболи",
            "keyboard.tooltip.greek": "Греек Леттерс",
            "keyboard.tooltip.command": "ЛаТеКс командни режим",
            "keyboard.tooltip.numeric": "Нумерички",
            "keyboard.tooltip.roman": "Римска писма",
            "tooltip.copy to clipboard": "Копирајте у међуспремник",
            "tooltip.redo": "Понови",
            "tooltip.toggle virtual keyboard": "Укључи / искључи виртуелну тастатуру",
            "tooltip.undo": "Опозови",
            "menu.insert matrix": "Уметни матрицу",
            "menu.insert vector": "Уметни вектор",
            "submenu.array.matrix delimiters": "Матрик Делимитерс",
            "menu.array.add row above": "Додај ред после",
            "menu.array.add row below": "Додај ред пре",
            "menu.array.add column after": "Додај колону после",
            "menu.array.add column before": "Додај колону пре",
            "menu.array.delete row": "Избриши ред",
            "menu.array.delete rows": "Избриши изабране редове",
            "menu.array.delete column": "Избриши колону",
            "menu.array.delete columns": "Избриши изабране колоне",
            "submenu.array.insert separator": "Уметни сепаратор",
            "menu.insert table": "Убаци табелу",
            "submenu.table style": "Табеларни стил"
        },
        sv: {
            "keyboard.tooltip.functions": "Funktioner",
            "keyboard.tooltip.symbols": "Symboler",
            "keyboard.tooltip.greek": "Grekiska bokst\xe4ver",
            "keyboard.tooltip.command": "LaTeX kommandol\xe4ge",
            "keyboard.tooltip.numeric": "Numerisk",
            "keyboard.tooltip.roman": "Romerska bokst\xe4ver",
            "tooltip.copy to clipboard": "Kopiera till Urklipp",
            "tooltip.redo": "G\xf6ra om",
            "tooltip.toggle virtual keyboard": "V\xe4xla virtuellt tangentbord",
            "tooltip.undo": "\xc5ngra",
            "menu.insert matrix": "S\xe4tt in matris",
            "menu.insert vector": "Infoga vektor",
            "submenu.array.matrix delimiters": "Matrisavgr\xe4nsare",
            "menu.array.add row above": "L\xe4gg till rad efter",
            "menu.array.add row below": "L\xe4gg till rad f\xf6re",
            "menu.array.add column after": "L\xe4gg till kolumn efter",
            "menu.array.add column before": "L\xe4gg till kolumn f\xf6re",
            "menu.array.delete row": "Radera rad",
            "menu.array.delete rows": "Ta bort valda rader",
            "menu.array.delete column": "Ta bort kolumn",
            "menu.array.delete columns": "Ta bort valda kolumner",
            "submenu.array.insert separator": "S\xe4tt i separator",
            "menu.insert table": "Infoga tabell",
            "submenu.table style": "Tabellstil"
        },
        th: {
            "keyboard.tooltip.functions": "ฟังก์ชั่น",
            "keyboard.tooltip.symbols": "สัญลักษณ์",
            "keyboard.tooltip.greek": "อักษรกรีก",
            "keyboard.tooltip.command": "โหมดคำสั่ง น้ำยาง",
            "keyboard.tooltip.numeric": "ตัวเลข",
            "keyboard.tooltip.roman": "อักษรโรมัน",
            "tooltip.copy to clipboard": "คัดลอกไปที่คลิปบอร์ด",
            "tooltip.redo": "ทำซ้ำ",
            "tooltip.toggle virtual keyboard": "สลับแป้นพิมพ์เสมือน",
            "tooltip.undo": "เลิกทำ",
            "menu.insert matrix": "แทรกเมทริกซ์",
            "menu.insert vector": "แทรกเวกเตอร์",
            "submenu.array.matrix delimiters": "ตัวคั่นเมทริกซ์",
            "menu.array.add row above": "เพิ่มแถวหลัง",
            "menu.array.add row below": "เพิ่มแถวก่อน",
            "menu.array.add column after": "เพิ่มคอลัมน์หลัง",
            "menu.array.add column before": "เพิ่มคอลัมน์ก่อน",
            "menu.array.delete row": "ลบแถว",
            "menu.array.delete rows": "ลบแถวที่เลือก",
            "menu.array.delete column": "ลบคอลัมน์",
            "menu.array.delete columns": "ลบคอลัมน์ที่เลือก",
            "submenu.array.insert separator": "ตัวคั่นแทรก",
            "menu.insert table": "แทรกตาราง",
            "submenu.table style": "สไตล์ตาราง"
        },
        tr: {
            "keyboard.tooltip.functions": "Fonksiyonlar",
            "keyboard.tooltip.symbols": "Semboller",
            "keyboard.tooltip.greek": "Yunan harfleri",
            "keyboard.tooltip.command": "LaTeX Komut Modu",
            "keyboard.tooltip.numeric": "Sayısal",
            "keyboard.tooltip.roman": "Roma Harfleri",
            "tooltip.copy to clipboard": "Panoya kopyala",
            "tooltip.redo": "Yeniden yap",
            "tooltip.toggle virtual keyboard": "Sanal Klavyeyi A\xe7/Kapat",
            "tooltip.undo": "Geri alma",
            "menu.insert matrix": "Matris Ekle",
            "menu.insert vector": "Vekt\xf6r Ekle",
            "submenu.array.matrix delimiters": "Matris Sınırlayıcılar",
            "menu.array.add row above": "Satırdan Sonra Ekle",
            "menu.array.add row below": "\xd6nce Satır Ekle",
            "menu.array.add column after": "Sonra S\xfctun Ekle",
            "menu.array.add column before": "\xd6nce S\xfctun Ekle",
            "menu.array.delete row": "Sırayı sil",
            "menu.array.delete rows": "Se\xe7ili Satırları Sil",
            "menu.array.delete column": "S\xfctunu Sil",
            "menu.array.delete columns": "Se\xe7ili S\xfctunları Sil",
            "submenu.array.insert separator": "Ayırıcı Ekle",
            "menu.insert table": "Tablo Ekle",
            "submenu.table style": "Tablo Stili"
        },
        uk: {
            "keyboard.tooltip.functions": "Функції",
            "keyboard.tooltip.symbols": "Символи",
            "keyboard.tooltip.greek": "Грецькі літери",
            "keyboard.tooltip.command": "Командний режим латексу",
            "keyboard.tooltip.numeric": "Числовий",
            "keyboard.tooltip.roman": "Римські літери",
            "tooltip.copy to clipboard": "Копіювати в буфер обміну",
            "tooltip.redo": "Повторити",
            "tooltip.toggle virtual keyboard": "Переключити віртуальну клавіатуру",
            "tooltip.undo": "Скасувати",
            "menu.insert matrix": "Вставити матрицю",
            "menu.insert vector": "Вставити вектор",
            "submenu.array.matrix delimiters": "Матричні роздільники",
            "menu.array.add row above": "Додати рядок після",
            "menu.array.add row below": "Додати рядок до",
            "menu.array.add column after": "Додати стовпець після",
            "menu.array.add column before": "Додати стовпець перед",
            "menu.array.delete row": "Видалити рядок",
            "menu.array.delete rows": "Видалити вибрані рядки",
            "menu.array.delete column": "Видалити стовпець",
            "menu.array.delete columns": "Видалити вибрані стовпці",
            "submenu.array.insert separator": "Вставте роздільник",
            "menu.insert table": "Вставити таблицю",
            "submenu.table style": "Стиль таблиці"
        },
        vi: {
            "keyboard.tooltip.functions": "Chức năng",
            "keyboard.tooltip.symbols": "K\xfd hiệu",
            "keyboard.tooltip.greek": "Chữ Hy Lạp",
            "keyboard.tooltip.command": "Chế độ lệnh LaTeX",
            "keyboard.tooltip.numeric": "Số",
            "keyboard.tooltip.roman": "Chữ c\xe1i La m\xe3",
            "tooltip.copy to clipboard": "Sao ch\xe9p v\xe0o clipboard",
            "tooltip.redo": "L\xe0m lại",
            "tooltip.toggle virtual keyboard": "Chuyển đổi b\xe0n ph\xedm ảo",
            "tooltip.undo": "Ho\xe0n t\xe1c",
            "menu.insert matrix": "Ch\xe8n ma trận",
            "menu.insert vector": "Insert Vector",
            "submenu.array.matrix delimiters": "Dấu ph\xe2n c\xe1ch ma trận",
            "menu.array.add row above": "Th\xeam h\xe0ng sau",
            "menu.array.add row below": "Th\xeam h\xe0ng trước",
            "menu.array.add column after": "Th\xeam cột sau",
            "menu.array.add column before": "Th\xeam cột trước",
            "menu.array.delete row": "X\xf3a h\xe0ng",
            "menu.array.delete rows": "X\xf3a h\xe0ng đ\xe3 chọn",
            "menu.array.delete column": "X\xf3a cột",
            "menu.array.delete columns": "X\xf3a c\xe1c cột đ\xe3 chọn",
            "submenu.array.insert separator": "Ch\xe8n dấu ph\xe2n c\xe1ch",
            "menu.insert table": "Ch\xe8n bảng",
            "submenu.table style": "Kiểu bảng"
        },
        zh_cn: {
            "keyboard.tooltip.functions": "职能",
            "keyboard.tooltip.symbols": "符号",
            "keyboard.tooltip.greek": "希腊字母",
            "keyboard.tooltip.command": "乳胶 命令模式",
            "keyboard.tooltip.numeric": "数字",
            "keyboard.tooltip.roman": "罗马字母",
            "tooltip.copy to clipboard": "复制到剪贴板",
            "tooltip.redo": "重做",
            "tooltip.toggle virtual keyboard": "切换虚拟键盘",
            "tooltip.undo": "撤消",
            "menu.insert matrix": "插入矩阵",
            "menu.insert vector": "插入向量",
            "submenu.array.matrix delimiters": "矩阵分隔符",
            "menu.array.add row above": "在后面添加行",
            "menu.array.add row below": "在前面添加行",
            "menu.array.add column after": "在后面添加列r",
            "menu.array.add column before": "在前面添加列",
            "menu.array.delete row": "删除行",
            "menu.array.delete rows": "删除选定行",
            "menu.array.delete column": "删除列",
            "menu.array.delete columns": "删除选定的列",
            "submenu.array.insert separator": "插入分隔符",
            "menu.insert table": "插入表格",
            "submenu.table style": "表格样式"
        },
        zh_tw: {
            "keyboard.tooltip.functions": "職能",
            "keyboard.tooltip.symbols": "符號",
            "keyboard.tooltip.greek": "希臘字母",
            "keyboard.tooltip.command": "乳膠命令模式",
            "keyboard.tooltip.numeric": "數字",
            "keyboard.tooltip.roman": "羅馬字母",
            "tooltip.copy to clipboard": "複製到剪貼板",
            "tooltip.redo": "重做",
            "tooltip.toggle virtual keyboard": "切換虛擬鍵盤",
            "tooltip.undo": "撤消",
            "menu.insert matrix": "插入矩陣",
            "menu.insert vector": "插入向量",
            "submenu.array.matrix delimiters": "矩陣分隔符",
            "menu.array.add row above": "在後面添加行",
            "menu.array.add row below": "在前面添加行",
            "menu.array.add column after": "在後面添加列",
            "menu.array.add column before": "在前面添加列",
            "menu.array.delete row": "刪除行",
            "menu.array.delete rows": "刪除選定行",
            "menu.array.delete column": "刪除列",
            "menu.array.delete columns": "刪除選定的列",
            "submenu.array.insert separator": "插入分隔符",
            "menu.insert table": "插入表格",
            "submenu.table style": "表格樣式"
        }
    },
    _locale: "",
    get locale () {
        return s._locale || (s._locale = t() ? navigator.language.slice(0, 5) : "en"), s._locale;
    },
    set locale (e){
        s._locale = e;
    },
    merge (e1, t) {
        if (e1 && t) {
            const i = s._locale;
            s.locale = e1, s.strings[e1] = {
                ...s.strings[e1],
                ...t
            }, s.locale = i;
        } else if (e1 && !t) for (const t1 of Object.keys(e1))s.merge(t1, e1[t1]);
    }
};
function l(e1) {
    if (void 0 === e1) return;
    const t = s.locale.slice(0, 2);
    let i = "";
    return s.strings[s.locale] && (i = s.strings[s.locale][e1]), !i && s.strings[t] && (i = s.strings[t][e1]), i || (i = s.strings.en[e1]), i || void 0;
}
const u = {
    m0: "#3F3D99",
    m1: "#993D71",
    m2: "#998B3D",
    m3: "#3D9956",
    m4: "#3D5A99",
    m5: "#993D90",
    m6: "#996D3D",
    m7: "#43993D",
    m8: "#3D7999",
    m9: "#843D99"
}, c = {
    blue: "#0072BD",
    orange: "#D95319",
    yellow: "#EDB120",
    purple: "#7E2F8E",
    green: "#77AC30",
    cyan: "#4DBEEE",
    red: "#A2142F"
}, d = {
    red: "#fbbbb6",
    orange: "#ffe0c2",
    yellow: "#fff1c2",
    lime: "#d0e8b9",
    green: "#bceac4",
    teal: "#b9f1f1",
    blue: "#b6d9fb",
    indigo: "#d1c2f0",
    purple: "#e3baf8",
    magenta: "#f9c8e0",
    black: "#353535",
    "dark-grey": "#8C8C8C",
    grey: "#D0D0D0",
    "light-grey": "#F0F0F0",
    white: "#ffffff"
}, h = {
    red: "#d7170b",
    orange: "#fe8a2b",
    yellow: "#ffc02b",
    lime: "#63b215",
    green: "#21ba3a",
    teal: "#17cfcf",
    blue: "#0d80f2",
    indigo: "#63c",
    purple: "#a219e6",
    magenta: "#eb4799",
    black: "#000",
    "dark-grey": "#666",
    grey: "#A6A6A6",
    "light-grey": "#d4d5d2",
    white: "#ffffff"
}, m = {
    Red: "red",
    Orange: "orange",
    Yellow: "yellow",
    LimeGreen: "lime",
    Green: "green",
    TealBlue: "teal",
    Blue: "blue",
    Violet: "indigo",
    Purple: "purple",
    Magenta: "magenta",
    Black: "black",
    Gray: "grey",
    White: "white"
}, p = {
    Apricot: "#FBB982",
    Aquamarine: "#00B5BE",
    Bittersweet: "#C04F17",
    Black: "#221E1F",
    Blue: "#2D2F92",
    BlueGreen: "#00B3B8",
    BlueViolet: "#473992",
    BrickRed: "#B6321C",
    Brown: "#792500",
    BurntOrange: "#F7921D",
    CadetBlue: "#74729A",
    CarnationPink: "#F282B4",
    Cerulean: "#00A2E3",
    CornflowerBlue: "#41B0E4",
    Cyan: "#00AEEF",
    Dandelion: "#FDBC42",
    DarkOrchid: "#A4538A",
    Emerald: "#00A99D",
    ForestGreen: "#009B55",
    Fuchsia: "#8C368C",
    Goldenrod: "#FFDF42",
    Gray: "#949698",
    Green: "#00A64F",
    GreenYellow: "#DFE674",
    JungleGreen: "#00A99A",
    Lavender: "#F49EC4",
    Limegreen: "#8DC73E",
    Magenta: "#EC008C",
    Mahogany: "#A9341F",
    Maroon: "#AF3235",
    Melon: "#F89E7B",
    MidnightBlue: "#006795",
    Mulberry: "#A93C93",
    NavyBlue: "#006EB8",
    OliveGreen: "#3C8031",
    Orange: "#F58137",
    OrangeRed: "#ED135A",
    Orchid: "#AF72B0",
    Peach: "#F7965A",
    Periwinkle: "#7977B8",
    PineGreen: "#008B72",
    Plum: "#92268F",
    ProcessBlue: "#00B0F0",
    Purple: "#99479B",
    RawSienna: "#974006",
    Red: "#ED1B23",
    RedOrange: "#F26035",
    RedViolet: "#A1246B",
    Rhodamine: "#EF559F",
    RoyalBlue: "#0071BC",
    RoyalPurple: "#613F99",
    RubineRed: "#ED017D",
    Salmon: "#F69289",
    SeaGreen: "#3FBC9D",
    Sepia: "#671800",
    SkyBlue: "#46C5DD",
    SpringGreen: "#C6DC67",
    Tan: "#DA9D76",
    TealBlue: "#00AEB3",
    Thistle: "#D883B7",
    Turquoise: "#00B4CE",
    Violet: "#58429B",
    VioletRed: "#EF58A0",
    White: "#FFFFFF",
    WildStrawberry: "#EE2967",
    Yellow: "#FFF200",
    YellowGreen: "#98CC70",
    YellowOrange: "#FAA21A"
};
function f(e1) {
    var t, i, n, r, o, a;
    const s = e1.split("!");
    let l, d, f, g = 255, y = 255, b = 255, v = -1;
    const x = s.length > 0 && s[0].startsWith("-");
    x && (s[0] = s[0].slice(1));
    for(let e2 = 0; e2 < s.length; e2++){
        l = g, d = y, f = b;
        const x1 = null === (t = s[e2].trim().match(/^([A-Za-z\d]+)/)) || void 0 === t ? void 0 : t[1], k = null == x1 ? void 0 : x1.toLowerCase(), _ = x1 && null !== (a = null !== (o = null !== (r = null !== (n = null !== (i = h[k]) && void 0 !== i ? i : h[m[x1]]) && void 0 !== n ? n : c[x1]) && void 0 !== r ? r : p[x1]) && void 0 !== o ? o : u[x1]) && void 0 !== a ? a : s[e2].trim();
        let w = _.match(/^#([\da-f]{2})([\da-f]{2})([\da-f]{2})$/i);
        if ((null == w ? void 0 : w[1]) && w[2] && w[3]) g = Math.max(0, Math.min(255, Number.parseInt(w[1], 16))), y = Math.max(0, Math.min(255, Number.parseInt(w[2], 16))), b = Math.max(0, Math.min(255, Number.parseInt(w[3], 16)));
        else if (w = _.match(/^#([\da-f]{3})$/i), null == w ? void 0 : w[1]) {
            const e3 = Number.parseInt(w[1][0], 16), t1 = Number.parseInt(w[1][1], 16), i1 = Number.parseInt(w[1][2], 16);
            g = Math.max(0, Math.min(255, 16 * e3 + e3)), y = Math.max(0, Math.min(255, 16 * t1 + t1)), b = Math.max(0, Math.min(255, 16 * i1 + i1));
        } else {
            if (w = _.match(/^rgb\s*\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*\)$/i), !((null == w ? void 0 : w[1]) && w[2] && w[3])) return;
            g = Math.max(0, Math.min(255, Number.parseInt(w[1]))), y = Math.max(0, Math.min(255, Number.parseInt(w[2]))), b = Math.max(0, Math.min(255, Number.parseInt(w[3])));
        }
        v >= 0 && (g = (1 - v) * g + v * l, y = (1 - v) * y + v * d, b = (1 - v) * b + v * f, v = -1), e2 + 1 < s.length && (v = Math.max(0, Math.min(100, Number.parseInt(s[++e2]))) / 100);
    }
    return v >= 0 && (g = v * g + (1 - v) * l, y = v * y + (1 - v) * d, b = v * b + (1 - v) * f), x && (g = 255 - g, y = 255 - y, b = 255 - b), "#" + ("00" + Math.round(g).toString(16)).slice(-2) + ("00" + Math.round(y).toString(16)).slice(-2) + ("00" + Math.round(b).toString(16)).slice(-2);
}
function g(e1) {
    var t, i;
    return e1 = e1.trim(), null !== (i = null !== (t = d[e1.toLowerCase()]) && void 0 !== t ? t : d[m[e1]]) && void 0 !== i ? i : f(e1);
}
function y(e1, t, i) {
    return i < 0 && (i += 6), i >= 6 && (i -= 6), i < 1 ? (t - e1) * i + e1 : i < 3 ? t : i < 4 ? (t - e1) * (4 - i) + e1 : e1;
}
function b(e1) {
    return e1 < 0 ? 0 : e1 > 255 ? 255 : Math.round(e1);
}
function v(e1) {
    let t = function(e1) {
        if (!e1) return;
        if ("#" !== e1[0]) return;
        let t;
        return (e1 = e1.slice(1)).length <= 4 ? (t = {
            r: parseInt(e1[0] + e1[0], 16),
            g: parseInt(e1[1] + e1[1], 16),
            b: parseInt(e1[2] + e1[2], 16)
        }, 4 === e1.length && (t.a = parseInt(e1[3] + e1[3], 16) / 255)) : (t = {
            r: parseInt(e1[0] + e1[1], 16),
            g: parseInt(e1[2] + e1[3], 16),
            b: parseInt(e1[4] + e1[5], 16)
        }, 8 === e1.length && (t.a = parseInt(e1[6] + e1[7], 16) / 255)), t && void 0 === t.a && (t.a = 1), t;
    }(e1);
    if (!t) return e1;
    let { h: i , s: n , l: r  } = function(e1) {
        let { r: t , g: i , b: n  } = e1;
        t /= 255, i /= 255, n /= 255;
        const r = Math.min(t, i, n), o = Math.max(t, i, n), a = o - r;
        let s, l;
        o === r ? s = 0 : t === o ? s = (i - n) / a : i === o ? s = 2 + (n - t) / a : n === o && (s = 4 + (t - i) / a), s = Math.min(60 * s, 360), s < 0 && (s += 360);
        const u = (r + o) / 2;
        return l = o === r ? 0 : u <= .5 ? a / (o + r) : a / (2 - o - r), {
            h: s,
            s: l,
            l: u
        };
    }(t);
    return n += .1, r -= .1, function(e1) {
        const { r: t , g: i , b: n  } = e1;
        let r = (16777216 + (b(t) << 16) + (b(i) << 8) + b(n)).toString(16).slice(1);
        return r[0] === r[1] && r[2] === r[3] && r[4] === r[5] && r[6] === r[7] && (r = r[0] + r[2] + r[4]), "#" + r;
    }(function(e1) {
        let [t, i, n] = [
            e1.h,
            e1.s,
            e1.l
        ];
        t = (t + 360) % 360 / 60, n = Math.max(0, Math.min(n, 1)), i = Math.max(0, Math.min(i, 1));
        const r = n <= .5 ? n * (i + 1) : n + i - n * i, o = 2 * n - r;
        return {
            r: Math.round(255 * y(o, r, t + 2)),
            g: Math.round(255 * y(o, r, t)),
            b: Math.round(255 * y(o, r, t - 2))
        };
    }({
        h: i,
        s: n,
        l: r
    }));
}
const x = {}, k = {
    60: "\\lt",
    62: "\\gt",
    111: "o",
    38: "\\&",
    123: "\\lbrace",
    125: "\\rbrace",
    91: "\\lbrack",
    93: "\\rbrack",
    58: "\\colon",
    160: "~",
    172: "\\neg",
    183: "\\cdot",
    188: "\\frac{1}{4}",
    189: "\\frac{1}{2}",
    190: "\\frac{3}{4}",
    8304: "^{0}",
    8305: "^{i}",
    185: "^{1}",
    178: "^{2}",
    179: "^{3}",
    8224: "\\dagger",
    8225: "\\ddagger",
    8230: "\\ldots",
    8308: "^{4}",
    8309: "^{5}",
    8310: "^{6}",
    8311: "^{7}",
    8312: "^{8}",
    8313: "^{9}",
    8314: "^{+}",
    8315: "^{-}",
    8316: "^{=}",
    8319: "^{n}",
    8320: "_{0}",
    8321: "_{1}",
    8322: "_{2}",
    8323: "_{3}",
    8324: "_{4}",
    8325: "_{5}",
    8326: "_{6}",
    8327: "_{7}",
    8328: "_{8}",
    8329: "_{9}",
    8330: "_{+}",
    8331: "_{-}",
    8332: "_{=}",
    8336: "_{a}",
    8337: "_{e}",
    8338: "_{o}",
    8339: "_{x}",
    8242: "\\prime",
    39: "\\prime",
    8592: "\\gets",
    8594: "\\to",
    9651: "\\triangle",
    9661: "\\triangledown",
    8715: "\\owns",
    8727: "\\ast",
    8739: "\\vert",
    8741: "\\Vert",
    8743: "\\land",
    8744: "\\lor",
    8901: "\\cdot",
    8904: "\\bowtie",
    8800: "\\ne",
    8804: "\\le",
    8805: "\\ge",
    8869: "\\bot",
    10231: "\\biconditional",
    10232: "\\impliedby",
    10233: "\\implies",
    10234: "\\iff",
    8450: "\\mathbb{C}",
    8469: "\\mathbb{N}",
    8473: "\\mathbb{P}",
    8474: "\\mathbb{Q}",
    8477: "\\mathbb{R}",
    8484: "\\mathbb{Z}",
    8461: "\\mathbb{H}",
    8476: "\\Re",
    8465: "\\Im",
    42: "\\ast",
    11036: "\\square",
    9633: "\\square",
    8720: "\\coprod",
    8716: "\\not\\ni",
    9671: "\\diamond",
    8846: "\\uplus",
    8851: "\\sqcap",
    8852: "\\sqcup",
    8768: "\\wr",
    8750: "\\oint",
    8226: "\\textbullet",
    8722: "-",
    978: "\\Upsilon"
}, _ = {}, w = {}, S = {
    iff: "\\;⟺\\;",
    nicefrac: "^{#1}\\!\\!/\\!_{#2}",
    rd: "\\mathrm{d}",
    rD: "\\mathrm{D}",
    doubleStruckCapitalN: "\\mathbb{N}",
    doubleStruckCapitalR: "\\mathbb{R}",
    doubleStruckCapitalQ: "\\mathbb{Q}",
    doubleStruckCapitalZ: "\\mathbb{Z}",
    doubleStruckCapitalP: "\\mathbb{P}",
    scriptCapitalE: "\\mathscr{E}",
    scriptCapitalH: "\\mathscr{H}",
    scriptCapitalL: "\\mathscr{L}",
    gothicCapitalC: "\\mathfrak{C}",
    gothicCapitalH: "\\mathfrak{H}",
    gothicCapitalI: "\\mathfrak{I}",
    gothicCapitalR: "\\mathfrak{R}",
    imaginaryI: "\\mathrm{i}",
    imaginaryJ: "\\mathrm{j}",
    exponentialE: "\\mathrm{e}",
    differentialD: "\\mathrm{d}",
    capitalDifferentialD: "\\mathrm{D}",
    "braket.sty": {
        package: {
            bra: "\\mathinner{\\langle{#1}|}",
            ket: "\\mathinner{|{#1}\\rangle}",
            braket: "\\mathinner{\\langle{#1}\\rangle}",
            set: "\\mathinner{\\lbrace #1 \\rbrace}",
            Bra: "\\left\\langle #1\\right|",
            Ket: "\\left|#1\\right\\rangle",
            Braket: "\\left\\langle{#1}\\right\\rangle",
            Set: "\\left\\lbrace #1 \\right\\rbrace"
        }
    },
    "amsmath.sty": {
        package: {
            varGamma: "\\mathit{\\Gamma}",
            varDelta: "\\mathit{\\Delta}",
            varTheta: "\\mathit{\\Theta}",
            varLambda: "\\mathit{\\Lambda}",
            varXi: "\\mathit{\\Xi}",
            varPi: "\\mathit{\\Pi}",
            varSigma: "\\mathit{\\Sigma}",
            varUpsilon: "\\mathit{\\Upsilon}",
            varPhi: "\\mathit{\\Phi}",
            varPsi: "\\mathit{\\Psi}",
            varOmega: "\\mathit{\\Omega}",
            pmod: {
                def: "\\quad(\\operatorname{mod}\\ #1)",
                args: 1,
                expand: !1
            },
            mod: {
                def: "\\quad\\operatorname{mod}\\,\\,#1",
                args: 1,
                expand: !1
            },
            bmod: {
                def: "\\;\\mathbin{\\operatorname{mod }}",
                expand: !1
            }
        },
        expand: !1
    },
    "texvc.sty": {
        package: {
            darr: "\\downarrow",
            dArr: "\\Downarrow",
            Darr: "\\Downarrow",
            lang: "\\langle",
            rang: "\\rangle",
            uarr: "\\uparrow",
            uArr: "\\Uparrow",
            Uarr: "\\Uparrow",
            N: "\\mathbb{N}",
            R: "\\mathbb{R}",
            Z: "\\mathbb{Z}",
            alef: "\\aleph",
            alefsym: "\\aleph",
            Alpha: "\\mathrm{A}",
            Beta: "\\mathrm{B}",
            bull: "\\bullet",
            Chi: "\\mathrm{X}",
            clubs: "\\clubsuit",
            cnums: "\\mathbb{C}",
            Complex: "\\mathbb{C}",
            Dagger: "\\ddagger",
            diamonds: "\\diamondsuit",
            empty: "\\emptyset",
            Epsilon: "\\mathrm{E}",
            Eta: "\\mathrm{H}",
            exist: "\\exists",
            harr: "\\leftrightarrow",
            hArr: "\\Leftrightarrow",
            Harr: "\\Leftrightarrow",
            hearts: "\\heartsuit",
            image: "\\Im",
            infin: "\\infty",
            Iota: "\\mathrm{I}",
            isin: "\\in",
            Kappa: "\\mathrm{K}",
            larr: "\\leftarrow",
            lArr: "\\Leftarrow",
            Larr: "\\Leftarrow",
            lrarr: "\\leftrightarrow",
            lrArr: "\\Leftrightarrow",
            Lrarr: "\\Leftrightarrow",
            Mu: "\\mathrm{M}",
            natnums: "\\mathbb{N}",
            Nu: "\\mathrm{N}",
            Omicron: "\\mathrm{O}",
            plusmn: "\\pm",
            rarr: "\\rightarrow",
            rArr: "\\Rightarrow",
            Rarr: "\\Rightarrow",
            real: "\\Re",
            reals: "\\mathbb{R}",
            Reals: "\\mathbb{R}",
            Rho: "\\mathrm{P}",
            sdot: "\\cdot",
            sect: "\\S",
            spades: "\\spadesuit",
            sub: "\\subset",
            sube: "\\subseteq",
            supe: "\\supseteq",
            Tau: "\\mathrm{T}",
            thetasym: "\\vartheta",
            weierp: "\\wp",
            Zeta: "\\mathrm{Z}"
        },
        expand: !1
    }
}, M = {
    " ": 32,
    "\\#": 35,
    "\\&": 38,
    "\\$": 36,
    "\\%": 37,
    "\\_": 95,
    "\\euro": 8364,
    "\\maltese": 10016,
    "\\{": 123,
    "\\}": 125,
    "\\nobreakspace": 160,
    "\\ldots": 8230,
    "\\textellipsis": 8230,
    "\\backslash": 92,
    "`": 8216,
    "'": 8217,
    "``": 8220,
    "''": 8221,
    "\\degree": 176,
    "\\textasciicircum": 94,
    "\\textasciitilde": 126,
    "\\textasteriskcentered": 42,
    "\\textbackslash": 92,
    "\\textbraceleft": 123,
    "\\textbraceright": 125,
    "\\textbullet": 8226,
    "\\textdollar": 36,
    "\\textsterling": 163,
    "\\textdagger": 8224,
    "\\textdaggerdbl": 8225,
    "–": 8211,
    "—": 8212,
    "‘": 8216,
    "’": 8217,
    "“": 8220,
    "”": 8221,
    '"': 8221,
    "\\ss": 223,
    "\\ae": 230,
    "\\oe": 339,
    "\\AE": 198,
    "\\OE": 338,
    "\\O": 216,
    "\\i": 305,
    "\\j": 567,
    "\\aa": 229,
    "\\AA": 197
}, N = /[\w!@*()-=+{}[\]\\';:?/.,~<>`|$%#&^" ]/, L = a() ? new RegExp("\\p{Letter}", "u") : /[a-zA-Z\u0430\u0410\u0431\u0411\u0432\u0412\u0433\u0413\u0434\u0414\u0435\u0415\u0451\u0401\u0436\u0416\u0437\u0417\u0438\u0418\u0439\u0419\u043a\u041a\u043b\u041b\u043c\u041c\u043d\u041d\u043e\u041e\u043f\u041f\u0440\u0420\u0441\u0421\u0442\u0422\u0443\u0423\u0444\u0424\u0445\u0425\u0446\u0426\u0447\u0427\u0448\u0428\u0449\u0429\u044a\u042a\u044b\u042b\u044c\u042c\u044d\u042d\u044e\u042e\u044f\u0104\u0105\u0106\u0107\u0118\u0119\u0141\u0142\u0143\u0144\xd3\xf3\u015a\u015b\u0179\u017a\u017b\u017c\xe0\xe2\xe4\xf4\xe9\xe8\xeb\xea\xef\xee\xe7\xf9\xfb\xfc\xff\xe6\u0153\xc0\xc2\xc4\xd4\xc9\xc8\xcb\xca\xcf\xce\u0178\xc7\xd9\xdb\xdc\xc6\u0152\xf6\xdf\xd6\u1e9e\xec\xed\xf2\xfa\xcc\xcd\xd2\xda\xe1\xf1\xc1\xd1]/, A = a() ? new RegExp("[0-9\\p{Letter}]", "u") : /[\da-zA-Z\u0430\u0410\u0431\u0411\u0432\u0412\u0433\u0413\u0434\u0414\u0435\u0415\u0451\u0401\u0436\u0416\u0437\u0417\u0438\u0418\u0439\u0419\u043a\u041a\u043b\u041b\u043c\u041c\u043d\u041d\u043e\u041e\u043f\u041f\u0440\u0420\u0441\u0421\u0442\u0422\u0443\u0423\u0444\u0424\u0445\u0425\u0446\u0426\u0447\u0427\u0448\u0428\u0449\u0429\u044a\u042a\u044b\u042b\u044c\u042c\u044d\u042d\u044e\u042e\u044f\u0104\u0105\u0106\u0107\u0118\u0119\u0141\u0142\u0143\u0144\xd3\xf3\u015a\u015b\u0179\u017a\u017b\u017c\xe0\xe2\xe4\xf4\xe9\xe8\xeb\xea\xef\xee\xe7\xf9\xfb\xfc\xff\xe6\u0153\xc0\xc2\xc4\xd4\xc9\xc8\xcb\xca\xcf\xce\u0178\xc7\xd9\xdb\xdc\xc6\u0152\xf6\xdf\xd6\u1e9e\xec\xed\xf2\xfa\xcc\xcd\xd2\xda\xe1\xf1\xc1\xd1]/;
function C(e1, t, i = "mord", n) {
    void 0 !== t && (x[e1] = {
        definitionType: "symbol",
        type: i,
        variant: n,
        codepoint: t
    }, k[t] || (k[t] = e1), M[e1] || (M[e1] = t));
}
function E(e1, t, i) {
    if ("string" != typeof e1) for (const [n, r, o, a] of e1)C(n, r, null != o ? o : t, null != a ? a : i);
    else for(let t1 = 0; t1 < e1.length; t1++){
        const i1 = e1.charAt(t1);
        C(i1, i1.codePointAt(0));
    }
}
function T(e1, t) {
    for(let i = e1; i <= t; i++)C(String.fromCodePoint(i), i);
}
function D(e1, t) {
    if (void 0 === t) return "";
    if ("math" === e1 && k[t]) return k[t];
    if ("text" === e1) {
        let e2 = Object.keys(M).find((e1)=>M[e1] === t);
        if (!e2) {
            const i = t.toString(16);
            e2 = "^".repeat(i.length) + i;
        }
        return e2;
    }
    return String.fromCodePoint(t);
}
const z = {
    119893: 8462,
    119965: 8492,
    119968: 8496,
    119969: 8497,
    119971: 8459,
    119972: 8464,
    119975: 8466,
    119976: 8499,
    119981: 8475,
    119994: 8495,
    119996: 8458,
    120004: 8500,
    120070: 8493,
    120075: 8460,
    120076: 8465,
    120085: 8476,
    120093: 8488,
    120122: 8450,
    120127: 8461,
    120133: 8469,
    120135: 8473,
    120136: 8474,
    120137: 8477,
    120145: 8484
}, q = [
    {
        start: 119808,
        len: 26,
        offset: 65,
        style: "bold"
    },
    {
        start: 119834,
        len: 26,
        offset: 97,
        style: "bold"
    },
    {
        start: 119860,
        len: 26,
        offset: 65,
        style: "italic"
    },
    {
        start: 119886,
        len: 26,
        offset: 97,
        style: "italic"
    },
    {
        start: 119912,
        len: 26,
        offset: 65,
        style: "bolditalic"
    },
    {
        start: 119938,
        len: 26,
        offset: 97,
        style: "bolditalic"
    },
    {
        start: 119964,
        len: 26,
        offset: 65,
        variant: "script"
    },
    {
        start: 119990,
        len: 26,
        offset: 97,
        variant: "script"
    },
    {
        start: 120016,
        len: 26,
        offset: 65,
        variant: "script",
        style: "bold"
    },
    {
        start: 120042,
        len: 26,
        offset: 97,
        variant: "script",
        style: "bold"
    },
    {
        start: 120068,
        len: 26,
        offset: 65,
        variant: "fraktur"
    },
    {
        start: 120094,
        len: 26,
        offset: 97,
        variant: "fraktur"
    },
    {
        start: 120172,
        len: 26,
        offset: 65,
        variant: "fraktur",
        style: "bold"
    },
    {
        start: 120198,
        len: 26,
        offset: 97,
        variant: "fraktur",
        style: "bold"
    },
    {
        start: 120120,
        len: 26,
        offset: 65,
        variant: "double-struck"
    },
    {
        start: 120146,
        len: 26,
        offset: 97,
        variant: "double-struck"
    },
    {
        start: 120224,
        len: 26,
        offset: 65,
        variant: "sans-serif"
    },
    {
        start: 120250,
        len: 26,
        offset: 97,
        variant: "sans-serif"
    },
    {
        start: 120276,
        len: 26,
        offset: 65,
        variant: "sans-serif",
        style: "bold"
    },
    {
        start: 120302,
        len: 26,
        offset: 97,
        variant: "sans-serif",
        style: "bold"
    },
    {
        start: 120328,
        len: 26,
        offset: 65,
        variant: "sans-serif",
        style: "italic"
    },
    {
        start: 120354,
        len: 26,
        offset: 97,
        variant: "sans-serif",
        style: "italic"
    },
    {
        start: 120380,
        len: 26,
        offset: 65,
        variant: "sans-serif",
        style: "bolditalic"
    },
    {
        start: 120406,
        len: 26,
        offset: 97,
        variant: "sans-serif",
        style: "bolditalic"
    },
    {
        start: 120432,
        len: 26,
        offset: 65,
        variant: "monospace"
    },
    {
        start: 120458,
        len: 26,
        offset: 97,
        variant: "monospace"
    },
    {
        start: 120488,
        len: 25,
        offset: 913,
        style: "bold"
    },
    {
        start: 120514,
        len: 25,
        offset: 945,
        style: "bold"
    },
    {
        start: 120546,
        len: 25,
        offset: 913,
        style: "italic"
    },
    {
        start: 120572,
        len: 25,
        offset: 945,
        style: "italic"
    },
    {
        start: 120604,
        len: 25,
        offset: 913,
        style: "bolditalic"
    },
    {
        start: 120630,
        len: 25,
        offset: 945,
        style: "bolditalic"
    },
    {
        start: 120662,
        len: 25,
        offset: 913,
        variant: "sans-serif",
        style: "bold"
    },
    {
        start: 120688,
        len: 25,
        offset: 945,
        variant: "sans-serif",
        style: "bold"
    },
    {
        start: 120720,
        len: 25,
        offset: 913,
        variant: "sans-serif",
        style: "bolditalic"
    },
    {
        start: 120746,
        len: 25,
        offset: 945,
        variant: "sans-serif",
        style: "bolditalic"
    },
    {
        start: 120782,
        len: 10,
        offset: 48,
        variant: "main",
        style: "bold"
    },
    {
        start: 120792,
        len: 10,
        offset: 48,
        variant: "double-struck"
    },
    {
        start: 120803,
        len: 10,
        offset: 48,
        variant: "sans-serif"
    },
    {
        start: 120812,
        len: 10,
        offset: 48,
        variant: "sans-serif",
        style: "bold"
    },
    {
        start: 120822,
        len: 10,
        offset: 48,
        variant: "monospace"
    }
];
function I(e1) {
    let t = "auto";
    const i = e1.match(/:([^=]+)/);
    return i && (t = i[1].trim()), t;
}
function O(e1) {
    if (!e1) return [];
    const t = [];
    let i = e1.split("]");
    if (i[0].startsWith("[")) {
        t.push({
            isOptional: !0,
            type: I(i[0].slice(1))
        });
        for(let e2 = 1; e2 <= i.length; e2++)t.push(...O(i[e2]));
    } else if (i = e1.split("}"), i[0].startsWith("{")) {
        t.push({
            isOptional: !1,
            type: I(i[0].slice(1))
        });
        for(let e3 = 1; e3 <= i.length; e3++)t.push(...O(i[e3]));
    }
    return t;
}
function F(e1) {
    if (!e1) return "";
    let t = "", i = !0;
    for (const n of e1)"string" == typeof n.value ? t += n.value : i = !1;
    return i ? t : "";
}
function B(e1, t, i, n = !1) {
    "string" == typeof e1 && (e1 = [
        e1
    ]);
    const r = {
        tabular: n,
        params: O(t),
        createAtom: i
    };
    for (const t1 of e1)w[t1] = r;
}
function $(e1, t, i) {
    B(e1, t, i, !0);
}
function P(e1, t, i) {
    var n, r;
    i || (i = {});
    const o = {
        definitionType: "function",
        params: O(t),
        ifMode: i.ifMode,
        isFunction: null !== (n = i.isFunction) && void 0 !== n && n,
        applyMode: i.applyMode,
        infix: null !== (r = i.infix) && void 0 !== r && r,
        createAtom: i.createAtom,
        applyStyle: i.applyStyle
    };
    if ("string" == typeof e1) _["\\" + e1] = o;
    else for (const t1 of e1)_["\\" + t1] = o;
}
let R;
function K(e1) {
    return R || (R = j(S)), e1 ? j({
        ...R,
        ...e1
    }) : R;
}
function V(e1, t) {
    var i, n, r, o;
    if ("string" == typeof e1) {
        let r1 = 0;
        const o1 = e1;
        return /(^|[^\\])#1/.test(o1) && (r1 = 1), /(^|[^\\])#2/.test(o1) && (r1 = 2), /(^|[^\\])#3/.test(o1) && (r1 = 3), /(^|[^\\])#4/.test(o1) && (r1 = 4), /(^|[^\\])#5/.test(o1) && (r1 = 5), /(^|[^\\])#6/.test(o1) && (r1 = 6), /(^|[^\\])#7/.test(o1) && (r1 = 7), /(^|[^\\])#8/.test(o1) && (r1 = 8), /(^|[^\\])#9/.test(o1) && (r1 = 9), {
            expand: null === (i = null == t ? void 0 : t.expand) || void 0 === i || i,
            captureSelection: null === (n = null == t ? void 0 : t.captureSelection) || void 0 === n || n,
            args: r1,
            def: o1
        };
    }
    return {
        expand: null === (r = null == t ? void 0 : t.expand) || void 0 === r || r,
        captureSelection: null === (o = null == t ? void 0 : t.captureSelection) || void 0 === o || o,
        args: 0,
        ...e1
    };
}
function j(e1) {
    if (!e1) return {};
    const t = {};
    for (const i of Object.keys(e1)){
        const n = e1[i];
        if (null == n) delete t[i];
        else if ("object" == typeof n && "package" in n) for (const e2 of Object.keys(n.package))t[e2] = V(n.package[e2], {
            expand: n.expand,
            captureSelection: n.captureSelection
        });
        else t[i] = V(n);
    }
    return t;
}
const H = [
    0,
    .69444,
    0,
    0
], U = [
    0,
    .61111,
    0,
    0
], G = [
    .25,
    .75,
    0,
    0
], Z = [
    0,
    .44444,
    0,
    0
], W = [
    0,
    .68611,
    0,
    0
], J = [
    .19444,
    .69444,
    0,
    0
], X = [
    0,
    .68333,
    0,
    0
], Y = [
    0,
    .68889,
    0,
    0
], Q = [
    0,
    .69141,
    0,
    0
], ee = [
    0,
    0,
    0,
    0
], te = [
    0,
    .64444,
    0,
    0
], ie = [
    0,
    .69224,
    0,
    0
], ne = [
    .19444,
    .44444,
    0,
    0
], re = [
    .65002,
    1.15,
    0,
    0
], oe = [
    0,
    .55556,
    0,
    0
], ae = [
    .35001,
    .85,
    0,
    0
], se = [
    1.25003,
    1.75,
    0,
    0
], le = [
    .95003,
    1.45,
    0,
    0
], ue = [
    0,
    .75,
    0,
    0
], ce = [
    0,
    .47534,
    0,
    0
], de = [
    .25001,
    .75,
    0,
    0
], he = [
    .55001,
    1.05,
    0,
    0
], me = [
    .16667,
    .68889,
    0,
    0
], pe = [
    .08167,
    .58167,
    0,
    0
];
var fe = {
    "AMS-Regular": {
        32: ee,
        65: Y,
        66: Y,
        67: Y,
        68: Y,
        69: Y,
        70: Y,
        71: Y,
        72: Y,
        73: Y,
        74: me,
        75: Y,
        76: Y,
        77: Y,
        78: Y,
        79: me,
        80: Y,
        81: me,
        82: Y,
        83: Y,
        84: Y,
        85: Y,
        86: Y,
        87: Y,
        88: Y,
        89: Y,
        90: Y,
        107: Y,
        160: ee,
        165: [
            0,
            .675,
            .025,
            0
        ],
        174: [
            .15559,
            .69224,
            0,
            0
        ],
        240: Y,
        295: Y,
        710: [
            0,
            .825,
            0,
            0
        ],
        732: [
            0,
            .9,
            0,
            0
        ],
        770: [
            0,
            .825,
            0,
            0
        ],
        771: [
            0,
            .9,
            0,
            0
        ],
        989: pe,
        1008: [
            0,
            .43056,
            .04028,
            0
        ],
        8245: [
            0,
            .54986,
            0,
            0
        ],
        8463: Y,
        8487: Y,
        8498: Y,
        8502: Y,
        8503: Y,
        8504: Y,
        8513: Y,
        8592: [
            -0.03598,
            .46402,
            0,
            0
        ],
        8594: [
            -0.03598,
            .46402,
            0,
            0
        ],
        8602: [
            -0.13313,
            .36687,
            0,
            0
        ],
        8603: [
            -0.13313,
            .36687,
            0,
            0
        ],
        8606: [
            .01354,
            .52239,
            0,
            0
        ],
        8608: [
            .01354,
            .52239,
            0,
            0
        ],
        8610: [
            .01354,
            .52239,
            0,
            0
        ],
        8611: [
            .01354,
            .52239,
            0,
            0
        ],
        8619: [
            0,
            .54986,
            0,
            0
        ],
        8620: [
            0,
            .54986,
            0,
            0
        ],
        8621: [
            -0.13313,
            .37788,
            0,
            0
        ],
        8622: [
            -0.13313,
            .36687,
            0,
            0
        ],
        8624: ie,
        8625: ie,
        8630: [
            0,
            .43056,
            0,
            0
        ],
        8631: [
            0,
            .43056,
            0,
            0
        ],
        8634: [
            .08198,
            .58198,
            0,
            0
        ],
        8635: [
            .08198,
            .58198,
            0,
            0
        ],
        8638: [
            .19444,
            .69224,
            0,
            0
        ],
        8639: [
            .19444,
            .69224,
            0,
            0
        ],
        8642: [
            .19444,
            .69224,
            0,
            0
        ],
        8643: [
            .19444,
            .69224,
            0,
            0
        ],
        8644: [
            .1808,
            .675,
            0,
            0
        ],
        8646: [
            .1808,
            .675,
            0,
            0
        ],
        8647: [
            .1808,
            .675,
            0,
            0
        ],
        8648: [
            .19444,
            .69224,
            0,
            0
        ],
        8649: [
            .1808,
            .675,
            0,
            0
        ],
        8650: [
            .19444,
            .69224,
            0,
            0
        ],
        8651: [
            .01354,
            .52239,
            0,
            0
        ],
        8652: [
            .01354,
            .52239,
            0,
            0
        ],
        8653: [
            -0.13313,
            .36687,
            0,
            0
        ],
        8654: [
            -0.13313,
            .36687,
            0,
            0
        ],
        8655: [
            -0.13313,
            .36687,
            0,
            0
        ],
        8666: [
            .13667,
            .63667,
            0,
            0
        ],
        8667: [
            .13667,
            .63667,
            0,
            0
        ],
        8669: [
            -0.13313,
            .37788,
            0,
            0
        ],
        8672: [
            -0.064,
            .437,
            0,
            0
        ],
        8674: [
            -0.064,
            .437,
            0,
            0
        ],
        8705: [
            0,
            .825,
            0,
            0
        ],
        8708: Y,
        8709: pe,
        8717: [
            0,
            .43056,
            0,
            0
        ],
        8722: [
            -0.03598,
            .46402,
            0,
            0
        ],
        8724: [
            .08198,
            .69224,
            0,
            0
        ],
        8726: pe,
        8733: ie,
        8736: ie,
        8737: ie,
        8738: [
            .03517,
            .52239,
            0,
            0
        ],
        8739: pe,
        8740: [
            .25142,
            .74111,
            0,
            0
        ],
        8741: pe,
        8742: [
            .25142,
            .74111,
            0,
            0
        ],
        8756: ie,
        8757: ie,
        8764: [
            -0.13313,
            .36687,
            0,
            0
        ],
        8765: [
            -0.13313,
            .37788,
            0,
            0
        ],
        8769: [
            -0.13313,
            .36687,
            0,
            0
        ],
        8770: [
            -0.03625,
            .46375,
            0,
            0
        ],
        8774: [
            .30274,
            .79383,
            0,
            0
        ],
        8776: [
            -0.01688,
            .48312,
            0,
            0
        ],
        8778: pe,
        8782: [
            .06062,
            .54986,
            0,
            0
        ],
        8783: [
            .06062,
            .54986,
            0,
            0
        ],
        8785: [
            .08198,
            .58198,
            0,
            0
        ],
        8786: [
            .08198,
            .58198,
            0,
            0
        ],
        8787: [
            .08198,
            .58198,
            0,
            0
        ],
        8790: ie,
        8791: [
            .22958,
            .72958,
            0,
            0
        ],
        8796: [
            .08198,
            .91667,
            0,
            0
        ],
        8806: [
            .25583,
            .75583,
            0,
            0
        ],
        8807: [
            .25583,
            .75583,
            0,
            0
        ],
        8808: [
            .25142,
            .75726,
            0,
            0
        ],
        8809: [
            .25142,
            .75726,
            0,
            0
        ],
        8812: [
            .25583,
            .75583,
            0,
            0
        ],
        8814: [
            .20576,
            .70576,
            0,
            0
        ],
        8815: [
            .20576,
            .70576,
            0,
            0
        ],
        8816: [
            .30274,
            .79383,
            0,
            0
        ],
        8817: [
            .30274,
            .79383,
            0,
            0
        ],
        8818: [
            .22958,
            .72958,
            0,
            0
        ],
        8819: [
            .22958,
            .72958,
            0,
            0
        ],
        8822: [
            .1808,
            .675,
            0,
            0
        ],
        8823: [
            .1808,
            .675,
            0,
            0
        ],
        8828: [
            .13667,
            .63667,
            0,
            0
        ],
        8829: [
            .13667,
            .63667,
            0,
            0
        ],
        8830: [
            .22958,
            .72958,
            0,
            0
        ],
        8831: [
            .22958,
            .72958,
            0,
            0
        ],
        8832: [
            .20576,
            .70576,
            0,
            0
        ],
        8833: [
            .20576,
            .70576,
            0,
            0
        ],
        8840: [
            .30274,
            .79383,
            0,
            0
        ],
        8841: [
            .30274,
            .79383,
            0,
            0
        ],
        8842: [
            .13597,
            .63597,
            0,
            0
        ],
        8843: [
            .13597,
            .63597,
            0,
            0
        ],
        8847: [
            .03517,
            .54986,
            0,
            0
        ],
        8848: [
            .03517,
            .54986,
            0,
            0
        ],
        8858: [
            .08198,
            .58198,
            0,
            0
        ],
        8859: [
            .08198,
            .58198,
            0,
            0
        ],
        8861: [
            .08198,
            .58198,
            0,
            0
        ],
        8862: [
            0,
            .675,
            0,
            0
        ],
        8863: [
            0,
            .675,
            0,
            0
        ],
        8864: [
            0,
            .675,
            0,
            0
        ],
        8865: [
            0,
            .675,
            0,
            0
        ],
        8872: ie,
        8873: ie,
        8874: ie,
        8876: Y,
        8877: Y,
        8878: Y,
        8879: Y,
        8882: [
            .03517,
            .54986,
            0,
            0
        ],
        8883: [
            .03517,
            .54986,
            0,
            0
        ],
        8884: [
            .13667,
            .63667,
            0,
            0
        ],
        8885: [
            .13667,
            .63667,
            0,
            0
        ],
        8888: [
            0,
            .54986,
            0,
            0
        ],
        8890: [
            .19444,
            .43056,
            0,
            0
        ],
        8891: [
            .19444,
            .69224,
            0,
            0
        ],
        8892: [
            .19444,
            .69224,
            0,
            0
        ],
        8901: [
            0,
            .54986,
            0,
            0
        ],
        8903: pe,
        8905: pe,
        8906: pe,
        8907: ie,
        8908: ie,
        8909: [
            -0.03598,
            .46402,
            0,
            0
        ],
        8910: [
            0,
            .54986,
            0,
            0
        ],
        8911: [
            0,
            .54986,
            0,
            0
        ],
        8912: [
            .03517,
            .54986,
            0,
            0
        ],
        8913: [
            .03517,
            .54986,
            0,
            0
        ],
        8914: [
            0,
            .54986,
            0,
            0
        ],
        8915: [
            0,
            .54986,
            0,
            0
        ],
        8916: ie,
        8918: [
            .0391,
            .5391,
            0,
            0
        ],
        8919: [
            .0391,
            .5391,
            0,
            0
        ],
        8920: [
            .03517,
            .54986,
            0,
            0
        ],
        8921: [
            .03517,
            .54986,
            0,
            0
        ],
        8922: [
            .38569,
            .88569,
            0,
            0
        ],
        8923: [
            .38569,
            .88569,
            0,
            0
        ],
        8926: [
            .13667,
            .63667,
            0,
            0
        ],
        8927: [
            .13667,
            .63667,
            0,
            0
        ],
        8928: [
            .30274,
            .79383,
            0,
            0
        ],
        8929: [
            .30274,
            .79383,
            0,
            0
        ],
        8934: [
            .23222,
            .74111,
            0,
            0
        ],
        8935: [
            .23222,
            .74111,
            0,
            0
        ],
        8936: [
            .23222,
            .74111,
            0,
            0
        ],
        8937: [
            .23222,
            .74111,
            0,
            0
        ],
        8938: [
            .20576,
            .70576,
            0,
            0
        ],
        8939: [
            .20576,
            .70576,
            0,
            0
        ],
        8940: [
            .30274,
            .79383,
            0,
            0
        ],
        8941: [
            .30274,
            .79383,
            0,
            0
        ],
        8994: [
            .19444,
            .69224,
            0,
            0
        ],
        8995: [
            .19444,
            .69224,
            0,
            0
        ],
        9416: [
            .15559,
            .69224,
            0,
            0
        ],
        9484: ie,
        9488: ie,
        9492: [
            0,
            .37788,
            0,
            0
        ],
        9496: [
            0,
            .37788,
            0,
            0
        ],
        9585: [
            .19444,
            .68889,
            0,
            0
        ],
        9586: [
            .19444,
            .74111,
            0,
            0
        ],
        9632: [
            0,
            .675,
            0,
            0
        ],
        9633: [
            0,
            .675,
            0,
            0
        ],
        9650: [
            0,
            .54986,
            0,
            0
        ],
        9651: [
            0,
            .54986,
            0,
            0
        ],
        9654: [
            .03517,
            .54986,
            0,
            0
        ],
        9660: [
            0,
            .54986,
            0,
            0
        ],
        9661: [
            0,
            .54986,
            0,
            0
        ],
        9664: [
            .03517,
            .54986,
            0,
            0
        ],
        9674: [
            .11111,
            .69224,
            0,
            0
        ],
        9733: [
            .19444,
            .69224,
            0,
            0
        ],
        10003: ie,
        10016: ie,
        10731: [
            .11111,
            .69224,
            0,
            0
        ],
        10846: [
            .19444,
            .75583,
            0,
            0
        ],
        10877: [
            .13667,
            .63667,
            0,
            0
        ],
        10878: [
            .13667,
            .63667,
            0,
            0
        ],
        10885: [
            .25583,
            .75583,
            0,
            0
        ],
        10886: [
            .25583,
            .75583,
            0,
            0
        ],
        10887: [
            .13597,
            .63597,
            0,
            0
        ],
        10888: [
            .13597,
            .63597,
            0,
            0
        ],
        10889: [
            .26167,
            .75726,
            0,
            0
        ],
        10890: [
            .26167,
            .75726,
            0,
            0
        ],
        10891: [
            .48256,
            .98256,
            0,
            0
        ],
        10892: [
            .48256,
            .98256,
            0,
            0
        ],
        10901: [
            .13667,
            .63667,
            0,
            0
        ],
        10902: [
            .13667,
            .63667,
            0,
            0
        ],
        10933: [
            .25142,
            .75726,
            0,
            0
        ],
        10934: [
            .25142,
            .75726,
            0,
            0
        ],
        10935: [
            .26167,
            .75726,
            0,
            0
        ],
        10936: [
            .26167,
            .75726,
            0,
            0
        ],
        10937: [
            .26167,
            .75726,
            0,
            0
        ],
        10938: [
            .26167,
            .75726,
            0,
            0
        ],
        10949: [
            .25583,
            .75583,
            0,
            0
        ],
        10950: [
            .25583,
            .75583,
            0,
            0
        ],
        10955: [
            .28481,
            .79383,
            0,
            0
        ],
        10956: [
            .28481,
            .79383,
            0,
            0
        ],
        57350: pe,
        57351: pe,
        57352: pe,
        57353: [
            0,
            .43056,
            .04028,
            0
        ],
        57356: [
            .25142,
            .75726,
            0,
            0
        ],
        57357: [
            .25142,
            .75726,
            0,
            0
        ],
        57358: [
            .41951,
            .91951,
            0,
            0
        ],
        57359: [
            .30274,
            .79383,
            0,
            0
        ],
        57360: [
            .30274,
            .79383,
            0,
            0
        ],
        57361: [
            .41951,
            .91951,
            0,
            0
        ],
        57366: [
            .25142,
            .75726,
            0,
            0
        ],
        57367: [
            .25142,
            .75726,
            0,
            0
        ],
        57368: [
            .25142,
            .75726,
            0,
            0
        ],
        57369: [
            .25142,
            .75726,
            0,
            0
        ],
        57370: [
            .13597,
            .63597,
            0,
            0
        ],
        57371: [
            .13597,
            .63597,
            0,
            0
        ]
    },
    "Caligraphic-Regular": {
        32: ee,
        65: [
            0,
            .68333,
            0,
            .19445
        ],
        66: [
            0,
            .68333,
            .03041,
            .13889
        ],
        67: [
            0,
            .68333,
            .05834,
            .13889
        ],
        68: [
            0,
            .68333,
            .02778,
            .08334
        ],
        69: [
            0,
            .68333,
            .08944,
            .11111
        ],
        70: [
            0,
            .68333,
            .09931,
            .11111
        ],
        71: [
            .09722,
            .68333,
            .0593,
            .11111
        ],
        72: [
            0,
            .68333,
            .00965,
            .11111
        ],
        73: [
            0,
            .68333,
            .07382,
            0
        ],
        74: [
            .09722,
            .68333,
            .18472,
            .16667
        ],
        75: [
            0,
            .68333,
            .01445,
            .05556
        ],
        76: [
            0,
            .68333,
            0,
            .13889
        ],
        77: [
            0,
            .68333,
            0,
            .13889
        ],
        78: [
            0,
            .68333,
            .14736,
            .08334
        ],
        79: [
            0,
            .68333,
            .02778,
            .11111
        ],
        80: [
            0,
            .68333,
            .08222,
            .08334
        ],
        81: [
            .09722,
            .68333,
            0,
            .11111
        ],
        82: [
            0,
            .68333,
            0,
            .08334
        ],
        83: [
            0,
            .68333,
            .075,
            .13889
        ],
        84: [
            0,
            .68333,
            .25417,
            0
        ],
        85: [
            0,
            .68333,
            .09931,
            .08334
        ],
        86: [
            0,
            .68333,
            .08222,
            0
        ],
        87: [
            0,
            .68333,
            .08222,
            .08334
        ],
        88: [
            0,
            .68333,
            .14643,
            .13889
        ],
        89: [
            .09722,
            .68333,
            .08222,
            .08334
        ],
        90: [
            0,
            .68333,
            .07944,
            .13889
        ],
        160: ee
    },
    "Fraktur-Regular": {
        32: ee,
        33: Q,
        34: Q,
        38: Q,
        39: Q,
        40: [
            .24982,
            .74947,
            0,
            0
        ],
        41: [
            .24982,
            .74947,
            0,
            0
        ],
        42: [
            0,
            .62119,
            0,
            0
        ],
        43: [
            .08319,
            .58283,
            0,
            0
        ],
        44: [
            0,
            .10803,
            0,
            0
        ],
        45: [
            .08319,
            .58283,
            0,
            0
        ],
        46: [
            0,
            .10803,
            0,
            0
        ],
        47: [
            .24982,
            .74947,
            0,
            0
        ],
        48: ce,
        49: ce,
        50: ce,
        51: [
            .18906,
            .47534,
            0,
            0
        ],
        52: [
            .18906,
            .47534,
            0,
            0
        ],
        53: [
            .18906,
            .47534,
            0,
            0
        ],
        54: Q,
        55: [
            .18906,
            .47534,
            0,
            0
        ],
        56: Q,
        57: [
            .18906,
            .47534,
            0,
            0
        ],
        58: ce,
        59: [
            .12604,
            .47534,
            0,
            0
        ],
        61: [
            -0.13099,
            .36866,
            0,
            0
        ],
        63: Q,
        65: Q,
        66: Q,
        67: Q,
        68: Q,
        69: Q,
        70: [
            .12604,
            .69141,
            0,
            0
        ],
        71: Q,
        72: [
            .06302,
            .69141,
            0,
            0
        ],
        73: Q,
        74: [
            .12604,
            .69141,
            0,
            0
        ],
        75: Q,
        76: Q,
        77: Q,
        78: Q,
        79: Q,
        80: [
            .18906,
            .69141,
            0,
            0
        ],
        81: [
            .03781,
            .69141,
            0,
            0
        ],
        82: Q,
        83: Q,
        84: Q,
        85: Q,
        86: Q,
        87: Q,
        88: Q,
        89: [
            .18906,
            .69141,
            0,
            0
        ],
        90: [
            .12604,
            .69141,
            0,
            0
        ],
        91: [
            .24982,
            .74947,
            0,
            0
        ],
        93: [
            .24982,
            .74947,
            0,
            0
        ],
        94: Q,
        97: ce,
        98: Q,
        99: ce,
        100: [
            0,
            .62119,
            0,
            0
        ],
        101: ce,
        102: [
            .18906,
            .69141,
            0,
            0
        ],
        103: [
            .18906,
            .47534,
            0,
            0
        ],
        104: [
            .18906,
            .69141,
            0,
            0
        ],
        105: Q,
        106: Q,
        107: Q,
        108: Q,
        109: ce,
        110: ce,
        111: ce,
        112: [
            .18906,
            .52396,
            0,
            0
        ],
        113: [
            .18906,
            .47534,
            0,
            0
        ],
        114: ce,
        115: ce,
        116: [
            0,
            .62119,
            0,
            0
        ],
        117: ce,
        118: [
            0,
            .52396,
            0,
            0
        ],
        119: [
            0,
            .52396,
            0,
            0
        ],
        120: [
            .18906,
            .47534,
            0,
            0
        ],
        121: [
            .18906,
            .47534,
            0,
            0
        ],
        122: [
            .18906,
            .47534,
            0,
            0
        ],
        160: ee,
        8216: Q,
        8217: Q,
        58112: [
            0,
            .62119,
            0,
            0
        ],
        58113: [
            0,
            .62119,
            0,
            0
        ],
        58114: [
            .18906,
            .69141,
            0,
            0
        ],
        58115: [
            .18906,
            .69141,
            0,
            0
        ],
        58116: [
            .18906,
            .47534,
            0,
            0
        ],
        58117: Q,
        58118: [
            0,
            .62119,
            0,
            0
        ],
        58119: ce
    },
    "Main-Bold": {
        32: ee,
        33: H,
        34: H,
        35: J,
        36: [
            .05556,
            .75,
            0,
            0
        ],
        37: [
            .05556,
            .75,
            0,
            0
        ],
        38: H,
        39: H,
        40: G,
        41: G,
        42: ue,
        43: [
            .13333,
            .63333,
            0,
            0
        ],
        44: [
            .19444,
            .15556,
            0,
            0
        ],
        45: Z,
        46: [
            0,
            .15556,
            0,
            0
        ],
        47: G,
        48: te,
        49: te,
        50: te,
        51: te,
        52: te,
        53: te,
        54: te,
        55: te,
        56: te,
        57: te,
        58: Z,
        59: ne,
        60: [
            .08556,
            .58556,
            0,
            0
        ],
        61: [
            -0.10889,
            .39111,
            0,
            0
        ],
        62: [
            .08556,
            .58556,
            0,
            0
        ],
        63: H,
        64: H,
        65: W,
        66: W,
        67: W,
        68: W,
        69: W,
        70: W,
        71: W,
        72: W,
        73: W,
        74: W,
        75: W,
        76: W,
        77: W,
        78: W,
        79: W,
        80: W,
        81: [
            .19444,
            .68611,
            0,
            0
        ],
        82: W,
        83: W,
        84: W,
        85: W,
        86: [
            0,
            .68611,
            .01597,
            0
        ],
        87: [
            0,
            .68611,
            .01597,
            0
        ],
        88: W,
        89: [
            0,
            .68611,
            .02875,
            0
        ],
        90: W,
        91: G,
        92: G,
        93: G,
        94: H,
        95: [
            .31,
            .13444,
            .03194,
            0
        ],
        97: Z,
        98: H,
        99: Z,
        100: H,
        101: Z,
        102: [
            0,
            .69444,
            .10903,
            0
        ],
        103: [
            .19444,
            .44444,
            .01597,
            0
        ],
        104: H,
        105: H,
        106: J,
        107: H,
        108: H,
        109: Z,
        110: Z,
        111: Z,
        112: ne,
        113: ne,
        114: Z,
        115: Z,
        116: [
            0,
            .63492,
            0,
            0
        ],
        117: Z,
        118: [
            0,
            .44444,
            .01597,
            0
        ],
        119: [
            0,
            .44444,
            .01597,
            0
        ],
        120: Z,
        121: [
            .19444,
            .44444,
            .01597,
            0
        ],
        122: Z,
        123: G,
        124: G,
        125: G,
        126: [
            .35,
            .34444,
            0,
            0
        ],
        160: ee,
        163: H,
        168: H,
        172: Z,
        176: H,
        177: [
            .13333,
            .63333,
            0,
            0
        ],
        184: [
            .17014,
            0,
            0,
            0
        ],
        198: W,
        215: [
            .13333,
            .63333,
            0,
            0
        ],
        216: [
            .04861,
            .73472,
            0,
            0
        ],
        223: H,
        230: Z,
        247: [
            .13333,
            .63333,
            0,
            0
        ],
        248: [
            .09722,
            .54167,
            0,
            0
        ],
        305: Z,
        338: W,
        339: Z,
        567: ne,
        710: H,
        711: [
            0,
            .63194,
            0,
            0
        ],
        713: [
            0,
            .59611,
            0,
            0
        ],
        714: H,
        715: H,
        728: H,
        729: H,
        730: H,
        732: H,
        733: H,
        915: W,
        916: W,
        920: W,
        923: W,
        926: W,
        928: W,
        931: W,
        933: W,
        934: W,
        936: W,
        937: W,
        8211: [
            0,
            .44444,
            .03194,
            0
        ],
        8212: [
            0,
            .44444,
            .03194,
            0
        ],
        8216: H,
        8217: H,
        8220: H,
        8221: H,
        8224: J,
        8225: J,
        8242: oe,
        8407: [
            0,
            .72444,
            .15486,
            0
        ],
        8463: H,
        8465: H,
        8467: H,
        8472: ne,
        8476: H,
        8501: H,
        8592: [
            -0.10889,
            .39111,
            0,
            0
        ],
        8593: J,
        8594: [
            -0.10889,
            .39111,
            0,
            0
        ],
        8595: J,
        8596: [
            -0.10889,
            .39111,
            0,
            0
        ],
        8597: G,
        8598: J,
        8599: J,
        8600: J,
        8601: J,
        8636: [
            -0.10889,
            .39111,
            0,
            0
        ],
        8637: [
            -0.10889,
            .39111,
            0,
            0
        ],
        8640: [
            -0.10889,
            .39111,
            0,
            0
        ],
        8641: [
            -0.10889,
            .39111,
            0,
            0
        ],
        8656: [
            -0.10889,
            .39111,
            0,
            0
        ],
        8657: J,
        8658: [
            -0.10889,
            .39111,
            0,
            0
        ],
        8659: J,
        8660: [
            -0.10889,
            .39111,
            0,
            0
        ],
        8661: G,
        8704: H,
        8706: [
            0,
            .69444,
            .06389,
            0
        ],
        8707: H,
        8709: [
            .05556,
            .75,
            0,
            0
        ],
        8711: W,
        8712: [
            .08556,
            .58556,
            0,
            0
        ],
        8715: [
            .08556,
            .58556,
            0,
            0
        ],
        8722: [
            .13333,
            .63333,
            0,
            0
        ],
        8723: [
            .13333,
            .63333,
            0,
            0
        ],
        8725: G,
        8726: G,
        8727: [
            -0.02778,
            .47222,
            0,
            0
        ],
        8728: [
            -0.02639,
            .47361,
            0,
            0
        ],
        8729: [
            -0.02639,
            .47361,
            0,
            0
        ],
        8730: [
            .18,
            .82,
            0,
            0
        ],
        8733: Z,
        8734: Z,
        8736: ie,
        8739: G,
        8741: G,
        8743: oe,
        8744: oe,
        8745: oe,
        8746: oe,
        8747: [
            .19444,
            .69444,
            .12778,
            0
        ],
        8764: [
            -0.10889,
            .39111,
            0,
            0
        ],
        8768: J,
        8771: [
            .00222,
            .50222,
            0,
            0
        ],
        8776: [
            .02444,
            .52444,
            0,
            0
        ],
        8781: [
            .00222,
            .50222,
            0,
            0
        ],
        8801: [
            .00222,
            .50222,
            0,
            0
        ],
        8804: [
            .19667,
            .69667,
            0,
            0
        ],
        8805: [
            .19667,
            .69667,
            0,
            0
        ],
        8810: [
            .08556,
            .58556,
            0,
            0
        ],
        8811: [
            .08556,
            .58556,
            0,
            0
        ],
        8826: [
            .08556,
            .58556,
            0,
            0
        ],
        8827: [
            .08556,
            .58556,
            0,
            0
        ],
        8834: [
            .08556,
            .58556,
            0,
            0
        ],
        8835: [
            .08556,
            .58556,
            0,
            0
        ],
        8838: [
            .19667,
            .69667,
            0,
            0
        ],
        8839: [
            .19667,
            .69667,
            0,
            0
        ],
        8846: oe,
        8849: [
            .19667,
            .69667,
            0,
            0
        ],
        8850: [
            .19667,
            .69667,
            0,
            0
        ],
        8851: oe,
        8852: oe,
        8853: [
            .13333,
            .63333,
            0,
            0
        ],
        8854: [
            .13333,
            .63333,
            0,
            0
        ],
        8855: [
            .13333,
            .63333,
            0,
            0
        ],
        8856: [
            .13333,
            .63333,
            0,
            0
        ],
        8857: [
            .13333,
            .63333,
            0,
            0
        ],
        8866: H,
        8867: H,
        8868: H,
        8869: H,
        8900: [
            -0.02639,
            .47361,
            0,
            0
        ],
        8901: [
            -0.02639,
            .47361,
            0,
            0
        ],
        8902: [
            -0.02778,
            .47222,
            0,
            0
        ],
        8968: G,
        8969: G,
        8970: G,
        8971: G,
        8994: [
            -0.13889,
            .36111,
            0,
            0
        ],
        8995: [
            -0.13889,
            .36111,
            0,
            0
        ],
        9651: J,
        9657: [
            -0.02778,
            .47222,
            0,
            0
        ],
        9661: J,
        9667: [
            -0.02778,
            .47222,
            0,
            0
        ],
        9711: J,
        9824: [
            .12963,
            .69444,
            0,
            0
        ],
        9825: [
            .12963,
            .69444,
            0,
            0
        ],
        9826: [
            .12963,
            .69444,
            0,
            0
        ],
        9827: [
            .12963,
            .69444,
            0,
            0
        ],
        9837: ue,
        9838: J,
        9839: J,
        10216: G,
        10217: G,
        10815: W,
        10927: [
            .19667,
            .69667,
            0,
            0
        ],
        10928: [
            .19667,
            .69667,
            0,
            0
        ],
        57376: J
    },
    "Main-BoldItalic": {
        32: ee,
        33: [
            0,
            .69444,
            .11417,
            0
        ],
        34: [
            0,
            .69444,
            .07939,
            0
        ],
        35: [
            .19444,
            .69444,
            .06833,
            0
        ],
        37: [
            .05556,
            .75,
            .12861,
            0
        ],
        38: [
            0,
            .69444,
            .08528,
            0
        ],
        39: [
            0,
            .69444,
            .12945,
            0
        ],
        40: [
            .25,
            .75,
            .15806,
            0
        ],
        41: [
            .25,
            .75,
            .03306,
            0
        ],
        42: [
            0,
            .75,
            .14333,
            0
        ],
        43: [
            .10333,
            .60333,
            .03306,
            0
        ],
        44: [
            .19444,
            .14722,
            0,
            0
        ],
        45: [
            0,
            .44444,
            .02611,
            0
        ],
        46: [
            0,
            .14722,
            0,
            0
        ],
        47: [
            .25,
            .75,
            .15806,
            0
        ],
        48: [
            0,
            .64444,
            .13167,
            0
        ],
        49: [
            0,
            .64444,
            .13167,
            0
        ],
        50: [
            0,
            .64444,
            .13167,
            0
        ],
        51: [
            0,
            .64444,
            .13167,
            0
        ],
        52: [
            .19444,
            .64444,
            .13167,
            0
        ],
        53: [
            0,
            .64444,
            .13167,
            0
        ],
        54: [
            0,
            .64444,
            .13167,
            0
        ],
        55: [
            .19444,
            .64444,
            .13167,
            0
        ],
        56: [
            0,
            .64444,
            .13167,
            0
        ],
        57: [
            0,
            .64444,
            .13167,
            0
        ],
        58: [
            0,
            .44444,
            .06695,
            0
        ],
        59: [
            .19444,
            .44444,
            .06695,
            0
        ],
        61: [
            -0.10889,
            .39111,
            .06833,
            0
        ],
        63: [
            0,
            .69444,
            .11472,
            0
        ],
        64: [
            0,
            .69444,
            .09208,
            0
        ],
        65: W,
        66: [
            0,
            .68611,
            .0992,
            0
        ],
        67: [
            0,
            .68611,
            .14208,
            0
        ],
        68: [
            0,
            .68611,
            .09062,
            0
        ],
        69: [
            0,
            .68611,
            .11431,
            0
        ],
        70: [
            0,
            .68611,
            .12903,
            0
        ],
        71: [
            0,
            .68611,
            .07347,
            0
        ],
        72: [
            0,
            .68611,
            .17208,
            0
        ],
        73: [
            0,
            .68611,
            .15681,
            0
        ],
        74: [
            0,
            .68611,
            .145,
            0
        ],
        75: [
            0,
            .68611,
            .14208,
            0
        ],
        76: W,
        77: [
            0,
            .68611,
            .17208,
            0
        ],
        78: [
            0,
            .68611,
            .17208,
            0
        ],
        79: [
            0,
            .68611,
            .09062,
            0
        ],
        80: [
            0,
            .68611,
            .0992,
            0
        ],
        81: [
            .19444,
            .68611,
            .09062,
            0
        ],
        82: [
            0,
            .68611,
            .02559,
            0
        ],
        83: [
            0,
            .68611,
            .11264,
            0
        ],
        84: [
            0,
            .68611,
            .12903,
            0
        ],
        85: [
            0,
            .68611,
            .17208,
            0
        ],
        86: [
            0,
            .68611,
            .18625,
            0
        ],
        87: [
            0,
            .68611,
            .18625,
            0
        ],
        88: [
            0,
            .68611,
            .15681,
            0
        ],
        89: [
            0,
            .68611,
            .19803,
            0
        ],
        90: [
            0,
            .68611,
            .14208,
            0
        ],
        91: [
            .25,
            .75,
            .1875,
            0
        ],
        93: [
            .25,
            .75,
            .09972,
            0
        ],
        94: [
            0,
            .69444,
            .06709,
            0
        ],
        95: [
            .31,
            .13444,
            .09811,
            0
        ],
        97: [
            0,
            .44444,
            .09426,
            0
        ],
        98: [
            0,
            .69444,
            .07861,
            0
        ],
        99: [
            0,
            .44444,
            .05222,
            0
        ],
        100: [
            0,
            .69444,
            .10861,
            0
        ],
        101: [
            0,
            .44444,
            .085,
            0
        ],
        102: [
            .19444,
            .69444,
            .21778,
            0
        ],
        103: [
            .19444,
            .44444,
            .105,
            0
        ],
        104: [
            0,
            .69444,
            .09426,
            0
        ],
        105: [
            0,
            .69326,
            .11387,
            0
        ],
        106: [
            .19444,
            .69326,
            .1672,
            0
        ],
        107: [
            0,
            .69444,
            .11111,
            0
        ],
        108: [
            0,
            .69444,
            .10861,
            0
        ],
        109: [
            0,
            .44444,
            .09426,
            0
        ],
        110: [
            0,
            .44444,
            .09426,
            0
        ],
        111: [
            0,
            .44444,
            .07861,
            0
        ],
        112: [
            .19444,
            .44444,
            .07861,
            0
        ],
        113: [
            .19444,
            .44444,
            .105,
            0
        ],
        114: [
            0,
            .44444,
            .11111,
            0
        ],
        115: [
            0,
            .44444,
            .08167,
            0
        ],
        116: [
            0,
            .63492,
            .09639,
            0
        ],
        117: [
            0,
            .44444,
            .09426,
            0
        ],
        118: [
            0,
            .44444,
            .11111,
            0
        ],
        119: [
            0,
            .44444,
            .11111,
            0
        ],
        120: [
            0,
            .44444,
            .12583,
            0
        ],
        121: [
            .19444,
            .44444,
            .105,
            0
        ],
        122: [
            0,
            .44444,
            .13889,
            0
        ],
        126: [
            .35,
            .34444,
            .11472,
            0
        ],
        160: ee,
        168: [
            0,
            .69444,
            .11473,
            0
        ],
        176: H,
        184: [
            .17014,
            0,
            0,
            0
        ],
        198: [
            0,
            .68611,
            .11431,
            0
        ],
        216: [
            .04861,
            .73472,
            .09062,
            0
        ],
        223: [
            .19444,
            .69444,
            .09736,
            0
        ],
        230: [
            0,
            .44444,
            .085,
            0
        ],
        248: [
            .09722,
            .54167,
            .09458,
            0
        ],
        305: [
            0,
            .44444,
            .09426,
            0
        ],
        338: [
            0,
            .68611,
            .11431,
            0
        ],
        339: [
            0,
            .44444,
            .085,
            0
        ],
        567: [
            .19444,
            .44444,
            .04611,
            0
        ],
        710: [
            0,
            .69444,
            .06709,
            0
        ],
        711: [
            0,
            .63194,
            .08271,
            0
        ],
        713: [
            0,
            .59444,
            .10444,
            0
        ],
        714: [
            0,
            .69444,
            .08528,
            0
        ],
        715: H,
        728: [
            0,
            .69444,
            .10333,
            0
        ],
        729: [
            0,
            .69444,
            .12945,
            0
        ],
        730: H,
        732: [
            0,
            .69444,
            .11472,
            0
        ],
        733: [
            0,
            .69444,
            .11472,
            0
        ],
        915: [
            0,
            .68611,
            .12903,
            0
        ],
        916: W,
        920: [
            0,
            .68611,
            .09062,
            0
        ],
        923: W,
        926: [
            0,
            .68611,
            .15092,
            0
        ],
        928: [
            0,
            .68611,
            .17208,
            0
        ],
        931: [
            0,
            .68611,
            .11431,
            0
        ],
        933: [
            0,
            .68611,
            .10778,
            0
        ],
        934: [
            0,
            .68611,
            .05632,
            0
        ],
        936: [
            0,
            .68611,
            .10778,
            0
        ],
        937: [
            0,
            .68611,
            .0992,
            0
        ],
        8211: [
            0,
            .44444,
            .09811,
            0
        ],
        8212: [
            0,
            .44444,
            .09811,
            0
        ],
        8216: [
            0,
            .69444,
            .12945,
            0
        ],
        8217: [
            0,
            .69444,
            .12945,
            0
        ],
        8220: [
            0,
            .69444,
            .16772,
            0
        ],
        8221: [
            0,
            .69444,
            .07939,
            0
        ]
    },
    "Main-Italic": {
        32: ee,
        33: [
            0,
            .69444,
            .12417,
            0
        ],
        34: [
            0,
            .69444,
            .06961,
            0
        ],
        35: [
            .19444,
            .69444,
            .06616,
            0
        ],
        37: [
            .05556,
            .75,
            .13639,
            0
        ],
        38: [
            0,
            .69444,
            .09694,
            0
        ],
        39: [
            0,
            .69444,
            .12417,
            0
        ],
        40: [
            .25,
            .75,
            .16194,
            0
        ],
        41: [
            .25,
            .75,
            .03694,
            0
        ],
        42: [
            0,
            .75,
            .14917,
            0
        ],
        43: [
            .05667,
            .56167,
            .03694,
            0
        ],
        44: [
            .19444,
            .10556,
            0,
            0
        ],
        45: [
            0,
            .43056,
            .02826,
            0
        ],
        46: [
            0,
            .10556,
            0,
            0
        ],
        47: [
            .25,
            .75,
            .16194,
            0
        ],
        48: [
            0,
            .64444,
            .13556,
            0
        ],
        49: [
            0,
            .64444,
            .13556,
            0
        ],
        50: [
            0,
            .64444,
            .13556,
            0
        ],
        51: [
            0,
            .64444,
            .13556,
            0
        ],
        52: [
            .19444,
            .64444,
            .13556,
            0
        ],
        53: [
            0,
            .64444,
            .13556,
            0
        ],
        54: [
            0,
            .64444,
            .13556,
            0
        ],
        55: [
            .19444,
            .64444,
            .13556,
            0
        ],
        56: [
            0,
            .64444,
            .13556,
            0
        ],
        57: [
            0,
            .64444,
            .13556,
            0
        ],
        58: [
            0,
            .43056,
            .0582,
            0
        ],
        59: [
            .19444,
            .43056,
            .0582,
            0
        ],
        61: [
            -0.13313,
            .36687,
            .06616,
            0
        ],
        63: [
            0,
            .69444,
            .1225,
            0
        ],
        64: [
            0,
            .69444,
            .09597,
            0
        ],
        65: X,
        66: [
            0,
            .68333,
            .10257,
            0
        ],
        67: [
            0,
            .68333,
            .14528,
            0
        ],
        68: [
            0,
            .68333,
            .09403,
            0
        ],
        69: [
            0,
            .68333,
            .12028,
            0
        ],
        70: [
            0,
            .68333,
            .13305,
            0
        ],
        71: [
            0,
            .68333,
            .08722,
            0
        ],
        72: [
            0,
            .68333,
            .16389,
            0
        ],
        73: [
            0,
            .68333,
            .15806,
            0
        ],
        74: [
            0,
            .68333,
            .14028,
            0
        ],
        75: [
            0,
            .68333,
            .14528,
            0
        ],
        76: X,
        77: [
            0,
            .68333,
            .16389,
            0
        ],
        78: [
            0,
            .68333,
            .16389,
            0
        ],
        79: [
            0,
            .68333,
            .09403,
            0
        ],
        80: [
            0,
            .68333,
            .10257,
            0
        ],
        81: [
            .19444,
            .68333,
            .09403,
            0
        ],
        82: [
            0,
            .68333,
            .03868,
            0
        ],
        83: [
            0,
            .68333,
            .11972,
            0
        ],
        84: [
            0,
            .68333,
            .13305,
            0
        ],
        85: [
            0,
            .68333,
            .16389,
            0
        ],
        86: [
            0,
            .68333,
            .18361,
            0
        ],
        87: [
            0,
            .68333,
            .18361,
            0
        ],
        88: [
            0,
            .68333,
            .15806,
            0
        ],
        89: [
            0,
            .68333,
            .19383,
            0
        ],
        90: [
            0,
            .68333,
            .14528,
            0
        ],
        91: [
            .25,
            .75,
            .1875,
            0
        ],
        93: [
            .25,
            .75,
            .10528,
            0
        ],
        94: [
            0,
            .69444,
            .06646,
            0
        ],
        95: [
            .31,
            .12056,
            .09208,
            0
        ],
        97: [
            0,
            .43056,
            .07671,
            0
        ],
        98: [
            0,
            .69444,
            .06312,
            0
        ],
        99: [
            0,
            .43056,
            .05653,
            0
        ],
        100: [
            0,
            .69444,
            .10333,
            0
        ],
        101: [
            0,
            .43056,
            .07514,
            0
        ],
        102: [
            .19444,
            .69444,
            .21194,
            0
        ],
        103: [
            .19444,
            .43056,
            .08847,
            0
        ],
        104: [
            0,
            .69444,
            .07671,
            0
        ],
        105: [
            0,
            .65536,
            .1019,
            0
        ],
        106: [
            .19444,
            .65536,
            .14467,
            0
        ],
        107: [
            0,
            .69444,
            .10764,
            0
        ],
        108: [
            0,
            .69444,
            .10333,
            0
        ],
        109: [
            0,
            .43056,
            .07671,
            0
        ],
        110: [
            0,
            .43056,
            .07671,
            0
        ],
        111: [
            0,
            .43056,
            .06312,
            0
        ],
        112: [
            .19444,
            .43056,
            .06312,
            0
        ],
        113: [
            .19444,
            .43056,
            .08847,
            0
        ],
        114: [
            0,
            .43056,
            .10764,
            0
        ],
        115: [
            0,
            .43056,
            .08208,
            0
        ],
        116: [
            0,
            .61508,
            .09486,
            0
        ],
        117: [
            0,
            .43056,
            .07671,
            0
        ],
        118: [
            0,
            .43056,
            .10764,
            0
        ],
        119: [
            0,
            .43056,
            .10764,
            0
        ],
        120: [
            0,
            .43056,
            .12042,
            0
        ],
        121: [
            .19444,
            .43056,
            .08847,
            0
        ],
        122: [
            0,
            .43056,
            .12292,
            0
        ],
        126: [
            .35,
            .31786,
            .11585,
            0
        ],
        160: ee,
        168: [
            0,
            .66786,
            .10474,
            0
        ],
        176: H,
        184: [
            .17014,
            0,
            0,
            0
        ],
        198: [
            0,
            .68333,
            .12028,
            0
        ],
        216: [
            .04861,
            .73194,
            .09403,
            0
        ],
        223: [
            .19444,
            .69444,
            .10514,
            0
        ],
        230: [
            0,
            .43056,
            .07514,
            0
        ],
        248: [
            .09722,
            .52778,
            .09194,
            0
        ],
        338: [
            0,
            .68333,
            .12028,
            0
        ],
        339: [
            0,
            .43056,
            .07514,
            0
        ],
        710: [
            0,
            .69444,
            .06646,
            0
        ],
        711: [
            0,
            .62847,
            .08295,
            0
        ],
        713: [
            0,
            .56167,
            .10333,
            0
        ],
        714: [
            0,
            .69444,
            .09694,
            0
        ],
        715: H,
        728: [
            0,
            .69444,
            .10806,
            0
        ],
        729: [
            0,
            .66786,
            .11752,
            0
        ],
        730: H,
        732: [
            0,
            .66786,
            .11585,
            0
        ],
        733: [
            0,
            .69444,
            .1225,
            0
        ],
        915: [
            0,
            .68333,
            .13305,
            0
        ],
        916: X,
        920: [
            0,
            .68333,
            .09403,
            0
        ],
        923: X,
        926: [
            0,
            .68333,
            .15294,
            0
        ],
        928: [
            0,
            .68333,
            .16389,
            0
        ],
        931: [
            0,
            .68333,
            .12028,
            0
        ],
        933: [
            0,
            .68333,
            .11111,
            0
        ],
        934: [
            0,
            .68333,
            .05986,
            0
        ],
        936: [
            0,
            .68333,
            .11111,
            0
        ],
        937: [
            0,
            .68333,
            .10257,
            0
        ],
        8211: [
            0,
            .43056,
            .09208,
            0
        ],
        8212: [
            0,
            .43056,
            .09208,
            0
        ],
        8216: [
            0,
            .69444,
            .12417,
            0
        ],
        8217: [
            0,
            .69444,
            .12417,
            0
        ],
        8220: [
            0,
            .69444,
            .1685,
            0
        ],
        8221: [
            0,
            .69444,
            .06961,
            0
        ],
        8463: Y
    },
    "Main-Regular": {
        32: ee,
        33: H,
        34: H,
        35: J,
        36: [
            .05556,
            .75,
            0,
            0
        ],
        37: [
            .05556,
            .75,
            0,
            0
        ],
        38: H,
        39: H,
        40: G,
        41: G,
        42: ue,
        43: [
            .08333,
            .58333,
            0,
            0
        ],
        44: [
            .19444,
            .10556,
            0,
            0
        ],
        45: [
            0,
            .43056,
            0,
            0
        ],
        46: [
            0,
            .10556,
            0,
            0
        ],
        47: G,
        48: te,
        49: te,
        50: te,
        51: te,
        52: te,
        53: te,
        54: te,
        55: te,
        56: te,
        57: te,
        58: [
            0,
            .43056,
            0,
            0
        ],
        59: [
            .19444,
            .43056,
            0,
            0
        ],
        60: [
            .0391,
            .5391,
            0,
            0
        ],
        61: [
            -0.13313,
            .36687,
            0,
            0
        ],
        62: [
            .0391,
            .5391,
            0,
            0
        ],
        63: H,
        64: H,
        65: X,
        66: X,
        67: X,
        68: X,
        69: X,
        70: X,
        71: X,
        72: X,
        73: X,
        74: X,
        75: X,
        76: X,
        77: X,
        78: X,
        79: X,
        80: X,
        81: [
            .19444,
            .68333,
            0,
            0
        ],
        82: X,
        83: X,
        84: X,
        85: X,
        86: [
            0,
            .68333,
            .01389,
            0
        ],
        87: [
            0,
            .68333,
            .01389,
            0
        ],
        88: X,
        89: [
            0,
            .68333,
            .025,
            0
        ],
        90: X,
        91: G,
        92: G,
        93: G,
        94: H,
        95: [
            .31,
            .12056,
            .02778,
            0
        ],
        97: [
            0,
            .43056,
            0,
            0
        ],
        98: H,
        99: [
            0,
            .43056,
            0,
            0
        ],
        100: H,
        101: [
            0,
            .43056,
            0,
            0
        ],
        102: [
            0,
            .69444,
            .07778,
            0
        ],
        103: [
            .19444,
            .43056,
            .01389,
            0
        ],
        104: H,
        105: [
            0,
            .66786,
            0,
            0
        ],
        106: [
            .19444,
            .66786,
            0,
            0
        ],
        107: H,
        108: H,
        109: [
            0,
            .43056,
            0,
            0
        ],
        110: [
            0,
            .43056,
            0,
            0
        ],
        111: [
            0,
            .43056,
            0,
            0
        ],
        112: [
            .19444,
            .43056,
            0,
            0
        ],
        113: [
            .19444,
            .43056,
            0,
            0
        ],
        114: [
            0,
            .43056,
            0,
            0
        ],
        115: [
            0,
            .43056,
            0,
            0
        ],
        116: [
            0,
            .61508,
            0,
            0
        ],
        117: [
            0,
            .43056,
            0,
            0
        ],
        118: [
            0,
            .43056,
            .01389,
            0
        ],
        119: [
            0,
            .43056,
            .01389,
            0
        ],
        120: [
            0,
            .43056,
            0,
            0
        ],
        121: [
            .19444,
            .43056,
            .01389,
            0
        ],
        122: [
            0,
            .43056,
            0,
            0
        ],
        123: G,
        124: G,
        125: G,
        126: [
            .35,
            .31786,
            0,
            0
        ],
        160: ee,
        163: H,
        167: J,
        168: [
            0,
            .66786,
            0,
            0
        ],
        172: [
            0,
            .43056,
            0,
            0
        ],
        176: H,
        177: [
            .08333,
            .58333,
            0,
            0
        ],
        182: J,
        184: [
            .17014,
            0,
            0,
            0
        ],
        198: X,
        215: [
            .08333,
            .58333,
            0,
            0
        ],
        216: [
            .04861,
            .73194,
            0,
            0
        ],
        223: H,
        230: [
            0,
            .43056,
            0,
            0
        ],
        247: [
            .08333,
            .58333,
            0,
            0
        ],
        248: [
            .09722,
            .52778,
            0,
            0
        ],
        305: [
            0,
            .43056,
            0,
            0
        ],
        338: X,
        339: [
            0,
            .43056,
            0,
            0
        ],
        567: [
            .19444,
            .43056,
            0,
            0
        ],
        710: H,
        711: [
            0,
            .62847,
            0,
            0
        ],
        713: [
            0,
            .56778,
            0,
            0
        ],
        714: H,
        715: H,
        728: H,
        729: [
            0,
            .66786,
            0,
            0
        ],
        730: H,
        732: [
            0,
            .66786,
            0,
            0
        ],
        733: H,
        915: X,
        916: X,
        920: X,
        923: X,
        926: X,
        928: X,
        931: X,
        933: X,
        934: X,
        936: X,
        937: X,
        8211: [
            0,
            .43056,
            .02778,
            0
        ],
        8212: [
            0,
            .43056,
            .02778,
            0
        ],
        8216: H,
        8217: H,
        8220: H,
        8221: H,
        8224: J,
        8225: J,
        8230: [
            0,
            .12,
            0,
            0
        ],
        8242: oe,
        8407: [
            0,
            .71444,
            .15382,
            0
        ],
        8463: Y,
        8465: H,
        8467: [
            0,
            .69444,
            0,
            .11111
        ],
        8472: [
            .19444,
            .43056,
            0,
            .11111
        ],
        8476: H,
        8501: H,
        8592: [
            -0.13313,
            .36687,
            0,
            0
        ],
        8593: J,
        8594: [
            -0.13313,
            .36687,
            0,
            0
        ],
        8595: J,
        8596: [
            -0.13313,
            .36687,
            0,
            0
        ],
        8597: G,
        8598: J,
        8599: J,
        8600: J,
        8601: J,
        8614: [
            .011,
            .511,
            0,
            0
        ],
        8617: [
            .011,
            .511,
            0,
            0
        ],
        8618: [
            .011,
            .511,
            0,
            0
        ],
        8636: [
            -0.13313,
            .36687,
            0,
            0
        ],
        8637: [
            -0.13313,
            .36687,
            0,
            0
        ],
        8640: [
            -0.13313,
            .36687,
            0,
            0
        ],
        8641: [
            -0.13313,
            .36687,
            0,
            0
        ],
        8652: [
            .011,
            .671,
            0,
            0
        ],
        8656: [
            -0.13313,
            .36687,
            0,
            0
        ],
        8657: J,
        8658: [
            -0.13313,
            .36687,
            0,
            0
        ],
        8659: J,
        8660: [
            -0.13313,
            .36687,
            0,
            0
        ],
        8661: G,
        8704: H,
        8706: [
            0,
            .69444,
            .05556,
            .08334
        ],
        8707: H,
        8709: [
            .05556,
            .75,
            0,
            0
        ],
        8711: X,
        8712: [
            .0391,
            .5391,
            0,
            0
        ],
        8715: [
            .0391,
            .5391,
            0,
            0
        ],
        8722: [
            .08333,
            .58333,
            0,
            0
        ],
        8723: [
            .08333,
            .58333,
            0,
            0
        ],
        8725: G,
        8726: G,
        8727: [
            -0.03472,
            .46528,
            0,
            0
        ],
        8728: [
            -0.05555,
            .44445,
            0,
            0
        ],
        8729: [
            -0.05555,
            .44445,
            0,
            0
        ],
        8730: [
            .2,
            .8,
            0,
            0
        ],
        8733: [
            0,
            .43056,
            0,
            0
        ],
        8734: [
            0,
            .43056,
            0,
            0
        ],
        8736: ie,
        8739: G,
        8741: G,
        8743: oe,
        8744: oe,
        8745: oe,
        8746: oe,
        8747: [
            .19444,
            .69444,
            .11111,
            0
        ],
        8764: [
            -0.13313,
            .36687,
            0,
            0
        ],
        8768: J,
        8771: [
            -0.03625,
            .46375,
            0,
            0
        ],
        8773: [
            -0.022,
            .589,
            0,
            0
        ],
        8776: [
            -0.01688,
            .48312,
            0,
            0
        ],
        8781: [
            -0.03625,
            .46375,
            0,
            0
        ],
        8784: [
            -0.133,
            .67,
            0,
            0
        ],
        8801: [
            -0.03625,
            .46375,
            0,
            0
        ],
        8804: [
            .13597,
            .63597,
            0,
            0
        ],
        8805: [
            .13597,
            .63597,
            0,
            0
        ],
        8810: [
            .0391,
            .5391,
            0,
            0
        ],
        8811: [
            .0391,
            .5391,
            0,
            0
        ],
        8826: [
            .0391,
            .5391,
            0,
            0
        ],
        8827: [
            .0391,
            .5391,
            0,
            0
        ],
        8834: [
            .0391,
            .5391,
            0,
            0
        ],
        8835: [
            .0391,
            .5391,
            0,
            0
        ],
        8838: [
            .13597,
            .63597,
            0,
            0
        ],
        8839: [
            .13597,
            .63597,
            0,
            0
        ],
        8846: oe,
        8849: [
            .13597,
            .63597,
            0,
            0
        ],
        8850: [
            .13597,
            .63597,
            0,
            0
        ],
        8851: oe,
        8852: oe,
        8853: [
            .08333,
            .58333,
            0,
            0
        ],
        8854: [
            .08333,
            .58333,
            0,
            0
        ],
        8855: [
            .08333,
            .58333,
            0,
            0
        ],
        8856: [
            .08333,
            .58333,
            0,
            0
        ],
        8857: [
            .08333,
            .58333,
            0,
            0
        ],
        8866: H,
        8867: H,
        8868: H,
        8869: H,
        8872: [
            .249,
            .75,
            0,
            0
        ],
        8900: [
            -0.05555,
            .44445,
            0,
            0
        ],
        8901: [
            -0.05555,
            .44445,
            0,
            0
        ],
        8902: [
            -0.03472,
            .46528,
            0,
            0
        ],
        8904: [
            .005,
            .505,
            0,
            0
        ],
        8942: [
            .03,
            .9,
            0,
            0
        ],
        8943: [
            -0.19,
            .31,
            0,
            0
        ],
        8945: [
            -0.1,
            .82,
            0,
            0
        ],
        8968: G,
        8969: G,
        8970: G,
        8971: G,
        8994: [
            -0.14236,
            .35764,
            0,
            0
        ],
        8995: [
            -0.14236,
            .35764,
            0,
            0
        ],
        9136: [
            .244,
            .744,
            0,
            0
        ],
        9137: [
            .244,
            .744,
            0,
            0
        ],
        9651: J,
        9657: [
            -0.03472,
            .46528,
            0,
            0
        ],
        9661: J,
        9667: [
            -0.03472,
            .46528,
            0,
            0
        ],
        9711: J,
        9824: [
            .12963,
            .69444,
            0,
            0
        ],
        9825: [
            .12963,
            .69444,
            0,
            0
        ],
        9826: [
            .12963,
            .69444,
            0,
            0
        ],
        9827: [
            .12963,
            .69444,
            0,
            0
        ],
        9837: ue,
        9838: J,
        9839: J,
        10216: G,
        10217: G,
        10222: [
            .244,
            .744,
            0,
            0
        ],
        10223: [
            .244,
            .744,
            0,
            0
        ],
        10229: [
            .011,
            .511,
            0,
            0
        ],
        10230: [
            .011,
            .511,
            0,
            0
        ],
        10231: [
            .011,
            .511,
            0,
            0
        ],
        10232: [
            .024,
            .525,
            0,
            0
        ],
        10233: [
            .024,
            .525,
            0,
            0
        ],
        10234: [
            .024,
            .525,
            0,
            0
        ],
        10236: [
            .011,
            .511,
            0,
            0
        ],
        10815: X,
        10927: [
            .13597,
            .63597,
            0,
            0
        ],
        10928: [
            .13597,
            .63597,
            0,
            0
        ],
        57376: J
    },
    "Math-BoldItalic": {
        32: ee,
        48: Z,
        49: Z,
        50: Z,
        51: ne,
        52: ne,
        53: ne,
        54: te,
        55: ne,
        56: te,
        57: ne,
        65: W,
        66: [
            0,
            .68611,
            .04835,
            0
        ],
        67: [
            0,
            .68611,
            .06979,
            0
        ],
        68: [
            0,
            .68611,
            .03194,
            0
        ],
        69: [
            0,
            .68611,
            .05451,
            0
        ],
        70: [
            0,
            .68611,
            .15972,
            0
        ],
        71: W,
        72: [
            0,
            .68611,
            .08229,
            0
        ],
        73: [
            0,
            .68611,
            .07778,
            0
        ],
        74: [
            0,
            .68611,
            .10069,
            0
        ],
        75: [
            0,
            .68611,
            .06979,
            0
        ],
        76: W,
        77: [
            0,
            .68611,
            .11424,
            0
        ],
        78: [
            0,
            .68611,
            .11424,
            0
        ],
        79: [
            0,
            .68611,
            .03194,
            0
        ],
        80: [
            0,
            .68611,
            .15972,
            0
        ],
        81: [
            .19444,
            .68611,
            0,
            0
        ],
        82: [
            0,
            .68611,
            .00421,
            0
        ],
        83: [
            0,
            .68611,
            .05382,
            0
        ],
        84: [
            0,
            .68611,
            .15972,
            0
        ],
        85: [
            0,
            .68611,
            .11424,
            0
        ],
        86: [
            0,
            .68611,
            .25555,
            0
        ],
        87: [
            0,
            .68611,
            .15972,
            0
        ],
        88: [
            0,
            .68611,
            .07778,
            0
        ],
        89: [
            0,
            .68611,
            .25555,
            0
        ],
        90: [
            0,
            .68611,
            .06979,
            0
        ],
        97: Z,
        98: H,
        99: Z,
        100: H,
        101: Z,
        102: [
            .19444,
            .69444,
            .11042,
            0
        ],
        103: [
            .19444,
            .44444,
            .03704,
            0
        ],
        104: H,
        105: [
            0,
            .69326,
            0,
            0
        ],
        106: [
            .19444,
            .69326,
            .0622,
            0
        ],
        107: [
            0,
            .69444,
            .01852,
            0
        ],
        108: [
            0,
            .69444,
            .0088,
            0
        ],
        109: Z,
        110: Z,
        111: Z,
        112: ne,
        113: [
            .19444,
            .44444,
            .03704,
            0
        ],
        114: [
            0,
            .44444,
            .03194,
            0
        ],
        115: Z,
        116: [
            0,
            .63492,
            0,
            0
        ],
        117: Z,
        118: [
            0,
            .44444,
            .03704,
            0
        ],
        119: [
            0,
            .44444,
            .02778,
            0
        ],
        120: Z,
        121: [
            .19444,
            .44444,
            .03704,
            0
        ],
        122: [
            0,
            .44444,
            .04213,
            0
        ],
        160: ee,
        915: [
            0,
            .68611,
            .15972,
            0
        ],
        916: W,
        920: [
            0,
            .68611,
            .03194,
            0
        ],
        923: W,
        926: [
            0,
            .68611,
            .07458,
            0
        ],
        928: [
            0,
            .68611,
            .08229,
            0
        ],
        931: [
            0,
            .68611,
            .05451,
            0
        ],
        933: [
            0,
            .68611,
            .15972,
            0
        ],
        934: W,
        936: [
            0,
            .68611,
            .11653,
            0
        ],
        937: [
            0,
            .68611,
            .04835,
            0
        ],
        945: Z,
        946: [
            .19444,
            .69444,
            .03403,
            0
        ],
        947: [
            .19444,
            .44444,
            .06389,
            0
        ],
        948: [
            0,
            .69444,
            .03819,
            0
        ],
        949: Z,
        950: [
            .19444,
            .69444,
            .06215,
            0
        ],
        951: [
            .19444,
            .44444,
            .03704,
            0
        ],
        952: [
            0,
            .69444,
            .03194,
            0
        ],
        953: Z,
        954: Z,
        955: H,
        956: ne,
        957: [
            0,
            .44444,
            .06898,
            0
        ],
        958: [
            .19444,
            .69444,
            .03021,
            0
        ],
        959: Z,
        960: [
            0,
            .44444,
            .03704,
            0
        ],
        961: ne,
        962: [
            .09722,
            .44444,
            .07917,
            0
        ],
        963: [
            0,
            .44444,
            .03704,
            0
        ],
        964: [
            0,
            .44444,
            .13472,
            0
        ],
        965: [
            0,
            .44444,
            .03704,
            0
        ],
        966: ne,
        967: ne,
        968: [
            .19444,
            .69444,
            .03704,
            0
        ],
        969: [
            0,
            .44444,
            .03704,
            0
        ],
        977: H,
        981: J,
        982: [
            0,
            .44444,
            .03194,
            0
        ],
        1009: ne,
        1013: Z,
        57649: Z,
        57911: ne
    },
    "Math-Italic": {
        32: ee,
        48: [
            0,
            .43056,
            0,
            0
        ],
        49: [
            0,
            .43056,
            0,
            0
        ],
        50: [
            0,
            .43056,
            0,
            0
        ],
        51: [
            .19444,
            .43056,
            0,
            0
        ],
        52: [
            .19444,
            .43056,
            0,
            0
        ],
        53: [
            .19444,
            .43056,
            0,
            0
        ],
        54: te,
        55: [
            .19444,
            .43056,
            0,
            0
        ],
        56: te,
        57: [
            .19444,
            .43056,
            0,
            0
        ],
        65: [
            0,
            .68333,
            0,
            .13889
        ],
        66: [
            0,
            .68333,
            .05017,
            .08334
        ],
        67: [
            0,
            .68333,
            .07153,
            .08334
        ],
        68: [
            0,
            .68333,
            .02778,
            .05556
        ],
        69: [
            0,
            .68333,
            .05764,
            .08334
        ],
        70: [
            0,
            .68333,
            .13889,
            .08334
        ],
        71: [
            0,
            .68333,
            0,
            .08334
        ],
        72: [
            0,
            .68333,
            .08125,
            .05556
        ],
        73: [
            0,
            .68333,
            .07847,
            .11111
        ],
        74: [
            0,
            .68333,
            .09618,
            .16667
        ],
        75: [
            0,
            .68333,
            .07153,
            .05556
        ],
        76: [
            0,
            .68333,
            0,
            .02778
        ],
        77: [
            0,
            .68333,
            .10903,
            .08334
        ],
        78: [
            0,
            .68333,
            .10903,
            .08334
        ],
        79: [
            0,
            .68333,
            .02778,
            .08334
        ],
        80: [
            0,
            .68333,
            .13889,
            .08334
        ],
        81: [
            .19444,
            .68333,
            0,
            .08334
        ],
        82: [
            0,
            .68333,
            .00773,
            .08334
        ],
        83: [
            0,
            .68333,
            .05764,
            .08334
        ],
        84: [
            0,
            .68333,
            .13889,
            .08334
        ],
        85: [
            0,
            .68333,
            .10903,
            .02778
        ],
        86: [
            0,
            .68333,
            .22222,
            0
        ],
        87: [
            0,
            .68333,
            .13889,
            0
        ],
        88: [
            0,
            .68333,
            .07847,
            .08334
        ],
        89: [
            0,
            .68333,
            .22222,
            0
        ],
        90: [
            0,
            .68333,
            .07153,
            .08334
        ],
        97: [
            0,
            .43056,
            0,
            0
        ],
        98: H,
        99: [
            0,
            .43056,
            0,
            .05556
        ],
        100: [
            0,
            .69444,
            0,
            .16667
        ],
        101: [
            0,
            .43056,
            0,
            .05556
        ],
        102: [
            .19444,
            .69444,
            .10764,
            .16667
        ],
        103: [
            .19444,
            .43056,
            .03588,
            .02778
        ],
        104: H,
        105: [
            0,
            .65952,
            0,
            0
        ],
        106: [
            .19444,
            .65952,
            .05724,
            0
        ],
        107: [
            0,
            .69444,
            .03148,
            0
        ],
        108: [
            0,
            .69444,
            .01968,
            .08334
        ],
        109: [
            0,
            .43056,
            0,
            0
        ],
        110: [
            0,
            .43056,
            0,
            0
        ],
        111: [
            0,
            .43056,
            0,
            .05556
        ],
        112: [
            .19444,
            .43056,
            0,
            .08334
        ],
        113: [
            .19444,
            .43056,
            .03588,
            .08334
        ],
        114: [
            0,
            .43056,
            .02778,
            .05556
        ],
        115: [
            0,
            .43056,
            0,
            .05556
        ],
        116: [
            0,
            .61508,
            0,
            .08334
        ],
        117: [
            0,
            .43056,
            0,
            .02778
        ],
        118: [
            0,
            .43056,
            .03588,
            .02778
        ],
        119: [
            0,
            .43056,
            .02691,
            .08334
        ],
        120: [
            0,
            .43056,
            0,
            .02778
        ],
        121: [
            .19444,
            .43056,
            .03588,
            .05556
        ],
        122: [
            0,
            .43056,
            .04398,
            .05556
        ],
        160: ee,
        915: [
            0,
            .68333,
            .13889,
            .08334
        ],
        916: [
            0,
            .68333,
            0,
            .16667
        ],
        920: [
            0,
            .68333,
            .02778,
            .08334
        ],
        923: [
            0,
            .68333,
            0,
            .16667
        ],
        926: [
            0,
            .68333,
            .07569,
            .08334
        ],
        928: [
            0,
            .68333,
            .08125,
            .05556
        ],
        931: [
            0,
            .68333,
            .05764,
            .08334
        ],
        933: [
            0,
            .68333,
            .13889,
            .05556
        ],
        934: [
            0,
            .68333,
            0,
            .08334
        ],
        936: [
            0,
            .68333,
            .11,
            .05556
        ],
        937: [
            0,
            .68333,
            .05017,
            .08334
        ],
        945: [
            0,
            .43056,
            .0037,
            .02778
        ],
        946: [
            .19444,
            .69444,
            .05278,
            .08334
        ],
        947: [
            .19444,
            .43056,
            .05556,
            0
        ],
        948: [
            0,
            .69444,
            .03785,
            .05556
        ],
        949: [
            0,
            .43056,
            0,
            .08334
        ],
        950: [
            .19444,
            .69444,
            .07378,
            .08334
        ],
        951: [
            .19444,
            .43056,
            .03588,
            .05556
        ],
        952: [
            0,
            .69444,
            .02778,
            .08334
        ],
        953: [
            0,
            .43056,
            0,
            .05556
        ],
        954: [
            0,
            .43056,
            0,
            0
        ],
        955: H,
        956: [
            .19444,
            .43056,
            0,
            .02778
        ],
        957: [
            0,
            .43056,
            .06366,
            .02778
        ],
        958: [
            .19444,
            .69444,
            .04601,
            .11111
        ],
        959: [
            0,
            .43056,
            0,
            .05556
        ],
        960: [
            0,
            .43056,
            .03588,
            0
        ],
        961: [
            .19444,
            .43056,
            0,
            .08334
        ],
        962: [
            .09722,
            .43056,
            .07986,
            .08334
        ],
        963: [
            0,
            .43056,
            .03588,
            0
        ],
        964: [
            0,
            .43056,
            .1132,
            .02778
        ],
        965: [
            0,
            .43056,
            .03588,
            .02778
        ],
        966: [
            .19444,
            .43056,
            0,
            .08334
        ],
        967: [
            .19444,
            .43056,
            0,
            .05556
        ],
        968: [
            .19444,
            .69444,
            .03588,
            .11111
        ],
        969: [
            0,
            .43056,
            .03588,
            0
        ],
        977: [
            0,
            .69444,
            0,
            .08334
        ],
        981: [
            .19444,
            .69444,
            0,
            .08334
        ],
        982: [
            0,
            .43056,
            .02778,
            0
        ],
        1009: [
            .19444,
            .43056,
            0,
            .08334
        ],
        1013: [
            0,
            .43056,
            0,
            .05556
        ],
        57649: [
            0,
            .43056,
            0,
            .02778
        ],
        57911: [
            .19444,
            .43056,
            0,
            .08334
        ]
    },
    "SansSerif-Bold": {
        32: ee,
        33: H,
        34: H,
        35: J,
        36: [
            .05556,
            .75,
            0,
            0
        ],
        37: [
            .05556,
            .75,
            0,
            0
        ],
        38: H,
        39: H,
        40: G,
        41: G,
        42: ue,
        43: [
            .11667,
            .61667,
            0,
            0
        ],
        44: [
            .10556,
            .13056,
            0,
            0
        ],
        45: [
            0,
            .45833,
            0,
            0
        ],
        46: [
            0,
            .13056,
            0,
            0
        ],
        47: G,
        48: H,
        49: H,
        50: H,
        51: H,
        52: H,
        53: H,
        54: H,
        55: H,
        56: H,
        57: H,
        58: [
            0,
            .45833,
            0,
            0
        ],
        59: [
            .10556,
            .45833,
            0,
            0
        ],
        61: [
            -0.09375,
            .40625,
            0,
            0
        ],
        63: H,
        64: H,
        65: H,
        66: H,
        67: H,
        68: H,
        69: H,
        70: H,
        71: H,
        72: H,
        73: H,
        74: H,
        75: H,
        76: H,
        77: H,
        78: H,
        79: H,
        80: H,
        81: [
            .10556,
            .69444,
            0,
            0
        ],
        82: H,
        83: H,
        84: H,
        85: H,
        86: [
            0,
            .69444,
            .01528,
            0
        ],
        87: [
            0,
            .69444,
            .01528,
            0
        ],
        88: H,
        89: [
            0,
            .69444,
            .0275,
            0
        ],
        90: H,
        91: G,
        93: G,
        94: H,
        95: [
            .35,
            .10833,
            .03056,
            0
        ],
        97: [
            0,
            .45833,
            0,
            0
        ],
        98: H,
        99: [
            0,
            .45833,
            0,
            0
        ],
        100: H,
        101: [
            0,
            .45833,
            0,
            0
        ],
        102: [
            0,
            .69444,
            .07639,
            0
        ],
        103: [
            .19444,
            .45833,
            .01528,
            0
        ],
        104: H,
        105: H,
        106: J,
        107: H,
        108: H,
        109: [
            0,
            .45833,
            0,
            0
        ],
        110: [
            0,
            .45833,
            0,
            0
        ],
        111: [
            0,
            .45833,
            0,
            0
        ],
        112: [
            .19444,
            .45833,
            0,
            0
        ],
        113: [
            .19444,
            .45833,
            0,
            0
        ],
        114: [
            0,
            .45833,
            .01528,
            0
        ],
        115: [
            0,
            .45833,
            0,
            0
        ],
        116: [
            0,
            .58929,
            0,
            0
        ],
        117: [
            0,
            .45833,
            0,
            0
        ],
        118: [
            0,
            .45833,
            .01528,
            0
        ],
        119: [
            0,
            .45833,
            .01528,
            0
        ],
        120: [
            0,
            .45833,
            0,
            0
        ],
        121: [
            .19444,
            .45833,
            .01528,
            0
        ],
        122: [
            0,
            .45833,
            0,
            0
        ],
        126: [
            .35,
            .34444,
            0,
            0
        ],
        160: ee,
        168: H,
        176: H,
        180: H,
        184: [
            .17014,
            0,
            0,
            0
        ],
        305: [
            0,
            .45833,
            0,
            0
        ],
        567: [
            .19444,
            .45833,
            0,
            0
        ],
        710: H,
        711: [
            0,
            .63542,
            0,
            0
        ],
        713: [
            0,
            .63778,
            0,
            0
        ],
        728: H,
        729: H,
        730: H,
        732: H,
        733: H,
        915: H,
        916: H,
        920: H,
        923: H,
        926: H,
        928: H,
        931: H,
        933: H,
        934: H,
        936: H,
        937: H,
        8211: [
            0,
            .45833,
            .03056,
            0
        ],
        8212: [
            0,
            .45833,
            .03056,
            0
        ],
        8216: H,
        8217: H,
        8220: H,
        8221: H
    },
    "SansSerif-Italic": {
        32: ee,
        33: [
            0,
            .69444,
            .05733,
            0
        ],
        34: [
            0,
            .69444,
            .00316,
            0
        ],
        35: [
            .19444,
            .69444,
            .05087,
            0
        ],
        36: [
            .05556,
            .75,
            .11156,
            0
        ],
        37: [
            .05556,
            .75,
            .03126,
            0
        ],
        38: [
            0,
            .69444,
            .03058,
            0
        ],
        39: [
            0,
            .69444,
            .07816,
            0
        ],
        40: [
            .25,
            .75,
            .13164,
            0
        ],
        41: [
            .25,
            .75,
            .02536,
            0
        ],
        42: [
            0,
            .75,
            .11775,
            0
        ],
        43: [
            .08333,
            .58333,
            .02536,
            0
        ],
        44: [
            .125,
            .08333,
            0,
            0
        ],
        45: [
            0,
            .44444,
            .01946,
            0
        ],
        46: [
            0,
            .08333,
            0,
            0
        ],
        47: [
            .25,
            .75,
            .13164,
            0
        ],
        48: [
            0,
            .65556,
            .11156,
            0
        ],
        49: [
            0,
            .65556,
            .11156,
            0
        ],
        50: [
            0,
            .65556,
            .11156,
            0
        ],
        51: [
            0,
            .65556,
            .11156,
            0
        ],
        52: [
            0,
            .65556,
            .11156,
            0
        ],
        53: [
            0,
            .65556,
            .11156,
            0
        ],
        54: [
            0,
            .65556,
            .11156,
            0
        ],
        55: [
            0,
            .65556,
            .11156,
            0
        ],
        56: [
            0,
            .65556,
            .11156,
            0
        ],
        57: [
            0,
            .65556,
            .11156,
            0
        ],
        58: [
            0,
            .44444,
            .02502,
            0
        ],
        59: [
            .125,
            .44444,
            .02502,
            0
        ],
        61: [
            -0.13,
            .37,
            .05087,
            0
        ],
        63: [
            0,
            .69444,
            .11809,
            0
        ],
        64: [
            0,
            .69444,
            .07555,
            0
        ],
        65: H,
        66: [
            0,
            .69444,
            .08293,
            0
        ],
        67: [
            0,
            .69444,
            .11983,
            0
        ],
        68: [
            0,
            .69444,
            .07555,
            0
        ],
        69: [
            0,
            .69444,
            .11983,
            0
        ],
        70: [
            0,
            .69444,
            .13372,
            0
        ],
        71: [
            0,
            .69444,
            .11983,
            0
        ],
        72: [
            0,
            .69444,
            .08094,
            0
        ],
        73: [
            0,
            .69444,
            .13372,
            0
        ],
        74: [
            0,
            .69444,
            .08094,
            0
        ],
        75: [
            0,
            .69444,
            .11983,
            0
        ],
        76: H,
        77: [
            0,
            .69444,
            .08094,
            0
        ],
        78: [
            0,
            .69444,
            .08094,
            0
        ],
        79: [
            0,
            .69444,
            .07555,
            0
        ],
        80: [
            0,
            .69444,
            .08293,
            0
        ],
        81: [
            .125,
            .69444,
            .07555,
            0
        ],
        82: [
            0,
            .69444,
            .08293,
            0
        ],
        83: [
            0,
            .69444,
            .09205,
            0
        ],
        84: [
            0,
            .69444,
            .13372,
            0
        ],
        85: [
            0,
            .69444,
            .08094,
            0
        ],
        86: [
            0,
            .69444,
            .1615,
            0
        ],
        87: [
            0,
            .69444,
            .1615,
            0
        ],
        88: [
            0,
            .69444,
            .13372,
            0
        ],
        89: [
            0,
            .69444,
            .17261,
            0
        ],
        90: [
            0,
            .69444,
            .11983,
            0
        ],
        91: [
            .25,
            .75,
            .15942,
            0
        ],
        93: [
            .25,
            .75,
            .08719,
            0
        ],
        94: [
            0,
            .69444,
            .0799,
            0
        ],
        95: [
            .35,
            .09444,
            .08616,
            0
        ],
        97: [
            0,
            .44444,
            .00981,
            0
        ],
        98: [
            0,
            .69444,
            .03057,
            0
        ],
        99: [
            0,
            .44444,
            .08336,
            0
        ],
        100: [
            0,
            .69444,
            .09483,
            0
        ],
        101: [
            0,
            .44444,
            .06778,
            0
        ],
        102: [
            0,
            .69444,
            .21705,
            0
        ],
        103: [
            .19444,
            .44444,
            .10836,
            0
        ],
        104: [
            0,
            .69444,
            .01778,
            0
        ],
        105: [
            0,
            .67937,
            .09718,
            0
        ],
        106: [
            .19444,
            .67937,
            .09162,
            0
        ],
        107: [
            0,
            .69444,
            .08336,
            0
        ],
        108: [
            0,
            .69444,
            .09483,
            0
        ],
        109: [
            0,
            .44444,
            .01778,
            0
        ],
        110: [
            0,
            .44444,
            .01778,
            0
        ],
        111: [
            0,
            .44444,
            .06613,
            0
        ],
        112: [
            .19444,
            .44444,
            .0389,
            0
        ],
        113: [
            .19444,
            .44444,
            .04169,
            0
        ],
        114: [
            0,
            .44444,
            .10836,
            0
        ],
        115: [
            0,
            .44444,
            .0778,
            0
        ],
        116: [
            0,
            .57143,
            .07225,
            0
        ],
        117: [
            0,
            .44444,
            .04169,
            0
        ],
        118: [
            0,
            .44444,
            .10836,
            0
        ],
        119: [
            0,
            .44444,
            .10836,
            0
        ],
        120: [
            0,
            .44444,
            .09169,
            0
        ],
        121: [
            .19444,
            .44444,
            .10836,
            0
        ],
        122: [
            0,
            .44444,
            .08752,
            0
        ],
        126: [
            .35,
            .32659,
            .08826,
            0
        ],
        160: ee,
        168: [
            0,
            .67937,
            .06385,
            0
        ],
        176: H,
        184: [
            .17014,
            0,
            0,
            0
        ],
        305: [
            0,
            .44444,
            .04169,
            0
        ],
        567: [
            .19444,
            .44444,
            .04169,
            0
        ],
        710: [
            0,
            .69444,
            .0799,
            0
        ],
        711: [
            0,
            .63194,
            .08432,
            0
        ],
        713: [
            0,
            .60889,
            .08776,
            0
        ],
        714: [
            0,
            .69444,
            .09205,
            0
        ],
        715: H,
        728: [
            0,
            .69444,
            .09483,
            0
        ],
        729: [
            0,
            .67937,
            .07774,
            0
        ],
        730: H,
        732: [
            0,
            .67659,
            .08826,
            0
        ],
        733: [
            0,
            .69444,
            .09205,
            0
        ],
        915: [
            0,
            .69444,
            .13372,
            0
        ],
        916: H,
        920: [
            0,
            .69444,
            .07555,
            0
        ],
        923: H,
        926: [
            0,
            .69444,
            .12816,
            0
        ],
        928: [
            0,
            .69444,
            .08094,
            0
        ],
        931: [
            0,
            .69444,
            .11983,
            0
        ],
        933: [
            0,
            .69444,
            .09031,
            0
        ],
        934: [
            0,
            .69444,
            .04603,
            0
        ],
        936: [
            0,
            .69444,
            .09031,
            0
        ],
        937: [
            0,
            .69444,
            .08293,
            0
        ],
        8211: [
            0,
            .44444,
            .08616,
            0
        ],
        8212: [
            0,
            .44444,
            .08616,
            0
        ],
        8216: [
            0,
            .69444,
            .07816,
            0
        ],
        8217: [
            0,
            .69444,
            .07816,
            0
        ],
        8220: [
            0,
            .69444,
            .14205,
            0
        ],
        8221: [
            0,
            .69444,
            .00316,
            0
        ]
    },
    "SansSerif-Regular": {
        32: ee,
        33: H,
        34: H,
        35: J,
        36: [
            .05556,
            .75,
            0,
            0
        ],
        37: [
            .05556,
            .75,
            0,
            0
        ],
        38: H,
        39: H,
        40: G,
        41: G,
        42: ue,
        43: [
            .08333,
            .58333,
            0,
            0
        ],
        44: [
            .125,
            .08333,
            0,
            0
        ],
        45: Z,
        46: [
            0,
            .08333,
            0,
            0
        ],
        47: G,
        48: [
            0,
            .65556,
            0,
            0
        ],
        49: [
            0,
            .65556,
            0,
            0
        ],
        50: [
            0,
            .65556,
            0,
            0
        ],
        51: [
            0,
            .65556,
            0,
            0
        ],
        52: [
            0,
            .65556,
            0,
            0
        ],
        53: [
            0,
            .65556,
            0,
            0
        ],
        54: [
            0,
            .65556,
            0,
            0
        ],
        55: [
            0,
            .65556,
            0,
            0
        ],
        56: [
            0,
            .65556,
            0,
            0
        ],
        57: [
            0,
            .65556,
            0,
            0
        ],
        58: Z,
        59: [
            .125,
            .44444,
            0,
            0
        ],
        61: [
            -0.13,
            .37,
            0,
            0
        ],
        63: H,
        64: H,
        65: H,
        66: H,
        67: H,
        68: H,
        69: H,
        70: H,
        71: H,
        72: H,
        73: H,
        74: H,
        75: H,
        76: H,
        77: H,
        78: H,
        79: H,
        80: H,
        81: [
            .125,
            .69444,
            0,
            0
        ],
        82: H,
        83: H,
        84: H,
        85: H,
        86: [
            0,
            .69444,
            .01389,
            0
        ],
        87: [
            0,
            .69444,
            .01389,
            0
        ],
        88: H,
        89: [
            0,
            .69444,
            .025,
            0
        ],
        90: H,
        91: G,
        93: G,
        94: H,
        95: [
            .35,
            .09444,
            .02778,
            0
        ],
        97: Z,
        98: H,
        99: Z,
        100: H,
        101: Z,
        102: [
            0,
            .69444,
            .06944,
            0
        ],
        103: [
            .19444,
            .44444,
            .01389,
            0
        ],
        104: H,
        105: [
            0,
            .67937,
            0,
            0
        ],
        106: [
            .19444,
            .67937,
            0,
            0
        ],
        107: H,
        108: H,
        109: Z,
        110: Z,
        111: Z,
        112: ne,
        113: ne,
        114: [
            0,
            .44444,
            .01389,
            0
        ],
        115: Z,
        116: [
            0,
            .57143,
            0,
            0
        ],
        117: Z,
        118: [
            0,
            .44444,
            .01389,
            0
        ],
        119: [
            0,
            .44444,
            .01389,
            0
        ],
        120: Z,
        121: [
            .19444,
            .44444,
            .01389,
            0
        ],
        122: Z,
        126: [
            .35,
            .32659,
            0,
            0
        ],
        160: ee,
        168: [
            0,
            .67937,
            0,
            0
        ],
        176: H,
        184: [
            .17014,
            0,
            0,
            0
        ],
        305: Z,
        567: ne,
        710: H,
        711: [
            0,
            .63194,
            0,
            0
        ],
        713: [
            0,
            .60889,
            0,
            0
        ],
        714: H,
        715: H,
        728: H,
        729: [
            0,
            .67937,
            0,
            0
        ],
        730: H,
        732: [
            0,
            .67659,
            0,
            0
        ],
        733: H,
        915: H,
        916: H,
        920: H,
        923: H,
        926: H,
        928: H,
        931: H,
        933: H,
        934: H,
        936: H,
        937: H,
        8211: [
            0,
            .44444,
            .02778,
            0
        ],
        8212: [
            0,
            .44444,
            .02778,
            0
        ],
        8216: H,
        8217: H,
        8220: H,
        8221: H
    },
    "Script-Regular": {
        32: ee,
        65: [
            0,
            .7,
            .22925,
            0
        ],
        66: [
            0,
            .7,
            .04087,
            0
        ],
        67: [
            0,
            .7,
            .1689,
            0
        ],
        68: [
            0,
            .7,
            .09371,
            0
        ],
        69: [
            0,
            .7,
            .18583,
            0
        ],
        70: [
            0,
            .7,
            .13634,
            0
        ],
        71: [
            0,
            .7,
            .17322,
            0
        ],
        72: [
            0,
            .7,
            .29694,
            0
        ],
        73: [
            0,
            .7,
            .19189,
            0
        ],
        74: [
            .27778,
            .7,
            .19189,
            0
        ],
        75: [
            0,
            .7,
            .31259,
            0
        ],
        76: [
            0,
            .7,
            .19189,
            0
        ],
        77: [
            0,
            .7,
            .15981,
            0
        ],
        78: [
            0,
            .7,
            .3525,
            0
        ],
        79: [
            0,
            .7,
            .08078,
            0
        ],
        80: [
            0,
            .7,
            .08078,
            0
        ],
        81: [
            0,
            .7,
            .03305,
            0
        ],
        82: [
            0,
            .7,
            .06259,
            0
        ],
        83: [
            0,
            .7,
            .19189,
            0
        ],
        84: [
            0,
            .7,
            .29087,
            0
        ],
        85: [
            0,
            .7,
            .25815,
            0
        ],
        86: [
            0,
            .7,
            .27523,
            0
        ],
        87: [
            0,
            .7,
            .27523,
            0
        ],
        88: [
            0,
            .7,
            .26006,
            0
        ],
        89: [
            0,
            .7,
            .2939,
            0
        ],
        90: [
            0,
            .7,
            .24037,
            0
        ],
        160: ee
    },
    "Size1-Regular": {
        32: ee,
        40: ae,
        41: ae,
        47: ae,
        91: ae,
        92: ae,
        93: ae,
        123: ae,
        125: ae,
        160: ee,
        710: [
            0,
            .72222,
            0,
            0
        ],
        732: [
            0,
            .72222,
            0,
            0
        ],
        770: [
            0,
            .72222,
            0,
            0
        ],
        771: [
            0,
            .72222,
            0,
            0
        ],
        8214: [
            -0.00099,
            .601,
            0,
            0
        ],
        8593: [
            1e-5,
            .6,
            0,
            0
        ],
        8595: [
            1e-5,
            .6,
            0,
            0
        ],
        8657: [
            1e-5,
            .6,
            0,
            0
        ],
        8659: [
            1e-5,
            .6,
            0,
            0
        ],
        8719: de,
        8720: de,
        8721: de,
        8730: ae,
        8739: [
            -0.00599,
            .606,
            0,
            0
        ],
        8741: [
            -0.00599,
            .606,
            0,
            0
        ],
        8747: [
            .30612,
            .805,
            .19445,
            0
        ],
        8748: [
            .306,
            .805,
            .19445,
            0
        ],
        8749: [
            .306,
            .805,
            .19445,
            0
        ],
        8750: [
            .30612,
            .805,
            .19445,
            0
        ],
        8896: de,
        8897: de,
        8898: de,
        8899: de,
        8968: ae,
        8969: ae,
        8970: ae,
        8971: ae,
        9168: [
            -0.00099,
            .601,
            0,
            0
        ],
        10216: ae,
        10217: ae,
        10752: de,
        10753: de,
        10754: de,
        10756: de,
        10758: de
    },
    "Size2-Regular": {
        32: ee,
        40: re,
        41: re,
        47: re,
        91: re,
        92: re,
        93: re,
        123: re,
        125: re,
        160: ee,
        710: ue,
        732: ue,
        770: ue,
        771: ue,
        8719: he,
        8720: he,
        8721: he,
        8730: re,
        8747: [
            .86225,
            1.36,
            .44445,
            0
        ],
        8748: [
            .862,
            1.36,
            .44445,
            0
        ],
        8749: [
            .862,
            1.36,
            .44445,
            0
        ],
        8750: [
            .86225,
            1.36,
            .44445,
            0
        ],
        8896: he,
        8897: he,
        8898: he,
        8899: he,
        8968: re,
        8969: re,
        8970: re,
        8971: re,
        10216: re,
        10217: re,
        10752: he,
        10753: he,
        10754: he,
        10756: he,
        10758: he
    },
    "Size3-Regular": {
        32: ee,
        40: le,
        41: le,
        47: le,
        91: le,
        92: le,
        93: le,
        123: le,
        125: le,
        160: ee,
        710: ue,
        732: ue,
        770: ue,
        771: ue,
        8730: le,
        8968: le,
        8969: le,
        8970: le,
        8971: le,
        10216: le,
        10217: le
    },
    "Size4-Regular": {
        32: ee,
        40: se,
        41: se,
        47: se,
        91: se,
        92: se,
        93: se,
        123: se,
        125: se,
        160: ee,
        710: [
            0,
            .825,
            0,
            0
        ],
        732: [
            0,
            .825,
            0,
            0
        ],
        770: [
            0,
            .825,
            0,
            0
        ],
        771: [
            0,
            .825,
            0,
            0
        ],
        8730: se,
        8968: se,
        8969: se,
        8970: se,
        8971: se,
        9115: [
            .64502,
            1.155,
            0,
            0
        ],
        9116: [
            1e-5,
            .6,
            0,
            0
        ],
        9117: [
            .64502,
            1.155,
            0,
            0
        ],
        9118: [
            .64502,
            1.155,
            0,
            0
        ],
        9119: [
            1e-5,
            .6,
            0,
            0
        ],
        9120: [
            .64502,
            1.155,
            0,
            0
        ],
        9121: [
            .64502,
            1.155,
            0,
            0
        ],
        9122: [
            -0.00099,
            .601,
            0,
            0
        ],
        9123: [
            .64502,
            1.155,
            0,
            0
        ],
        9124: [
            .64502,
            1.155,
            0,
            0
        ],
        9125: [
            -0.00099,
            .601,
            0,
            0
        ],
        9126: [
            .64502,
            1.155,
            0,
            0
        ],
        9127: [
            1e-5,
            .9,
            0,
            0
        ],
        9128: re,
        9129: [
            .90001,
            0,
            0,
            0
        ],
        9130: [
            0,
            .3,
            0,
            0
        ],
        9131: [
            1e-5,
            .9,
            0,
            0
        ],
        9132: re,
        9133: [
            .90001,
            0,
            0,
            0
        ],
        9143: [
            .88502,
            .915,
            0,
            0
        ],
        10216: se,
        10217: se,
        57344: [
            -0.00499,
            .605,
            0,
            0
        ],
        57345: [
            -0.00499,
            .605,
            0,
            0
        ],
        57680: [
            0,
            .12,
            0,
            0
        ],
        57681: [
            0,
            .12,
            0,
            0
        ],
        57682: [
            0,
            .12,
            0,
            0
        ],
        57683: [
            0,
            .12,
            0,
            0
        ]
    },
    "Typewriter-Regular": {
        32: ee,
        33: U,
        34: U,
        35: U,
        36: [
            .08333,
            .69444,
            0,
            0
        ],
        37: [
            .08333,
            .69444,
            0,
            0
        ],
        38: U,
        39: U,
        40: [
            .08333,
            .69444,
            0,
            0
        ],
        41: [
            .08333,
            .69444,
            0,
            0
        ],
        42: [
            0,
            .52083,
            0,
            0
        ],
        43: [
            -0.08056,
            .53055,
            0,
            0
        ],
        44: [
            .13889,
            .125,
            0,
            0
        ],
        45: [
            -0.08056,
            .53055,
            0,
            0
        ],
        46: [
            0,
            .125,
            0,
            0
        ],
        47: [
            .08333,
            .69444,
            0,
            0
        ],
        48: U,
        49: U,
        50: U,
        51: U,
        52: U,
        53: U,
        54: U,
        55: U,
        56: U,
        57: U,
        58: [
            0,
            .43056,
            0,
            0
        ],
        59: [
            .13889,
            .43056,
            0,
            0
        ],
        60: [
            -0.05556,
            .55556,
            0,
            0
        ],
        61: [
            -0.19549,
            .41562,
            0,
            0
        ],
        62: [
            -0.05556,
            .55556,
            0,
            0
        ],
        63: U,
        64: U,
        65: U,
        66: U,
        67: U,
        68: U,
        69: U,
        70: U,
        71: U,
        72: U,
        73: U,
        74: U,
        75: U,
        76: U,
        77: U,
        78: U,
        79: U,
        80: U,
        81: [
            .13889,
            .61111,
            0,
            0
        ],
        82: U,
        83: U,
        84: U,
        85: U,
        86: U,
        87: U,
        88: U,
        89: U,
        90: U,
        91: [
            .08333,
            .69444,
            0,
            0
        ],
        92: [
            .08333,
            .69444,
            0,
            0
        ],
        93: [
            .08333,
            .69444,
            0,
            0
        ],
        94: U,
        95: [
            .09514,
            0,
            0,
            0
        ],
        96: U,
        97: [
            0,
            .43056,
            0,
            0
        ],
        98: U,
        99: [
            0,
            .43056,
            0,
            0
        ],
        100: U,
        101: [
            0,
            .43056,
            0,
            0
        ],
        102: U,
        103: [
            .22222,
            .43056,
            0,
            0
        ],
        104: U,
        105: U,
        106: [
            .22222,
            .61111,
            0,
            0
        ],
        107: U,
        108: U,
        109: [
            0,
            .43056,
            0,
            0
        ],
        110: [
            0,
            .43056,
            0,
            0
        ],
        111: [
            0,
            .43056,
            0,
            0
        ],
        112: [
            .22222,
            .43056,
            0,
            0
        ],
        113: [
            .22222,
            .43056,
            0,
            0
        ],
        114: [
            0,
            .43056,
            0,
            0
        ],
        115: [
            0,
            .43056,
            0,
            0
        ],
        116: [
            0,
            .55358,
            0,
            0
        ],
        117: [
            0,
            .43056,
            0,
            0
        ],
        118: [
            0,
            .43056,
            0,
            0
        ],
        119: [
            0,
            .43056,
            0,
            0
        ],
        120: [
            0,
            .43056,
            0,
            0
        ],
        121: [
            .22222,
            .43056,
            0,
            0
        ],
        122: [
            0,
            .43056,
            0,
            0
        ],
        123: [
            .08333,
            .69444,
            0,
            0
        ],
        124: [
            .08333,
            .69444,
            0,
            0
        ],
        125: [
            .08333,
            .69444,
            0,
            0
        ],
        126: U,
        127: U,
        160: ee,
        176: U,
        184: [
            .19445,
            0,
            0,
            0
        ],
        305: [
            0,
            .43056,
            0,
            0
        ],
        567: [
            .22222,
            .43056,
            0,
            0
        ],
        711: [
            0,
            .56597,
            0,
            0
        ],
        713: [
            0,
            .56555,
            0,
            0
        ],
        714: U,
        715: U,
        728: U,
        730: U,
        770: U,
        771: U,
        776: U,
        915: U,
        916: U,
        920: U,
        923: U,
        926: U,
        928: U,
        931: U,
        933: U,
        934: U,
        936: U,
        937: U,
        8216: U,
        8217: U,
        8242: U,
        9251: [
            .11111,
            .21944,
            0,
            0
        ]
    }
};
const ge = /[\u3040-\u309F]|[\u30A0-\u30FF]|[\u4E00-\u9FAF]|[\uAC00-\uD7AF]/, ye = {
    slant: [
        .25,
        .25,
        .25
    ],
    space: [
        0,
        0,
        0
    ],
    stretch: [
        0,
        0,
        0
    ],
    shrink: [
        0,
        0,
        0
    ],
    xHeight: [
        .431,
        .431,
        .431
    ],
    quad: [
        1,
        1.171,
        1.472
    ],
    extraSpace: [
        0,
        0,
        0
    ],
    num1: [
        .677,
        .732,
        .925
    ],
    num2: [
        .394,
        .384,
        .387
    ],
    num3: [
        .444,
        .471,
        .504
    ],
    denom1: [
        .686,
        .752,
        1.025
    ],
    denom2: [
        .345,
        .344,
        .532
    ],
    sup1: [
        .413,
        .503,
        .504
    ],
    sup2: [
        .363,
        .431,
        .404
    ],
    sup3: [
        .289,
        .286,
        .294
    ],
    sub1: [
        .15,
        .143,
        .2
    ],
    sub2: [
        .247,
        .286,
        .4
    ],
    supDrop: [
        .386,
        .353,
        .494
    ],
    subDrop: [
        .05,
        .071,
        .1
    ],
    delim1: [
        2.39,
        1.7,
        1.98
    ],
    delim2: [
        1.01,
        1.157,
        1.42
    ],
    axisHeight: [
        .25,
        .25,
        .25
    ],
    defaultRuleThickness: [
        .04,
        .049,
        .049
    ],
    bigOpSpacing1: [
        .111,
        .111,
        .111
    ],
    bigOpSpacing2: [
        .166,
        .166,
        .166
    ],
    bigOpSpacing3: [
        .2,
        .2,
        .2
    ],
    bigOpSpacing4: [
        .6,
        .611,
        .611
    ],
    bigOpSpacing5: [
        .1,
        .143,
        .143
    ],
    sqrtRuleThickness: [
        .04,
        .04,
        .04
    ]
}, be = [
    0,
    .5,
    .7,
    .8,
    .9,
    1,
    1.2,
    1.44,
    1.728,
    2.074,
    2.488
], ve = {
    "\xa0": " ",
    "​": " ",
    Å: "A",
    Ç: "C",
    Ð: "D",
    Þ: "o",
    å: "a",
    ç: "c",
    ð: "d",
    þ: "o",
    А: "A",
    Б: "B",
    В: "B",
    Г: "F",
    Д: "A",
    Е: "E",
    Ж: "K",
    З: "3",
    И: "N",
    Й: "N",
    К: "K",
    Л: "N",
    М: "M",
    Н: "H",
    О: "O",
    П: "N",
    Р: "P",
    С: "C",
    Т: "T",
    У: "y",
    Ф: "O",
    Х: "X",
    Ц: "U",
    Ч: "h",
    Ш: "W",
    Щ: "W",
    Ъ: "B",
    Ы: "X",
    Ь: "B",
    Э: "3",
    Ю: "X",
    Я: "R",
    а: "a",
    б: "b",
    в: "a",
    г: "r",
    д: "y",
    е: "e",
    ж: "m",
    з: "e",
    и: "n",
    й: "n",
    к: "n",
    л: "n",
    м: "m",
    н: "n",
    о: "o",
    п: "n",
    р: "p",
    с: "c",
    т: "o",
    у: "y",
    ф: "b",
    х: "x",
    ц: "n",
    ч: "n",
    ш: "w",
    щ: "w",
    ъ: "a",
    ы: "m",
    ь: "a",
    э: "e",
    ю: "m",
    я: "r"
};
function xe(e1, t) {
    void 0 === e1 && (e1 = 77);
    const i = fe[t][e1];
    if (i) return {
        defaultMetrics: !1,
        depth: i[0],
        height: i[1],
        italic: i[2],
        skew: i[3]
    };
    if (11034 === e1) return {
        defaultMetrics: !0,
        depth: .2,
        height: .8,
        italic: 0,
        skew: 0
    };
    const n = String.fromCodePoint(e1);
    if (n in ve) e1 = ve[n].codePointAt(0);
    else if (ge.test(n)) return e1 = 77, {
        defaultMetrics: !0,
        depth: .2,
        height: .9,
        italic: 0,
        skew: 0
    };
    return {
        defaultMetrics: !0,
        depth: .2,
        height: .7,
        italic: 0,
        skew: 0
    };
}
class ke {
    getFontSize(e1) {
        return Math.max(1, e1 + this.sizeDelta);
    }
    get sup() {
        return _e[[
            0,
            1,
            0,
            1,
            2,
            3,
            2,
            3
        ][this.id]];
    }
    get sub() {
        return _e[[
            0,
            0,
            0,
            0,
            2,
            2,
            2,
            2
        ][this.id]];
    }
    get fracNum() {
        return _e[[
            0,
            1,
            0,
            1,
            2,
            3,
            4,
            5
        ][this.id]];
    }
    get fracDen() {
        return _e[[
            0,
            0,
            0,
            0,
            2,
            2,
            4,
            4
        ][this.id]];
    }
    get cramp() {
        return _e[[
            0,
            0,
            2,
            2,
            4,
            4,
            6,
            6
        ][this.id]];
    }
    get isTight() {
        return this.sizeDelta < 0;
    }
    constructor(e1, t, i){
        this.id = e1, this.sizeDelta = t, this.cramped = i;
        const n = {
            "-4": 2,
            "-3": 1,
            0: 0
        }[t];
        this.metrics = Object.keys(ye).reduce((e1, t)=>({
                ...e1,
                [t]: ye[t][n]
            }), {});
    }
}
const _e = {
    7: new ke(7, 0, !1),
    6: new ke(6, 0, !0),
    5: new ke(5, 0, !1),
    4: new ke(4, 0, !0),
    3: new ke(3, -3, !1),
    2: new ke(2, -3, !0),
    1: new ke(1, -4, !1),
    0: new ke(0, -4, !0)
};
function we(e1, t) {
    return null === e1 ? 0 : function(e1, t) {
        var i;
        if (!e1) return 0;
        const n = {
            pt: 1,
            mm: 7227 / 2540,
            cm: 7227 / 254,
            ex: 35271 / 8192,
            px: 3 / 4,
            em: 10,
            bp: 1.00375,
            dd: 1238 / 1157,
            pc: 12,
            in: 72.27,
            mu: 10 / 18
        }[null !== (i = e1.unit) && void 0 !== i ? i : "pt"];
        if (Number.isFinite(t)) {
            const i1 = 10 ** t;
            return Math.round(e1.dimension / 10 * n * i1) / i1;
        }
        return e1.dimension * n;
    }(e1, t) / 10;
}
function Se(e1) {
    var t;
    return `${e1.dimension}${null !== (t = e1.unit) && void 0 !== t ? t : "pt"}`;
}
_e.displaystyle = _e[7], _e.textstyle = _e[5], _e.scriptstyle = _e[3], _e.scriptscriptstyle = _e[1];
class Me {
    get mathstyle() {
        let e1 = this._mathstyle, t = this.parent;
        for(; !e1;)e1 = t._mathstyle, t = t.parent;
        return e1;
    }
    getRegister(e1) {
        var t;
        return (null === (t = this.registers) || void 0 === t ? void 0 : t[e1]) ? this.registers[e1] : this.parent ? this.parent.getRegister(e1) : void 0;
    }
    getRegisterAsGlue(e1) {
        var t;
        if (null === (t = this.registers) || void 0 === t ? void 0 : t[e1]) {
            const t1 = this.registers[e1];
            return "object" == typeof t1 && "glue" in t1 ? t1 : "object" == typeof t1 && "dimension" in t1 ? {
                glue: {
                    dimension: t1.dimension
                }
            } : "number" == typeof t1 ? {
                glue: {
                    dimension: t1
                }
            } : void 0;
        }
        if (this.parent) return this.parent.getRegisterAsGlue(e1);
    }
    getRegisterAsEm(e1) {
        return we(this.getRegisterAsDimension(e1));
    }
    getRegisterAsDimension(e1) {
        var t;
        if (null === (t = this.registers) || void 0 === t ? void 0 : t[e1]) {
            const t1 = this.registers[e1];
            return "object" == typeof t1 && "glue" in t1 ? t1.glue : "object" == typeof t1 && "dimension" in t1 ? t1 : "number" == typeof t1 ? {
                dimension: t1
            } : void 0;
        }
        if (this.parent) return this.parent.getRegisterAsDimension(e1);
    }
    setRegister(e1, t) {
        void 0 !== t ? this.registers[e1] = t : delete this.registers[e1];
    }
    setGlobalRegister(e1, t) {
        let i = this;
        for(; i.parent;)i.setRegister(e1, void 0), i = i.parent;
        i.setRegister(e1, t);
    }
    get size() {
        let e1 = this._size, t = this.parent;
        for(; !e1;)e1 = t._size, t = t.parent;
        return e1;
    }
    makeID() {
        if (!this.atomIdsSettings) return;
        if (this.atomIdsSettings.overrideID) return this.atomIdsSettings.overrideID;
        if ("number" != typeof this.atomIdsSettings.seed) return Date.now().toString(36).slice(-2) + Math.floor(1e5 * Math.random()).toString(36);
        const e1 = this.atomIdsSettings.seed.toString(36);
        return this.atomIdsSettings.seed += 1, e1;
    }
    scale(e1) {
        return e1 * this.effectiveFontSize;
    }
    get scalingFactor() {
        return this.parent ? this.effectiveFontSize / this.parent.effectiveFontSize : 1;
    }
    get isDisplayStyle() {
        return 7 === this.mathstyle.id || 6 === this.mathstyle.id;
    }
    get isCramped() {
        return this.mathstyle.cramped;
    }
    get isTight() {
        return this.mathstyle.isTight;
    }
    get effectiveFontSize() {
        return be[Math.max(1, this.size + this.mathstyle.sizeDelta)];
    }
    get computedColor() {
        let e1 = this.color, t = this.parent;
        return !e1 && t && (e1 = t.color, t = t.parent), null != e1 ? e1 : "";
    }
    get computedBackgroundColor() {
        let e1 = this.backgroundColor, t = this.parent;
        return !e1 && t && (e1 = t.backgroundColor, t = t.parent), null != e1 ? e1 : "";
    }
    get metrics() {
        return this.mathstyle.metrics;
    }
    constructor(e1, t, i){
        var n, r, o, a, s, l;
        e1 instanceof Me && (this.parent = e1), e1 instanceof Me || (this.registers = null !== (n = e1.registers) && void 0 !== n ? n : {}), this.isPhantom = null !== (a = null !== (r = null == t ? void 0 : t.isPhantom) && void 0 !== r ? r : null === (o = this.parent) || void 0 === o ? void 0 : o.isPhantom) && void 0 !== a && a;
        const u = {
            ...e1
        };
        let c;
        if (t && (t.letterShapeStyle && "auto" !== t.letterShapeStyle && (u.letterShapeStyle = t.letterShapeStyle), t.color && "none" !== t.color && (u.color = t.color), t.backgroundColor && "none" !== t.backgroundColor && (u.backgroundColor = t.backgroundColor), t.fontSize && "auto" !== t.fontSize && t.fontSize !== (null === (s = this.parent) || void 0 === s ? void 0 : s._size) && (this._size = t.fontSize)), this.letterShapeStyle = null !== (l = u.letterShapeStyle) && void 0 !== l ? l : "tex", this.color = u.color, this.backgroundColor = u.backgroundColor, "string" == typeof i) {
            if (e1 instanceof Me) switch(i){
                case "cramp":
                    c = e1.mathstyle.cramp;
                    break;
                case "superscript":
                    c = e1.mathstyle.sup;
                    break;
                case "subscript":
                    c = e1.mathstyle.sub;
                    break;
                case "numerator":
                    c = e1.mathstyle.fracNum;
                    break;
                case "denominator":
                    c = e1.mathstyle.fracDen;
            }
            switch(i){
                case "textstyle":
                    c = _e.textstyle;
                    break;
                case "displaystyle":
                    c = _e.displaystyle;
                    break;
                case "scriptstyle":
                    c = _e.scriptstyle;
                    break;
                case "scriptscriptstyle":
                    c = _e.scriptscriptstyle;
            }
        }
        this._mathstyle = c, this.atomIdsSettings = e1.atomIdsSettings, this.renderPlaceholder = u.renderPlaceholder;
    }
}
const Ne = {
    overrightarrow: [
        [
            "rightarrow"
        ],
        .888,
        522,
        "xMaxYMin"
    ],
    overleftarrow: [
        [
            "leftarrow"
        ],
        .888,
        522,
        "xMinYMin"
    ],
    underrightarrow: [
        [
            "rightarrow"
        ],
        .888,
        522,
        "xMaxYMin"
    ],
    underleftarrow: [
        [
            "leftarrow"
        ],
        .888,
        522,
        "xMinYMin"
    ],
    xrightarrow: [
        [
            "rightarrow"
        ],
        1.469,
        522,
        "xMaxYMin"
    ],
    xleftarrow: [
        [
            "leftarrow"
        ],
        1.469,
        522,
        "xMinYMin"
    ],
    Overrightarrow: [
        [
            "doublerightarrow"
        ],
        .888,
        560,
        "xMaxYMin"
    ],
    xRightarrow: [
        [
            "doublerightarrow"
        ],
        1.526,
        560,
        "xMaxYMin"
    ],
    xLeftarrow: [
        [
            "doubleleftarrow"
        ],
        1.526,
        560,
        "xMinYMin"
    ],
    overleftharpoon: [
        [
            "leftharpoon"
        ],
        .888,
        522,
        "xMinYMin"
    ],
    xleftharpoonup: [
        [
            "leftharpoon"
        ],
        .888,
        522,
        "xMinYMin"
    ],
    xleftharpoondown: [
        [
            "leftharpoondown"
        ],
        .888,
        522,
        "xMinYMin"
    ],
    overrightharpoon: [
        [
            "rightharpoon"
        ],
        .888,
        522,
        "xMaxYMin"
    ],
    xrightharpoonup: [
        [
            "rightharpoon"
        ],
        .888,
        522,
        "xMaxYMin"
    ],
    xrightharpoondown: [
        [
            "rightharpoondown"
        ],
        .888,
        522,
        "xMaxYMin"
    ],
    xlongequal: [
        [
            "longequal"
        ],
        .888,
        334,
        "xMinYMin"
    ],
    xtwoheadleftarrow: [
        [
            "twoheadleftarrow"
        ],
        .888,
        334,
        "xMinYMin"
    ],
    xtwoheadrightarrow: [
        [
            "twoheadrightarrow"
        ],
        .888,
        334,
        "xMaxYMin"
    ],
    overleftrightarrow: [
        [
            "leftarrow",
            "rightarrow"
        ],
        .888,
        522
    ],
    overbrace: [
        [
            "leftbrace",
            "midbrace",
            "rightbrace"
        ],
        1.6,
        548
    ],
    underbrace: [
        [
            "leftbraceunder",
            "midbraceunder",
            "rightbraceunder"
        ],
        1.6,
        548
    ],
    underleftrightarrow: [
        [
            "leftarrow",
            "rightarrow"
        ],
        .888,
        522
    ],
    xleftrightarrow: [
        [
            "leftarrow",
            "rightarrow"
        ],
        1.75,
        522
    ],
    xLeftrightarrow: [
        [
            "doubleleftarrow",
            "doublerightarrow"
        ],
        1.75,
        560
    ],
    xrightleftharpoons: [
        [
            "leftharpoondownplus",
            "rightharpoonplus"
        ],
        1.75,
        716
    ],
    xleftrightharpoons: [
        [
            "leftharpoonplus",
            "rightharpoondownplus"
        ],
        1.75,
        716
    ],
    xhookleftarrow: [
        [
            "leftarrow",
            "righthook"
        ],
        1.08,
        522
    ],
    xhookrightarrow: [
        [
            "lefthook",
            "rightarrow"
        ],
        1.08,
        522
    ],
    overlinesegment: [
        [
            "leftlinesegment",
            "rightlinesegment"
        ],
        .888,
        522
    ],
    underlinesegment: [
        [
            "leftlinesegment",
            "rightlinesegment"
        ],
        .888,
        522
    ],
    overgroup: [
        [
            "leftgroup",
            "rightgroup"
        ],
        .888,
        342
    ],
    undergroup: [
        [
            "leftgroupunder",
            "rightgroupunder"
        ],
        .888,
        342
    ],
    xmapsto: [
        [
            "leftmapsto",
            "rightarrow"
        ],
        1.5,
        522
    ],
    xtofrom: [
        [
            "leftToFrom",
            "rightToFrom"
        ],
        1.75,
        528
    ],
    xrightleftarrows: [
        [
            "baraboveleftarrow",
            "rightarrowabovebar"
        ],
        1.75,
        901
    ],
    xrightequilibrium: [
        [
            "baraboveshortleftharpoon",
            "rightharpoonaboveshortbar"
        ],
        1.75,
        716
    ],
    xleftequilibrium: [
        [
            "shortbaraboveleftharpoon",
            "shortrightharpoonabovebar"
        ],
        1.75,
        716
    ]
}, Le = {
    widehat1: [
        1062,
        239,
        .24
    ],
    widehat2: [
        2364,
        300,
        .3
    ],
    widehat3: [
        2364,
        360,
        .36
    ],
    widehat4: [
        2364,
        420,
        .42
    ],
    widecheck1: [
        1062,
        239,
        .24
    ],
    widecheck2: [
        2364,
        300,
        .3
    ],
    widecheck3: [
        2364,
        360,
        .36
    ],
    widecheck4: [
        2364,
        420,
        .42
    ],
    widetilde1: [
        600,
        260,
        .26
    ],
    widetilde2: [
        1033,
        286,
        .286
    ],
    widetilde3: [
        2339,
        306,
        .306
    ],
    widetilde4: [
        2340,
        312,
        .34
    ],
    overarc: [
        1061,
        159,
        .3
    ],
    underarc: [
        1061,
        159,
        .3
    ]
}, Ae = {
    doubleleftarrow: "M262 157\nl10-10c34-36 62.7-77 86-123 3.3-8 5-13.3 5-16 0-5.3-6.7-8-20-8-7.3\n 0-12.2.5-14.5 1.5-2.3 1-4.8 4.5-7.5 10.5-49.3 97.3-121.7 169.3-217 216-28\n 14-57.3 25-88 33-6.7 2-11 3.8-13 5.5-2 1.7-3 4.2-3 7.5s1 5.8 3 7.5\nc2 1.7 6.3 3.5 13 5.5 68 17.3 128.2 47.8 180.5 91.5 52.3 43.7 93.8 96.2 124.5\n 157.5 9.3 8 15.3 12.3 18 13h6c12-.7 18-4 18-10 0-2-1.7-7-5-15-23.3-46-52-87\n-86-123l-10-10h399738v-40H218c328 0 0 0 0 0l-10-8c-26.7-20-65.7-43-117-69 2.7\n-2 6-3.7 10-5 36.7-16 72.3-37.3 107-64l10-8h399782v-40z\nm8 0v40h399730v-40zm0 194v40h399730v-40z",
    doublerightarrow: "M399738 392l\n-10 10c-34 36-62.7 77-86 123-3.3 8-5 13.3-5 16 0 5.3 6.7 8 20 8 7.3 0 12.2-.5\n 14.5-1.5 2.3-1 4.8-4.5 7.5-10.5 49.3-97.3 121.7-169.3 217-216 28-14 57.3-25 88\n-33 6.7-2 11-3.8 13-5.5 2-1.7 3-4.2 3-7.5s-1-5.8-3-7.5c-2-1.7-6.3-3.5-13-5.5-68\n-17.3-128.2-47.8-180.5-91.5-52.3-43.7-93.8-96.2-124.5-157.5-9.3-8-15.3-12.3-18\n-13h-6c-12 .7-18 4-18 10 0 2 1.7 7 5 15 23.3 46 52 87 86 123l10 10H0v40h399782\nc-328 0 0 0 0 0l10 8c26.7 20 65.7 43 117 69-2.7 2-6 3.7-10 5-36.7 16-72.3 37.3\n-107 64l-10 8H0v40zM0 157v40h399730v-40zm0 194v40h399730v-40z",
    leftarrow: "M400000 241H110l3-3c68.7-52.7 113.7-120\n 135-202 4-14.7 6-23 6-25 0-7.3-7-11-21-11-8 0-13.2.8-15.5 2.5-2.3 1.7-4.2 5.8\n-5.5 12.5-1.3 4.7-2.7 10.3-4 17-12 48.7-34.8 92-68.5 130S65.3 228.3 18 247\nc-10 4-16 7.7-18 11 0 8.7 6 14.3 18 17 47.3 18.7 87.8 47 121.5 85S196 441.3 208\n 490c.7 2 1.3 5 2 9s1.2 6.7 1.5 8c.3 1.3 1 3.3 2 6s2.2 4.5 3.5 5.5c1.3 1 3.3\n 1.8 6 2.5s6 1 10 1c14 0 21-3.7 21-11 0-2-2-10.3-6-25-20-79.3-65-146.7-135-202\n l-3-3h399890zM100 241v40h399900v-40z",
    leftbrace: "M6 548l-6-6v-35l6-11c56-104 135.3-181.3 238-232 57.3-28.7 117\n-45 179-50h399577v120H403c-43.3 7-81 15-113 26-100.7 33-179.7 91-237 174-2.7\n 5-6 9-10 13-.7 1-7.3 1-20 1H6z",
    leftbraceunder: "M0 6l6-6h17c12.688 0 19.313.3 20 1 4 4 7.313 8.3 10 13\n 35.313 51.3 80.813 93.8 136.5 127.5 55.688 33.7 117.188 55.8 184.5 66.5.688\n 0 2 .3 4 1 18.688 2.7 76 4.3 172 5h399450v120H429l-6-1c-124.688-8-235-61.7\n-331-161C60.687 138.7 32.312 99.3 7 54L0 41V6z",
    overarc: "M529 0c179 0 524 115 524 115 5 1 9 5 9 10 0 1-1 2-1 3l-4 22c-1 5-5 9-11 9h-2s-338-93-512-92c-174 0-513 92-513 92h-2c-5 0-9-4-11-9l-5-22c-1-6 2-12 8-13 0 0 342-115 520-115z",
    underarc: "m 529 160\n  c -179 0 -524 -115 -524 -115\n  c -5 -1 -9 -5 -9 -10\n  c 0 -1 1 -2 1 -3\n  l 4 -22\n  c 1 -5 5 -9 11 -9\n  h 2\n  s 338 93 512 92\n  c 174 0 513 -92 513 -92\n  h 2\n  c 5 0 9 4 11 9\n  l 5 22\n  c 1 6 -2 12 -8 13\n  c 0 0 -342 115 -520 115\n  z\n  ",
    leftgroup: "M400000 80\nH435C64 80 168.3 229.4 21 260c-5.9 1.2-18 0-18 0-2 0-3-1-3-3v-38C76 61 257 0\n 435 0h399565z",
    leftgroupunder: "M400000 262\nH435C64 262 168.3 112.6 21 82c-5.9-1.2-18 0-18 0-2 0-3 1-3 3v38c76 158 257 219\n 435 219h399565z",
    leftharpoon: "M0 267c.7 5.3 3 10 7 14h399993v-40H93c3.3\n-3.3 10.2-9.5 20.5-18.5s17.8-15.8 22.5-20.5c50.7-52 88-110.3 112-175 4-11.3 5\n-18.3 3-21-1.3-4-7.3-6-18-6-8 0-13 .7-15 2s-4.7 6.7-8 16c-42 98.7-107.3 174.7\n-196 228-6.7 4.7-10.7 8-12 10-1.3 2-2 5.7-2 11zm100-26v40h399900v-40z",
    leftharpoonplus: "M0 267c.7 5.3 3 10 7 14h399993v-40H93c3.3-3.3 10.2-9.5\n 20.5-18.5s17.8-15.8 22.5-20.5c50.7-52 88-110.3 112-175 4-11.3 5-18.3 3-21-1.3\n-4-7.3-6-18-6-8 0-13 .7-15 2s-4.7 6.7-8 16c-42 98.7-107.3 174.7-196 228-6.7 4.7\n-10.7 8-12 10-1.3 2-2 5.7-2 11zm100-26v40h399900v-40zM0 435v40h400000v-40z\nm0 0v40h400000v-40z",
    leftharpoondown: "M7 241c-4 4-6.333 8.667-7 14 0 5.333.667 9 2 11s5.333\n 5.333 12 10c90.667 54 156 130 196 228 3.333 10.667 6.333 16.333 9 17 2 .667 5\n 1 9 1h5c10.667 0 16.667-2 18-6 2-2.667 1-9.667-3-21-32-87.333-82.667-157.667\n-152-211l-3-3h399907v-40zM93 281 H400000 v-40L7 241z",
    leftharpoondownplus: "M7 435c-4 4-6.3 8.7-7 14 0 5.3.7 9 2 11s5.3 5.3 12\n 10c90.7 54 156 130 196 228 3.3 10.7 6.3 16.3 9 17 2 .7 5 1 9 1h5c10.7 0 16.7\n-2 18-6 2-2.7 1-9.7-3-21-32-87.3-82.7-157.7-152-211l-3-3h399907v-40H7zm93 0\nv40h399900v-40zM0 241v40h399900v-40zm0 0v40h399900v-40z",
    lefthook: "M400000 281 H103s-33-11.2-61-33.5S0 197.3 0 164s14.2-61.2 42.5\n-83.5C70.8 58.2 104 47 142 47 c16.7 0 25 6.7 25 20 0 12-8.7 18.7-26 20-40 3.3\n-68.7 15.7-86 37-10 12-15 25.3-15 40 0 22.7 9.8 40.7 29.5 54 19.7 13.3 43.5 21\n 71.5 23h399859zM103 281v-40h399897v40z",
    leftlinesegment: "M40 281 V428 H0 V94 H40 V241 H400000 v40z\nM40 281 V428 H0 V94 H40 V241 H400000 v40z",
    leftmapsto: "M40 281 V448H0V74H40V241H400000v40z\nM40 281 V448H0V74H40V241H400000v40z",
    leftToFrom: "M0 147h400000v40H0zm0 214c68 40 115.7 95.7 143 167h22c15.3 0 23\n-.3 23-1 0-1.3-5.3-13.7-16-37-18-35.3-41.3-69-70-101l-7-8h399905v-40H95l7-8\nc28.7-32 52-65.7 70-101 10.7-23.3 16-35.7 16-37 0-.7-7.7-1-23-1h-22C115.7 265.3\n 68 321 0 361zm0-174v-40h399900v40zm100 154v40h399900v-40z",
    longequal: "M0 50 h400000 v40H0z m0 194h40000v40H0z\nM0 50 h400000 v40H0z m0 194h40000v40H0z",
    midbrace: "M200428 334\nc-100.7-8.3-195.3-44-280-108-55.3-42-101.7-93-139-153l-9-14c-2.7 4-5.7 8.7-9 14\n-53.3 86.7-123.7 153-211 199-66.7 36-137.3 56.3-212 62H0V214h199568c178.3-11.7\n 311.7-78.3 403-201 6-8 9.7-12 11-12 .7-.7 6.7-1 18-1s17.3.3 18 1c1.3 0 5 4 11\n 12 44.7 59.3 101.3 106.3 170 141s145.3 54.3 229 60h199572v120z",
    midbraceunder: "M199572 214\nc100.7 8.3 195.3 44 280 108 55.3 42 101.7 93 139 153l9 14c2.7-4 5.7-8.7 9-14\n 53.3-86.7 123.7-153 211-199 66.7-36 137.3-56.3 212-62h199568v120H200432c-178.3\n 11.7-311.7 78.3-403 201-6 8-9.7 12-11 12-.7.7-6.7 1-18 1s-17.3-.3-18-1c-1.3 0\n-5-4-11-12-44.7-59.3-101.3-106.3-170-141s-145.3-54.3-229-60H0V214z",
    oiintSize1: "M512.6 71.6c272.6 0 320.3 106.8 320.3 178.2 0 70.8-47.7 177.6\n-320.3 177.6S193.1 320.6 193.1 249.8c0-71.4 46.9-178.2 319.5-178.2z\nm368.1 178.2c0-86.4-60.9-215.4-368.1-215.4-306.4 0-367.3 129-367.3 215.4 0 85.8\n60.9 214.8 367.3 214.8 307.2 0 368.1-129 368.1-214.8z",
    oiintSize2: "M757.8 100.1c384.7 0 451.1 137.6 451.1 230 0 91.3-66.4 228.8\n-451.1 228.8-386.3 0-452.7-137.5-452.7-228.8 0-92.4 66.4-230 452.7-230z\nm502.4 230c0-111.2-82.4-277.2-502.4-277.2s-504 166-504 277.2\nc0 110 84 276 504 276s502.4-166 502.4-276z",
    oiiintSize1: "M681.4 71.6c408.9 0 480.5 106.8 480.5 178.2 0 70.8-71.6 177.6\n-480.5 177.6S202.1 320.6 202.1 249.8c0-71.4 70.5-178.2 479.3-178.2z\nm525.8 178.2c0-86.4-86.8-215.4-525.7-215.4-437.9 0-524.7 129-524.7 215.4 0\n85.8 86.8 214.8 524.7 214.8 438.9 0 525.7-129 525.7-214.8z",
    oiiintSize2: "M1021.2 53c603.6 0 707.8 165.8 707.8 277.2 0 110-104.2 275.8\n-707.8 275.8-606 0-710.2-165.8-710.2-275.8C311 218.8 415.2 53 1021.2 53z\nm770.4 277.1c0-131.2-126.4-327.6-770.5-327.6S248.4 198.9 248.4 330.1\nc0 130 128.8 326.4 772.7 326.4s770.5-196.4 770.5-326.4z",
    rightarrow: "M0 241v40h399891c-47.3 35.3-84 78-110 128\n-16.7 32-27.7 63.7-33 95 0 1.3-.2 2.7-.5 4-.3 1.3-.5 2.3-.5 3 0 7.3 6.7 11 20\n 11 8 0 13.2-.8 15.5-2.5 2.3-1.7 4.2-5.5 5.5-11.5 2-13.3 5.7-27 11-41 14.7-44.7\n 39-84.5 73-119.5s73.7-60.2 119-75.5c6-2 9-5.7 9-11s-3-9-9-11c-45.3-15.3-85\n-40.5-119-75.5s-58.3-74.8-73-119.5c-4.7-14-8.3-27.3-11-40-1.3-6.7-3.2-10.8-5.5\n-12.5-2.3-1.7-7.5-2.5-15.5-2.5-14 0-21 3.7-21 11 0 2 2 10.3 6 25 20.7 83.3 67\n 151.7 139 205zm0 0v40h399900v-40z",
    rightbrace: "M400000 542l\n-6 6h-17c-12.7 0-19.3-.3-20-1-4-4-7.3-8.3-10-13-35.3-51.3-80.8-93.8-136.5-127.5\ns-117.2-55.8-184.5-66.5c-.7 0-2-.3-4-1-18.7-2.7-76-4.3-172-5H0V214h399571l6 1\nc124.7 8 235 61.7 331 161 31.3 33.3 59.7 72.7 85 118l7 13v35z",
    rightbraceunder: "M399994 0l6 6v35l-6 11c-56 104-135.3 181.3-238 232-57.3\n 28.7-117 45-179 50H-300V214h399897c43.3-7 81-15 113-26 100.7-33 179.7-91 237\n-174 2.7-5 6-9 10-13 .7-1 7.3-1 20-1h17z",
    rightgroup: "M0 80h399565c371 0 266.7 149.4 414 180 5.9 1.2 18 0 18 0 2 0\n 3-1 3-3v-38c-76-158-257-219-435-219H0z",
    rightgroupunder: "M0 262h399565c371 0 266.7-149.4 414-180 5.9-1.2 18 0 18\n 0 2 0 3 1 3 3v38c-76 158-257 219-435 219H0z",
    rightharpoon: "M0 241v40h399993c4.7-4.7 7-9.3 7-14 0-9.3\n-3.7-15.3-11-18-92.7-56.7-159-133.7-199-231-3.3-9.3-6-14.7-8-16-2-1.3-7-2-15-2\n-10.7 0-16.7 2-18 6-2 2.7-1 9.7 3 21 15.3 42 36.7 81.8 64 119.5 27.3 37.7 58\n 69.2 92 94.5zm0 0v40h399900v-40z",
    rightharpoonplus: "M0 241v40h399993c4.7-4.7 7-9.3 7-14 0-9.3-3.7-15.3-11\n-18-92.7-56.7-159-133.7-199-231-3.3-9.3-6-14.7-8-16-2-1.3-7-2-15-2-10.7 0-16.7\n 2-18 6-2 2.7-1 9.7 3 21 15.3 42 36.7 81.8 64 119.5 27.3 37.7 58 69.2 92 94.5z\nm0 0v40h399900v-40z m100 194v40h399900v-40zm0 0v40h399900v-40z",
    rightharpoondown: "M399747 511c0 7.3 6.7 11 20 11 8 0 13-.8 15-2.5s4.7-6.8\n 8-15.5c40-94 99.3-166.3 178-217 13.3-8 20.3-12.3 21-13 5.3-3.3 8.5-5.8 9.5\n-7.5 1-1.7 1.5-5.2 1.5-10.5s-2.3-10.3-7-15H0v40h399908c-34 25.3-64.7 57-92 95\n-27.3 38-48.7 77.7-64 119-3.3 8.7-5 14-5 16zM0 241v40h399900v-40z",
    rightharpoondownplus: "M399747 705c0 7.3 6.7 11 20 11 8 0 13-.8\n 15-2.5s4.7-6.8 8-15.5c40-94 99.3-166.3 178-217 13.3-8 20.3-12.3 21-13 5.3-3.3\n 8.5-5.8 9.5-7.5 1-1.7 1.5-5.2 1.5-10.5s-2.3-10.3-7-15H0v40h399908c-34 25.3\n-64.7 57-92 95-27.3 38-48.7 77.7-64 119-3.3 8.7-5 14-5 16zM0 435v40h399900v-40z\nm0-194v40h400000v-40zm0 0v40h400000v-40z",
    righthook: "M399859 241c-764 0 0 0 0 0 40-3.3 68.7-15.7 86-37 10-12 15-25.3\n 15-40 0-22.7-9.8-40.7-29.5-54-19.7-13.3-43.5-21-71.5-23-17.3-1.3-26-8-26-20 0\n-13.3 8.7-20 26-20 38 0 71 11.2 99 33.5 0 0 7 5.6 21 16.7 14 11.2 21 33.5 21\n 66.8s-14 61.2-42 83.5c-28 22.3-61 33.5-99 33.5L0 241z M0 281v-40h399859v40z",
    rightlinesegment: "M399960 241 V94 h40 V428 h-40 V281 H0 v-40z\nM399960 241 V94 h40 V428 h-40 V281 H0 v-40z",
    rightToFrom: "M400000 167c-70.7-42-118-97.7-142-167h-23c-15.3 0-23 .3-23\n 1 0 1.3 5.3 13.7 16 37 18 35.3 41.3 69 70 101l7 8H0v40h399905l-7 8c-28.7 32\n-52 65.7-70 101-10.7 23.3-16 35.7-16 37 0 .7 7.7 1 23 1h23c24-69.3 71.3-125 142\n-167z M100 147v40h399900v-40zM0 341v40h399900v-40z",
    twoheadleftarrow: "M0 167c68 40\n 115.7 95.7 143 167h22c15.3 0 23-.3 23-1 0-1.3-5.3-13.7-16-37-18-35.3-41.3-69\n-70-101l-7-8h125l9 7c50.7 39.3 85 86 103 140h46c0-4.7-6.3-18.7-19-42-18-35.3\n-40-67.3-66-96l-9-9h399716v-40H284l9-9c26-28.7 48-60.7 66-96 12.7-23.333 19\n-37.333 19-42h-46c-18 54-52.3 100.7-103 140l-9 7H95l7-8c28.7-32 52-65.7 70-101\n 10.7-23.333 16-35.7 16-37 0-.7-7.7-1-23-1h-22C115.7 71.3 68 127 0 167z",
    twoheadrightarrow: "M400000 167\nc-68-40-115.7-95.7-143-167h-22c-15.3 0-23 .3-23 1 0 1.3 5.3 13.7 16 37 18 35.3\n 41.3 69 70 101l7 8h-125l-9-7c-50.7-39.3-85-86-103-140h-46c0 4.7 6.3 18.7 19 42\n 18 35.3 40 67.3 66 96l9 9H0v40h399716l-9 9c-26 28.7-48 60.7-66 96-12.7 23.333\n-19 37.333-19 42h46c18-54 52.3-100.7 103-140l9-7h125l-7 8c-28.7 32-52 65.7-70\n 101-10.7 23.333-16 35.7-16 37 0 .7 7.7 1 23 1h22c27.3-71.3 75-127 143-167z",
    widetilde1: "M200 55.538c-77 0-168 73.953-177 73.953-3 0-7\n-2.175-9-5.437L2 97c-1-2-2-4-2-6 0-4 2-7 5-9l20-12C116 12 171 0 207 0c86 0\n 114 68 191 68 78 0 168-68 177-68 4 0 7 2 9 5l12 19c1 2.175 2 4.35 2 6.525 0\n 4.35-2 7.613-5 9.788l-19 13.05c-92 63.077-116.937 75.308-183 76.128\n-68.267.847-113-73.952-191-73.952z",
    widetilde2: "M344 55.266c-142 0-300.638 81.316-311.5 86.418\n-8.01 3.762-22.5 10.91-23.5 5.562L1 120c-1-2-1-3-1-4 0-5 3-9 8-10l18.4-9C160.9\n 31.9 283 0 358 0c148 0 188 122 331 122s314-97 326-97c4 0 8 2 10 7l7 21.114\nc1 2.14 1 3.21 1 4.28 0 5.347-3 9.626-7 10.696l-22.3 12.622C852.6 158.372 751\n 181.476 676 181.476c-149 0-189-126.21-332-126.21z",
    widetilde3: "M786 59C457 59 32 175.242 13 175.242c-6 0-10-3.457\n-11-10.37L.15 138c-1-7 3-12 10-13l19.2-6.4C378.4 40.7 634.3 0 804.3 0c337 0\n 411.8 157 746.8 157 328 0 754-112 773-112 5 0 10 3 11 9l1 14.075c1 8.066-.697\n 16.595-6.697 17.492l-21.052 7.31c-367.9 98.146-609.15 122.696-778.15 122.696\n -338 0-409-156.573-744-156.573z",
    widetilde4: "M786 58C457 58 32 177.487 13 177.487c-6 0-10-3.345\n-11-10.035L.15 143c-1-7 3-12 10-13l22-6.7C381.2 35 637.15 0 807.15 0c337 0 409\n 177 744 177 328 0 754-127 773-127 5 0 10 3 11 9l1 14.794c1 7.805-3 13.38-9\n 14.495l-20.7 5.574c-366.85 99.79-607.3 139.372-776.3 139.372-338 0-409\n -175.236-744-175.236z",
    vec: "M377 20c0-5.333 1.833-10 5.5-14S391 0 397 0c4.667 0 8.667 1.667 12 5\n3.333 2.667 6.667 9 10 19 6.667 24.667 20.333 43.667 41 57 7.333 4.667 11\n10.667 11 18 0 6-1 10-3 12s-6.667 5-14 9c-28.667 14.667-53.667 35.667-75 63\n-1.333 1.333-3.167 3.5-5.5 6.5s-4 4.833-5 5.5c-1 .667-2.5 1.333-4.5 2s-4.333 1\n-7 1c-4.667 0-9.167-1.833-13.5-5.5S337 184 337 178c0-12.667 15.667-32.333 47-59\nH213l-171-1c-8.667-6-13-12.333-13-19 0-4.667 4.333-11.333 13-20h359\nc-16-25.333-24-45-24-59z",
    widehat1: "M529 0h5l519 115c5 1 9 5 9 10 0 1-1 2-1 3l-4 22\nc-1 5-5 9-11 9h-2L532 67 19 159h-2c-5 0-9-4-11-9l-5-22c-1-6 2-12 8-13z",
    widehat2: "M1181 0h2l1171 176c6 0 10 5 10 11l-2 23c-1 6-5 10\n-11 10h-1L1182 67 15 220h-1c-6 0-10-4-11-10l-2-23c-1-6 4-11 10-11z",
    widehat3: "M1181 0h2l1171 236c6 0 10 5 10 11l-2 23c-1 6-5 10\n-11 10h-1L1182 67 15 280h-1c-6 0-10-4-11-10l-2-23c-1-6 4-11 10-11z",
    widehat4: "M1181 0h2l1171 296c6 0 10 5 10 11l-2 23c-1 6-5 10\n-11 10h-1L1182 67 15 340h-1c-6 0-10-4-11-10l-2-23c-1-6 4-11 10-11z",
    widecheck1: "M529,159h5l519,-115c5,-1,9,-5,9,-10c0,-1,-1,-2,-1,-3l-4,-22c-1,\n-5,-5,-9,-11,-9h-2l-512,92l-513,-92h-2c-5,0,-9,4,-11,9l-5,22c-1,6,2,12,8,13z",
    widecheck2: "M1181,220h2l1171,-176c6,0,10,-5,10,-11l-2,-23c-1,-6,-5,-10,\n-11,-10h-1l-1168,153l-1167,-153h-1c-6,0,-10,4,-11,10l-2,23c-1,6,4,11,10,11z",
    widecheck3: "M1181,280h2l1171,-236c6,0,10,-5,10,-11l-2,-23c-1,-6,-5,-10,\n-11,-10h-1l-1168,213l-1167,-213h-1c-6,0,-10,4,-11,10l-2,23c-1,6,4,11,10,11z",
    widecheck4: "M1181,340h2l1171,-296c6,0,10,-5,10,-11l-2,-23c-1,-6,-5,-10,\n-11,-10h-1l-1168,273l-1167,-273h-1c-6,0,-10,4,-11,10l-2,23c-1,6,4,11,10,11z",
    baraboveleftarrow: "M400000 620h-399890l3 -3c68.7 -52.7 113.7 -120 135 -202\nc4 -14.7 6 -23 6 -25c0 -7.3 -7 -11 -21 -11c-8 0 -13.2 0.8 -15.5 2.5\nc-2.3 1.7 -4.2 5.8 -5.5 12.5c-1.3 4.7 -2.7 10.3 -4 17c-12 48.7 -34.8 92 -68.5 130\ns-74.2 66.3 -121.5 85c-10 4 -16 7.7 -18 11c0 8.7 6 14.3 18 17c47.3 18.7 87.8 47\n121.5 85s56.5 81.3 68.5 130c0.7 2 1.3 5 2 9s1.2 6.7 1.5 8c0.3 1.3 1 3.3 2 6\ns2.2 4.5 3.5 5.5c1.3 1 3.3 1.8 6 2.5s6 1 10 1c14 0 21 -3.7 21 -11\nc0 -2 -2 -10.3 -6 -25c-20 -79.3 -65 -146.7 -135 -202l-3 -3h399890z\nM100 620v40h399900v-40z M0 241v40h399900v-40zM0 241v40h399900v-40z",
    rightarrowabovebar: "M0 241v40h399891c-47.3 35.3-84 78-110 128-16.7 32\n-27.7 63.7-33 95 0 1.3-.2 2.7-.5 4-.3 1.3-.5 2.3-.5 3 0 7.3 6.7 11 20 11 8 0\n13.2-.8 15.5-2.5 2.3-1.7 4.2-5.5 5.5-11.5 2-13.3 5.7-27 11-41 14.7-44.7 39\n-84.5 73-119.5s73.7-60.2 119-75.5c6-2 9-5.7 9-11s-3-9-9-11c-45.3-15.3-85-40.5\n-119-75.5s-58.3-74.8-73-119.5c-4.7-14-8.3-27.3-11-40-1.3-6.7-3.2-10.8-5.5\n-12.5-2.3-1.7-7.5-2.5-15.5-2.5-14 0-21 3.7-21 11 0 2 2 10.3 6 25 20.7 83.3 67\n151.7 139 205zm96 379h399894v40H0zm0 0h399904v40H0z",
    baraboveshortleftharpoon: "M507,435c-4,4,-6.3,8.7,-7,14c0,5.3,0.7,9,2,11\nc1.3,2,5.3,5.3,12,10c90.7,54,156,130,196,228c3.3,10.7,6.3,16.3,9,17\nc2,0.7,5,1,9,1c0,0,5,0,5,0c10.7,0,16.7,-2,18,-6c2,-2.7,1,-9.7,-3,-21\nc-32,-87.3,-82.7,-157.7,-152,-211c0,0,-3,-3,-3,-3l399351,0l0,-40\nc-398570,0,-399437,0,-399437,0z M593 435 v40 H399500 v-40z\nM0 281 v-40 H399908 v40z M0 281 v-40 H399908 v40z",
    rightharpoonaboveshortbar: "M0,241 l0,40c399126,0,399993,0,399993,0\nc4.7,-4.7,7,-9.3,7,-14c0,-9.3,-3.7,-15.3,-11,-18c-92.7,-56.7,-159,-133.7,-199,\n-231c-3.3,-9.3,-6,-14.7,-8,-16c-2,-1.3,-7,-2,-15,-2c-10.7,0,-16.7,2,-18,6\nc-2,2.7,-1,9.7,3,21c15.3,42,36.7,81.8,64,119.5c27.3,37.7,58,69.2,92,94.5z\nM0 241 v40 H399908 v-40z M0 475 v-40 H399500 v40z M0 475 v-40 H399500 v40z",
    shortbaraboveleftharpoon: "M7,435c-4,4,-6.3,8.7,-7,14c0,5.3,0.7,9,2,11\nc1.3,2,5.3,5.3,12,10c90.7,54,156,130,196,228c3.3,10.7,6.3,16.3,9,17c2,0.7,5,1,9,\n1c0,0,5,0,5,0c10.7,0,16.7,-2,18,-6c2,-2.7,1,-9.7,-3,-21c-32,-87.3,-82.7,-157.7,\n-152,-211c0,0,-3,-3,-3,-3l399907,0l0,-40c-399126,0,-399993,0,-399993,0z\nM93 435 v40 H400000 v-40z M500 241 v40 H400000 v-40z M500 241 v40 H400000 v-40z",
    shortrightharpoonabovebar: "M53,241l0,40c398570,0,399437,0,399437,0\nc4.7,-4.7,7,-9.3,7,-14c0,-9.3,-3.7,-15.3,-11,-18c-92.7,-56.7,-159,-133.7,-199,\n-231c-3.3,-9.3,-6,-14.7,-8,-16c-2,-1.3,-7,-2,-15,-2c-10.7,0,-16.7,2,-18,6\nc-2,2.7,-1,9.7,3,21c15.3,42,36.7,81.8,64,119.5c27.3,37.7,58,69.2,92,94.5z\nM500 241 v40 H399408 v-40z M500 435 v40 H400000 v-40z"
};
class Ce {
    static createAtom(e1, t, i, n) {
        return Ce._registry[e1].createAtom(t, i, n);
    }
    static serialize(e1, t) {
        return Ce._registry[e1[0].mode].serialize(e1, t);
    }
    static applyStyle(e1, t, i) {
        return Ce._registry[e1].applyStyle(t, i);
    }
    constructor(e1){
        Ce._registry[e1] = this;
    }
}
function Ee(e1, t) {
    const i = [];
    let n, r = [];
    for (const o of e1)if ("first" !== o.type && o.style) {
        let e2;
        "variant" === t ? (e2 = o.style.variant, o.style.variantStyle && "up" !== o.style.variantStyle && (e2 += "-" + o.style.variantStyle)) : "cssClass" === t ? "group" === o.type && (e2 = o.customClass) : e2 = o.style[t], e2 === n ? r.push(o) : (r.length > 0 && i.push(r), r = [
            o
        ], n = e2);
    }
    return r.length > 0 && i.push(r), i;
}
Ce._registry = {};
const Te = [
    "",
    "chem",
    "mord",
    "mbin",
    "mop",
    "mrel",
    "mopen",
    "mclose",
    "mpunct",
    "minner",
    "spacing",
    "first",
    "latex",
    "composition",
    "error",
    "placeholder",
    "supsub",
    "none",
    "mathfield"
], De = {
    mord: {
        mop: 3,
        mbin: 4,
        mrel: 5,
        minner: 3
    },
    mop: {
        mord: 3,
        mop: 3,
        rel: 5,
        minner: 3
    },
    mbin: {
        mord: 4,
        mop: 4,
        mopen: 4,
        minner: 4
    },
    mrel: {
        mord: 5,
        mop: 5,
        mopen: 5,
        minner: 5
    },
    mclose: {
        mop: 3,
        mbin: 4,
        mrel: 5,
        minner: 3
    },
    mpunct: {
        mord: 3,
        mop: 3,
        mrel: 3,
        mopen: 3,
        mpunct: 3,
        minner: 3
    },
    minner: {
        mord: 3,
        mop: 3,
        mbin: 4,
        mrel: 5,
        mopen: 3,
        mpunct: 3,
        minner: 3
    }
}, ze = {
    mord: {
        mop: 3
    },
    mop: {
        mord: 3,
        mop: 3
    },
    mclose: {
        mop: 3
    },
    minner: {
        mop: 3
    }
};
function qe(e1, t) {
    if ("string" == typeof e1) return e1;
    if ("number" == typeof e1) {
        const i = Math.ceil(100 * e1) / 100;
        return 0 === i ? "0" : i.toString() + (null != t ? t : "");
    }
    return "";
}
class Ie {
    set atomID(e1) {
        void 0 !== e1 && 0 !== e1.length && (this.attributes || (this.attributes = {}), this.attributes["data-atom-id"] = e1);
    }
    selected(e1) {
        if (this.isSelected !== e1 && (this.isSelected = e1, this.children)) for (const t of this.children)t.selected(e1);
    }
    setStyle(e1, t, i) {
        if (void 0 === t) return;
        const n = qe(t, i);
        n.length > 0 && (this.cssProperties || (this.cssProperties = {}), this.cssProperties[e1] = n);
    }
    setTop(e1) {
        Number.isFinite(e1) && Math.abs(e1) > .01 && (this.cssProperties || (this.cssProperties = {}), this.cssProperties.top = qe(e1, "em"), this.height -= e1, this.depth += e1);
    }
    get left() {
        var e1;
        return (null === (e1 = this.cssProperties) || void 0 === e1 ? void 0 : e1["margin-left"]) ? Number.parseFloat(this.cssProperties["margin-left"]) : 0;
    }
    set left(e1) {
        Number.isFinite(e1) && (0 === e1 ? this.cssProperties && delete this.cssProperties["margin-left"] : (this.cssProperties || (this.cssProperties = {}), this.cssProperties["margin-left"] = qe(e1, "em")));
    }
    set right(e1) {
        Number.isFinite(e1) && (0 === e1 ? this.cssProperties && delete this.cssProperties["margin-right"] : (this.cssProperties || (this.cssProperties = {}), this.cssProperties["margin-right"] = qe(e1, "em")));
    }
    set width(e1) {
        Number.isFinite(e1) && (0 === e1 ? this.cssProperties && delete this.cssProperties.width : (this.cssProperties || (this.cssProperties = {}), this.cssProperties.width = qe(e1, "em")));
    }
    wrap(e1, t) {
        const i = e1.parent;
        if (!i) return this;
        e1.isPhantom && this.setStyle("opacity", 0);
        let n = e1.computedColor;
        n === i.computedColor && (n = ""), this.setStyle("color", n);
        const r = e1.effectiveFontSize === i.effectiveFontSize ? void 0 : e1.effectiveFontSize;
        let o, a = e1.computedBackgroundColor;
        if (this.isSelected && (a = v(a)), a === i.computedBackgroundColor && (a = ""), !(r || a || t && (t.classes || t.type))) return this;
        a ? (o = Re(this, t), o.selected(this.isSelected), o.setStyle("background-color", a), o.setStyle("display", "inline-block")) : o = new Ie(this, t);
        const s = e1.scalingFactor;
        return 1 !== s && (o.setStyle("font-size", 100 * s, "%"), o.height *= s, o.depth *= s, o.italic *= s, o.skew *= s), o;
    }
    wrapSelect(e1) {
        if (!this.isSelected) return this;
        if (!e1.parent) return this;
        const t = v(e1.computedBackgroundColor), i = Re(this);
        return i.selected(!0), i.setStyle("background-color", t), i.setStyle("display", "inline-block"), i;
    }
    toMarkup() {
        var e1, t, i;
        let n = null !== (e1 = this.value) && void 0 !== e1 ? e1 : "";
        if (this.children) for (const e2 of this.children)n += e2.toMarkup();
        const r = this.classes.split(" ");
        r.push(null !== (t = ({
            latex: "ML__latex",
            placeholder: "ML__placeholder",
            error: "ML__error"
        })[this.type]) && void 0 !== t ? t : ""), "latex" === this.caret && r.push("ML__latex-caret");
        const o = 1 === r.length ? r[0] : r.filter((e1, t, i)=>e1.length > 0 && i.indexOf(e1) === t).join(" ");
        let a = "";
        if (n.length > 0 && "​" !== n || o.length > 0 || this.cssId || this.htmlData || this.htmlStyle || this.attributes || this.cssProperties || this.svgBody || this.svgOverlay) {
            let e3 = "";
            if (this.cssId && (e3 += ` id=${this.cssId.replace(/ /g, "-")} `), this.htmlData) {
                const t1 = this.htmlData.split(",");
                for (const i1 of t1){
                    const t2 = i1.match(/([^=]+)=(.+$)/);
                    if (t2) {
                        const i2 = t2[1].trim().replace(/ /g, "-");
                        i2 && (e3 += ` data-${i2}=${t2[2]} `);
                    } else {
                        const t3 = i1.trim().replace(/ /g, "-");
                        t3 && (e3 += ` data-${t3} `);
                    }
                }
            }
            if (this.htmlStyle) {
                const t4 = this.htmlStyle.split(";");
                let i3 = "";
                for (const e4 of t4){
                    const t5 = e4.match(/([^=]+):(.+$)/);
                    if (t5) {
                        const e5 = t5[1].trim().replace(/ /g, "-");
                        e5 && (i3 += `${e5}:${t5[2]};`);
                    }
                }
                i3 && (e3 += ` style="${i3}"`);
            }
            if (this.attributes && (e3 += " " + Object.keys(this.attributes).map((e1)=>`${e1}="${this.attributes[e1]}"`).join(" ")), o.length > 0 && (e3 += ` class="${o}"`), this.cssProperties) {
                const t6 = Object.keys(this.cssProperties).map((e1)=>`${e1}:${this.cssProperties[e1]}`).join(";");
                t6.length > 0 && (e3 += ` style="${t6}"`);
            }
            let t7 = "";
            this.svgBody ? t7 = function(e1) {
                if (Le[e1]) {
                    const [t, i, n] = Le[e1];
                    return `<span style="display:inline-block;height:${n / 2}em;min-width:0"><span class="stretchy" style="height:${n}em"><svg width="100%" height="${n}em" viewBox="0 0 ${t} ${i}" preserveAspectRatio="none" ><path fill="currentcolor" d="${Ae[e1]}"></path></svg></span></span>`;
                }
                const [t1, i1, n1, r] = Ne[e1];
                let o, a;
                const s = n1 / 1e3;
                3 === t1.length ? (o = [
                    "slice-1-of-3",
                    "slice-2-of-3",
                    "slice-3-of-3"
                ], a = [
                    "xMinYMin",
                    "xMidYMin",
                    "xMaxYMin"
                ]) : 2 === t1.length ? (o = [
                    "slice-1-of-2",
                    "slice-2-of-2"
                ], a = [
                    "xMinYMin",
                    "xMaxYMin"
                ]) : (o = [
                    "slice-1-of-1"
                ], a = [
                    r
                ]);
                const l = t1.map((e1, t)=>`<span class="${o[t]}" style=height:${s}em><svg width=400em height=${s}em viewBox="0 0 400000 ${n1}" preserveAspectRatio="${a[t]} slice"><path fill="currentcolor" d="${Ae[e1]}"></path></svg></span>`).join("");
                return `<span style="display:inline-block;height:${s}em;min-width:${i1}em;">${l}</span>`;
            }(this.svgBody) : this.svgOverlay && (t7 = '<span style="', t7 += "display: inline-block;", t7 += `height:${this.height + this.depth}em;`, t7 += `vertical-align:${this.depth}em;`, t7 += '">', t7 += n, t7 += "</span>", t7 += '<svg style="position:absolute;overflow:overlay;', t7 += `height:${this.height + this.depth}em;`, (null === (i = this.cssProperties) || void 0 === i ? void 0 : i.padding) ? (t7 += `top:${this.cssProperties.padding}em;`, t7 += `left:${this.cssProperties.padding}em;`, t7 += `width:calc(100% - 2 * ${this.cssProperties.padding}em );`) : t7 += "top:0;left:0;width:100%;", t7 += "z-index:2;", t7 += '"', this.svgStyle && (t7 += ` style="${this.svgStyle}"`), t7 += `>${this.svgOverlay}</svg>`), a = `<span${e3}>${n}${t7}</span>`;
        }
        return "text" === this.caret ? a += '<span class="ML__text-caret"></span>' : "math" === this.caret && (a += '<span class="ML__caret"></span>'), a;
    }
    tryCoalesceWith(e1) {
        if (this.type !== e1.type) return !1;
        if (!/ML__text/.test(this.classes) && ![
            "mord",
            "mbin",
            "mrel"
        ].includes(this.type)) return !1;
        if (this.svgBody || !this.value) return !1;
        if (e1.svgBody || !e1.value) return !1;
        const t = this.children && this.children.length > 0, i = e1.children && e1.children.length > 0;
        if (t || i) return !1;
        const n = this.cssProperties ? Object.keys(this.cssProperties).length : 0;
        if (n !== (e1.cssProperties ? Object.keys(e1.cssProperties).length : 0)) return !1;
        if (n > 0) {
            for (const t1 of Object.keys(this.cssProperties))if (this.cssProperties[t1] !== e1.cssProperties[t1]) return !1;
        }
        const r = this.classes.trim().replace(/\s+/g, " ").split(" "), o = e1.classes.trim().replace(/\s+/g, " ").split(" ");
        if (r.length !== o.length) return !1;
        r.sort(), o.sort();
        for (const [e2, t2] of r.entries()){
            if ("vertical-separator" === t2) return !1;
            if (t2 !== o[e2]) return !1;
        }
        return this.value += e1.value, this.height = Math.max(this.height, e1.height), this.depth = Math.max(this.depth, e1.depth), this.maxFontSize = Math.max(this.maxFontSize, e1.maxFontSize), this.italic = e1.italic, !0;
    }
    constructor(t, i){
        var n, r, o, a, s, l;
        if ("number" == typeof t ? this.value = String.fromCodePoint(t) : "string" == typeof t ? this.value = t : e1(t) ? this.children = t.filter((e1)=>null !== e1) : t && t instanceof Ie && (this.children = [
            t
        ]), this.type = null !== (n = null == i ? void 0 : i.type) && void 0 !== n ? n : "", this.isSelected = !1, this.isTight = null !== (r = null == i ? void 0 : i.isTight) && void 0 !== r && r, this.newList = null !== (o = null == i ? void 0 : i.newList) && void 0 !== o && o, null == i ? void 0 : i.properties) for (const e2 of Object.keys(i.properties))this.setStyle(e2, i.properties[e2]);
        (null == i ? void 0 : i.attributes) && (this.attributes = i.attributes), this.classes = null !== (a = null == i ? void 0 : i.classes) && void 0 !== a ? a : "";
        let u = (null == i ? void 0 : i.fontFamily) || "Main-Regular";
        if ((null == i ? void 0 : i.style) && this.value && (u = Ce.applyStyle(null !== (s = i.mode) && void 0 !== s ? s : "math", this, i.style) || "Main-Regular"), this.height = 0, this.depth = 0, this.skew = 0, this.italic = 0, this.maxFontSize = 0, "latex" === this.type) this.height = .8, this.depth = .2;
        else if ("number" == typeof t) {
            const e3 = xe(t, u);
            this.height = e3.height, this.depth = e3.depth, this.skew = e3.skew, this.italic = e3.italic;
        } else if (this.value) {
            this.height = -1 / 0, this.depth = -1 / 0, this.skew = -1 / 0, this.italic = -1 / 0;
            for(let e4 = 0; e4 < this.value.length; e4++){
                const t1 = xe(this.value.codePointAt(e4), u || "Main-Regular");
                this.height = Math.max(this.height, t1.height), this.depth = Math.max(this.depth, t1.depth), this.skew = t1.skew, this.italic = t1.italic;
            }
        } else if (this.children && this.children.length > 0) {
            if (1 === this.children.length) {
                const e5 = this.children[0];
                this.height = e5.height, this.depth = e5.depth, this.maxFontSize = e5.maxFontSize, this.skew = e5.skew, this.italic = e5.italic;
            } else {
                let e6 = -1 / 0, t2 = -1 / 0, i1 = 0;
                for (const n1 of this.children)n1.height > e6 && (e6 = n1.height), n1.depth > t2 && (t2 = n1.depth), i1 = Math.max(i1, null !== (l = n1.maxFontSize) && void 0 !== l ? l : 0);
                this.height = e6, this.depth = t2, this.maxFontSize = i1;
            }
        }
        void 0 !== (null == i ? void 0 : i.height) && (this.height = i.height), void 0 !== (null == i ? void 0 : i.depth) && (this.depth = i.depth), void 0 !== (null == i ? void 0 : i.maxFontSize) && (this.maxFontSize = i.maxFontSize);
    }
}
function Oe(e1) {
    if (!e1 || 0 === e1.length) return [];
    e1[0].children = Oe(e1[0].children);
    const t = [
        e1[0]
    ];
    for(let i = 1; i < e1.length; i++)t[t.length - 1].tryCoalesceWith(e1[i]) || (e1[i].children = Oe(e1[i].children), t.push(e1[i]));
    return t;
}
function Fe(e1) {
    return e1.children && (e1.children = Oe(e1.children)), e1;
}
function Be(e1, t, i) {
    t.newList && (e1 = null);
    const n = t.type;
    if ("first" === n) return null;
    if ("spacing" === n) return e1;
    if (i(e1, t), t.children) {
        let r = null;
        void 0 !== n && 0 !== n.length || (r = e1);
        for (const e2 of t.children)r = Be(r, e2, i);
        void 0 !== n && 0 !== n.length || (e1 = r);
    }
    return "supsub" !== n && void 0 !== n && n.length > 0 && (e1 = t), e1;
}
function $e(e1, t) {
    e1 && Be(null, e1, t);
}
function Pe(e1, t = 1) {
    return function(e1) {
        $e(e1, (e1, t)=>{
            "mbin" !== t.type || e1 && !/first|none|mbin|mop|mrel|mopen|mpunct/.test(e1.type) || (t.type = "mord"), e1 && "mbin" === e1.type && /mrel|mclose|mpunct|placeholder/.test(t.type) && (e1.type = "mord");
        });
    }(e1), function(e1, t) {
        $e(e1, (e1, i)=>{
            var n, r, o, a;
            const s = null !== (n = null == e1 ? void 0 : e1.type) && void 0 !== n ? n : "none", l = i.isTight ? null !== (r = ze[s]) && void 0 !== r ? r : null : null !== (o = De[s]) && void 0 !== o ? o : null, u = l && null !== (a = l[i.type]) && void 0 !== a ? a : 0;
            u && (i.left += t * (u / 18));
        });
    }(e1, t), e1;
}
function Re(e1, t) {
    if (!e1) return new Ie(null, t);
    const i = new Ie(null, {
        classes: "ML__strut"
    });
    i.setStyle("height", Math.max(0, e1.height), "em");
    const n = [
        i
    ];
    if (0 !== e1.depth) {
        const t1 = new Ie(null, {
            classes: "ML__strut--bottom"
        });
        t1.setStyle("height", e1.height + e1.depth, "em"), t1.setStyle("vertical-align", -e1.depth, "em"), n.push(t1);
    }
    return n.push(e1), new Ie(n, t);
}
function Ke(e1) {
    const t = function(e1) {
        return Ne[e1] ? Ne[e1][2] / 1e3 : Le[e1][2];
    }(e1) / 2, i = new Ie(null, {
        height: t + .166,
        depth: t - .166,
        maxFontSize: 0
    });
    return i.svgBody = e1, i;
}
class Ve extends Ie {
    constructor(e1, t){
        var i;
        const [n, r, o] = function(e1) {
            var t;
            const [i, n] = function(e1) {
                if ("individualShift" in e1) {
                    const t = e1.individualShift;
                    let i = t[0];
                    const n = [
                        i
                    ], r = -i.shift - i.box.depth;
                    let o = r;
                    for(let e2 = 1; e2 < t.length; e2++){
                        const r1 = t[e2], a = -r1.shift - o - r1.box.depth, s = a - (i.box.height + i.box.depth);
                        o += a, n.push(s), n.push(r1), i = r1;
                    }
                    return [
                        n,
                        r
                    ];
                }
                if ("top" in e1) {
                    let t1 = e1.top;
                    for (const i1 of e1.children)t1 -= "number" == typeof i1 ? i1 : i1.box.height + i1.box.depth;
                    return [
                        e1.children,
                        t1
                    ];
                }
                if ("bottom" in e1) return [
                    e1.children,
                    -e1.bottom
                ];
                if ("firstBaseline" in e1) {
                    const t2 = e1.firstBaseline[0];
                    if ("number" == typeof t2) throw new Error("First child must be an element.");
                    return [
                        e1.firstBaseline,
                        -t2.box.depth
                    ];
                }
                if ("shift" in e1) {
                    const t3 = e1.children[0];
                    if ("number" == typeof t3) throw new Error("First child must be an element.");
                    return [
                        e1.children,
                        -t3.box.depth - e1.shift
                    ];
                }
                return [
                    null,
                    0
                ];
            }(e1);
            if (!i) return [
                [],
                0,
                0
            ];
            let r = 0;
            for (const e2 of i)if ("number" != typeof e2) {
                const t1 = e2.box;
                r = Math.max(r, t1.maxFontSize, t1.height);
            }
            r += 2;
            const o = new Ie(null, {
                classes: "pstrut"
            });
            o.setStyle("height", r, "em");
            const a = [];
            let s = n, l = n, u = n;
            for (const e3 of i){
                if ("number" == typeof e3) u += e3;
                else {
                    const i1 = e3.box, n1 = null !== (t = e3.classes) && void 0 !== t ? t : [], s1 = new Ie([
                        o,
                        i1
                    ], {
                        classes: n1.join(" "),
                        style: e3.style
                    });
                    s1.setStyle("top", -r - u - i1.depth, "em"), e3.marginLeft && s1.setStyle("margin-left", e3.marginLeft, "em"), e3.marginRight && s1.setStyle("margin-right", e3.marginRight, "em"), a.push(s1), u += i1.height + i1.depth;
                }
                s = Math.min(s, u), l = Math.max(l, u);
            }
            const c = new Ie(a, {
                classes: "vlist"
            });
            let d;
            if (c.setStyle("height", l, "em"), s < 0) {
                const e4 = new Ie(new Ie(null), {
                    classes: "vlist"
                });
                e4.setStyle("height", -s, "em");
                const t2 = new Ie(8203, {
                    classes: "vlist-s",
                    maxFontSize: 0,
                    height: 0,
                    depth: 0
                });
                d = [
                    new Ie([
                        c,
                        t2
                    ], {
                        classes: "vlist-r"
                    }),
                    new Ie(e4, {
                        classes: "vlist-r"
                    })
                ];
            } else d = [
                new Ie(c, {
                    classes: "vlist-r"
                })
            ];
            return [
                d,
                l,
                -s
            ];
        }(e1);
        super(1 === n.length ? n[0] : n, {
            classes: (null !== (i = null == t ? void 0 : t.classes) && void 0 !== i ? i : "") + " vlist-t" + (2 === n.length ? " vlist-t2" : ""),
            height: r,
            depth: o,
            type: null == t ? void 0 : t.type
        });
    }
}
const je = [
    [
        8205,
        1
    ],
    [
        65038,
        2
    ],
    [
        127995,
        5
    ],
    [
        129456,
        4
    ],
    [
        917536,
        96
    ]
];
let He;
const Ue = [
    127462,
    127487
];
function Ge(e1) {
    var t;
    if (void 0 === He) {
        He = {};
        for (const e2 of je)for(let t1 = e2[0]; t1 <= e2[0] + e2[1] - 1; t1++)He[t1] = !0;
    }
    return null !== (t = He[e1]) && void 0 !== t && t;
}
function Ze(e1) {
    return e1 >= Ue[0] && e1 <= Ue[1];
}
function We(e1) {
    if (/^[\u0020-\u00FF]*$/.test(e1)) return e1;
    const t = [], i = function(e1) {
        const t = [];
        for(let i = 0; i < e1.length; i++){
            let n = e1.charCodeAt(i);
            if (13 === n && 10 === e1.charCodeAt(i + 1) && (n = 10, i++), 13 !== n && 12 !== n || (n = 10), 0 === n && (n = 65533), n >= 55296 && n <= 56319) {
                const t1 = e1.charCodeAt(i + 1);
                t1 >= 56320 && t1 <= 57343 && (n = 65536 + 1024 * (n - 55296) + (t1 - 56320), i++);
            }
            t.push(n);
        }
        return t;
    }(e1);
    let n = 0;
    for(; n < i.length;){
        const e2 = i[n++], r = i[n];
        if (8205 === r) {
            const e3 = n - 1;
            for(n += 2; 8205 === i[n];)n += 2;
            t.push(String.fromCodePoint(...i.slice(e3, n - e3 + 1)));
        } else if (Ge(r)) {
            const e4 = n - 1;
            for(; Ge(i[n]);)n += 8205 === i[n] ? 2 : 1;
            t.push(String.fromCodePoint(...i.slice(e4, 2 * n - e4 - 1)));
        } else Ze(e2) ? (n += 1, t.push(String.fromCodePoint(...i.slice(n - 2, 2)))) : t.push(String.fromCodePoint(e2));
    }
    return t;
}
class Je {
    end() {
        return this.pos >= this.s.length;
    }
    get() {
        return this.pos < this.s.length ? this.s[this.pos++] : "";
    }
    peek() {
        return this.s[this.pos];
    }
    match(e1) {
        const t = "string" == typeof this.s ? e1.exec(this.s.slice(this.pos)) : e1.exec(this.s.slice(this.pos).join(""));
        return (null == t ? void 0 : t[0]) ? (this.pos += t[0].length, t[0]) : "";
    }
    next() {
        if (this.end()) return null;
        if (!this.obeyspaces && this.match(/^[ \f\n\r\t\v\u00A0\u2028\u2029]+/)) return "<space>";
        if (this.obeyspaces && this.match(/^[ \f\n\r\t\v\u00A0\u2028\u2029]/)) return "<space>";
        const e1 = this.get();
        if ("\\" === e1) {
            if (!this.end()) {
                let e2 = this.match(/^[a-zA-Z\*]+/);
                if (e2) this.match(/^[ \f\n\r\t\v\u00A0\u2028\u2029]*/);
                else if (e2 = this.get(), " " === e2) return "<space>";
                return "\\" + e2;
            }
        } else {
            if ("{" === e1) return "<{>";
            if ("}" === e1) return "<}>";
            if ("^" === e1) {
                if ("^" === this.peek()) {
                    this.get();
                    const e3 = this.match(/^(\^(\^(\^(\^[\da-f])?[\da-f])?[\da-f])?[\da-f])?[\da-f]{2}/);
                    if (e3) return String.fromCodePoint(Number.parseInt(e3.slice(e3.lastIndexOf("^") + 1), 16));
                }
                return e1;
            }
            if ("#" === e1) {
                if (!this.end()) {
                    let e4 = !1;
                    if (/[\d?@]/.test(this.peek()) && (e4 = !0, this.pos + 1 < this.s.length)) {
                        const t = this.s[this.pos + 1];
                        e4 = /[^\dA-Za-z]/.test(t);
                    }
                    return e4 ? "#" + this.get() : "#";
                }
            } else if ("$" === e1) return "$" === this.peek() ? (this.get(), "<$$>") : "<$>";
        }
        return e1;
    }
    constructor(e1){
        this.s = We(e1), this.pos = 0, this.obeyspaces = !1;
    }
}
function Xe(e1, t) {
    var i, n, r, o;
    const a = [];
    let s = e1.next();
    if (s) {
        if ("\\relax" === s) ;
        else if ("\\noexpand" === s) s = e1.next(), s && a.push(s);
        else if ("\\obeyspaces" === s) e1.obeyspaces = !0;
        else if ("\\space" === s || "~" === s) a.push("<space>");
        else if ("\\bgroup" === s) a.push("<{>");
        else if ("\\egroup" === s) a.push("<}>");
        else if ("\\string" === s) {
            if (s = e1.next(), s) {
                if (s.startsWith("\\")) for (const e2 of s)a.push("\\" === e2 ? "\\backslash" : e2);
                else "<{>" === s ? a.push("\\{") : "<space>" === s ? a.push("~") : "<}>" === s && a.push("\\}");
            }
        } else if ("\\csname" === s) {
            for(; "<space>" === e1.peek();)e1.next();
            let r1 = "", o1 = !1, l = [];
            do {
                if (0 === l.length) {
                    if (/^#[\d?@]$/.test(e1.peek())) {
                        const r2 = e1.get().slice(1);
                        l = Ye(null !== (n = null !== (i = null == t ? void 0 : t(r2)) && void 0 !== i ? i : null == t ? void 0 : t("?")) && void 0 !== n ? n : "\\placeholder{}", t), s = l[0];
                    } else s = e1.next(), l = s ? [
                        s
                    ] : [];
                }
                o1 = 0 === l.length, o1 || "\\endcsname" !== s || (o1 = !0, l.shift()), o1 || (o1 = "<$>" === s || "<$$>" === s || "<{>" === s || "<}>" === s || "string" == typeof s && s.length > 1 && s.startsWith("\\")), o1 || (r1 += l.shift());
            }while (!o1);
            r1 && a.push("\\" + r1), a.push(...l);
        } else if ("\\endcsname" === s) ;
        else if (s.length > 1 && s.startsWith("#")) {
            const e3 = s.slice(1);
            a.push(...Ye(null !== (o = null !== (r = null == t ? void 0 : t(e3)) && void 0 !== r ? r : null == t ? void 0 : t("?")) && void 0 !== o ? o : "\\placeholder{}", t));
        } else a.push(s);
    }
    return a;
}
function Ye(e1, t = null) {
    const i = [];
    let n = "";
    for (const t1 of e1.toString().split(/\r?\n/)){
        n && i.push(n), n = " ";
        const e2 = t1.match(/((?:\\%)|[^%])*/);
        null !== e2 && i.push(e2[0]);
    }
    const r = new Je(i.join("")), o = [];
    do o.push(...Xe(r, t));
    while (!r.end());
    return o;
}
function Qe(e1) {
    let t = "";
    const i = [];
    for (const n of e1)n && (/[a-zA-Z\*]/.test(n[0]) && i.push(t), i.push(n), /\\[a-zA-Z]+\*?[\"\'][^\ ]+$/.test(n) && i.push(" "), t = /\\[a-zA-Z]+\*?$/.test(n) ? " " : "");
    return i.join("");
}
function et(e1) {
    return Qe(e1.map((e1)=>{
        var t;
        return null !== (t = ({
            "<space>": " ",
            "<$$>": "$$",
            "<$>": "$",
            "<{>": "{",
            "<}>": "}"
        })[e1]) && void 0 !== t ? t : e1;
    }));
}
class tt extends Ie {
    toMarkup() {
        let e1 = "";
        const t = this.classes.split(" "), i = 1 === t.length ? t[0] : t.filter((e1, t, i)=>e1.length > 0 && i.indexOf(e1) === t).join(" ");
        if (this.cssId && (e1 += ` id=${this.cssId.replace(/ /g, "-")} `), this.htmlData) {
            const t1 = this.htmlData.split(",");
            for (const i1 of t1){
                const t2 = i1.match(/([^=]+)=(.+$)/);
                if (t2) {
                    const i2 = t2[1].trim().replace(/ /g, "-");
                    i2 && (e1 += ` data-${i2}=${t2[2]} `);
                } else {
                    const t3 = i1.trim().replace(/ /g, "-");
                    t3 && (e1 += ` data-${t3} `);
                }
            }
        }
        if (this.htmlStyle) {
            const t4 = this.htmlStyle.split(";");
            let i3 = "";
            for (const e2 of t4){
                const t5 = e2.match(/([^=]+):(.+$)/);
                if (t5) {
                    const e3 = t5[1].trim().replace(/ /g, "-");
                    e3 && (i3 += `${e3}:${t5[2]};`);
                }
            }
            i3 && (e1 += ` style="${i3}"`);
        }
        return this.attributes && (e1 += " " + Object.keys(this.attributes).map((e1)=>`${e1}="${this.attributes[e1]}"`).join(" ")), i.length > 0 && (e1 += ` class="${i}"`), e1 += ` style="display: inline-block; width:${this.element.clientWidth}px; height:${this.element.clientHeight}px; "`, `<span ${e1}></span>`;
    }
    constructor(e1, t, i){
        super(null, i), this.placeholderId = e1, this.element = t, this.htmlData = `placeholder-id=${e1}`, this.height = "" === t.style.fontSize ? 1 : t.clientHeight / parseInt(t.style.fontSize) * .6;
    }
}
const it = [
    "above",
    "body",
    "below",
    "superscript",
    "subscript"
];
function nt(e1) {
    return "string" == typeof e1 && it.includes(e1);
}
function rt(e1) {
    return void 0 !== e1 && Array.isArray(e1) && 2 === e1.length;
}
class ot {
    static createBox(e1, t, i) {
        var n, r, o;
        if (!t) return null;
        const a = function(e1) {
            let t;
            const i = [];
            let n = [];
            for (const r of e1)if (t || r.style) {
                const e2 = r.computedStyle;
                t && e2.color === t.color && e2.backgroundColor === t.backgroundColor && e2.fontSize === t.fontSize ? n.push(r) : (n.length > 0 && i.push(n), n = [
                    r
                ], t = e2);
            } else n.push(r);
            return n.length > 0 && i.push(n), i;
        }(t);
        if (1 === a.length) {
            const t1 = a[0];
            return t1[0].style ? st(e1, t1, {
                ...i,
                style: {
                    color: t1[0].style.color,
                    backgroundColor: t1[0].style.backgroundColor,
                    fontSize: t1[0].style.fontSize
                }
            }) : st(e1, t1, i);
        }
        const s = [];
        let l = null == i ? void 0 : i.newList;
        for (const t2 of a){
            const i1 = st(new Me(e1, {
                color: null === (n = t2[0].style) || void 0 === n ? void 0 : n.color,
                backgroundColor: null === (r = t2[0].style) || void 0 === r ? void 0 : r.backgroundColor,
                fontSize: null === (o = t2[0].style) || void 0 === o ? void 0 : o.fontSize
            }), t2, {
                newList: l
            });
            i1 && (l = !1, s.push(i1));
        }
        return 0 === s.length ? null : 1 !== s.length || (null == i ? void 0 : i.classes) || (null == i ? void 0 : i.type) ? new Ie(s, {
            classes: null == i ? void 0 : i.classes,
            type: null == i ? void 0 : i.type,
            newList: null == i ? void 0 : i.newList
        }).wrap(e1) : s[0].wrap(e1);
    }
    static serialize(t, i) {
        return e1(t) ? at(t, i) : "number" == typeof t || "boolean" == typeof t ? t.toString() : "string" == typeof t ? t.replace(/\s/g, "~") : void 0 === t ? "" : i.expandMacro || "string" != typeof t.verbatimLatex ? t.command && ot.customSerializer[t.command] ? ot.customSerializer[t.command](t, i) : t.serialize(i) : t.verbatimLatex;
    }
    static commonAncestor(e1, t) {
        if (e1 === t) return e1.parent;
        if (e1.parent === t.parent) return e1.parent;
        const i = new WeakSet;
        let { parent: n  } = e1;
        for(; n;)i.add(n), n = n.parent;
        for(n = t.parent; n;){
            if (i.has(n)) return n;
            n = n.parent;
        }
    }
    static fromJson(e1, t) {
        const i = new ot(e1.type, t, e1);
        for (const t1 of it)e1[t1] && i.setChildren(e1[t1], t1);
        return i;
    }
    toJson() {
        const e1 = {
            type: this.type
        };
        if ("math" !== this.mode && (e1.mode = this.mode), this.command && this.command !== this.value && (e1.command = this.command), void 0 !== this.value && (e1.value = this.value), this.style && Object.keys(this.style).length > 0 && (e1.style = {
            ...this.style
        }), void 0 !== this.verbatimLatex && (e1.verbatimLatex = this.verbatimLatex), this.subsupPlacement && (e1.subsupPlacement = this.subsupPlacement), this.explicitSubsupPlacement && (e1.explicitSubsupPlacement = !0), this.isFunction && (e1.isFunction = !0), this.displayContainsHighlight && (e1.displayContainsHighlight = !0), this.isExtensibleSymbol && (e1.isExtensibleSymbol = !0), this.skipBoundary && (e1.skipBoundary = !0), this.captureSelection && (e1.captureSelection = !0), this._branches) for (const t of Object.keys(this._branches))this._branches[t] && (e1[t] = this._branches[t].filter((e1)=>"first" !== e1.type).map((e1)=>e1.toJson()));
        return e1;
    }
    get changeCounter() {
        return this._changeCounter;
    }
    get isDirty() {
        return this._isDirty;
    }
    set isDirty(e1) {
        if (this._isDirty = e1, e1) {
            this._changeCounter++, this.verbatimLatex = void 0, this._children = void 0;
            let { parent: e2  } = this;
            for(; e2;)e2._isDirty = !0, e2._changeCounter++, e2.verbatimLatex = void 0, e2._children = void 0, e2 = e2.parent;
        }
    }
    serialize(e1) {
        var t;
        return this.body && this.command ? Qe([
            this.command,
            "{",
            this.bodyToLatex(e1),
            "}",
            this.supsubToLatex(e1)
        ]) : this.body ? Qe([
            this.bodyToLatex(e1),
            this.supsubToLatex(e1)
        ]) : this.value && "​" !== this.value ? null !== (t = this.command) && void 0 !== t ? t : function(e1, t) {
            var i;
            if ("text" === e1) return null !== (i = D(e1, t.codePointAt(0))) && void 0 !== i ? i : t;
            let n;
            if (n = D(e1, t.codePointAt(0)), n) return n;
            const r = function(e1) {
                var t;
                if ((e1 < 119808 || e1 > 120831) && (e1 < 8448 || e1 > 8527)) return {
                    char: String.fromCodePoint(e1)
                };
                for(const i in z)if (z[i] === e1) {
                    e1 = null !== (t = i.codePointAt(0)) && void 0 !== t ? t : 0;
                    break;
                }
                for (const t1 of q)if (e1 >= t1.start && e1 < t1.start + t1.len) return {
                    char: String.fromCodePoint(e1 - t1.start + t1.offset),
                    variant: t1.variant,
                    style: t1.style
                };
                return {
                    char: String.fromCodePoint(e1)
                };
            }(t.codePointAt(0));
            return r.style || r.variant ? (n = r.char, r.variant && (n = "\\" + r.variant + "{" + n + "}"), "bold" === r.style ? n = "\\mathbf{" + n + "}" : "italic" === r.style ? n = "\\mathit{" + n + "}" : "bolditalic" === r.style && (n = "\\mathbfit{" + n + "}"), "\\mathord{" + n + "}") : "";
        }(this.mode, this.value) : "";
    }
    bodyToLatex(e1) {
        return at(this.body, e1);
    }
    aboveToLatex(e1) {
        return at(this.above, e1);
    }
    belowToLatex(e1) {
        return at(this.below, e1);
    }
    supsubToLatex(e1) {
        let t = "";
        if (void 0 !== this.branch("subscript")) {
            const i = at(this.subscript, e1);
            0 === i.length ? t += "_{}" : 1 === i.length ? t += "_" + i : t += `_{${i}}`;
        }
        if (void 0 !== this.branch("superscript")) {
            const i1 = at(this.superscript, e1);
            0 === i1.length ? t += "^{}" : 1 === i1.length ? t += "′" === i1 ? "^\\prime " : "″" === i1 ? "^\\doubleprime " : "^" + i1 : t += `^{${i1}}`;
        }
        return t;
    }
    get treeDepth() {
        let e1 = 1, t = this.parent;
        for(; t;)t = t.parent, e1 += 1;
        return e1;
    }
    get inCaptureSelection() {
        let e1 = !1, t = this;
        for(; t;){
            if (t.captureSelection) {
                e1 = !0;
                break;
            }
            t = t.parent;
        }
        return e1;
    }
    branch(e1) {
        if (nt(e1) && this._branches) return this._branches[e1];
    }
    get branches() {
        if (!this._branches) return [];
        const e1 = [];
        for (const t of it)this._branches[t] && e1.push(t);
        return e1;
    }
    createBranch(e1) {
        return nt(e1) ? (this._branches ? this._branches[e1] || (this._branches[e1] = [
            this.makeFirstAtom(e1)
        ]) : this._branches = {
            [e1]: [
                this.makeFirstAtom(e1)
            ]
        }, this.isDirty = !0, this._branches[e1]) : [];
    }
    get row() {
        return rt(this.treeBranch) ? this.treeBranch[0] : -1;
    }
    get col() {
        return rt(this.treeBranch) ? this.treeBranch[1] : -1;
    }
    get body() {
        var e1;
        return null === (e1 = this._branches) || void 0 === e1 ? void 0 : e1.body;
    }
    set body(e1) {
        this.setChildren(e1, "body");
    }
    get superscript() {
        var e1;
        return null === (e1 = this._branches) || void 0 === e1 ? void 0 : e1.superscript;
    }
    set superscript(e1) {
        this.setChildren(e1, "superscript");
    }
    get subscript() {
        var e1;
        return null === (e1 = this._branches) || void 0 === e1 ? void 0 : e1.subscript;
    }
    set subscript(e1) {
        this.setChildren(e1, "subscript");
    }
    get above() {
        var e1;
        return null === (e1 = this._branches) || void 0 === e1 ? void 0 : e1.above;
    }
    set above(e1) {
        this.setChildren(e1, "above");
    }
    get below() {
        var e1;
        return null === (e1 = this._branches) || void 0 === e1 ? void 0 : e1.below;
    }
    set below(e1) {
        this.setChildren(e1, "below");
    }
    get computedStyle() {
        var e1;
        if (!this.parent) return {
            ...null !== (e1 = this.style) && void 0 !== e1 ? e1 : {}
        };
        const t = void 0 !== this.style.verbatimColor, i = void 0 !== this.style.verbatimBackgroundColor, n = {
            ...this.parent.computedStyle,
            ...this.style
        };
        return delete n.variant, delete n.variantStyle, i || delete n.verbatimBackgroundColor, t || delete n.verbatimColor, n;
    }
    applyStyle(e1) {
        this.isDirty = !0, this.style = {
            ...this.style,
            ...e1
        }, "none" === this.style.fontFamily && delete this.style.fontFamily, "auto" === this.style.fontShape && delete this.style.fontShape, "auto" === this.style.fontSeries && delete this.style.fontSeries, "none" === this.style.color && (delete this.style.color, delete this.style.verbatimColor), "none" === this.style.backgroundColor && (delete this.style.backgroundColor, delete this.style.verbatimBackgroundColor), "auto" === this.style.fontSize && delete this.style.fontSize;
        for (const t of this.children)t.applyStyle(e1);
    }
    getInitialBaseElement() {
        let e1;
        return this.hasEmptyBranch("body") || (e1 = this.body[1].getInitialBaseElement()), null != e1 ? e1 : this;
    }
    getFinalBaseElement() {
        return this.hasEmptyBranch("body") ? this : this.body[this.body.length - 1].getFinalBaseElement();
    }
    isCharacterBox() {
        const e1 = this.getInitialBaseElement();
        return /mord/.test(e1.type);
    }
    hasEmptyBranch(e1) {
        const t = this.branch(e1);
        return !t || 1 === t.length;
    }
    setChildren(e1, t) {
        if (!e1) return;
        if (!nt(t)) return;
        const i = [
            this.makeFirstAtom(t),
            ...e1
        ];
        this._branches ? this._branches[t] = i : this._branches = {
            [t]: i
        };
        for (const i1 of e1)i1.parent = this, i1.treeBranch = t;
        this.isDirty = !0;
    }
    makeFirstAtom(e1) {
        const t = new ot("first", this.context, {
            mode: this.mode
        });
        return t.parent = this, t.treeBranch = e1, t;
    }
    addChild(e1, t) {
        this.createBranch(t).push(e1), this.isDirty = !0, e1.parent = this, e1.treeBranch = t;
    }
    addChildBefore(e1, t) {
        const i = this.createBranch(t.treeBranch);
        i.splice(i.indexOf(t), 0, e1), this.isDirty = !0, e1.parent = this, e1.treeBranch = t.treeBranch;
    }
    addChildAfter(e1, t) {
        const i = this.createBranch(t.treeBranch);
        i.splice(i.indexOf(t) + 1, 0, e1), this.isDirty = !0, e1.parent = this, e1.treeBranch = t.treeBranch;
    }
    addChildren(e1, t) {
        for (const i of e1)this.addChild(i, t);
    }
    addChildrenAfter(e1, t) {
        const i = this.createBranch(t.treeBranch);
        i.splice(i.indexOf(t) + 1, 0, ...e1), this.isDirty = !0;
        for (const i1 of e1)i1.parent = this, i1.treeBranch = t.treeBranch;
        return e1[e1.length - 1];
    }
    removeBranch(e1) {
        const t = this.branch(e1);
        if (nt(e1) && (this._branches[e1] = void 0), !t) return [];
        for (const e2 of t)e2.parent = void 0, e2.treeBranch = void 0;
        return t.shift(), this.isDirty = !0, t;
    }
    removeChild(e1) {
        if ("first" === e1.type) return;
        const t = this.branch(e1.treeBranch), i = t.indexOf(e1);
        t.splice(i, 1), this.isDirty = !0, e1.parent = void 0, e1.treeBranch = void 0;
    }
    get siblings() {
        return "root" === this.type ? [] : this.parent.branch(this.treeBranch);
    }
    get firstSibling() {
        return this.siblings[0];
    }
    get lastSibling() {
        const { siblings: e1  } = this;
        return e1[e1.length - 1];
    }
    get isFirstSibling() {
        return this === this.firstSibling;
    }
    get isLastSibling() {
        return this === this.lastSibling;
    }
    get hasNoSiblings() {
        return 1 === this.siblings.length;
    }
    get leftSibling() {
        const e1 = this.parent.branch(this.treeBranch);
        return e1[e1.indexOf(this) - 1];
    }
    get rightSibling() {
        const e1 = this.parent.branch(this.treeBranch);
        return e1[e1.indexOf(this) + 1];
    }
    get hasChildren() {
        return Boolean(this._branches && this.children.length > 0);
    }
    get firstChild() {
        return this.children[0];
    }
    get lastChild() {
        const { children: e1  } = this;
        return e1[e1.length - 1];
    }
    get children() {
        if (this._children) return this._children;
        if (!this._branches) return [];
        const e1 = [];
        for (const t of it)if (this._branches[t]) for (const i of this._branches[t])e1.push(...i.children), e1.push(i);
        return this._children = e1, e1;
    }
    render(e1, t) {
        if ("first" === this.type && !e1.atomIdsSettings) return null;
        const i = new Me(e1, this.style);
        let n = "";
        "root" === this.type && (n += " ML__base"), this.isSelected && (n += " ML__selected");
        let r = this.createBox(i, {
            classes: n,
            newList: !0 === (null == t ? void 0 : t.newList) || "first" === this.type
        });
        return r ? (this.subsupPlacement || !this.superscript && !this.subscript || (r = this.attachSupsub(i, {
            base: r
        })), r.wrap(i)) : null;
    }
    attachSupsub(e1, t) {
        var i, n;
        const r = t.base, o = this.superscript, a = this.subscript;
        if (!o && !a) return r;
        let s = null, l = null;
        const u = null !== (i = t.isCharacterBox) && void 0 !== i ? i : this.isCharacterBox();
        let c = 0;
        if (o) {
            const t1 = new Me(e1, void 0, "superscript");
            s = ot.createBox(t1, o, {
                newList: !0
            }), u || (c = r.height - e1.metrics.supDrop * t1.scalingFactor);
        }
        let d, h = 0;
        if (a) {
            const t2 = new Me(e1, void 0, "subscript");
            l = ot.createBox(t2, a, {
                newList: !0
            }), u || (h = r.depth + e1.metrics.subDrop * t2.scalingFactor);
        }
        d = e1.isDisplayStyle ? e1.metrics.sup1 : e1.isCramped ? e1.metrics.sup3 : e1.metrics.sup2;
        const m = .05 / e1.scalingFactor;
        let p = null;
        if (l && s) {
            c = Math.max(c, d, s.depth + .25 * e1.metrics.xHeight), h = Math.max(h, e1.metrics.sub2);
            const t3 = e1.metrics.defaultRuleThickness;
            if (c - s.depth - (l.height - h) < 4 * t3) {
                h = 4 * t3 - (c - s.depth) + l.height;
                const i1 = .8 * e1.metrics.xHeight - (c - s.depth);
                i1 > 0 && (c += i1, h -= i1);
            }
            const i2 = this.isExtensibleSymbol && r.italic ? -r.italic : 0;
            p = new Ve({
                individualShift: [
                    {
                        box: l,
                        shift: h,
                        marginLeft: i2
                    },
                    {
                        box: s,
                        shift: -c
                    }
                ]
            }).wrap(e1);
        } else l && !s ? (h = Math.max(h, e1.metrics.sub1, l.height - .3448), p = new Ve({
            shift: h,
            children: [
                {
                    box: l,
                    marginRight: m,
                    marginLeft: this.isCharacterBox() ? -(null !== (n = r.italic) && void 0 !== n ? n : 0) : 0
                }
            ]
        })) : !l && s && (c = Math.max(c, d, s.depth + .10775), p = new Ve({
            shift: -c,
            children: [
                {
                    box: s,
                    marginRight: m
                }
            ]
        }), p.wrap(e1));
        const f = new Ie(p, {
            classes: "msubsup" + (this.isSelected ? " ML__selected" : "")
        });
        return this.caret && (f.caret = this.caret), new Ie([
            r,
            f
        ], {
            type: t.type
        });
    }
    attachLimits(e1, t) {
        var i;
        const n = this.superscript ? ot.createBox(new Me(e1, this.style, "superscript"), this.superscript, {
            newList: !0
        }) : null, r = this.subscript ? ot.createBox(new Me(e1, this.style, "subscript"), this.subscript, {
            newList: !0
        }) : null;
        return n || r ? function(e1, t) {
            var i, n, r, o, a;
            const s = e1.metrics, l = new Ie(t.base), u = null !== (i = t.baseShift) && void 0 !== i ? i : 0, c = null !== (n = t.slant) && void 0 !== n ? n : 0;
            let d = 0, h = 0;
            t.above && (d = null !== (r = t.aboveShift) && void 0 !== r ? r : Math.max(s.bigOpSpacing1, s.bigOpSpacing3 - t.above.depth)), t.below && (h = null !== (o = t.belowShift) && void 0 !== o ? o : Math.max(s.bigOpSpacing2, s.bigOpSpacing4 - t.below.height));
            let m = null;
            if (t.below && t.above) {
                const i1 = s.bigOpSpacing5 + t.below.height + t.below.depth + h + l.depth + u;
                m = new Ve({
                    bottom: i1,
                    children: [
                        s.bigOpSpacing5,
                        {
                            box: t.below,
                            marginLeft: -c,
                            classes: [
                                "ML__center"
                            ]
                        },
                        h,
                        {
                            box: l,
                            classes: [
                                "ML__center"
                            ]
                        },
                        d,
                        {
                            box: t.above,
                            marginLeft: c,
                            classes: [
                                "ML__center"
                            ]
                        },
                        s.bigOpSpacing5
                    ]
                }).wrap(e1);
            } else if (t.below && !t.above) m = new Ve({
                top: l.height - u,
                children: [
                    s.bigOpSpacing5,
                    {
                        box: t.below,
                        marginLeft: -c,
                        classes: [
                            "ML__center"
                        ]
                    },
                    h,
                    {
                        box: l,
                        classes: [
                            "ML__center"
                        ]
                    }
                ]
            }).wrap(e1);
            else if (!t.below && t.above) {
                const i2 = l.depth + u;
                m = new Ve({
                    bottom: i2,
                    children: [
                        {
                            box: l,
                            classes: [
                                "ML__center"
                            ]
                        },
                        d,
                        {
                            box: t.above,
                            marginLeft: c,
                            classes: [
                                "ML__center"
                            ]
                        },
                        s.bigOpSpacing5
                    ]
                }).wrap(e1);
            } else {
                const t1 = l.depth + u;
                m = new Ve({
                    bottom: t1,
                    children: [
                        {
                            box: l
                        },
                        s.bigOpSpacing5
                    ]
                }).wrap(e1);
            }
            return new Ie(m, {
                type: null !== (a = t.type) && void 0 !== a ? a : "mop"
            });
        }(e1, {
            ...t,
            above: n,
            below: r,
            type: null !== (i = null == t ? void 0 : t.type) && void 0 !== i ? i : "mop"
        }) : t.base.wrap(e1);
    }
    bind(e1, t) {
        if (!t || e1.isPhantom || "​" === this.value) return t;
        let i = this.parent;
        for(; i && !i.captureSelection;)i = i.parent;
        return (null == i ? void 0 : i.captureSelection) || (this.id || (this.id = e1.makeID()), t.atomID = this.id), t;
    }
    createMathfieldBox(e1, t) {
        var i;
        const n = null !== (i = null == t ? void 0 : t.classes) && void 0 !== i ? i : "", r = new tt(t.placeholderId, t.element, {
            type: "mathfield",
            mode: this.mode,
            maxFontSize: e1.scalingFactor,
            style: {
                variant: "normal",
                ...this.style,
                letterShapeStyle: e1.letterShapeStyle,
                fontSize: Math.max(1, e1.size + e1.mathstyle.sizeDelta)
            },
            classes: n,
            newList: null == t ? void 0 : t.newList
        });
        return e1.isTight && (r.isTight = !0), "math" === this.mode && "main" !== this.style.variant || (r.italic = 0), r.right = r.italic, this.bind(e1, r), r;
    }
    createBox(e1, t) {
        var i, n, r, o;
        const a = null !== (i = this.value) && void 0 !== i ? i : this.body, s = function(e1) {
            return Te.includes(e1);
        }(this.type) ? this.type : void 0;
        let l = null !== (n = null == t ? void 0 : t.classes) && void 0 !== n ? n : "";
        "text" === this.mode && (l += " ML__text");
        const u = "string" == typeof a || void 0 === a ? new Ie(null !== (r = a) && void 0 !== r ? r : null, {
            type: s,
            mode: this.mode,
            maxFontSize: e1.scalingFactor,
            style: {
                variant: "normal",
                ...this.style,
                letterShapeStyle: e1.letterShapeStyle,
                fontSize: Math.max(1, e1.size + e1.mathstyle.sizeDelta)
            },
            classes: l,
            newList: null == t ? void 0 : t.newList
        }) : null !== (o = ot.createBox(e1, a, {
            type: s,
            mode: this.mode,
            style: this.style,
            classes: l,
            newList: null == t ? void 0 : t.newList
        })) && void 0 !== o ? o : new Ie(null);
        return e1.isTight && (u.isTight = !0), "math" === this.mode && "main" !== this.style.variant || (u.italic = 0), u.right = u.italic, this.bind(e1, u), this.caret && (this.superscript || this.subscript || (u.caret = this.caret)), u;
    }
    isDigit() {
        var e1;
        return "mord" === this.type && this.value ? /^[\d,.]$/.test(this.value) : "group" === this.type && 2 === (null === (e1 = this.body) || void 0 === e1 ? void 0 : e1.length) && "first" === this.body[0].type && "," === this.body[1].value;
    }
    asDigit() {
        var e1;
        return "mord" === this.type && this.value && /^[\d,.]$/.test(this.value) ? this.value : "group" === this.type && 2 === (null === (e1 = this.body) || void 0 === e1 ? void 0 : e1.length) && "first" === this.body[0].type && "," === this.body[1].value ? "." : "";
    }
    constructor(e1, t, i){
        var n, r, o, a, s, l;
        this.id = void 0, this.verbatimLatex = void 0, this._isDirty = !1, this._changeCounter = 0, this.subsupPlacement = void 0, this.explicitSubsupPlacement = !1, this.skipBoundary = !1, this.captureSelection = !1, this.type = e1, this.context = t, "string" == typeof (null == i ? void 0 : i.value) && (this.value = i.value), this.command = null !== (r = null !== (n = null == i ? void 0 : i.command) && void 0 !== n ? n : this.value) && void 0 !== r ? r : "", this.mode = null !== (o = null == i ? void 0 : i.mode) && void 0 !== o ? o : "math", this.isFunction = null !== (a = null == i ? void 0 : i.isFunction) && void 0 !== a && a, this.subsupPlacement = null == i ? void 0 : i.limits, this.style = null !== (s = null == i ? void 0 : i.style) && void 0 !== s ? s : {}, this.displayContainsHighlight = null !== (l = null == i ? void 0 : i.displayContainsHighlight) && void 0 !== l && l, (null == i ? void 0 : i.serialize) && (ot.customSerializer[i.command] = i.serialize);
    }
}
function at(e1, t) {
    if (!e1 || 0 === e1.length) return "";
    if ("first" === e1[0].type) {
        if (1 === e1.length) return "";
        e1 = e1.slice(1);
    }
    return 0 === e1.length ? "" : Qe(Ee(e1, "cssClass").map((e1)=>Qe(Ee(e1, "color").map((e1)=>Qe((function(e1) {
                const t = [];
                let i = [], n = "NONE";
                for (const r of e1)"first" !== r.type && (r.mode !== n ? (i.length > 0 && t.push(i), i = [
                    r
                ], n = r.mode) : i.push(r));
                return i.length > 0 && t.push(i), t;
            })(e1).map((e1)=>Ce.serialize(e1, t)))))));
}
function st(e1, t, i) {
    var n, r, o, a;
    function s(e1) {
        return "text" === e1.mode;
    }
    if (!t || 0 === t.length) return null;
    const l = new Me(e1, null == i ? void 0 : i.style), u = !l.atomIdsSettings || !l.atomIdsSettings.groupNumbers;
    let c, d = [], h = null !== (n = null == i ? void 0 : i.newList) && void 0 !== n && n;
    if (1 === t.length) {
        const e2 = t[0], i1 = e2.render(l, {
            newList: h
        });
        i1 && (u && e2.isSelected && i1.selected(!0), d = [
            i1
        ]);
    } else {
        let e3 = "", i2 = !0;
        for (const n1 of t){
            (null === (r = l.atomIdsSettings) || void 0 === r ? void 0 : r.groupNumbers) && e3 && (i2 && n1.isDigit() || !i2 && s(n1)) && (l.atomIdsSettings.overrideID = e3);
            const t1 = n1.render(l, {
                newList: h
            });
            l.atomIdsSettings && (l.atomIdsSettings.overrideID = void 0), t1 && (h = "group" === n1.type && !n1.boxType, (null === (o = l.atomIdsSettings) || void 0 === o ? void 0 : o.groupNumbers) && ((n1.isDigit() || s(n1)) && (e3 && i2 === n1.isDigit() || (i2 = n1.isDigit(), e3 = null !== (a = n1.id) && void 0 !== a ? a : "")), !e3 || (n1.isDigit() || s(n1)) && n1.hasEmptyBranch("superscript") && n1.hasEmptyBranch("subscript") || (e3 = "")), u && n1.isSelected && t1.selected(!0), d.push(t1));
        }
    }
    return 0 === d.length ? null : (i || l.isTight || d.length > 1 ? (c = new Ie(d, {
        isTight: l.isTight,
        ...null != i ? i : {}
    }), c.isSelected = d.every((e1)=>e1.isSelected)) : c = d[0], c.wrap(l).wrap(e1));
}
ot.customSerializer = {};
class lt extends ot {
    static fromJson(e1, t) {
        return new lt(e1.command, e1.body, t, {
            accentChar: e1.accentChar,
            svgAccent: e1.svgAccent,
            style: e1.style
        });
    }
    toJson() {
        return {
            ...super.toJson(),
            accentChar: this.accent,
            svgAccent: this.svgAccent
        };
    }
    render(e1) {
        var t;
        const i = new Me(e1, this.style, "cramp"), n = null !== (t = ot.createBox(i, this.body)) && void 0 !== t ? t : new Ie(null);
        let r = 0;
        !this.hasEmptyBranch("body") && 2 === this.body.length && this.body[1].isCharacterBox() && (r = n.skew);
        let o, a = Math.min(n.height, .431);
        if (this.svgAccent) o = Ke(this.svgAccent), a = i.metrics.bigOpSpacing1 - a;
        else if (this.accent) {
            const e2 = new Ie(this.accent, {
                fontFamily: "Main-Regular"
            });
            e2.italic = 0;
            const t1 = 8407 === this.accent ? " ML__accent-vec" : "";
            o = new Ie(new Ie(e2), {
                classes: "ML__accent-body" + t1
            });
        }
        o = new Ve({
            shift: 0,
            children: [
                {
                    box: new Ie(n)
                },
                -a,
                {
                    box: o,
                    marginLeft: n.left + 2 * r,
                    classes: [
                        "ML__center"
                    ]
                }
            ]
        });
        const s = new Ie(o, {
            newList: !0,
            type: "mord"
        });
        return this.caret && (s.caret = this.caret), this.bind(i, s.wrap(i)), this.attachSupsub(i, {
            base: s
        });
    }
    constructor(e1, t, i, n){
        super("accent", i, {
            command: e1,
            style: n.style
        }), n.accentChar ? this.accent = n.accentChar : this.svgAccent = null == n ? void 0 : n.svgAccent, this.body = t, this.skipBoundary = !0;
    }
}
const ut = {
    "(": ")",
    "{": "}",
    "[": "]",
    "|": "|",
    "\\lbrace": "\\rbrace",
    "\\lparen": "\\rparen",
    "\\{": "\\}",
    "\\langle": "\\rangle",
    "\\lfloor": "\\rfloor",
    "\\lceil": "\\rceil",
    "\\vert": "\\vert",
    "\\lvert": "\\rvert",
    "\\Vert": "\\Vert",
    "\\lVert": "\\rVert",
    "\\lbrack": "\\rbrack",
    "\\ulcorner": "\\urcorner",
    "\\llcorner": "\\lrcorner",
    "\\lgroup": "\\rgroup",
    "\\lmoustache": "\\rmoustache"
}, ct = Object.fromEntries(Object.entries(ut).map(([e1, t])=>[
        t,
        e1
    ]));
function dt(e1) {
    var t;
    return null !== (t = ({
        "[": 91,
        "]": 93,
        "(": 40,
        ")": 41,
        "\\mid": 8739,
        "|": 8739,
        "∣": 8739,
        "∥": 8741,
        "\\|": 8739,
        "\\{": 123,
        "\\}": 125,
        "\\lbrace": 123,
        "\\rbrace": 125,
        "\\lparen": 40,
        "\\rparen": 41,
        "\\lbrack": 91,
        "\\rbrack": 93,
        "\\vert": 8739,
        "\\lvert": 8739,
        "\\mvert": 8739,
        "\\rvert": 8739,
        "\\Vert": 8741,
        "\\lVert": 8741,
        "\\mVert": 8741,
        "\\rVert": 8741,
        "\\parallel": 8741,
        "\\shortparallel": 8741,
        "\\langle": 10216,
        "\\rangle": 10217,
        "\\lfloor": 8970,
        "\\rfloor": 8971,
        "\\lceil": 8968,
        "\\rceil": 8969,
        "\\ulcorner": 9484,
        "\\urcorner": 9488,
        "\\llcorner": 9492,
        "\\lrcorner": 9496,
        "\\lgroup": 10222,
        "\\rgroup": 10223,
        "\\lmoustache": 9136,
        "\\rmoustache": 9137,
        "\\surd": 8730
    })[e1]) && void 0 !== t ? t : e1.codePointAt(0);
}
function ht(e1, t, i, n, r) {
    const o = new Me(n, null == r ? void 0 : r.style, "textstyle"), a = new Ie(dt(e1), {
        fontFamily: "Size" + t + "-Regular",
        classes: "ML__delim-size" + t
    }).wrap(o);
    return i && a.setTop(.25 * (1 - o.scalingFactor)), a;
}
function mt(e1, t, i, n, r) {
    var o;
    let a, s, l, u;
    a = l = u = dt(e1), s = null;
    let c = "Size1-Regular";
    "\\vert" === e1 || "\\lvert" === e1 || "\\rvert" === e1 || "\\mvert" === e1 || "\\mid" === e1 ? l = a = u = 8739 : "\\Vert" === e1 || "\\lVert" === e1 || "\\rVert" === e1 || "\\mVert" === e1 || "\\|" === e1 ? l = a = u = 8741 : "\\uparrow" === e1 ? l = u = 9168 : "\\Uparrow" === e1 ? l = u = 8214 : "\\downarrow" === e1 ? a = l = 9168 : "\\Downarrow" === e1 ? a = l = 8214 : "\\updownarrow" === e1 ? (a = 8593, l = 9168, u = 8595) : "\\Updownarrow" === e1 ? (a = 8657, l = 8214, u = 8659) : "[" === e1 || "\\lbrack" === e1 ? (a = 9121, l = 9122, u = 9123, c = "Size4-Regular") : "]" === e1 || "\\rbrack" === e1 ? (a = 9124, l = 9125, u = 9126, c = "Size4-Regular") : "\\lfloor" === e1 || "⌊" === e1 ? (l = a = 9122, u = 9123, c = "Size4-Regular") : "\\lceil" === e1 || "⌈" === e1 ? (a = 9121, l = u = 9122, c = "Size4-Regular") : "\\rfloor" === e1 || "⌋" === e1 ? (l = a = 9125, u = 9126, c = "Size4-Regular") : "\\rceil" === e1 || "⌉" === e1 ? (a = 9124, l = u = 9125, c = "Size4-Regular") : "(" === e1 || "\\lparen" === e1 ? (a = 9115, l = 9116, u = 9117, c = "Size4-Regular") : ")" === e1 || "\\rparen" === e1 ? (a = 9118, l = 9119, u = 9120, c = "Size4-Regular") : "\\{" === e1 || "\\lbrace" === e1 ? (a = 9127, s = 9128, u = 9129, l = 9130, c = "Size4-Regular") : "\\}" === e1 || "\\rbrace" === e1 ? (a = 9131, s = 9132, u = 9133, l = 9130, c = "Size4-Regular") : "\\lgroup" === e1 || "⟮" === e1 ? (a = 9127, u = 9129, l = 9130, c = "Size4-Regular") : "\\rgroup" === e1 || "⟯" === e1 ? (a = 9131, u = 9133, l = 9130, c = "Size4-Regular") : "\\lmoustache" === e1 || "⎰" === e1 ? (a = 9127, u = 9133, l = 9130, c = "Size4-Regular") : "\\rmoustache" === e1 || "⎱" === e1 ? (a = 9131, u = 9129, l = 9130, c = "Size4-Regular") : "\\surd" === e1 ? (a = 57345, u = 9143, l = 57344, c = "Size4-Regular") : "\\ulcorner" === e1 ? (a = 9484, l = u = 32) : "\\urcorner" === e1 ? (a = 9488, l = u = 32) : "\\llcorner" === e1 ? (u = 9492, l = a = 32) : "\\lrcorner" === e1 && (a = 9496, l = a = 32);
    const d = xe(a, c), h = d.height + d.depth, m = xe(l, c), p = m.height + m.depth, f = xe(u, c), g = f.height + f.depth;
    let y = 0, b = 1;
    if (null !== s) {
        const e2 = xe(s, c);
        y = e2.height + e2.depth, b = 2;
    }
    const v = h + g + y, x = Math.max(0, Math.ceil((t - v) / (b * p))), k = v + x * b * p;
    let _ = .25;
    i && (_ *= n.scalingFactor);
    const w = k / 2 - _, S = [];
    S.push({
        box: new Ie(u, {
            fontFamily: c
        })
    }), S.push(-0.008);
    const M = new Ie(l, {
        fontFamily: c
    });
    if (null === s) for(let e3 = 0; e3 < x; e3++)S.push({
        box: M
    });
    else {
        for(let e4 = 0; e4 < x; e4++)S.push({
            box: M
        });
        S.push(-0.008), S.push({
            box: new Ie(s, {
                fontFamily: c
            })
        }), S.push(-0.008);
        for(let e5 = 0; e5 < x; e5++)S.push({
            box: M
        });
    }
    S.push(-0.008), S.push({
        box: new Ie(a, {
            fontFamily: c
        })
    });
    let N = "";
    "Size1-Regular" === c ? N = " delim-size1" : "Size4-Regular" === c && (N = " delim-size4");
    const L = new Ve({
        bottom: w,
        children: S
    }, {
        classes: N
    });
    return new Ie(L, {
        ...null != r ? r : {},
        classes: (null !== (o = null == r ? void 0 : r.classes) && void 0 !== o ? o : "") + " ML__delim-mult"
    });
}
const pt = new Set([
    "(",
    ")",
    "\\lparen",
    "\\rparen",
    "[",
    "]",
    "\\lbrack",
    "\\rbrack",
    "\\{",
    "\\}",
    "\\lbrace",
    "\\rbrace",
    "\\lfloor",
    "\\rfloor",
    "\\lceil",
    "\\rceil",
    "\\surd",
    "⌊",
    "⌋",
    "⌈",
    "⌉"
]), ft = new Set([
    "\\uparrow",
    "\\downarrow",
    "\\updownarrow",
    "\\Uparrow",
    "\\Downarrow",
    "\\Updownarrow",
    "|",
    "\\|",
    "\\vert",
    "\\Vert",
    "\\lvert",
    "\\rvert",
    "\\lVert",
    "\\rVert",
    "\\mvert",
    "\\mid",
    "\\lgroup",
    "\\rgroup",
    "\\lmoustache",
    "\\rmoustache",
    "⟮",
    "⟯",
    "⎰",
    "⎱"
]), gt = new Set([
    "<",
    ">",
    "\\langle",
    "\\rangle",
    "/",
    "\\backslash",
    "\\lt",
    "\\gt"
]), yt = [
    0,
    1.2,
    1.8,
    2.4,
    3
], bt = [
    {
        type: "small",
        mathstyle: "scriptscriptstyle"
    },
    {
        type: "small",
        mathstyle: "scriptstyle"
    },
    {
        type: "small",
        mathstyle: "textstyle"
    },
    {
        type: "large",
        size: 1
    },
    {
        type: "large",
        size: 2
    },
    {
        type: "large",
        size: 3
    },
    {
        type: "large",
        size: 4
    }
], vt = [
    {
        type: "small",
        mathstyle: "scriptscriptstyle"
    },
    {
        type: "small",
        mathstyle: "scriptscriptstyle"
    },
    {
        type: "small",
        mathstyle: "textstyle"
    },
    {
        type: "stack"
    }
], xt = [
    {
        type: "small",
        mathstyle: "scriptscriptstyle"
    },
    {
        type: "small",
        mathstyle: "scriptstyle"
    },
    {
        type: "small",
        mathstyle: "textstyle"
    },
    {
        type: "large",
        size: 1
    },
    {
        type: "large",
        size: 2
    },
    {
        type: "large",
        size: 3
    },
    {
        type: "large",
        size: 4
    },
    {
        type: "stack"
    }
];
function kt(e1, t, i, n, r, o) {
    var a;
    if (!t || 0 === t.length || "." === t) return wt(r, e1, e1);
    let s;
    "<" === t || "\\lt" === t ? t = "\\langle" : ">" !== t && "\\gt" !== t || (t = "\\rangle"), s = gt.has(t) ? bt : pt.has(t) ? xt : vt;
    const l = function(e1, t, i, n) {
        for(let o = {
            "-4": 0,
            "-3": 1,
            0: 2
        }[n.mathstyle.sizeDelta]; o < i.length && "stack" !== i[o].type; o++){
            const a = xe(e1, "small" === (r = i[o]).type ? "Main-Regular" : "large" === r.type ? "Size" + r.size + "-Regular" : "Size4-Regular");
            if (a.defaultMetrics) return {
                type: "small",
                mathstyle: "scriptstyle"
            };
            let s = a.height + a.depth;
            if ("small" === i[o].type && ("scriptscriptstyle" === i[o].mathstyle ? s *= be[Math.max(1, n.size - 2)] : "scriptstyle" === i[o].mathstyle && (s *= be[Math.max(1, n.size - 1)])), s > t) return i[o];
        }
        var r;
        return i[i.length - 1];
    }(dt(t), i, s, r), u = new Me(r, null == o ? void 0 : o.style, l.mathstyle);
    return "small" === l.type ? function(e1, t, i, n) {
        const r = new Ie(dt(e1), {
            fontFamily: "Main-Regular"
        }).wrap(t, n);
        return i && r.setTop(.25 * (1 - t.scalingFactor)), r;
    }(t, u, n, {
        type: e1,
        classes: "ML__small-delim " + (null !== (a = null == o ? void 0 : o.classes) && void 0 !== a ? a : "")
    }) : "large" === l.type ? ht(t, l.size, n, u, {
        ...o,
        type: e1
    }) : mt(t, i, n, u, {
        ...o,
        type: e1
    });
}
function _t(e1, t, i, n, r, o) {
    if ("." === t) return wt(r, e1, null == o ? void 0 : o.classes);
    const a = .25 * r.scalingFactor, s = Math.max(i - a, n + a);
    return kt(e1, t, Math.max(s / 500 * 901, 2 * s - .5), !0, r, o);
}
function wt(e1, t, i) {
    const n = new Me(e1, void 0, "textstyle");
    return new Ie(null, {
        classes: " nulldelimiter " + (null != i ? i : ""),
        type: t
    }).wrap(n);
}
class St extends ot {
    static fromJson(e1, t) {
        return new St(e1.command, t, e1);
    }
    toJson() {
        const e1 = {};
        return this.skipBoundary || (e1.skipBoundary = !1), this.subsupPlacement && (e1.subsupPlacement = this.subsupPlacement), this.svgAbove && (e1.svgAbove = this.svgAbove), this.svgBelow && (e1.svgBelow = this.svgBelow), this.svgBody && (e1.svgBody = this.svgBody), "mord" !== this.boxType && (e1.boxType = this.boxType), this.paddedBody && (e1.paddedBody = !0), this.paddedLabels && (e1.paddedLabels = !0), {
            ...super.toJson(),
            ...e1
        };
    }
    render(e1) {
        let t = this.svgBody ? Ke(this.svgBody) : ot.createBox(e1, this.body, {
            newList: !0
        });
        const i = new Me(e1, this.style, "scriptstyle");
        let n = null;
        this.svgAbove ? n = Ke(this.svgAbove) : this.above && (n = ot.createBox(i, this.above, {
            newList: !0
        }));
        let r = null;
        this.svgBelow ? r = Ke(this.svgBelow) : this.below && (r = ot.createBox(i, this.below, {
            newList: !0
        })), this.paddedBody && (t = new Ie([
            wt(e1, "mopen"),
            t,
            wt(e1, "mclose")
        ], {
            newList: !0
        }));
        let o = function(e1, t) {
            if (!t.base) return null;
            if (!t.above && !t.below) {
                const e2 = new Ie(t.base, {
                    type: t.type
                });
                return e2.setStyle("position", "relative"), e2;
            }
            let i = 0;
            t.above && (i = -t.above.depth + e1.metrics.bigOpSpacing2);
            let n = null;
            const r = t.base, o = [
                "ML__center"
            ];
            if (t.paddedAboveBelow && o.push("ML__label_padding"), t.below && t.above) {
                const a = e1.metrics.bigOpSpacing5 + t.below.height + t.below.depth + r.depth + 0;
                n = new Ve({
                    bottom: a,
                    children: [
                        e1.metrics.bigOpSpacing5,
                        {
                            box: t.below,
                            classes: o
                        },
                        {
                            box: r,
                            classes: [
                                "ML__center"
                            ]
                        },
                        i,
                        {
                            box: t.above,
                            classes: o
                        },
                        e1.metrics.bigOpSpacing5
                    ]
                });
            } else t.below ? n = new Ve({
                top: r.height - 0,
                children: [
                    e1.metrics.bigOpSpacing5,
                    {
                        box: t.below,
                        classes: o
                    },
                    {
                        box: r,
                        classes: [
                            "ML__center"
                        ]
                    }
                ]
            }) : t.above && (n = new Ve({
                bottom: r.depth + 0,
                children: [
                    {
                        box: r,
                        classes: [
                            "ML__center"
                        ]
                    },
                    i,
                    {
                        box: t.above,
                        classes: o
                    },
                    e1.metrics.bigOpSpacing5
                ]
            }));
            return new Ie(n, {
                type: t.type
            });
        }(e1, {
            base: t,
            above: n,
            below: r,
            type: "mbin" === this.boxType || "mrel" === this.boxType ? this.boxType : "mord",
            paddedAboveBelow: this.paddedLabels
        });
        return o ? (o = "over-under" === this.subsupPlacement ? this.attachLimits(e1, {
            base: o,
            type: o.type
        }) : this.attachSupsub(e1, {
            base: o
        }), this.caret && (o.caret = this.caret), this.bind(e1, o)) : null;
    }
    constructor(e1, t, i){
        var n, r, o, a;
        super("overunder", t, {
            command: e1,
            serialize: i.serialize,
            style: i.style
        }), this.skipBoundary = null === (n = i.skipBoundary) || void 0 === n || n, this.subsupPlacement = i.supsubPlacement, this.body = i.body, this.svgAbove = i.svgAbove, this.svgBelow = i.svgBelow, this.svgBody = i.svgBody, this.above = i.above, this.below = i.below, this.boxType = null !== (r = i.boxType) && void 0 !== r ? r : "mord", this.paddedBody = null !== (o = i.paddedBody) && void 0 !== o && o, this.paddedLabels = null !== (a = i.paddedLabels) && void 0 !== a && a;
    }
}
class Mt extends ot {
    static fromJson(e1, t) {
        return new Mt(e1.body, t, e1);
    }
    toJson() {
        const e1 = {};
        return this.mathstyleName && (e1.mathstyleName = this.mathstyleName), this.latexOpen && (e1.latexOpen = this.latexOpen), this.latexClose && (e1.latexClose = this.latexClose), this.cssId && (e1.cssId = this.cssId), this.htmlData && (e1.htmlData = this.htmlData), this.htmlStyle && (e1.htmlStyle = this.htmlStyle), this.customClass && (e1.customClass = this.customClass), this.boxType && (e1.boxType = this.boxType), this.captureSelection && (e1.captureSelection = !0), this.changeMode && (e1.changeMode = !0), {
            ...super.toJson(),
            ...e1
        };
    }
    render(e1) {
        const t = new Me(e1, this.style, this.mathstyleName), i = ot.createBox(t, this.body, {
            type: this.boxType,
            classes: this.customClass,
            mode: this.mode,
            style: {
                backgroundColor: this.style.backgroundColor
            },
            newList: !this.boxType
        });
        return i ? (this.cssId && (i.cssId = this.cssId), this.htmlData && (i.htmlData = this.htmlData), this.htmlStyle && (i.htmlStyle = this.htmlStyle), this.caret && (i.caret = this.caret), this.bind(e1, i)) : null;
    }
    serialize(e1) {
        let t = this.bodyToLatex(e1);
        return "string" == typeof this.latexOpen && (t = this.latexOpen + t + this.latexClose), this.htmlData && (t = `\\htmlData{${this.htmlData}}{${t}}`), this.htmlStyle && (t = `\\htmlStyle{${this.htmlStyle}}{${t}}`), this.customClass && (t = `\\class{${this.customClass}}{${t}}`), this.cssId && (t = `\\cssId{${this.cssId}}{${t}}`), t;
    }
    constructor(e1, t, i){
        var n, r, o;
        super("group", t, {
            command: null == i ? void 0 : i.command,
            mode: null !== (n = null == i ? void 0 : i.mode) && void 0 !== n ? n : "math",
            serialize: null == i ? void 0 : i.serialize,
            style: null == i ? void 0 : i.style
        }), this.body = e1, this.mathstyleName = null == i ? void 0 : i.mathstyleName, this.latexOpen = null == i ? void 0 : i.latexOpen, this.latexClose = null == i ? void 0 : i.latexClose, this.cssId = null == i ? void 0 : i.cssId, this.htmlData = null == i ? void 0 : i.htmlData, this.htmlStyle = null == i ? void 0 : i.htmlStyle, this.customClass = null == i ? void 0 : i.customClass, this.boxType = null == i ? void 0 : i.boxType, this.skipBoundary = !0, this.captureSelection = null !== (r = null == i ? void 0 : i.captureSelection) && void 0 !== r && r, this.changeMode = null !== (o = null == i ? void 0 : i.changeMode) && void 0 !== o && o, this.displayContainsHighlight = !1, e1 && 1 === e1.length && "," === e1[0].command && (this.captureSelection = !0);
    }
}
class Nt extends ot {
    static fromJson(e1, t) {
        return new Nt(e1.command, e1.style, t, e1.width);
    }
    toJson() {
        const e1 = {};
        return this.width && (e1.width = this.width), {
            ...super.toJson(),
            ...e1
        };
    }
    render(e1) {
        var t;
        let i;
        if (this.width) i = new Ie(null, {
            classes: "mspace"
        }), i.left = we(this.width.glue);
        else {
            const e2 = null !== (t = ({
                "\\qquad": "qquad",
                "\\quad": "quad",
                "\\enspace": "enspace",
                "\\;": "thickspace",
                "\\:": "mediumspace",
                "\\,": "thinspace",
                "\\!": "negativethinspace"
            })[this.command]) && void 0 !== t ? t : "mediumspace";
            i = new Ie(null, {
                classes: e2
            });
        }
        return i = this.bind(e1, i), this.caret && (i.caret = this.caret), i;
    }
    serialize(e1) {
        var t;
        let i = null !== (t = this.command) && void 0 !== t ? t : "";
        return "\\hspace" === this.command || "\\hspace*" === this.command ? Number.isFinite(this.width) ? i += `{${this.width}em'}` : i += "{0pt}" : Number.isFinite(this.width) && (i += ` ${this.width}em`), i;
    }
    constructor(e1, t, i, n){
        super("spacing", i, {
            command: e1,
            style: t
        }), this.width = n;
    }
}
class Lt extends ot {
    static fromJson(e1, t) {
        var i;
        return new Lt(null !== (i = e1.variant) && void 0 !== i ? i : "", e1.body, t, e1);
    }
    toJson() {
        const e1 = super.toJson();
        return this.variant && (e1.variant = this.variant), this.leftDelim && (e1.leftDelim = this.leftDelim), this.rightDelim && (e1.rightDelim = this.rightDelim), e1;
    }
    serialize(e1) {
        var t, i;
        const n = this.matchingRightDelim();
        return "left...right" === this.variant ? Qe([
            "\\left" + (null !== (t = this.leftDelim) && void 0 !== t ? t : "."),
            this.bodyToLatex(e1),
            "\\right" + n
        ]) : "mleft...mright" === this.variant ? Qe([
            "\\mleft" + (null !== (i = this.leftDelim) && void 0 !== i ? i : "."),
            this.bodyToLatex(e1),
            "\\mright" + n
        ]) : Qe([
            this.leftDelim && "." !== this.leftDelim ? this.leftDelim : "",
            this.bodyToLatex(e1),
            n
        ]);
    }
    matchingRightDelim() {
        var e1, t;
        if (this.rightDelim && "?" !== this.rightDelim) return this.rightDelim;
        const i = null !== (e1 = this.leftDelim) && void 0 !== e1 ? e1 : ".";
        return null !== (t = ut[i]) && void 0 !== t ? t : i;
    }
    render(e1) {
        var t, i, n;
        const r = new Me(e1, this.style), o = new Me(e1, this.style, "textstyle"), a = null !== (t = ot.createBox(r, this.body, {
            newList: !0
        })) && void 0 !== t ? t : new Ie(null, {
            newList: !0
        }), s = a.height / o.scalingFactor, l = a.depth / o.scalingFactor, u = [];
        if (this.leftDelim && u.push(this.bind(o, _t("mopen", this.leftDelim, s, l, o, {
            classes: "ML__open" + (this.containsCaret ? " ML__contains-caret" : ""),
            mode: this.mode,
            style: this.style
        }))), a) {
            if (a.children) for(let e2 = 0; e2 < a.children.length; e2++){
                const t1 = a.children[e2];
                if (t1.delim) {
                    const i1 = t1.caret;
                    a.children[e2] = this.bind(r, _t("minner", t1.delim, s, l, r)), a.children[e2].caret = i1;
                }
            }
            u.push(a);
        }
        if (this.rightDelim) {
            let e3 = this.containsCaret ? " ML__contains-caret" : "", t2 = this.rightDelim;
            "?" === t2 && (this.context.smartFence ? (t2 = this.matchingRightDelim(), e3 += " ML__smart-fence__close") : t2 = "."), u.push(this.bind(o, _t("mclose", t2, s, l, o, {
                classes: e3 + " ML__close",
                mode: this.mode,
                style: this.style
            })));
        }
        const c = null !== (n = "mleft...mright" === this.variant || (null === (i = this.leftSibling) || void 0 === i ? void 0 : i.isFunction)) && void 0 !== n && n, d = new Ie(u, {
            type: c ? "mclose" : "minner",
            classes: "left-right"
        });
        return this.caret && (d.caret = this.caret), this.bind(r, d.wrap(r));
    }
    constructor(e1, t, i, n){
        super("leftright", i, {
            style: n.style,
            displayContainsHighlight: !0
        }), this.variant = e1, this.body = t, this.leftDelim = n.leftDelim, this.rightDelim = n.rightDelim;
    }
}
class At extends ot {
    static fromJson(e1, t) {
        const i = new At(t, e1);
        for (const t1 of it)e1[t1] && i.setChildren(e1[t1], t1);
        return i;
    }
    toJson() {
        return super.toJson();
    }
    render(e1) {
        var t;
        const i = new Me(e1, {
            isPhantom: !0
        }), n = null !== (t = this.leftSibling.render(i)) && void 0 !== t ? t : new Ie(null), r = new Ie(null, {
            height: n.height,
            depth: n.depth
        });
        return this.attachSupsub(e1, {
            base: r,
            isCharacterBox: this.leftSibling.isCharacterBox(),
            type: "supsub"
        });
    }
    serialize(e1) {
        return this.supsubToLatex(e1);
    }
    constructor(e1, t){
        super("msubsup", e1, {
            style: null == t ? void 0 : t.style
        });
    }
}
class Ct extends ot {
    static fromJson(e1, t) {
        return new Ct(t, e1);
    }
    toJson() {
        const e1 = super.toJson();
        return this.placeholderId && (e1.placeholderId = this.placeholderId), this.value === this.context.placeholderSymbol && delete e1.value, this.defaultValue && (e1.defaultValue = this.defaultValue.map((e1)=>e1.toJson())), e1;
    }
    render(e1) {
        if ("function" == typeof e1.renderPlaceholder) return e1.renderPlaceholder(e1, this);
        let t = "";
        return this.caret && (t += "ML__placeholder-selected"), this.isSelected && (t += "ML__selected"), this.createBox(e1, {
            classes: t
        });
    }
    serialize(e1) {
        var t;
        let i = null !== (t = this.value) && void 0 !== t ? t : "";
        return i === this.context.placeholderSymbol && (i = ""), `\\placeholder${this.placeholderId ? `[${this.placeholderId}]` : ""}${this.defaultValue ? `[${ot.serialize(this.defaultValue, e1)}]` : ""}{${i}}`;
    }
    constructor(e1, t){
        var i;
        const n = (null == t ? void 0 : t.value) || e1.placeholderSymbol;
        super("placeholder", e1, {
            mode: null !== (i = null == t ? void 0 : t.mode) && void 0 !== i ? i : "math",
            style: null == t ? void 0 : t.style,
            value: n,
            command: "\\placeholder"
        }), this.captureSelection = !0, this.placeholderId = null == t ? void 0 : t.placeholderId, (null == t ? void 0 : t.default) && (this.defaultValue = null == t ? void 0 : t.default);
    }
}
class Et extends ot {
    static fromJson(e1, t) {
        return new Et(e1.command, t);
    }
    toJson() {
        return super.toJson();
    }
    render(e1) {
        const t = this.createBox(e1, {
            classes: "ML__error"
        });
        return this.caret && (t.caret = this.caret), t;
    }
    constructor(e1, t){
        super("error", t, {
            value: e1,
            command: e1,
            mode: "math"
        }), this.verbatimLatex = e1;
    }
}
class Tt extends ot {
    static fromJson(e1, t) {
        return new Tt(e1.command, t, e1);
    }
    toJson() {
        const e1 = super.toJson();
        return this.expand && (e1.expand = !0), void 0 !== this.captureSelection && (e1.captureSelection = this.captureSelection), this.macroArgs && (e1.args = this.macroArgs), e1;
    }
    serialize(e1) {
        return e1.expandMacro && this.expand ? this.bodyToLatex(e1) : this.command + this.macroArgs;
    }
    render(e1) {
        const t = ot.createBox(e1, this.body);
        return t ? (this.caret && (t.caret = this.caret), this.bind(e1, t)) : null;
    }
    constructor(e1, t, i){
        var n, r;
        super("macro", t, {
            command: e1
        }), this.body = i.body, void 0 === i.captureSelection ? i.args ? this.captureSelection = !1 : this.captureSelection = !0 : this.captureSelection = i.captureSelection, this.macroArgs = null !== (n = i.args) && void 0 !== n ? n : "", this.expand = null !== (r = i.expand) && void 0 !== r && r;
    }
}
class Dt extends ot {
    static fromJson(e1, t) {
        return new Dt(e1.command, e1.value, e1.style, t);
    }
    toJson() {
        return super.toJson();
    }
    render(e1) {
        const t = this.createBox(e1);
        return this.caret && (t.caret = this.caret), t;
    }
    serialize(e1) {
        var t;
        return null !== (t = this.verbatimLatex) && void 0 !== t ? t : D("text", this.value.codePointAt(0));
    }
    constructor(e1, t, i, n){
        super("text", n, {
            command: e1,
            mode: "text",
            displayContainsHighlight: !0
        }), this.value = t, this.verbatimLatex = t, this.applyStyle(i);
    }
}
function zt(e1) {
    return !/^<({|}|\$|\$\$|space)>$/.test(e1);
}
class qt {
    get currentContext() {
        return this._currentParsingContext;
    }
    get rootContext() {
        let e1 = this._currentParsingContext;
        for(; e1.parent;)e1 = e1.parent;
        return e1;
    }
    beginContext(e1) {
        var t, i, n;
        const r = {
            parent: this.currentContext,
            mathlist: [],
            style: {
                ...this.currentContext.style
            },
            parseMode: null !== (t = null == e1 ? void 0 : e1.mode) && void 0 !== t ? t : this.currentContext.parseMode,
            mathstyle: null !== (i = null == e1 ? void 0 : e1.mathstyle) && void 0 !== i ? i : this.currentContext.mathstyle,
            registers: null,
            tabular: null !== (n = null == e1 ? void 0 : e1.tabular) && void 0 !== n && n
        };
        this._currentParsingContext = r;
    }
    endContext() {
        this._currentParsingContext = this._currentParsingContext.parent;
    }
    onError(e1) {
        this.errors.push({
            before: et(this.tokens.slice(this.index, this.index + 10)),
            after: et(this.tokens.slice(Math.max(0, this.index - 10), this.index)),
            ...e1
        });
    }
    get mathlist() {
        return this.currentContext.mathlist;
    }
    set mathlist(e1) {
        this.currentContext.mathlist = e1;
    }
    get parseMode() {
        return this.currentContext.parseMode;
    }
    set parseMode(e1) {
        this.currentContext.parseMode = e1;
    }
    get tabularMode() {
        return this.currentContext.tabular;
    }
    get style() {
        let e1 = this.currentContext;
        for(; e1;){
            if (e1.style) return e1.style;
            e1 = e1.parent;
        }
        return {};
    }
    set style(e1) {
        this.currentContext.style = e1;
    }
    getRegister(e1) {
        var t, i, n;
        if (e1.startsWith("global ")) return null !== (i = null === (t = this.rootContext.registers) || void 0 === t ? void 0 : t[e1.slice(7)]) && void 0 !== i ? i : 0;
        let r = this.currentContext;
        for(; r;){
            if (null === (n = r.registers) || void 0 === n ? void 0 : n[e1]) return r.registers[e1];
            r = r.parent;
        }
        return 0;
    }
    setRegister(e1, t) {
        var i;
        if (e1.startsWith("global ")) {
            e1 = e1.slice(7);
            let n = this.currentContext;
            for(; n;)(null === (i = n.registers) || void 0 === i ? void 0 : i[e1]) && delete n.registers[e1], n = n.parent;
            this.rootContext.registers[e1] = t;
        } else this.currentContext.registers || (this.currentContext.registers = {}), this.currentContext.registers[e1] = t;
    }
    end() {
        return this.endCount++, this.index >= this.tokens.length || this.endCount > 1e3;
    }
    get() {
        return this.endCount = 0, this.index < this.tokens.length ? this.tokens[this.index++] : "";
    }
    peek() {
        return this.tokens[this.index];
    }
    match(e1) {
        return this.tokens[this.index] === e1 && (this.index++, !0);
    }
    lastSubsupAtom() {
        let e1;
        if (this.mathlist.length > 0) {
            if (e1 = this.mathlist[this.mathlist.length - 1], "msubsup" === e1.type) return e1;
            if (void 0 !== e1.subsupPlacement) return e1;
        }
        return e1 = new At(this.context, {
            style: this.style
        }), this.mathlist.push(e1), e1;
    }
    hasPattern(e1) {
        return e1.test(this.tokens[this.index]);
    }
    hasInfixCommand() {
        var e1;
        const { index: t  } = this;
        if (t < this.tokens.length && this.tokens[t].startsWith("\\")) {
            const i = this.context.getDefinition(this.tokens[t], this.parseMode);
            return !(!i || "symbol" === i.definitionType) && !(i.ifMode && !i.ifMode.includes(this.parseMode)) && null !== (e1 = i.infix) && void 0 !== e1 && e1;
        }
        return !1;
    }
    matchColumnSeparator() {
        const { index: e1  } = this;
        return !(!this.tabularMode || "&" !== this.tokens[e1] || (this.index++, 0));
    }
    matchRowSeparator() {
        const { index: e1  } = this;
        return !(!this.tabularMode || "\\\\" !== this.tokens[e1] && "\\cr" !== this.tokens[e1] || (this.index++, 0));
    }
    placeholder() {
        var e1;
        const t = null === (e1 = this.args) || void 0 === e1 ? void 0 : e1.call(this, "?");
        return t ? It(t, this.context, {
            parseMode: this.parseMode,
            mathstyle: "textstyle"
        }) : [
            new Ct(this.context, {
                mode: this.parseMode,
                style: this.style
            })
        ];
    }
    matchWhitespace() {
        let e1 = !1;
        for(; this.match("<space>");)e1 = !0;
        return e1;
    }
    skipUntilToken(e1) {
        let t = this.tokens[this.index];
        for(; t && t !== e1;)t = this.tokens[++this.index];
        t === e1 && this.index++;
    }
    skipFiller() {
        let e1 = !1;
        do {
            const t = this.matchWhitespace(), i = this.match("\\relax");
            e1 = !t && !i;
        }while (!e1);
    }
    matchKeyword(e1) {
        const t = this.index;
        let i = this.end(), n = "";
        for(; !i;){
            const t1 = this.get();
            zt(t1) ? (n += t1, i = this.end() || n.length >= e1.length) : i = !0;
        }
        const r = e1.toUpperCase() === n.toUpperCase();
        return r || (this.index = t), r;
    }
    scanString() {
        let e1 = "";
        for(; !this.end();)if (this.match("<space>")) e1 += " ";
        else {
            const t = this.peek();
            if ("]" === t) break;
            if (zt(t)) e1 += this.get();
            else {
                if (!t.startsWith("\\")) break;
                this.onError({
                    code: "unbalanced-braces"
                }), e1 += this.get();
            }
        }
        return e1;
    }
    scanBalancedString() {
        let e1 = "", t = this.end(), i = 1;
        for(; !t;){
            if (this.match("<space>")) e1 += " ";
            else {
                const t1 = this.get();
                "<{>" === t1 ? (e1 += "{", i += 1) : "<}>" === t1 ? (i -= 1, i > 0 ? e1 += "}" : this.index -= 1) : e1 += "<$>" === t1 ? "$" : "<$$>" === t1 ? "$$" : t1;
            }
            t = 0 === i || this.end();
        }
        return e1;
    }
    matchLiteralArg() {
        var e1;
        let t = "";
        if (this.match("<{>")) {
            let i = 1;
            for(; i > 0 && !this.end();){
                const n = this.get();
                "<}>" === n ? (i -= 1, i > 0 && (t += "}")) : "<{>" === n ? (i += 1, t += "{") : t += null !== (e1 = ({
                    "<space>": " ",
                    "<$$>": "$$",
                    "<$>": "$"
                })[n]) && void 0 !== e1 ? e1 : n;
            }
        }
        return t;
    }
    scanNumber(e1 = !0) {
        var t, i;
        let n = !1, r = this.peek();
        for(; "<space>" === r || "+" === r || "-" === r;)this.get(), "-" === r && (n = !n), r = this.peek();
        e1 = Boolean(e1);
        let o = 10, a = /\d/;
        if (this.match("'")) o = 8, a = /[0-7]/, e1 = !0;
        else if (this.match('"') || this.match("x")) o = 16, a = /[\dA-F]/, e1 = !0;
        else if (this.match("`")) return r = this.get(), r ? r.startsWith("\\") && 2 === r.length ? (n ? -1 : 1) * (null !== (t = r.codePointAt(1)) && void 0 !== t ? t : 0) : (n ? -1 : 1) * (null !== (i = r.codePointAt(0)) && void 0 !== i ? i : 0) : null;
        let s = "";
        for(; this.hasPattern(a);)s += this.get();
        if (!e1 && (this.match(".") || this.match(","))) for(s += "."; this.hasPattern(a);)s += this.get();
        const l = e1 ? Number.parseInt(s, o) : Number.parseFloat(s);
        return Number.isNaN(l) ? null : n ? -l : l;
    }
    scanDimen() {
        var e1, t, i;
        let n, r = this.scanNumber(!1);
        if (null === r) {
            if (!(null === (e1 = this.peek()) || void 0 === e1 ? void 0 : e1.startsWith("\\"))) return null;
            r = 1;
        }
        return this.matchWhitespace(), this.matchKeyword("pt") ? n = {
            dimension: r,
            unit: "pt"
        } : this.matchKeyword("mm") ? n = {
            dimension: r,
            unit: "mm"
        } : this.matchKeyword("cm") ? n = {
            dimension: r,
            unit: "cm"
        } : this.matchKeyword("ex") ? n = {
            dimension: r,
            unit: "ex"
        } : this.matchKeyword("px") ? n = {
            dimension: r,
            unit: "px"
        } : this.matchKeyword("em") ? n = {
            dimension: r,
            unit: "em"
        } : this.matchKeyword("bp") ? n = {
            dimension: r,
            unit: "bp"
        } : this.matchKeyword("dd") ? n = {
            dimension: r,
            unit: "dd"
        } : this.matchKeyword("pc") ? n = {
            dimension: r,
            unit: "pc"
        } : this.matchKeyword("in") ? n = {
            dimension: r,
            unit: "in"
        } : this.matchKeyword("mu") ? n = {
            dimension: r,
            unit: "mu"
        } : (null === (t = this.peek()) || void 0 === t ? void 0 : t.startsWith("\\")) ? (n = null !== (i = Bt(this.getRegister(this.get().slice(1)), this.context)) && void 0 !== i ? i : {
            dimension: 0
        }, n.dimension *= r) : (this.match("\\relax") || this.onError({
            code: "missing-unit"
        }), n = {
            dimension: r,
            unit: "pt"
        }), n;
    }
    scanGlue() {
        const e1 = this.scanDimen();
        if (null === e1) return null;
        const t = {
            glue: e1
        };
        return this.matchWhitespace(), this.match("\\relax") || (this.matchKeyword("plus") && this.scanDimen(), this.matchWhitespace(), this.match("\\relax") || (this.matchWhitespace(), this.matchKeyword("minus") && this.scanDimen())), t;
    }
    scanColspec() {
        this.matchWhitespace();
        const e1 = [];
        for(; !this.end() && "<}>" !== this.peek() && "]" !== this.peek();){
            const t = this.get();
            "c" === t || "r" === t || "l" === t ? e1.push({
                align: t
            }) : "|" === t ? e1.push({
                separator: "solid"
            }) : ":" === t ? e1.push({
                separator: "dashed"
            }) : "@" === t && (this.match("<{>") && (this.beginContext({
                mode: "math"
            }), e1.push({
                gap: this.parse((e1)=>"<}>" === e1)
            }), this.endContext()), this.match("<}>") || this.onError({
                code: "unbalanced-braces"
            }));
        }
        return e1;
    }
    parseModeSet() {
        let e1 = "";
        if (this.match("\\(") && (e1 = "\\)"), !e1 && this.match("\\[") && (e1 = "\\]"), !e1) return null;
        this.beginContext({
            mode: "math",
            mathstyle: "\\)" === e1 ? "textstyle" : "displaystyle"
        });
        const t = new Mt(this.parse((t)=>t === e1), this.context, {
            mathstyleName: "\\)" === e1 ? "textstyle" : "displaystyle",
            latexOpen: "\\]" === e1 ? "\\[" : "\\(",
            latexClose: e1,
            boxType: "mord"
        });
        return this.match(e1) || this.onError({
            code: "unbalanced-mode-shift"
        }), this.endContext(), t.hasEmptyBranch("body") ? null : t;
    }
    parseModeShift() {
        let e1 = "";
        if (this.match("<$>") && (e1 = "<$>"), !e1 && this.match("<$$>") && (e1 = "<$$>"), !e1) return null;
        this.beginContext({
            mode: "math",
            mathstyle: "textstyle"
        });
        const t = new Mt(this.parse((t)=>t === e1), this.context, {
            mathstyleName: "<$>" === e1 ? "textstyle" : "displaystyle",
            latexOpen: "<$>" === e1 ? "$ " : "$$ ",
            latexClose: "<$>" === e1 ? " $" : " $$"
        });
        return this.match(e1) || this.onError({
            code: "unbalanced-mode-shift"
        }), this.endContext(), t.hasEmptyBranch("body") ? null : t;
    }
    parseEnvironment() {
        if (!this.match("\\begin")) return null;
        const e1 = this.parseArgument("string");
        if (!e1) return null;
        const t = function(e1) {
            var t;
            return null !== (t = w[e1]) && void 0 !== t ? t : null;
        }(e1);
        if (!t) return this.onError({
            code: "unknown-environment",
            arg: e1
        }), null;
        const i = [];
        if (t.params) for (const n of t.params)if (n.isOptional) i.push(this.parseOptionalArgument(n.type));
        else {
            const t1 = this.parseArgument(n.type);
            t1 || this.onError({
                code: "missing-argument",
                arg: e1
            }), i.push(t1);
        }
        this.beginContext({
            tabular: t.tabular
        });
        const n1 = [], r = [];
        let o = [], a = !1;
        do if (this.end() && (this.onError({
            code: "unbalanced-environment",
            arg: e1
        }), a = !0), !a && this.match("\\end") && (this.parseArgument("string") !== e1 && this.onError({
            code: "unbalanced-environment",
            arg: e1
        }), a = !0), !a) {
            if (this.matchColumnSeparator()) o.push(this.mathlist), this.mathlist = [];
            else if (this.matchRowSeparator()) {
                o.push(this.mathlist), this.mathlist = [];
                let e2 = null;
                this.matchWhitespace(), this.match("[") && (e2 = this.scanDimen(), this.matchWhitespace(), this.match("]")), r.push(null != e2 ? e2 : {
                    dimension: 0
                }), n1.push(o), o = [];
            } else this.mathlist.push(...this.parse((e1)=>"<}>" === e1 || "&" === e1 || "\\end" === e1 || "\\cr" === e1 || "\\\\" === e1));
        }
        while (!a);
        return o.push(this.mathlist), o.length > 0 && n1.push(o), this.endContext(), t.createAtom(this.context, e1, n1, r, i);
    }
    parse(e1) {
        this.beginContext(), e1 || (e1 = (e1)=>"<}>" === e1);
        let t = "", i = null, n = [], r = null;
        const o = this.mathlist;
        for(this.mathlist = []; !this.end() && !e1(this.peek());)this.hasInfixCommand() && !t ? (t = this.get(), i = this.context.getDefinition(t, "math"), i && (n = this.parseArguments(i)[1]), r = this.mathlist, this.mathlist = []) : this.parseToken();
        let a;
        return t ? (n.unshift(this.mathlist), this.mathlist = o, r && n.unshift(r), a = [
            i.createAtom(t, n, this.style, this.context)
        ]) : (a = this.mathlist, this.mathlist = o), this.endContext(), a;
    }
    parseGroup() {
        if (!this.match("<{>")) return null;
        const e1 = new Mt(this.parse((e1)=>"<}>" === e1), this.context, {
            mode: this.parseMode,
            latexOpen: "{",
            latexClose: "}"
        });
        return this.match("<}>") || this.onError({
            code: "unbalanced-braces"
        }), e1;
    }
    scanSmartFence() {
        if (this.matchWhitespace(), !this.match("(")) return null;
        this.beginContext();
        let e1 = 1;
        for(; !this.end() && 0 !== e1;)this.match("(") && (e1 += 1), this.match(")") && (e1 -= 1), 0 !== e1 && this.parseToken();
        0 === e1 && this.match(")");
        const t = new Lt("", this.mathlist, this.context, {
            leftDelim: "(",
            rightDelim: 0 === e1 ? ")" : "?"
        });
        return this.endContext(), t;
    }
    scanDelim() {
        this.matchWhitespace();
        const e1 = this.get();
        if (!e1) return this.onError({
            code: "unexpected-end-of-string"
        }), null;
        let t = ".";
        (e1.startsWith("\\") || zt(e1)) && (t = e1);
        const i = this.context.getDefinition(t, "math");
        return i ? "function" === i.definitionType && i.ifMode && !i.ifMode.includes(this.parseMode) ? (this.onError({
            code: "unexpected-delimiter",
            arg: t
        }), null) : "symbol" !== i.definitionType || "mopen" !== i.type && "mclose" !== i.type ? /^(\.|\?|\||<|>|\\vert|\\Vert|\\\||\\surd|\\uparrow|\\downarrow|\\Uparrow|\\Downarrow|\\updownarrow|\\Updownarrow|\\mid|\\mvert|\\mVert)$/.test(t) ? t : (this.onError({
            code: "unexpected-delimiter",
            arg: t
        }), null) : t : (this.onError({
            code: "unknown-command",
            arg: t
        }), null);
    }
    parseLeftRight() {
        var e1;
        if (this.match("\\right") || this.match("\\mright")) return this.onError({
            code: "unbalanced-braces"
        }), null;
        let t = "\\right";
        if (!this.match("\\left")) {
            if (!this.match("\\mleft")) return null;
            t = "\\mright";
        }
        const i = this.scanDelim();
        if (!i) return null;
        for(this.beginContext(); !this.end() && !this.match(t);)this.parseToken();
        const n = this.mathlist;
        this.endContext();
        const r = null !== (e1 = this.scanDelim()) && void 0 !== e1 ? e1 : ".";
        return new Lt("\\right" === t ? "left...right" : "mleft...mright", n, this.context, {
            leftDelim: i,
            rightDelim: r,
            style: this.style
        });
    }
    parseSupSub() {
        if ("math" !== this.parseMode) return !1;
        let e1 = this.peek();
        if ("^" !== e1 && "_" !== e1 && "'" !== e1) return !1;
        for(; "^" === e1 || "_" === e1 || "'" === e1;){
            if (this.match("'")) this.match("'") ? this.lastSubsupAtom().addChild(new ot("mord", this.context, {
                command: "\\doubleprime",
                mode: "math",
                value: "′′"
            }), "superscript") : this.lastSubsupAtom().addChild(new ot("mord", this.context, {
                command: "\\prime",
                mode: "math",
                value: "′"
            }), "superscript");
            else if (this.match("^") || this.match("_")) {
                const t = this.parseArgument("math");
                t ? this.lastSubsupAtom().addChildren(t, "_" === e1 ? "subscript" : "superscript") : this.lastSubsupAtom().createBranch("_" === e1 ? "subscript" : "superscript");
            }
            e1 = this.peek();
        }
        return !0;
    }
    parseLimits() {
        const e1 = this.match("\\limits"), t = !e1 && this.match("\\nolimits"), i = !t && !e1 && this.match("\\displaylimits");
        if (!e1 && !t && !i) return !1;
        const n = this.mathlist.length > 0 ? this.mathlist[this.mathlist.length - 1] : null;
        return !(null === n || "mop" !== n.type || (e1 ? (n.subsupPlacement = "over-under", n.explicitSubsupPlacement = !0, 0) : t ? (n.subsupPlacement = "adjacent", n.explicitSubsupPlacement = !0, 0) : !i || (n.subsupPlacement = "auto", n.explicitSubsupPlacement = !0, 0)));
    }
    parseArguments(e1) {
        if (!(null == e1 ? void 0 : e1.params)) return [
            void 0,
            []
        ];
        let t;
        const i = [];
        let n = e1.infix ? 2 : 0;
        for(; n < e1.params.length;){
            const r = e1.params[n];
            if ("rest" === r.type) i.push(this.parse((e1)=>"<}>" === e1 || "&" === e1 || "\\end" === e1 || "\\cr" === e1 || "\\\\" === e1));
            else if (r.isOptional) i.push(this.parseOptionalArgument(r.type));
            else if (r.type.endsWith("*")) t = r.type.slice(0, -1);
            else {
                const e2 = this.parseArgument(r.type);
                if (null !== e2) i.push(e2);
                else switch(this.onError({
                    code: "missing-argument"
                }), r.type){
                    case "number":
                        i.push(0);
                        break;
                    case "dimen":
                        i.push({
                            dimension: 0,
                            unit: "pt"
                        });
                        break;
                    case "glue":
                        i.push({
                            glue: {
                                dimension: 0,
                                unit: "pt"
                            }
                        });
                        break;
                    case "string":
                    case "balanced-string":
                        i.push("");
                        break;
                    case "delim":
                        i.push(".");
                        break;
                    case "colspec":
                        i.push("llllllllll");
                        break;
                    default:
                        i.push(this.placeholder());
                }
            }
            n += 1;
        }
        return [
            t,
            i
        ];
    }
    parseArgument(e1) {
        var t, i;
        this.skipFiller(), "auto" === e1 && (e1 = this.parseMode);
        let n = null;
        const r = "<{>" === this.peek();
        if (!r) {
            if ("delim" === e1) return null !== (t = this.scanDelim()) && void 0 !== t ? t : ".";
            if ("text" === e1 || "math" === e1) {
                this.beginContext();
                const e2 = this.parseSimpleToken();
                return this.endContext(), e2;
            }
        }
        if (r && this.get(), "text" === e1 || "math" === e1) {
            this.beginContext({
                mode: e1
            });
            do this.mathlist.push(...this.parse());
            while (!this.match("<}>") && !this.end());
        } else if (this.beginContext(), "string" === e1 ? n = this.scanString() : "balanced-string" === e1 ? n = this.scanBalancedString() : "number" === e1 ? n = this.scanNumber() : "colspec" === e1 ? n = this.scanColspec() : "dimen" === e1 ? n = this.scanDimen() : "glue" === e1 ? n = this.scanGlue() : "delim" === e1 && (n = null !== (i = this.scanDelim()) && void 0 !== i ? i : "."), r && this.skipUntilToken("<}>"), null === n) return this.endContext(), null;
        const o = this.mathlist;
        return this.endContext(), null != n ? n : o;
    }
    parseOptionalArgument(e1) {
        var t, i;
        if (e1 = "auto" === e1 ? this.parseMode : e1, this.matchWhitespace(), !this.match("[")) return null;
        let n = null;
        for(; !this.end() && !this.match("]");)if ("string" === e1) n = this.scanString();
        else if ("number" === e1) n = this.scanNumber();
        else if ("dimen" === e1) n = this.scanDimen();
        else if ("glue" === e1) n = this.scanGlue();
        else if ("colspec" === e1) n = this.scanColspec();
        else if ("bbox" === e1) {
            const e2 = this.scanString().toLowerCase().trim().split(/,(?![^(]*\)(?:(?:[^(]*\)){2})*[^"]*$)/), r = {};
            for (const n1 of e2){
                const e3 = null === (i = (t = this.context).backgroundColorMap) || void 0 === i ? void 0 : i.call(t, n1);
                if (e3) r.backgroundcolor = e3;
                else {
                    const e4 = n1.match(/^\s*([\d.]+)\s*([a-z]{2})/);
                    if (e4) r.padding = e4[0];
                    else {
                        const e5 = n1.match(/^\s*border\s*:\s*(.*)/);
                        e5 && (r.border = e5[1]);
                    }
                }
            }
            n = r;
        } else "math" === e1 && (this.beginContext({
            mode: "math"
        }), n = this.mathlist.concat(this.parse((e1)=>"]" === e1)), this.endContext());
        return n;
    }
    parseCommand(e1) {
        var t, i, n, r, o, a, s;
        if ("\\placeholder" === e1) {
            const e2 = this.parseOptionalArgument("string"), i1 = this.parseOptionalArgument("math"), n1 = null !== (t = this.parseArgument("string")) && void 0 !== t ? t : void 0;
            return [
                new Ct(this.context, {
                    mode: this.parseMode,
                    placeholderId: e2,
                    value: n1,
                    default: i1,
                    style: this.style
                })
            ];
        }
        let l = null;
        if ("\\char" === e1) {
            const e3 = this.index;
            let t1 = Math.floor(null !== (i = this.scanNumber(!0)) && void 0 !== i ? i : Number.NaN);
            (!Number.isFinite(t1) || t1 < 0 || t1 > 1114111) && (t1 = 10067);
            const n2 = "\\char" + et(this.tokens.slice(e3, this.index));
            return l = new ot("math" === this.parseMode ? "mord" : "text", this.context, {
                command: "\\char",
                mode: this.parseMode,
                value: String.fromCodePoint(t1),
                serialize: ()=>n2
            }), l.verbatimLatex = n2, [
                l
            ];
        }
        if ("\\hskip" === e1 || "\\kern" === e1) {
            const t2 = this.scanGlue();
            return t2 ? [
                new Nt(e1, this.style, this.context, t2)
            ] : null;
        }
        if (l = this.scanMacro(e1), l) return [
            l
        ];
        const u = this.context.getDefinition(e1, this.parseMode);
        if (!u) return this.onError({
            code: "unknown-command",
            arg: e1
        }), [
            new Et(e1, this.context)
        ];
        const c = this.index;
        if ("symbol" === u.definitionType) {
            const t3 = {
                ...this.style
            };
            u.variant && (t3.variant = u.variant), l = new ot(null !== (n = u.type) && void 0 !== n ? n : "mop", this.context, {
                command: e1,
                style: t3,
                value: String.fromCodePoint(u.codepoint),
                mode: this.parseMode
            });
        } else {
            if (u.ifMode && !u.ifMode.includes(this.parseMode)) return [];
            const t4 = this.parseMode;
            u.applyMode && (this.parseMode = u.applyMode);
            const [i2, n3] = this.parseArguments(u);
            if (this.parseMode = t4, !n3) return null;
            if (u.applyMode && !u.applyStyle && !u.createAtom) return n3[0];
            if (u.infix) return this.onError({
                code: "too-many-infix-commands",
                arg: e1
            }), null;
            if ("function" == typeof u.createAtom) l = u.createAtom(e1, n3, this.style, this.context), i2 && (l.body = null !== (r = this.parseArgument(i2)) && void 0 !== r ? r : void 0);
            else if ("function" == typeof u.applyStyle) {
                const t5 = u.applyStyle(e1, n3, this.context), r1 = this.parseMode;
                if (u.applyMode && (this.parseMode = u.applyMode), i2) {
                    const e4 = this.style;
                    this.style = {
                        ...this.style,
                        ...t5
                    };
                    const n4 = this.parseArgument(i2);
                    return this.style = e4, this.parseMode = r1, n4;
                }
                this.style = {
                    ...this.style,
                    ...t5
                }, this.parseMode = r1;
            } else l = new ot("mop", this.context, {
                command: null !== (o = u.command) && void 0 !== o ? o : e1,
                style: {
                    ...this.style
                },
                value: e1,
                mode: null !== (a = u.applyMode) && void 0 !== a ? a : this.parseMode
            });
        }
        if (l instanceof ot && void 0 === l.verbatimLatex && !/^\\(llap|rlap|class|cssId|htmlData)$/.test(e1) && (l.verbatimLatex = (null !== (s = l.command) && void 0 !== s ? s : "") + et(this.tokens.slice(c, this.index)), 0 === l.verbatimLatex.length && (l.verbatimLatex = void 0), l.isFunction && this.smartFence)) {
            const e5 = this.scanSmartFence();
            if (e5) return [
                l,
                e5
            ];
        }
        return l ? [
            l
        ] : null;
    }
    parseLiteral(e1) {
        const t = Ce.createAtom(this.parseMode, e1, this.context, {
            ...this.style
        });
        if (!t) return null;
        if (t.isFunction && this.smartFence) {
            const e2 = this.scanSmartFence();
            if (e2) return [
                t,
                e2
            ];
        }
        return [
            t
        ];
    }
    parseSimpleToken() {
        const e1 = this.get();
        return e1 ? "<space>" === e1 ? "text" === this.parseMode ? [
            new Dt(" ", " ", this.style, this.context)
        ] : null : e1.startsWith("\\") ? this.parseCommand(e1) : zt(e1) ? this.parseLiteral(e1) : ("<}>" === e1 ? this.onError({
            latex: "",
            code: "unbalanced-braces"
        }) : this.onError({
            latex: "",
            code: "unexpected-token",
            arg: e1
        }), null) : null;
    }
    scanMacro(e1) {
        var t;
        const i = this.context.getMacro(e1);
        if (!i) return null;
        const n = this.index, r = i.args, o = {
            "?": null === (t = this.args) || void 0 === t ? void 0 : t.call(this, "?")
        };
        for(let e2 = 1; e2 <= r; e2++)o[e2] = this.matchLiteralArg();
        return new Tt(e1, this.context, {
            expand: i.expand,
            captureSelection: i.captureSelection,
            args: et(this.tokens.slice(n, this.index)),
            body: It(i.def, this.context, {
                parseMode: this.parseMode,
                args: (e1)=>o[e1],
                mathstyle: this.currentContext.mathstyle
            })
        });
    }
    parseToken() {
        var t, i, n, r;
        let o = null !== (r = null !== (n = null !== (i = null !== (t = this.parseEnvironment()) && void 0 !== t ? t : this.parseModeShift()) && void 0 !== i ? i : this.parseModeSet()) && void 0 !== n ? n : this.parseGroup()) && void 0 !== r ? r : this.parseLeftRight();
        if (null === o) {
            if (this.parseSupSub()) return !0;
            if (this.parseLimits()) return !0;
            o = this.parseSimpleToken();
        }
        return e1(o) ? this.mathlist.push(...o) : o && this.mathlist.push(o), null !== o;
    }
    constructor(e1, t, i){
        var n, r, o, a, s, l;
        this.index = 0, this.endCount = 0, this.tokens = e1, this.context = t, this.errors = [], this.args = null !== (n = i.args) && void 0 !== n ? n : null, this.smartFence = null !== (r = i.smartFence) && void 0 !== r ? r : t.smartFence, this._currentParsingContext = {
            parent: void 0,
            mathlist: [],
            style: null !== (o = i.style) && void 0 !== o ? o : {},
            parseMode: null !== (a = i.parseMode) && void 0 !== a ? a : "math",
            mathstyle: null !== (s = i.mathstyle) && void 0 !== s ? s : "displaystyle",
            registers: null !== (l = i.registers) && void 0 !== l ? l : t.registers,
            tabular: !1
        };
    }
}
function It(e1, t, i) {
    var n, r, o;
    const a = null !== (n = null == i ? void 0 : i.args) && void 0 !== n ? n : null, s = new qt(Ye(e1, a), t, {
        args: a,
        mathstyle: null !== (r = null == i ? void 0 : i.mathstyle) && void 0 !== r ? r : "displaystyle",
        parseMode: null !== (o = null == i ? void 0 : i.parseMode) && void 0 !== o ? o : "math"
    }), l = [];
    for(; !s.end();)l.push(...s.parse());
    return l;
}
function Ot(e1, t, i) {
    var n;
    const r = new qt(Ye(e1, null), t, {
        args: null,
        mathstyle: "displaystyle",
        parseMode: null !== (n = null == i ? void 0 : i.parseMode) && void 0 !== n ? n : "math"
    });
    for(; !r.end();)r.parse();
    return r.errors;
}
function Ft(e1, t, i) {
    return "object" == typeof e1 && "glue" in e1 ? e1 : "object" == typeof e1 && "dimension" in e1 ? {
        glue: e1
    } : "number" == typeof e1 ? {
        glue: {
            dimension: e1
        }
    } : new qt(Ye(e1), t, {
        registers: i
    }).scanGlue();
}
function Bt(e1, t, i) {
    return "number" == typeof e1 ? {
        dimension: e1,
        unit: "pt"
    } : ("object" == typeof e1 && "glue" in e1 && (e1 = e1.glue), "object" == typeof e1 && "dimension" in e1 ? e1 : new qt(Ye(e1), t, {
        registers: i
    }).scanDimen());
}
class $t extends ot {
    static fromJson(e1, t) {
        return new $t(e1.command, e1.body, t, e1);
    }
    toJson() {
        return {
            ...super.toJson(),
            framecolor: this.framecolor,
            verbatimFramecolor: this.verbatimFramecolor,
            backgroundcolor: this.backgroundcolor,
            verbatimBackgroundcolor: this.verbatimBackgroundcolor,
            padding: this.padding,
            border: this.border
        };
    }
    render(e1) {
        const t = new Me(e1, this.style), i = we(t.getRegisterAsDimension("fboxsep")), n = void 0 === this.padding ? i : we(Bt(this.padding, {
            ...this.context,
            registers: e1.registers
        })), r = ot.createBox(e1, this.body);
        if (!r) return null;
        r.setStyle("vertical-align", -r.height, "em");
        const o = new Ie(r, {
            type: "mord"
        }), a = new Ie(null, {
            classes: "ML__box"
        });
        a.height = o.height + n, a.depth = o.depth + n, a.setStyle("box-sizing", "border-box"), a.setStyle("position", "absolute"), a.setStyle("height", o.height + o.depth + 2 * n, "em"), 0 === n ? a.setStyle("width", "100%") : (a.setStyle("width", `calc(100% + ${2 * n}em)`), a.setStyle("top", i, "em"), a.setStyle("left", -n, "em")), a.setStyle("z-index", "-1"), this.backgroundcolor && a.setStyle("background-color", this.backgroundcolor), this.framecolor && a.setStyle("border", `${we(t.getRegisterAsDimension("fboxrule"))}em solid ${this.framecolor}`), this.border && a.setStyle("border", this.border), o.setStyle("display", "inline-block"), o.setStyle("height", r.height + r.depth, "em"), o.setStyle("vertical-align", -n, "em");
        const s = new Ie([
            a,
            o
        ]);
        return s.setStyle("position", "relative"), s.setStyle("display", "inline-block"), s.setStyle("line-height", 0), s.height = o.height + n, s.depth = o.depth + n, s.left = n, s.right = n, s.setStyle("height", o.height + n, "em"), s.setStyle("top", o.depth - o.height, "em"), s.setStyle("vertical-align", o.depth + n, "em"), this.caret && (s.caret = this.caret), this.attachSupsub(e1, {
            base: s
        });
    }
    constructor(e1, t, i, n){
        super("box", i, {
            command: e1,
            serialize: n.serialize,
            style: n.style
        }), this.body = t, this.framecolor = n.framecolor, this.verbatimFramecolor = n.verbatimBackgroundcolor, this.backgroundcolor = n.backgroundcolor, this.verbatimBackgroundcolor = n.verbatimBackgroundcolor, this.padding = n.padding, this.border = n.border;
    }
}
class Pt extends ot {
    static fromJson(e1, t) {
        return new Pt(t, e1.environmentName, e1.array, e1.rowGaps, e1);
    }
    toJson() {
        const e1 = {
            ...super.toJson(),
            environmentName: this.environmentName,
            array: this.array.map((e1)=>e1.map((e1)=>e1.map((e1)=>e1.toJson()))),
            rowGaps: this.rowGaps,
            columns: this.colFormat,
            colSeparationType: this.colSeparationType
        };
        return 1 !== this.arraystretch && (e1.arraystretch = this.arraystretch), this.arraycolsep && (e1.arraycolsep = this.arraycolsep), this.leftDelim && (e1.leftDelim = this.leftDelim), this.rightDelim && (e1.rightDelim = this.rightDelim), void 0 !== this.jot && (e1.jot = this.jot), e1;
    }
    branch(e1) {
        var t;
        if (rt(e1)) return null !== (t = this.array[e1[0]][e1[1]]) && void 0 !== t ? t : void 0;
    }
    get branches() {
        const e1 = super.branches;
        return this.array.forEach((t, i)=>{
            this.array[i].forEach((t, n)=>{
                this.array[i][n] && e1.push([
                    i,
                    n
                ]);
            });
        }), e1;
    }
    createBranch(e1) {
        var t;
        return rt(e1) ? (this.isDirty = !0, null !== (t = this.branch(e1)) && void 0 !== t ? t : []) : [];
    }
    get rowCount() {
        return this.array.length;
    }
    get colCount() {
        return this.array[0].length;
    }
    get maxColumns() {
        return this.colFormat.filter((e1)=>Boolean(e1.align)).length;
    }
    removeBranch(e1) {
        if (nt(e1)) return super.removeBranch(e1);
        const t = this.branch(e1);
        return this.array[e1[0]][e1[1]] = void 0, t.forEach((e1)=>{
            e1.parent = void 0, e1.treeBranch = void 0;
        }), t.shift(), this.isDirty = !0, t;
    }
    get hasChildren() {
        return this.children.length > 0;
    }
    get children() {
        const e1 = [];
        for (const t of this.array)for (const i of t)if (i) for (const t1 of i)e1.push(...t1.children), e1.push(t1);
        return [
            ...e1,
            ...super.children
        ];
    }
    render(e1) {
        var t, i, n, r, o;
        const a = new Me(e1, this.style, this.mathstyleName), s = a.getRegisterAsEm("arrayrulewidth"), l = a.getRegisterAsEm("arraycolsep"), u = a.getRegisterAsEm("doublerulesep"), c = null !== (t = this.arraystretch) && void 0 !== t ? t : 1;
        let d = "number" == typeof this.arraycolsep ? this.arraycolsep : l;
        "small" === this.colSeparationType && (d = new Me(e1, void 0, "scriptstyle").scalingFactor / e1.scalingFactor * .2778);
        const h = 1.2 * c, m = .7 * h, p = .3 * h;
        let f = 0;
        const g = [];
        let y = 0;
        const b = this.array.length;
        for(let e2 = 0; e2 < b; ++e2){
            const t1 = this.array[e2];
            y = Math.max(y, t1.length);
            const r1 = new Me(a, this.style, this.mathstyleName);
            let o1 = m / r1.scalingFactor, s1 = p / r1.scalingFactor;
            const l1 = {
                cells: [],
                height: 0,
                depth: 0,
                pos: 0
            };
            for (const e3 of t1){
                const t2 = null !== (i = ot.createBox(r1, e3, {
                    newList: !0
                })) && void 0 !== i ? i : new Ie(null, {
                    newList: !0
                });
                s1 = Math.max(s1, t2.depth), o1 = Math.max(o1, t2.height), l1.cells.push(t2);
            }
            let u1 = null !== (n = we(this.rowGaps[e2])) && void 0 !== n ? n : 0;
            u1 > 0 && (u1 += p, s1 = Math.max(s1, u1), u1 = 0), void 0 !== this.jot && (s1 += this.jot), l1.height = o1, l1.depth = s1, f += o1, l1.pos = f, f += s1 + u1, g.push(l1);
        }
        const v = f / 2 + .25, x = [];
        for(let e4 = 0; e4 < y; e4++){
            const t3 = [];
            for (const i1 of g){
                const n1 = i1.cells[e4];
                n1.depth = i1.depth, n1.height = i1.height, t3.push({
                    box: n1,
                    shift: i1.pos - v
                });
            }
            t3.length > 0 && x.push(new Ve({
                individualShift: t3
            }));
        }
        const k = [];
        let _ = !1, w = !1, S = 0, M = !this.leftDelim;
        const { colFormat: N  } = this;
        for (const t4 of N){
            if ("align" in t4 && S >= x.length) break;
            if ("align" in t4) _ ? k.push(Kt(2 * d)) : (w || M) && k.push(Kt(d)), k.push(new Ie(x[S], {
                classes: "col-align-" + t4.align
            })), S++, _ = !0, w = !1, M = !1;
            else if ("gap" in t4) {
                if ("number" == typeof t4.gap) k.push(Kt(t4.gap));
                else {
                    const i2 = Vt(e1, g, v, t4.gap);
                    i2 && k.push(i2);
                }
                _ = !1, w = !1, M = !1;
            } else if ("separator" in t4) {
                const e5 = new Ie(null, {
                    classes: "vertical-separator"
                });
                e5.setStyle("height", f, "em"), e5.setStyle("border-right", `${s}em ${t4.separator} currentColor`), e5.setStyle("vertical-align", -(f - v), "em");
                let i3 = 0;
                w ? i3 = u - s : _ && (i3 = d - s), e5.left = i3, k.push(e5), _ = !1, w = !0, M = !1;
            }
        }
        _ && !this.rightDelim && k.push(Kt(d));
        const L = new Ie(k, {
            classes: "mtable"
        });
        if (!(this.leftDelim && "." !== this.leftDelim || this.rightDelim && "." !== this.rightDelim)) return this.caret && (L.caret = this.caret), L;
        const A = L.height, C = L.depth, E = this.bind(e1, new Ie([
            this.bind(e1, _t("mopen", null !== (r = this.leftDelim) && void 0 !== r ? r : ".", A, C, a)),
            L,
            this.bind(e1, _t("mclose", null !== (o = this.rightDelim) && void 0 !== o ? o : ".", A, C, a))
        ], {
            type: "mord"
        }));
        return E ? (this.caret && (E.caret = this.caret), this.attachSupsub(e1, {
            base: E
        })) : null;
    }
    serialize(e1) {
        let t = "\\begin{" + this.environmentName + "}";
        if ("array" === this.environmentName) {
            if (t += "{", void 0 !== this.colFormat) for (const e2 of this.colFormat)"align" in e2 ? t += e2.align : "separator" in e2 && "solid" === e2.separator ? t += "|" : "separator" in e2 && "dashed" === e2.separator && (t += ":");
            t += "}";
        }
        for(let i = 0; i < this.array.length; i++){
            for(let n = 0; n < this.array[i].length; n++)n > 0 && (t += " & "), t = Qe([
                t,
                ot.serialize(this.array[i][n], e1)
            ]);
            i < this.array.length - 1 && (t += " \\\\ ");
        }
        return t += "\\end{" + this.environmentName + "}", t;
    }
    getCell(e1, t) {
        return this.array[e1][t];
    }
    setCell(e1, t, i) {
        for (const i1 of this.array[e1][t])i1.parent = void 0, i1.treeBranch = void 0;
        let n = i;
        0 !== i.length && "first" === i[0].type || (n = [
            new ot("first", this.context, {
                mode: this.mode
            }),
            ...i
        ]), this.array[e1][t] = n;
        for (const i2 of n)i2.parent = this, i2.treeBranch = [
            e1,
            t
        ];
        this.isDirty = !0;
    }
    addRowBefore(e1) {
        const t = [];
        for(let e2 = 0; e2 < this.colCount; e2++)t.push(Rt(this));
        this.array.splice(e1, 0, t);
        for(let t1 = e1; t1 < this.rowCount; t1++)for(let e3 = 0; e3 < this.colCount; e3++){
            const i = this.array[t1][e3];
            if (i) for (const n of i)n.treeBranch = [
                t1,
                e3
            ];
        }
        this.isDirty = !0;
    }
    addRowAfter(e1) {
        const t = [];
        for(let e2 = 0; e2 < this.colCount; e2++)t.push(Rt(this));
        this.array.splice(e1 + 1, 0, t);
        for(let t1 = e1 + 1; t1 < this.rowCount; t1++)for(let e3 = 0; e3 < this.colCount; e3++){
            const i = this.array[t1][e3];
            if (i) for (const n of i)n.treeBranch = [
                t1,
                e3
            ];
        }
        this.isDirty = !0;
    }
    removeRow(e1) {
        const t = this.array.splice(e1, 1);
        for (const e2 of t)for (const t1 of e2)if (t1) for (const e3 of t1)e3.parent = void 0, e3.treeBranch = void 0;
        for(let t2 = e1; t2 < this.rowCount; t2++)for(let e4 = 0; e4 < this.colCount; e4++){
            const i = this.array[t2][e4];
            if (i) for (const n of i)n.treeBranch = [
                t2,
                e4
            ];
        }
        this.isDirty = !0;
    }
    addColumnBefore(e1) {
        for (const t of this.array)t.splice(e1, 0, Rt(this));
        for(let t1 = 0; t1 < this.rowCount; t1++)for(let i = e1; i < this.colCount; i++){
            const e2 = this.array[t1][i];
            if (e2) for (const n of e2)n.treeBranch = [
                t1,
                i
            ];
        }
        this.isDirty = !0;
    }
    addColumnAfter(e1) {
        for (const t of this.array)t.splice(e1 + 1, 0, Rt(this));
        for(let t1 = 0; t1 < this.rowCount; t1++)for(let i = e1 + 1; i < this.colCount; i++){
            const e2 = this.array[t1][i];
            if (e2) for (const n of e2)n.treeBranch = [
                t1,
                i
            ];
        }
        this.isDirty = !0;
    }
    addColumn() {
        this.addColumnAfter(this.colCount - 1);
    }
    removeColumn(e1) {
        for (const t of this.array){
            const i = t.splice(e1, 1);
            for (const e2 of i)if (e2) for (const t1 of e2)t1.parent = void 0, t1.treeBranch = void 0;
        }
        for(let t2 = 0; t2 < this.rowCount; t2++)for(let i1 = e1; i1 < this.colCount; i1++){
            const e3 = this.array[t2][i1];
            if (e3) for (const n of e3)n.treeBranch = [
                t2,
                i1
            ];
        }
        this.isDirty = !0;
    }
    get cells() {
        const e1 = [];
        for (const t of this.array)for (const i of t)i && e1.push(i);
        return e1;
    }
    constructor(e1, t, i, n, r = {}){
        var o, a;
        super("array", e1), this.environmentName = t, this.rowGaps = n, r.mathstyleName && (this.mathstyleName = r.mathstyleName), r.columns && (0 === r.columns.length ? this.colFormat = [
            {
                align: "l"
            }
        ] : this.colFormat = r.columns), this.colFormat || (this.colFormat = [
            {
                align: "l"
            },
            {
                align: "l"
            },
            {
                align: "l"
            },
            {
                align: "l"
            },
            {
                align: "l"
            },
            {
                align: "l"
            },
            {
                align: "l"
            },
            {
                align: "l"
            },
            {
                align: "l"
            },
            {
                align: "l"
            }
        ]), this.array = function(e1, t, i, n) {
            let r = 0;
            for (const e2 of n)"align" in e2 && (r += 1);
            let o = 0;
            const a = [];
            for (const n1 of i){
                let i1 = 0;
                for(o = Math.max(o, Math.min(n1.length, r)); i1 < n1.length;){
                    const o1 = [], s = Math.min(n1.length, i1 + r);
                    for(; i1 < s;)0 === n1[i1].length ? o1.push([
                        new ot("first", e1, {
                            mode: t.mode
                        })
                    ]) : "first" !== n1[i1][0].type ? o1.push([
                        new ot("first", e1, {
                            mode: t.mode
                        }),
                        ...n1[i1]
                    ]) : o1.push(n1[i1]), i1 += 1;
                    a.push(o1);
                }
            }
            1 === a[a.length - 1].length && 0 === a[a.length - 1][0].length && a.pop();
            const s1 = [];
            for (const i2 of a){
                if (i2.length !== o) for(let n2 = i2.length; n2 < o; n2++)i2.push([
                    new ot("first", e1, {
                        mode: t.mode
                    }),
                    new Ct(e1)
                ]);
                s1.push(i2);
            }
            let l = 0, u = 0;
            for (const e3 of s1){
                u = 0;
                for (const i3 of e3){
                    for (const e4 of i3)e4.parent = t, e4.treeBranch = [
                        l,
                        u
                    ];
                    u += 1;
                }
                l += 1;
            }
            return t.isDirty = !0, s1;
        }(e1, this, i, this.colFormat), r.leftDelim && (this.leftDelim = r.leftDelim), r.rightDelim && (this.rightDelim = r.rightDelim), void 0 !== r.jot && (this.jot = r.jot), r.arraycolsep && (this.arraycolsep = r.arraycolsep), this.colSeparationType = r.colSeparationType, this.arraystretch = null !== (o = r.arraystretch) && void 0 !== o ? o : 1, this.minColumns = null !== (a = r.minColumns) && void 0 !== a ? a : 1;
    }
}
function Rt(e1) {
    const t = new ot("first", e1.context, {
        mode: e1.mode
    });
    t.parent = e1;
    const i = new Ct(e1.context, {
        mode: e1.mode
    });
    return i.parent = e1, [
        t,
        i
    ];
}
function Kt(e1) {
    const t = new Ie(null, {
        classes: "arraycolsep"
    });
    return t.width = e1, t;
}
function Vt(e1, t, i, n) {
    if (!n) return null;
    const r = [];
    for (const o of t){
        const t1 = ot.createBox(e1, n, {
            newList: !0
        });
        t1 && (t1.depth = o.depth, t1.height = o.height, r.push({
            box: t1,
            shift: o.pos - i
        }));
    }
    return new Ve({
        individualShift: r
    }).wrap(e1);
}
class jt extends ot {
    static fromJson(e1, t) {
        return new jt(e1.value, t, e1);
    }
    toJson() {
        return super.toJson();
    }
    get computedStyle() {
        return {};
    }
    render(e1) {
        const t = new Ie(this.value, {
            classes: "ML__composition",
            type: "composition"
        });
        return this.bind(e1, t), this.caret && (t.caret = this.caret), t;
    }
    serialize(e1) {
        return "";
    }
    constructor(e1, t, i){
        var n;
        super("composition", t, {
            mode: null !== (n = null == i ? void 0 : i.mode) && void 0 !== n ? n : "math",
            value: e1
        });
    }
}
class Ht extends ot {
    static fromJson(e1, t) {
        return new Ht(e1.command, e1.arg, t);
    }
    toJson() {
        return {
            ...super.toJson(),
            arg: this.arg
        };
    }
    render(e1) {
        const t = ot.createBox(e1, this.body, {
            type: "chem",
            newList: !0
        });
        return this.caret && (t.caret = this.caret), this.bind(e1, t);
    }
    serialize(e1) {
        return this.verbatimLatex;
    }
    constructor(e1, t, i){
        super("chem", i, {
            command: e1,
            mode: "math"
        });
        const n = Gt.go(Ut.go(t, "\\pu" === e1 ? "pu" : "ce"), !1);
        this.body = It(n, i), this.verbatimLatex = e1 + "{" + t + "}", this.arg = t, this.captureSelection = !0;
    }
}
P([
    "ce",
    "pu"
], "{chemformula:balanced-string}", {
    createAtom: (e1, t, i, n)=>new Ht(e1, t[0], n)
});
var Ut = {
    go: function(e1, t) {
        if (!e1) return [];
        void 0 === t && (t = "ce");
        var i, n = "0", r = {
            parenthesisLevel: 0
        };
        e1 = (e1 = (e1 = e1.replace(/\n/g, " ")).replace(/[\u2212\u2013\u2014\u2010]/g, "-")).replace(/[\u2026]/g, "...");
        for(var o = 10, a = [];;){
            i !== e1 ? (o = 10, i = e1) : o--;
            var s = Ut.stateMachines[t], l = s.transitions[n] || s.transitions["*"];
            e: for(var u = 0; u < l.length; u++){
                var c = Ut.patterns.match_(l[u].pattern, e1);
                if (c) {
                    for(var d = l[u].task, h = 0; h < d.action_.length; h++){
                        var m;
                        if (s.actions[d.action_[h].type_]) m = s.actions[d.action_[h].type_](r, c.match_, d.action_[h].option);
                        else {
                            if (!Ut.actions[d.action_[h].type_]) throw [
                                "MhchemBugA",
                                "mhchem bug A. Please report. (" + d.action_[h].type_ + ")"
                            ];
                            m = Ut.actions[d.action_[h].type_](r, c.match_, d.action_[h].option);
                        }
                        Ut.concatArray(a, m);
                    }
                    if (n = d.nextState || n, !(e1.length > 0)) return a;
                    if (d.revisit || (e1 = c.remainder), !d.toContinue) break e;
                }
            }
            if (o <= 0) throw [
                "MhchemBugU",
                "mhchem bug U. Please report."
            ];
        }
    },
    concatArray: function(e1, t) {
        if (t) {
            if (Array.isArray(t)) for(var i = 0; i < t.length; i++)e1.push(t[i]);
            else e1.push(t);
        }
    },
    patterns: {
        patterns: {
            empty: /^$/,
            else: /^./,
            else2: /^./,
            space: /^\s/,
            "space A": /^\s(?=[A-Z\\$])/,
            space$: /^\s$/,
            "a-z": /^[a-z]/,
            x: /^x/,
            x$: /^x$/,
            i$: /^i$/,
            letters: /^(?:[a-zA-Z\u03B1-\u03C9\u0391-\u03A9?@]|(?:\\(?:alpha|beta|gamma|delta|epsilon|zeta|eta|theta|iota|kappa|lambda|mu|nu|xi|omicron|pi|rho|sigma|tau|upsilon|phi|chi|psi|omega|Gamma|Delta|Theta|Lambda|Xi|Pi|Sigma|Upsilon|Phi|Psi|Omega)(?:\s+|\{\}|(?![a-zA-Z]))))+/,
            "\\greek": /^\\(?:alpha|beta|gamma|delta|epsilon|zeta|eta|theta|iota|kappa|lambda|mu|nu|xi|omicron|pi|rho|sigma|tau|upsilon|phi|chi|psi|omega|Gamma|Delta|Theta|Lambda|Xi|Pi|Sigma|Upsilon|Phi|Psi|Omega)(?:\s+|\{\}|(?![a-zA-Z]))/,
            "one lowercase latin letter $": /^(?:([a-z])(?:$|[^a-zA-Z]))$/,
            "$one lowercase latin letter$ $": /^\$(?:([a-z])(?:$|[^a-zA-Z]))\$$/,
            "one lowercase greek letter $": /^(?:\$?[\u03B1-\u03C9]\$?|\$?\\(?:alpha|beta|gamma|delta|epsilon|zeta|eta|theta|iota|kappa|lambda|mu|nu|xi|omicron|pi|rho|sigma|tau|upsilon|phi|chi|psi|omega)\s*\$?)(?:\s+|\{\}|(?![a-zA-Z]))$/,
            digits: /^[0-9]+/,
            "-9.,9": /^[+\-]?(?:[0-9]+(?:[,.][0-9]+)?|[0-9]*(?:\.[0-9]+))/,
            "-9.,9 no missing 0": /^[+\-]?[0-9]+(?:[.,][0-9]+)?/,
            "(-)(9.,9)(e)(99)": function(e1) {
                var t = e1.match(/^(\+\-|\+\/\-|\+|\-|\\pm\s?)?([0-9]+(?:[,.][0-9]+)?|[0-9]*(?:\.[0-9]+))?(\((?:[0-9]+(?:[,.][0-9]+)?|[0-9]*(?:\.[0-9]+))\))?(?:([eE]|\s*(\*|x|\\times|\u00D7)\s*10\^)([+\-]?[0-9]+|\{[+\-]?[0-9]+\}))?/);
                return t && t[0] ? {
                    match_: t.splice(1),
                    remainder: e1.substr(t[0].length)
                } : null;
            },
            "(-)(9)^(-9)": function(e1) {
                var t = e1.match(/^(\+\-|\+\/\-|\+|\-|\\pm\s?)?([0-9]+(?:[,.][0-9]+)?|[0-9]*(?:\.[0-9]+)?)\^([+\-]?[0-9]+|\{[+\-]?[0-9]+\})/);
                return t && t[0] ? {
                    match_: t.splice(1),
                    remainder: e1.substr(t[0].length)
                } : null;
            },
            "state of aggregation $": function(e1) {
                var t = Ut.patterns.findObserveGroups(e1, "", /^\([a-z]{1,3}(?=[\),])/, ")", "");
                if (t && t.remainder.match(/^($|[\s,;\)\]\}])/)) return t;
                var i = e1.match(/^(?:\((?:\\ca\s?)?\$[amothc]\$\))/);
                return i ? {
                    match_: i[0],
                    remainder: e1.substr(i[0].length)
                } : null;
            },
            "_{(state of aggregation)}$": /^_\{(\([a-z]{1,3}\))\}/,
            "{[(": /^(?:\\\{|\[|\()/,
            ")]}": /^(?:\)|\]|\\\})/,
            ", ": /^[,;]\s*/,
            ",": /^[,;]/,
            ".": /^[.]/,
            ". ": /^([.\u22C5\u00B7\u2022])\s*/,
            "...": /^\.\.\.(?=$|[^.])/,
            "* ": /^([*])\s*/,
            "^{(...)}": function(e1) {
                return Ut.patterns.findObserveGroups(e1, "^{", "", "", "}");
            },
            "^($...$)": function(e1) {
                return Ut.patterns.findObserveGroups(e1, "^", "$", "$", "");
            },
            "^a": /^\^([0-9]+|[^\\_])/,
            "^\\x{}{}": function(e1) {
                return Ut.patterns.findObserveGroups(e1, "^", /^\\[a-zA-Z]+\{/, "}", "", "", "{", "}", "", !0);
            },
            "^\\x{}": function(e1) {
                return Ut.patterns.findObserveGroups(e1, "^", /^\\[a-zA-Z]+\{/, "}", "");
            },
            "^\\x": /^\^(\\[a-zA-Z]+)\s*/,
            "^(-1)": /^\^(-?\d+)/,
            "'": /^'/,
            "_{(...)}": function(e1) {
                return Ut.patterns.findObserveGroups(e1, "_{", "", "", "}");
            },
            "_($...$)": function(e1) {
                return Ut.patterns.findObserveGroups(e1, "_", "$", "$", "");
            },
            _9: /^_([+\-]?[0-9]+|[^\\])/,
            "_\\x{}{}": function(e1) {
                return Ut.patterns.findObserveGroups(e1, "_", /^\\[a-zA-Z]+\{/, "}", "", "", "{", "}", "", !0);
            },
            "_\\x{}": function(e1) {
                return Ut.patterns.findObserveGroups(e1, "_", /^\\[a-zA-Z]+\{/, "}", "");
            },
            "_\\x": /^_(\\[a-zA-Z]+)\s*/,
            "^_": /^(?:\^(?=_)|\_(?=\^)|[\^_]$)/,
            "{}": /^\{\}/,
            "{...}": function(e1) {
                return Ut.patterns.findObserveGroups(e1, "", "{", "}", "");
            },
            "{(...)}": function(e1) {
                return Ut.patterns.findObserveGroups(e1, "{", "", "", "}");
            },
            "$...$": function(e1) {
                return Ut.patterns.findObserveGroups(e1, "", "$", "$", "");
            },
            "${(...)}$": function(e1) {
                return Ut.patterns.findObserveGroups(e1, "${", "", "", "}$");
            },
            "$(...)$": function(e1) {
                return Ut.patterns.findObserveGroups(e1, "$", "", "", "$");
            },
            "=<>": /^[=<>]/,
            "#": /^[#\u2261]/,
            "+": /^\+/,
            "-$": /^-(?=[\s_},;\]/]|$|\([a-z]+\))/,
            "-9": /^-(?=[0-9])/,
            "- orbital overlap": /^-(?=(?:[spd]|sp)(?:$|[\s,;\)\]\}]))/,
            "-": /^-/,
            "pm-operator": /^(?:\\pm|\$\\pm\$|\+-|\+\/-)/,
            operator: /^(?:\+|(?:[\-=<>]|<<|>>|\\approx|\$\\approx\$)(?=\s|$|-?[0-9]))/,
            arrowUpDown: /^(?:v|\(v\)|\^|\(\^\))(?=$|[\s,;\)\]\}])/,
            "\\bond{(...)}": function(e1) {
                return Ut.patterns.findObserveGroups(e1, "\\bond{", "", "", "}");
            },
            "->": /^(?:<->|<-->|->|<-|<=>>|<<=>|<=>|[\u2192\u27F6\u21CC])/,
            CMT: /^[CMT](?=\[)/,
            "[(...)]": function(e1) {
                return Ut.patterns.findObserveGroups(e1, "[", "", "", "]");
            },
            "1st-level escape": /^(&|\\\\|\\hline)\s*/,
            "\\,": /^(?:\\[,\ ;:])/,
            "\\x{}{}": function(e1) {
                return Ut.patterns.findObserveGroups(e1, "", /^\\[a-zA-Z]+\{/, "}", "", "", "{", "}", "", !0);
            },
            "\\x{}": function(e1) {
                return Ut.patterns.findObserveGroups(e1, "", /^\\[a-zA-Z]+\{/, "}", "");
            },
            "\\ca": /^\\ca(?:\s+|(?![a-zA-Z]))/,
            "\\x": /^(?:\\[a-zA-Z]+\s*|\\[_&{}%])/,
            orbital: /^(?:[0-9]{1,2}[spdfgh]|[0-9]{0,2}sp)(?=$|[^a-zA-Z])/,
            others: /^[\/~|]/,
            "\\frac{(...)}": function(e1) {
                return Ut.patterns.findObserveGroups(e1, "\\frac{", "", "", "}", "{", "", "", "}");
            },
            "\\overset{(...)}": function(e1) {
                return Ut.patterns.findObserveGroups(e1, "\\overset{", "", "", "}", "{", "", "", "}");
            },
            "\\underset{(...)}": function(e1) {
                return Ut.patterns.findObserveGroups(e1, "\\underset{", "", "", "}", "{", "", "", "}");
            },
            "\\underbrace{(...)}": function(e1) {
                return Ut.patterns.findObserveGroups(e1, "\\underbrace{", "", "", "}_", "{", "", "", "}");
            },
            "\\color{(...)}0": function(e1) {
                return Ut.patterns.findObserveGroups(e1, "\\color{", "", "", "}");
            },
            "\\color{(...)}{(...)}1": function(e1) {
                return Ut.patterns.findObserveGroups(e1, "\\color{", "", "", "}", "{", "", "", "}");
            },
            "\\color(...){(...)}2": function(e1) {
                return Ut.patterns.findObserveGroups(e1, "\\color", "\\", "", /^(?=\{)/, "{", "", "", "}");
            },
            "\\ce{(...)}": function(e1) {
                return Ut.patterns.findObserveGroups(e1, "\\ce{", "", "", "}");
            },
            oxidation$: /^(?:[+-][IVX]+|\\pm\s*0|\$\\pm\$\s*0)$/,
            "d-oxidation$": /^(?:[+-]?\s?[IVX]+|\\pm\s*0|\$\\pm\$\s*0)$/,
            "roman numeral": /^[IVX]+/,
            "1/2$": /^[+\-]?(?:[0-9]+|\$[a-z]\$|[a-z])\/[0-9]+(?:\$[a-z]\$|[a-z])?$/,
            amount: function(e1) {
                var t;
                if (t = e1.match(/^(?:(?:(?:\([+\-]?[0-9]+\/[0-9]+\)|[+\-]?(?:[0-9]+|\$[a-z]\$|[a-z])\/[0-9]+|[+\-]?[0-9]+[.,][0-9]+|[+\-]?\.[0-9]+|[+\-]?[0-9]+)(?:[a-z](?=\s*[A-Z]))?)|[+\-]?[a-z](?=\s*[A-Z])|\+(?!\s))/)) return {
                    match_: t[0],
                    remainder: e1.substr(t[0].length)
                };
                var i = Ut.patterns.findObserveGroups(e1, "", "$", "$", "");
                return i && (t = i.match_.match(/^\$(?:\(?[+\-]?(?:[0-9]*[a-z]?[+\-])?[0-9]*[a-z](?:[+\-][0-9]*[a-z]?)?\)?|\+|-)\$$/)) ? {
                    match_: t[0],
                    remainder: e1.substr(t[0].length)
                } : null;
            },
            amount2: function(e1) {
                return this.amount(e1);
            },
            "(KV letters),": /^(?:[A-Z][a-z]{0,2}|i)(?=,)/,
            formula$: function(e1) {
                if (e1.match(/^\([a-z]+\)$/)) return null;
                var t = e1.match(/^(?:[a-z]|(?:[0-9\ \+\-\,\.\(\)]+[a-z])+[0-9\ \+\-\,\.\(\)]*|(?:[a-z][0-9\ \+\-\,\.\(\)]+)+[a-z]?)$/);
                return t ? {
                    match_: t[0],
                    remainder: e1.substr(t[0].length)
                } : null;
            },
            uprightEntities: /^(?:pH|pOH|pC|pK|iPr|iBu)(?=$|[^a-zA-Z])/,
            "/": /^\s*(\/)\s*/,
            "//": /^\s*(\/\/)\s*/,
            "*": /^\s*[*.]\s*/
        },
        findObserveGroups: function(e1, t, i, n, r, o, a, s, l, u) {
            var c = function(e1, t) {
                if ("string" == typeof t) return 0 !== e1.indexOf(t) ? null : t;
                var i = e1.match(t);
                return i ? i[0] : null;
            }, d = c(e1, t);
            if (null === d) return null;
            if (e1 = e1.substr(d.length), null === (d = c(e1, i))) return null;
            var h = function(e1, t, i) {
                for(var n = 0; t < e1.length;){
                    var r = e1.charAt(t), o = c(e1.substr(t), i);
                    if (null !== o && 0 === n) return {
                        endMatchBegin: t,
                        endMatchEnd: t + o.length
                    };
                    if ("{" === r) n++;
                    else if ("}" === r) {
                        if (0 === n) throw [
                            "ExtraCloseMissingOpen",
                            "Extra close brace or missing open brace"
                        ];
                        n--;
                    }
                    t++;
                }
                return null;
            }(e1, d.length, n || r);
            if (null === h) return null;
            var m = e1.substring(0, n ? h.endMatchEnd : h.endMatchBegin);
            if (o || a) {
                var p = this.findObserveGroups(e1.substr(h.endMatchEnd), o, a, s, l);
                if (null === p) return null;
                var f = [
                    m,
                    p.match_
                ];
                return {
                    match_: u ? f.join("") : f,
                    remainder: p.remainder
                };
            }
            return {
                match_: m,
                remainder: e1.substr(h.endMatchEnd)
            };
        },
        match_: function(e1, t) {
            var i = Ut.patterns.patterns[e1];
            if (void 0 === i) throw [
                "MhchemBugP",
                "mhchem bug P. Please report. (" + e1 + ")"
            ];
            if ("function" == typeof i) return Ut.patterns.patterns[e1](t);
            var n = t.match(i);
            return n ? {
                match_: n[2] ? [
                    n[1],
                    n[2]
                ] : n[1] ? n[1] : n[0],
                remainder: t.substr(n[0].length)
            } : null;
        }
    },
    actions: {
        "a=": function(e1, t) {
            e1.a = (e1.a || "") + t;
        },
        "b=": function(e1, t) {
            e1.b = (e1.b || "") + t;
        },
        "p=": function(e1, t) {
            e1.p = (e1.p || "") + t;
        },
        "o=": function(e1, t) {
            e1.o = (e1.o || "") + t;
        },
        "q=": function(e1, t) {
            e1.q = (e1.q || "") + t;
        },
        "d=": function(e1, t) {
            e1.d = (e1.d || "") + t;
        },
        "rm=": function(e1, t) {
            e1.rm = (e1.rm || "") + t;
        },
        "text=": function(e1, t) {
            e1.text_ = (e1.text_ || "") + t;
        },
        insert: function(e1, t, i) {
            return {
                type_: i
            };
        },
        "insert+p1": function(e1, t, i) {
            return {
                type_: i,
                p1: t
            };
        },
        "insert+p1+p2": function(e1, t, i) {
            return {
                type_: i,
                p1: t[0],
                p2: t[1]
            };
        },
        copy: function(e1, t) {
            return t;
        },
        rm: function(e1, t) {
            return {
                type_: "rm",
                p1: t || ""
            };
        },
        text: function(e1, t) {
            return Ut.go(t, "text");
        },
        "{text}": function(e1, t) {
            var i = [
                "{"
            ];
            return Ut.concatArray(i, Ut.go(t, "text")), i.push("}"), i;
        },
        "tex-math": function(e1, t) {
            return Ut.go(t, "tex-math");
        },
        "tex-math tight": function(e1, t) {
            return Ut.go(t, "tex-math tight");
        },
        bond: function(e1, t, i) {
            return {
                type_: "bond",
                kind_: i || t
            };
        },
        "color0-output": function(e1, t) {
            return {
                type_: "color0",
                color: t[0]
            };
        },
        ce: function(e1, t) {
            return Ut.go(t);
        },
        "1/2": function(e1, t) {
            var i = [];
            t.match(/^[+\-]/) && (i.push(t.substr(0, 1)), t = t.substr(1));
            var n = t.match(/^([0-9]+|\$[a-z]\$|[a-z])\/([0-9]+)(\$[a-z]\$|[a-z])?$/);
            return n[1] = n[1].replace(/\$/g, ""), i.push({
                type_: "frac",
                p1: n[1],
                p2: n[2]
            }), n[3] && (n[3] = n[3].replace(/\$/g, ""), i.push({
                type_: "tex-math",
                p1: n[3]
            })), i;
        },
        "9,9": function(e1, t) {
            return Ut.go(t, "9,9");
        }
    },
    createTransitions: function(e1) {
        var t, i, n, r, o = {};
        for(t in e1)for(i in e1[t])for(n = i.split("|"), e1[t][i].stateArray = n, r = 0; r < n.length; r++)o[n[r]] = [];
        for(t in e1)for(i in e1[t])for(n = e1[t][i].stateArray || [], r = 0; r < n.length; r++){
            var a = e1[t][i];
            if (a.action_) {
                a.action_ = [].concat(a.action_);
                for(var s = 0; s < a.action_.length; s++)"string" == typeof a.action_[s] && (a.action_[s] = {
                    type_: a.action_[s]
                });
            } else a.action_ = [];
            for(var l = t.split("|"), u = 0; u < l.length; u++)if ("*" === n[r]) for(var c in o)o[c].push({
                pattern: l[u],
                task: a
            });
            else o[n[r]].push({
                pattern: l[u],
                task: a
            });
        }
        return o;
    },
    stateMachines: {}
};
Ut.stateMachines = {
    ce: {
        transitions: Ut.createTransitions({
            empty: {
                "*": {
                    action_: "output"
                }
            },
            else: {
                "0|1|2": {
                    action_: "beginsWithBond=false",
                    revisit: !0,
                    toContinue: !0
                }
            },
            oxidation$: {
                0: {
                    action_: "oxidation-output"
                }
            },
            CMT: {
                r: {
                    action_: "rdt=",
                    nextState: "rt"
                },
                rd: {
                    action_: "rqt=",
                    nextState: "rdt"
                }
            },
            arrowUpDown: {
                "0|1|2|as": {
                    action_: [
                        "sb=false",
                        "output",
                        "operator"
                    ],
                    nextState: "1"
                }
            },
            uprightEntities: {
                "0|1|2": {
                    action_: [
                        "o=",
                        "output"
                    ],
                    nextState: "1"
                }
            },
            orbital: {
                "0|1|2|3": {
                    action_: "o=",
                    nextState: "o"
                }
            },
            "->": {
                "0|1|2|3": {
                    action_: "r=",
                    nextState: "r"
                },
                "a|as": {
                    action_: [
                        "output",
                        "r="
                    ],
                    nextState: "r"
                },
                "*": {
                    action_: [
                        "output",
                        "r="
                    ],
                    nextState: "r"
                }
            },
            "+": {
                o: {
                    action_: "d= kv",
                    nextState: "d"
                },
                "d|D": {
                    action_: "d=",
                    nextState: "d"
                },
                q: {
                    action_: "d=",
                    nextState: "qd"
                },
                "qd|qD": {
                    action_: "d=",
                    nextState: "qd"
                },
                dq: {
                    action_: [
                        "output",
                        "d="
                    ],
                    nextState: "d"
                },
                3: {
                    action_: [
                        "sb=false",
                        "output",
                        "operator"
                    ],
                    nextState: "0"
                }
            },
            amount: {
                "0|2": {
                    action_: "a=",
                    nextState: "a"
                }
            },
            "pm-operator": {
                "0|1|2|a|as": {
                    action_: [
                        "sb=false",
                        "output",
                        {
                            type_: "operator",
                            option: "\\pm"
                        }
                    ],
                    nextState: "0"
                }
            },
            operator: {
                "0|1|2|a|as": {
                    action_: [
                        "sb=false",
                        "output",
                        "operator"
                    ],
                    nextState: "0"
                }
            },
            "-$": {
                "o|q": {
                    action_: [
                        "charge or bond",
                        "output"
                    ],
                    nextState: "qd"
                },
                d: {
                    action_: "d=",
                    nextState: "d"
                },
                D: {
                    action_: [
                        "output",
                        {
                            type_: "bond",
                            option: "-"
                        }
                    ],
                    nextState: "3"
                },
                q: {
                    action_: "d=",
                    nextState: "qd"
                },
                qd: {
                    action_: "d=",
                    nextState: "qd"
                },
                "qD|dq": {
                    action_: [
                        "output",
                        {
                            type_: "bond",
                            option: "-"
                        }
                    ],
                    nextState: "3"
                }
            },
            "-9": {
                "3|o": {
                    action_: [
                        "output",
                        {
                            type_: "insert",
                            option: "hyphen"
                        }
                    ],
                    nextState: "3"
                }
            },
            "- orbital overlap": {
                o: {
                    action_: [
                        "output",
                        {
                            type_: "insert",
                            option: "hyphen"
                        }
                    ],
                    nextState: "2"
                },
                d: {
                    action_: [
                        "output",
                        {
                            type_: "insert",
                            option: "hyphen"
                        }
                    ],
                    nextState: "2"
                }
            },
            "-": {
                "0|1|2": {
                    action_: [
                        {
                            type_: "output",
                            option: 1
                        },
                        "beginsWithBond=true",
                        {
                            type_: "bond",
                            option: "-"
                        }
                    ],
                    nextState: "3"
                },
                3: {
                    action_: {
                        type_: "bond",
                        option: "-"
                    }
                },
                a: {
                    action_: [
                        "output",
                        {
                            type_: "insert",
                            option: "hyphen"
                        }
                    ],
                    nextState: "2"
                },
                as: {
                    action_: [
                        {
                            type_: "output",
                            option: 2
                        },
                        {
                            type_: "bond",
                            option: "-"
                        }
                    ],
                    nextState: "3"
                },
                b: {
                    action_: "b="
                },
                o: {
                    action_: {
                        type_: "- after o/d",
                        option: !1
                    },
                    nextState: "2"
                },
                q: {
                    action_: {
                        type_: "- after o/d",
                        option: !1
                    },
                    nextState: "2"
                },
                "d|qd|dq": {
                    action_: {
                        type_: "- after o/d",
                        option: !0
                    },
                    nextState: "2"
                },
                "D|qD|p": {
                    action_: [
                        "output",
                        {
                            type_: "bond",
                            option: "-"
                        }
                    ],
                    nextState: "3"
                }
            },
            amount2: {
                "1|3": {
                    action_: "a=",
                    nextState: "a"
                }
            },
            letters: {
                "0|1|2|3|a|as|b|p|bp|o": {
                    action_: "o=",
                    nextState: "o"
                },
                "q|dq": {
                    action_: [
                        "output",
                        "o="
                    ],
                    nextState: "o"
                },
                "d|D|qd|qD": {
                    action_: "o after d",
                    nextState: "o"
                }
            },
            digits: {
                o: {
                    action_: "q=",
                    nextState: "q"
                },
                "d|D": {
                    action_: "q=",
                    nextState: "dq"
                },
                q: {
                    action_: [
                        "output",
                        "o="
                    ],
                    nextState: "o"
                },
                a: {
                    action_: "o=",
                    nextState: "o"
                }
            },
            "space A": {
                "b|p|bp": {}
            },
            space: {
                a: {
                    nextState: "as"
                },
                0: {
                    action_: "sb=false"
                },
                "1|2": {
                    action_: "sb=true"
                },
                "r|rt|rd|rdt|rdq": {
                    action_: "output",
                    nextState: "0"
                },
                "*": {
                    action_: [
                        "output",
                        "sb=true"
                    ],
                    nextState: "1"
                }
            },
            "1st-level escape": {
                "1|2": {
                    action_: [
                        "output",
                        {
                            type_: "insert+p1",
                            option: "1st-level escape"
                        }
                    ]
                },
                "*": {
                    action_: [
                        "output",
                        {
                            type_: "insert+p1",
                            option: "1st-level escape"
                        }
                    ],
                    nextState: "0"
                }
            },
            "[(...)]": {
                "r|rt": {
                    action_: "rd=",
                    nextState: "rd"
                },
                "rd|rdt": {
                    action_: "rq=",
                    nextState: "rdq"
                }
            },
            "...": {
                "o|d|D|dq|qd|qD": {
                    action_: [
                        "output",
                        {
                            type_: "bond",
                            option: "..."
                        }
                    ],
                    nextState: "3"
                },
                "*": {
                    action_: [
                        {
                            type_: "output",
                            option: 1
                        },
                        {
                            type_: "insert",
                            option: "ellipsis"
                        }
                    ],
                    nextState: "1"
                }
            },
            ". |* ": {
                "*": {
                    action_: [
                        "output",
                        {
                            type_: "insert",
                            option: "addition compound"
                        }
                    ],
                    nextState: "1"
                }
            },
            "state of aggregation $": {
                "*": {
                    action_: [
                        "output",
                        "state of aggregation"
                    ],
                    nextState: "1"
                }
            },
            "{[(": {
                "a|as|o": {
                    action_: [
                        "o=",
                        "output",
                        "parenthesisLevel++"
                    ],
                    nextState: "2"
                },
                "0|1|2|3": {
                    action_: [
                        "o=",
                        "output",
                        "parenthesisLevel++"
                    ],
                    nextState: "2"
                },
                "*": {
                    action_: [
                        "output",
                        "o=",
                        "output",
                        "parenthesisLevel++"
                    ],
                    nextState: "2"
                }
            },
            ")]}": {
                "0|1|2|3|b|p|bp|o": {
                    action_: [
                        "o=",
                        "parenthesisLevel--"
                    ],
                    nextState: "o"
                },
                "a|as|d|D|q|qd|qD|dq": {
                    action_: [
                        "output",
                        "o=",
                        "parenthesisLevel--"
                    ],
                    nextState: "o"
                }
            },
            ", ": {
                "*": {
                    action_: [
                        "output",
                        "comma"
                    ],
                    nextState: "0"
                }
            },
            "^_": {
                "*": {}
            },
            "^{(...)}|^($...$)": {
                "0|1|2|as": {
                    action_: "b=",
                    nextState: "b"
                },
                p: {
                    action_: "b=",
                    nextState: "bp"
                },
                "3|o": {
                    action_: "d= kv",
                    nextState: "D"
                },
                q: {
                    action_: "d=",
                    nextState: "qD"
                },
                "d|D|qd|qD|dq": {
                    action_: [
                        "output",
                        "d="
                    ],
                    nextState: "D"
                }
            },
            "^a|^\\x{}{}|^\\x{}|^\\x|'": {
                "0|1|2|as": {
                    action_: "b=",
                    nextState: "b"
                },
                p: {
                    action_: "b=",
                    nextState: "bp"
                },
                "3|o": {
                    action_: "d= kv",
                    nextState: "d"
                },
                q: {
                    action_: "d=",
                    nextState: "qd"
                },
                "d|qd|D|qD": {
                    action_: "d="
                },
                dq: {
                    action_: [
                        "output",
                        "d="
                    ],
                    nextState: "d"
                }
            },
            "_{(state of aggregation)}$": {
                "d|D|q|qd|qD|dq": {
                    action_: [
                        "output",
                        "q="
                    ],
                    nextState: "q"
                }
            },
            "_{(...)}|_($...$)|_9|_\\x{}{}|_\\x{}|_\\x": {
                "0|1|2|as": {
                    action_: "p=",
                    nextState: "p"
                },
                b: {
                    action_: "p=",
                    nextState: "bp"
                },
                "3|o": {
                    action_: "q=",
                    nextState: "q"
                },
                "d|D": {
                    action_: "q=",
                    nextState: "dq"
                },
                "q|qd|qD|dq": {
                    action_: [
                        "output",
                        "q="
                    ],
                    nextState: "q"
                }
            },
            "=<>": {
                "0|1|2|3|a|as|o|q|d|D|qd|qD|dq": {
                    action_: [
                        {
                            type_: "output",
                            option: 2
                        },
                        "bond"
                    ],
                    nextState: "3"
                }
            },
            "#": {
                "0|1|2|3|a|as|o": {
                    action_: [
                        {
                            type_: "output",
                            option: 2
                        },
                        {
                            type_: "bond",
                            option: "#"
                        }
                    ],
                    nextState: "3"
                }
            },
            "{}": {
                "*": {
                    action_: {
                        type_: "output",
                        option: 1
                    },
                    nextState: "1"
                }
            },
            "{...}": {
                "0|1|2|3|a|as|b|p|bp": {
                    action_: "o=",
                    nextState: "o"
                },
                "o|d|D|q|qd|qD|dq": {
                    action_: [
                        "output",
                        "o="
                    ],
                    nextState: "o"
                }
            },
            "$...$": {
                a: {
                    action_: "a="
                },
                "0|1|2|3|as|b|p|bp|o": {
                    action_: "o=",
                    nextState: "o"
                },
                "as|o": {
                    action_: "o="
                },
                "q|d|D|qd|qD|dq": {
                    action_: [
                        "output",
                        "o="
                    ],
                    nextState: "o"
                }
            },
            "\\bond{(...)}": {
                "*": {
                    action_: [
                        {
                            type_: "output",
                            option: 2
                        },
                        "bond"
                    ],
                    nextState: "3"
                }
            },
            "\\frac{(...)}": {
                "*": {
                    action_: [
                        {
                            type_: "output",
                            option: 1
                        },
                        "frac-output"
                    ],
                    nextState: "3"
                }
            },
            "\\overset{(...)}": {
                "*": {
                    action_: [
                        {
                            type_: "output",
                            option: 2
                        },
                        "overset-output"
                    ],
                    nextState: "3"
                }
            },
            "\\underset{(...)}": {
                "*": {
                    action_: [
                        {
                            type_: "output",
                            option: 2
                        },
                        "underset-output"
                    ],
                    nextState: "3"
                }
            },
            "\\underbrace{(...)}": {
                "*": {
                    action_: [
                        {
                            type_: "output",
                            option: 2
                        },
                        "underbrace-output"
                    ],
                    nextState: "3"
                }
            },
            "\\color{(...)}{(...)}1|\\color(...){(...)}2": {
                "*": {
                    action_: [
                        {
                            type_: "output",
                            option: 2
                        },
                        "color-output"
                    ],
                    nextState: "3"
                }
            },
            "\\color{(...)}0": {
                "*": {
                    action_: [
                        {
                            type_: "output",
                            option: 2
                        },
                        "color0-output"
                    ]
                }
            },
            "\\ce{(...)}": {
                "*": {
                    action_: [
                        {
                            type_: "output",
                            option: 2
                        },
                        "ce"
                    ],
                    nextState: "3"
                }
            },
            "\\,": {
                "*": {
                    action_: [
                        {
                            type_: "output",
                            option: 1
                        },
                        "copy"
                    ],
                    nextState: "1"
                }
            },
            "\\x{}{}|\\x{}|\\x": {
                "0|1|2|3|a|as|b|p|bp|o|c0": {
                    action_: [
                        "o=",
                        "output"
                    ],
                    nextState: "3"
                },
                "*": {
                    action_: [
                        "output",
                        "o=",
                        "output"
                    ],
                    nextState: "3"
                }
            },
            others: {
                "*": {
                    action_: [
                        {
                            type_: "output",
                            option: 1
                        },
                        "copy"
                    ],
                    nextState: "3"
                }
            },
            else2: {
                a: {
                    action_: "a to o",
                    nextState: "o",
                    revisit: !0
                },
                as: {
                    action_: [
                        "output",
                        "sb=true"
                    ],
                    nextState: "1",
                    revisit: !0
                },
                "r|rt|rd|rdt|rdq": {
                    action_: [
                        "output"
                    ],
                    nextState: "0",
                    revisit: !0
                },
                "*": {
                    action_: [
                        "output",
                        "copy"
                    ],
                    nextState: "3"
                }
            }
        }),
        actions: {
            "o after d": function(e1, t) {
                var i;
                if ((e1.d || "").match(/^[0-9]+$/)) {
                    var n = e1.d;
                    e1.d = void 0, i = this.output(e1), e1.b = n;
                } else i = this.output(e1);
                return Ut.actions["o="](e1, t), i;
            },
            "d= kv": function(e1, t) {
                e1.d = t, e1.dType = "kv";
            },
            "charge or bond": function(e1, t) {
                if (e1.beginsWithBond) {
                    var i = [];
                    return Ut.concatArray(i, this.output(e1)), Ut.concatArray(i, Ut.actions.bond(e1, t, "-")), i;
                }
                e1.d = t;
            },
            "- after o/d": function(e1, t, i) {
                var n = Ut.patterns.match_("orbital", e1.o || ""), r = Ut.patterns.match_("one lowercase greek letter $", e1.o || ""), o = Ut.patterns.match_("one lowercase latin letter $", e1.o || ""), a = Ut.patterns.match_("$one lowercase latin letter$ $", e1.o || ""), s = "-" === t && (n && "" === n.remainder || r || o || a);
                !s || e1.a || e1.b || e1.p || e1.d || e1.q || n || !o || (e1.o = "$" + e1.o + "$");
                var l = [];
                return s ? (Ut.concatArray(l, this.output(e1)), l.push({
                    type_: "hyphen"
                })) : (n = Ut.patterns.match_("digits", e1.d || ""), i && n && "" === n.remainder ? (Ut.concatArray(l, Ut.actions["d="](e1, t)), Ut.concatArray(l, this.output(e1))) : (Ut.concatArray(l, this.output(e1)), Ut.concatArray(l, Ut.actions.bond(e1, t, "-")))), l;
            },
            "a to o": function(e1) {
                e1.o = e1.a, e1.a = void 0;
            },
            "sb=true": function(e1) {
                e1.sb = !0;
            },
            "sb=false": function(e1) {
                e1.sb = !1;
            },
            "beginsWithBond=true": function(e1) {
                e1.beginsWithBond = !0;
            },
            "beginsWithBond=false": function(e1) {
                e1.beginsWithBond = !1;
            },
            "parenthesisLevel++": function(e1) {
                e1.parenthesisLevel++;
            },
            "parenthesisLevel--": function(e1) {
                e1.parenthesisLevel--;
            },
            "state of aggregation": function(e1, t) {
                return {
                    type_: "state of aggregation",
                    p1: Ut.go(t, "o")
                };
            },
            comma: function(e1, t) {
                var i = t.replace(/\s*$/, "");
                return i !== t && 0 === e1.parenthesisLevel ? {
                    type_: "comma enumeration L",
                    p1: i
                } : {
                    type_: "comma enumeration M",
                    p1: i
                };
            },
            output: function(e1, t, i) {
                var n, r, o;
                for(var a in e1.r ? (r = "M" === e1.rdt ? Ut.go(e1.rd, "tex-math") : "T" === e1.rdt ? [
                    {
                        type_: "text",
                        p1: e1.rd || ""
                    }
                ] : Ut.go(e1.rd), o = "M" === e1.rqt ? Ut.go(e1.rq, "tex-math") : "T" === e1.rqt ? [
                    {
                        type_: "text",
                        p1: e1.rq || ""
                    }
                ] : Ut.go(e1.rq), n = {
                    type_: "arrow",
                    r: e1.r,
                    rd: r,
                    rq: o
                }) : (n = [], (e1.a || e1.b || e1.p || e1.o || e1.q || e1.d || i) && (e1.sb && n.push({
                    type_: "entitySkip"
                }), e1.o || e1.q || e1.d || e1.b || e1.p || 2 === i ? e1.o || e1.q || e1.d || !e1.b && !e1.p ? e1.o && "kv" === e1.dType && Ut.patterns.match_("d-oxidation$", e1.d || "") ? e1.dType = "oxidation" : e1.o && "kv" === e1.dType && !e1.q && (e1.dType = void 0) : (e1.o = e1.a, e1.d = e1.b, e1.q = e1.p, e1.a = e1.b = e1.p = void 0) : (e1.o = e1.a, e1.a = void 0), n.push({
                    type_: "chemfive",
                    a: Ut.go(e1.a, "a"),
                    b: Ut.go(e1.b, "bd"),
                    p: Ut.go(e1.p, "pq"),
                    o: Ut.go(e1.o, "o"),
                    q: Ut.go(e1.q, "pq"),
                    d: Ut.go(e1.d, "oxidation" === e1.dType ? "oxidation" : "bd"),
                    dType: e1.dType
                }))), e1)"parenthesisLevel" !== a && "beginsWithBond" !== a && delete e1[a];
                return n;
            },
            "oxidation-output": function(e1, t) {
                var i = [
                    "{"
                ];
                return Ut.concatArray(i, Ut.go(t, "oxidation")), i.push("}"), i;
            },
            "frac-output": function(e1, t) {
                return {
                    type_: "frac-ce",
                    p1: Ut.go(t[0]),
                    p2: Ut.go(t[1])
                };
            },
            "overset-output": function(e1, t) {
                return {
                    type_: "overset",
                    p1: Ut.go(t[0]),
                    p2: Ut.go(t[1])
                };
            },
            "underset-output": function(e1, t) {
                return {
                    type_: "underset",
                    p1: Ut.go(t[0]),
                    p2: Ut.go(t[1])
                };
            },
            "underbrace-output": function(e1, t) {
                return {
                    type_: "underbrace",
                    p1: Ut.go(t[0]),
                    p2: Ut.go(t[1])
                };
            },
            "color-output": function(e1, t) {
                return {
                    type_: "color",
                    color1: t[0],
                    color2: Ut.go(t[1])
                };
            },
            "r=": function(e1, t) {
                e1.r = t;
            },
            "rdt=": function(e1, t) {
                e1.rdt = t;
            },
            "rd=": function(e1, t) {
                e1.rd = t;
            },
            "rqt=": function(e1, t) {
                e1.rqt = t;
            },
            "rq=": function(e1, t) {
                e1.rq = t;
            },
            operator: function(e1, t, i) {
                return {
                    type_: "operator",
                    kind_: i || t
                };
            }
        }
    },
    a: {
        transitions: Ut.createTransitions({
            empty: {
                "*": {}
            },
            "1/2$": {
                0: {
                    action_: "1/2"
                }
            },
            else: {
                0: {
                    nextState: "1",
                    revisit: !0
                }
            },
            "$(...)$": {
                "*": {
                    action_: "tex-math tight",
                    nextState: "1"
                }
            },
            ",": {
                "*": {
                    action_: {
                        type_: "insert",
                        option: "commaDecimal"
                    }
                }
            },
            else2: {
                "*": {
                    action_: "copy"
                }
            }
        }),
        actions: {}
    },
    o: {
        transitions: Ut.createTransitions({
            empty: {
                "*": {}
            },
            "1/2$": {
                0: {
                    action_: "1/2"
                }
            },
            else: {
                0: {
                    nextState: "1",
                    revisit: !0
                }
            },
            letters: {
                "*": {
                    action_: "rm"
                }
            },
            "\\ca": {
                "*": {
                    action_: {
                        type_: "insert",
                        option: "circa"
                    }
                }
            },
            "\\x{}{}|\\x{}|\\x": {
                "*": {
                    action_: "copy"
                }
            },
            "${(...)}$|$(...)$": {
                "*": {
                    action_: "tex-math"
                }
            },
            "{(...)}": {
                "*": {
                    action_: "{text}"
                }
            },
            else2: {
                "*": {
                    action_: "copy"
                }
            }
        }),
        actions: {}
    },
    text: {
        transitions: Ut.createTransitions({
            empty: {
                "*": {
                    action_: "output"
                }
            },
            "{...}": {
                "*": {
                    action_: "text="
                }
            },
            "${(...)}$|$(...)$": {
                "*": {
                    action_: "tex-math"
                }
            },
            "\\greek": {
                "*": {
                    action_: [
                        "output",
                        "rm"
                    ]
                }
            },
            "\\,|\\x{}{}|\\x{}|\\x": {
                "*": {
                    action_: [
                        "output",
                        "copy"
                    ]
                }
            },
            else: {
                "*": {
                    action_: "text="
                }
            }
        }),
        actions: {
            output: function(e1) {
                if (e1.text_) {
                    var t = {
                        type_: "text",
                        p1: e1.text_
                    };
                    for(var i in e1)delete e1[i];
                    return t;
                }
            }
        }
    },
    pq: {
        transitions: Ut.createTransitions({
            empty: {
                "*": {}
            },
            "state of aggregation $": {
                "*": {
                    action_: "state of aggregation"
                }
            },
            i$: {
                0: {
                    nextState: "!f",
                    revisit: !0
                }
            },
            "(KV letters),": {
                0: {
                    action_: "rm",
                    nextState: "0"
                }
            },
            formula$: {
                0: {
                    nextState: "f",
                    revisit: !0
                }
            },
            "1/2$": {
                0: {
                    action_: "1/2"
                }
            },
            else: {
                0: {
                    nextState: "!f",
                    revisit: !0
                }
            },
            "${(...)}$|$(...)$": {
                "*": {
                    action_: "tex-math"
                }
            },
            "{(...)}": {
                "*": {
                    action_: "text"
                }
            },
            "a-z": {
                f: {
                    action_: "tex-math"
                }
            },
            letters: {
                "*": {
                    action_: "rm"
                }
            },
            "-9.,9": {
                "*": {
                    action_: "9,9"
                }
            },
            ",": {
                "*": {
                    action_: {
                        type_: "insert+p1",
                        option: "comma enumeration S"
                    }
                }
            },
            "\\color{(...)}{(...)}1|\\color(...){(...)}2": {
                "*": {
                    action_: "color-output"
                }
            },
            "\\color{(...)}0": {
                "*": {
                    action_: "color0-output"
                }
            },
            "\\ce{(...)}": {
                "*": {
                    action_: "ce"
                }
            },
            "\\,|\\x{}{}|\\x{}|\\x": {
                "*": {
                    action_: "copy"
                }
            },
            else2: {
                "*": {
                    action_: "copy"
                }
            }
        }),
        actions: {
            "state of aggregation": function(e1, t) {
                return {
                    type_: "state of aggregation subscript",
                    p1: Ut.go(t, "o")
                };
            },
            "color-output": function(e1, t) {
                return {
                    type_: "color",
                    color1: t[0],
                    color2: Ut.go(t[1], "pq")
                };
            }
        }
    },
    bd: {
        transitions: Ut.createTransitions({
            empty: {
                "*": {}
            },
            x$: {
                0: {
                    nextState: "!f",
                    revisit: !0
                }
            },
            formula$: {
                0: {
                    nextState: "f",
                    revisit: !0
                }
            },
            else: {
                0: {
                    nextState: "!f",
                    revisit: !0
                }
            },
            "-9.,9 no missing 0": {
                "*": {
                    action_: "9,9"
                }
            },
            ".": {
                "*": {
                    action_: {
                        type_: "insert",
                        option: "electron dot"
                    }
                }
            },
            "a-z": {
                f: {
                    action_: "tex-math"
                }
            },
            x: {
                "*": {
                    action_: {
                        type_: "insert",
                        option: "KV x"
                    }
                }
            },
            letters: {
                "*": {
                    action_: "rm"
                }
            },
            "'": {
                "*": {
                    action_: {
                        type_: "insert",
                        option: "prime"
                    }
                }
            },
            "${(...)}$|$(...)$": {
                "*": {
                    action_: "tex-math"
                }
            },
            "{(...)}": {
                "*": {
                    action_: "text"
                }
            },
            "\\color{(...)}{(...)}1|\\color(...){(...)}2": {
                "*": {
                    action_: "color-output"
                }
            },
            "\\color{(...)}0": {
                "*": {
                    action_: "color0-output"
                }
            },
            "\\ce{(...)}": {
                "*": {
                    action_: "ce"
                }
            },
            "\\,|\\x{}{}|\\x{}|\\x": {
                "*": {
                    action_: "copy"
                }
            },
            else2: {
                "*": {
                    action_: "copy"
                }
            }
        }),
        actions: {
            "color-output": function(e1, t) {
                return {
                    type_: "color",
                    color1: t[0],
                    color2: Ut.go(t[1], "bd")
                };
            }
        }
    },
    oxidation: {
        transitions: Ut.createTransitions({
            empty: {
                "*": {}
            },
            "roman numeral": {
                "*": {
                    action_: "roman-numeral"
                }
            },
            "${(...)}$|$(...)$": {
                "*": {
                    action_: "tex-math"
                }
            },
            else: {
                "*": {
                    action_: "copy"
                }
            }
        }),
        actions: {
            "roman-numeral": function(e1, t) {
                return {
                    type_: "roman numeral",
                    p1: t || ""
                };
            }
        }
    },
    "tex-math": {
        transitions: Ut.createTransitions({
            empty: {
                "*": {
                    action_: "output"
                }
            },
            "\\ce{(...)}": {
                "*": {
                    action_: [
                        "output",
                        "ce"
                    ]
                }
            },
            "{...}|\\,|\\x{}{}|\\x{}|\\x": {
                "*": {
                    action_: "o="
                }
            },
            else: {
                "*": {
                    action_: "o="
                }
            }
        }),
        actions: {
            output: function(e1) {
                if (e1.o) {
                    var t = {
                        type_: "tex-math",
                        p1: e1.o
                    };
                    for(var i in e1)delete e1[i];
                    return t;
                }
            }
        }
    },
    "tex-math tight": {
        transitions: Ut.createTransitions({
            empty: {
                "*": {
                    action_: "output"
                }
            },
            "\\ce{(...)}": {
                "*": {
                    action_: [
                        "output",
                        "ce"
                    ]
                }
            },
            "{...}|\\,|\\x{}{}|\\x{}|\\x": {
                "*": {
                    action_: "o="
                }
            },
            "-|+": {
                "*": {
                    action_: "tight operator"
                }
            },
            else: {
                "*": {
                    action_: "o="
                }
            }
        }),
        actions: {
            "tight operator": function(e1, t) {
                e1.o = (e1.o || "") + "{" + t + "}";
            },
            output: function(e1) {
                if (e1.o) {
                    var t = {
                        type_: "tex-math",
                        p1: e1.o
                    };
                    for(var i in e1)delete e1[i];
                    return t;
                }
            }
        }
    },
    "9,9": {
        transitions: Ut.createTransitions({
            empty: {
                "*": {}
            },
            ",": {
                "*": {
                    action_: "comma"
                }
            },
            else: {
                "*": {
                    action_: "copy"
                }
            }
        }),
        actions: {
            comma: function() {
                return {
                    type_: "commaDecimal"
                };
            }
        }
    },
    pu: {
        transitions: Ut.createTransitions({
            empty: {
                "*": {
                    action_: "output"
                }
            },
            space$: {
                "*": {
                    action_: [
                        "output",
                        "space"
                    ]
                }
            },
            "{[(|)]}": {
                "0|a": {
                    action_: "copy"
                }
            },
            "(-)(9)^(-9)": {
                0: {
                    action_: "number^",
                    nextState: "a"
                }
            },
            "(-)(9.,9)(e)(99)": {
                0: {
                    action_: "enumber",
                    nextState: "a"
                }
            },
            space: {
                "0|a": {}
            },
            "pm-operator": {
                "0|a": {
                    action_: {
                        type_: "operator",
                        option: "\\pm"
                    },
                    nextState: "0"
                }
            },
            operator: {
                "0|a": {
                    action_: "copy",
                    nextState: "0"
                }
            },
            "//": {
                d: {
                    action_: "o=",
                    nextState: "/"
                }
            },
            "/": {
                d: {
                    action_: "o=",
                    nextState: "/"
                }
            },
            "{...}|else": {
                "0|d": {
                    action_: "d=",
                    nextState: "d"
                },
                a: {
                    action_: [
                        "space",
                        "d="
                    ],
                    nextState: "d"
                },
                "/|q": {
                    action_: "q=",
                    nextState: "q"
                }
            }
        }),
        actions: {
            enumber: function(e1, t) {
                var i = [];
                return "+-" === t[0] || "+/-" === t[0] ? i.push("\\pm ") : t[0] && i.push(t[0]), t[1] && (Ut.concatArray(i, Ut.go(t[1], "pu-9,9")), t[2] && (t[2].match(/[,.]/) ? Ut.concatArray(i, Ut.go(t[2], "pu-9,9")) : i.push(t[2])), t[3] = t[4] || t[3], t[3] && (t[3] = t[3].trim(), "e" === t[3] || "*" === t[3].substr(0, 1) ? i.push({
                    type_: "cdot"
                }) : i.push({
                    type_: "times"
                }))), t[3] && i.push("10^{" + t[5] + "}"), i;
            },
            "number^": function(e1, t) {
                var i = [];
                return "+-" === t[0] || "+/-" === t[0] ? i.push("\\pm ") : t[0] && i.push(t[0]), Ut.concatArray(i, Ut.go(t[1], "pu-9,9")), i.push("^{" + t[2] + "}"), i;
            },
            operator: function(e1, t, i) {
                return {
                    type_: "operator",
                    kind_: i || t
                };
            },
            space: function() {
                return {
                    type_: "pu-space-1"
                };
            },
            output: function(e1) {
                var t, i = Ut.patterns.match_("{(...)}", e1.d || "");
                i && "" === i.remainder && (e1.d = i.match_);
                var n = Ut.patterns.match_("{(...)}", e1.q || "");
                if (n && "" === n.remainder && (e1.q = n.match_), e1.d && (e1.d = e1.d.replace(/\u00B0C|\^oC|\^{o}C/g, "{}^{\\circ}C"), e1.d = e1.d.replace(/\u00B0F|\^oF|\^{o}F/g, "{}^{\\circ}F")), e1.q) {
                    e1.q = e1.q.replace(/\u00B0C|\^oC|\^{o}C/g, "{}^{\\circ}C"), e1.q = e1.q.replace(/\u00B0F|\^oF|\^{o}F/g, "{}^{\\circ}F");
                    var r = {
                        d: Ut.go(e1.d, "pu"),
                        q: Ut.go(e1.q, "pu")
                    };
                    "//" === e1.o ? t = {
                        type_: "pu-frac",
                        p1: r.d,
                        p2: r.q
                    } : (t = r.d, r.d.length > 1 || r.q.length > 1 ? t.push({
                        type_: " / "
                    }) : t.push({
                        type_: "/"
                    }), Ut.concatArray(t, r.q));
                } else t = Ut.go(e1.d, "pu-2");
                for(var o in e1)delete e1[o];
                return t;
            }
        }
    },
    "pu-2": {
        transitions: Ut.createTransitions({
            empty: {
                "*": {
                    action_: "output"
                }
            },
            "*": {
                "*": {
                    action_: [
                        "output",
                        "cdot"
                    ],
                    nextState: "0"
                }
            },
            "\\x": {
                "*": {
                    action_: "rm="
                }
            },
            space: {
                "*": {
                    action_: [
                        "output",
                        "space"
                    ],
                    nextState: "0"
                }
            },
            "^{(...)}|^(-1)": {
                1: {
                    action_: "^(-1)"
                }
            },
            "-9.,9": {
                0: {
                    action_: "rm=",
                    nextState: "0"
                },
                1: {
                    action_: "^(-1)",
                    nextState: "0"
                }
            },
            "{...}|else": {
                "*": {
                    action_: "rm=",
                    nextState: "1"
                }
            }
        }),
        actions: {
            cdot: function() {
                return {
                    type_: "tight cdot"
                };
            },
            "^(-1)": function(e1, t) {
                e1.rm += "^{" + t + "}";
            },
            space: function() {
                return {
                    type_: "pu-space-2"
                };
            },
            output: function(e1) {
                var t = [];
                if (e1.rm) {
                    var i = Ut.patterns.match_("{(...)}", e1.rm || "");
                    t = i && "" === i.remainder ? Ut.go(i.match_, "pu") : {
                        type_: "rm",
                        p1: e1.rm
                    };
                }
                for(var n in e1)delete e1[n];
                return t;
            }
        }
    },
    "pu-9,9": {
        transitions: Ut.createTransitions({
            empty: {
                0: {
                    action_: "output-0"
                },
                o: {
                    action_: "output-o"
                }
            },
            ",": {
                0: {
                    action_: [
                        "output-0",
                        "comma"
                    ],
                    nextState: "o"
                }
            },
            ".": {
                0: {
                    action_: [
                        "output-0",
                        "copy"
                    ],
                    nextState: "o"
                }
            },
            else: {
                "*": {
                    action_: "text="
                }
            }
        }),
        actions: {
            comma: function() {
                return {
                    type_: "commaDecimal"
                };
            },
            "output-0": function(e1) {
                var t = [];
                if (e1.text_ = e1.text_ || "", e1.text_.length > 4) {
                    var i = e1.text_.length % 3;
                    0 === i && (i = 3);
                    for(var n = e1.text_.length - 3; n > 0; n -= 3)t.push(e1.text_.substr(n, 3)), t.push({
                        type_: "1000 separator"
                    });
                    t.push(e1.text_.substr(0, i)), t.reverse();
                } else t.push(e1.text_);
                for(var r in e1)delete e1[r];
                return t;
            },
            "output-o": function(e1) {
                var t = [];
                if (e1.text_ = e1.text_ || "", e1.text_.length > 4) {
                    for(var i = e1.text_.length - 3, n = 0; n < i; n += 3)t.push(e1.text_.substr(n, 3)), t.push({
                        type_: "1000 separator"
                    });
                    t.push(e1.text_.substr(n));
                } else t.push(e1.text_);
                for(var r in e1)delete e1[r];
                return t;
            }
        }
    }
};
var Gt = {
    go: function(e1, t) {
        if (!e1) return "";
        for(var i = "", n = !1, r = 0; r < e1.length; r++){
            var o = e1[r];
            "string" == typeof o ? i += o : (i += Gt._go2(o), "1st-level escape" === o.type_ && (n = !0));
        }
        return t || n || !i || (i = "{" + i + "}"), i;
    },
    _goInner: function(e1) {
        return e1 ? Gt.go(e1, !0) : e1;
    },
    _go2: function(e1) {
        var t;
        switch(e1.type_){
            case "chemfive":
                t = "";
                var i = {
                    a: Gt._goInner(e1.a),
                    b: Gt._goInner(e1.b),
                    p: Gt._goInner(e1.p),
                    o: Gt._goInner(e1.o),
                    q: Gt._goInner(e1.q),
                    d: Gt._goInner(e1.d)
                };
                i.a && (i.a.match(/^[+\-]/) && (i.a = "{" + i.a + "}"), t += i.a + "\\,"), (i.b || i.p) && (t += "{\\vphantom{X}}", t += "^{\\hphantom{" + (i.b || "") + "}}_{\\hphantom{" + (i.p || "") + "}}", t += "{\\vphantom{X}}", t += "^{\\smash[t]{\\vphantom{2}}\\mathllap{" + (i.b || "") + "}}", t += "_{\\vphantom{2}\\mathllap{\\smash[t]{" + (i.p || "") + "}}}"), i.o && (i.o.match(/^[+\-]/) && (i.o = "{" + i.o + "}"), t += i.o), "kv" === e1.dType ? ((i.d || i.q) && (t += "{\\vphantom{X}}"), i.d && (t += "^{" + i.d + "}"), i.q && (t += "_{\\smash[t]{" + i.q + "}}")) : "oxidation" === e1.dType ? (i.d && (t += "{\\vphantom{X}}", t += "^{" + i.d + "}"), i.q && (t += "{\\vphantom{X}}", t += "_{\\smash[t]{" + i.q + "}}")) : (i.q && (t += "{\\vphantom{X}}", t += "_{\\smash[t]{" + i.q + "}}"), i.d && (t += "{\\vphantom{X}}", t += "^{" + i.d + "}"));
                break;
            case "rm":
            case "roman numeral":
                t = "\\mathrm{" + e1.p1 + "}";
                break;
            case "text":
                e1.p1.match(/[\^_]/) ? (e1.p1 = e1.p1.replace(" ", "~").replace("-", "\\text{-}"), t = "\\mathrm{" + e1.p1 + "}") : t = "\\text{" + e1.p1 + "}";
                break;
            case "state of aggregation":
                t = "\\mskip2mu " + Gt._goInner(e1.p1);
                break;
            case "state of aggregation subscript":
                t = "\\mskip1mu " + Gt._goInner(e1.p1);
                break;
            case "bond":
                if (!(t = Gt._getBond(e1.kind_))) throw [
                    "MhchemErrorBond",
                    "mhchem Error. Unknown bond type (" + e1.kind_ + ")"
                ];
                break;
            case "frac":
                var n = "\\frac{" + e1.p1 + "}{" + e1.p2 + "}";
                t = "\\mathchoice{\\textstyle" + n + "}{" + n + "}{" + n + "}{" + n + "}";
                break;
            case "pu-frac":
                var r = "\\frac{" + Gt._goInner(e1.p1) + "}{" + Gt._goInner(e1.p2) + "}";
                t = "\\mathchoice{\\textstyle" + r + "}{" + r + "}{" + r + "}{" + r + "}";
                break;
            case "tex-math":
            case "1st-level escape":
                t = e1.p1 + " ";
                break;
            case "frac-ce":
                t = "\\frac{" + Gt._goInner(e1.p1) + "}{" + Gt._goInner(e1.p2) + "}";
                break;
            case "overset":
                t = "\\overset{" + Gt._goInner(e1.p1) + "}{" + Gt._goInner(e1.p2) + "}";
                break;
            case "underset":
                t = "\\underset{" + Gt._goInner(e1.p1) + "}{" + Gt._goInner(e1.p2) + "}";
                break;
            case "underbrace":
                t = "\\underbrace{" + Gt._goInner(e1.p1) + "}_{" + Gt._goInner(e1.p2) + "}";
                break;
            case "color":
                t = "{\\color{" + e1.color1 + "}{" + Gt._goInner(e1.color2) + "}}";
                break;
            case "color0":
                t = "\\color{" + e1.color + "}";
                break;
            case "arrow":
                var o = {
                    rd: Gt._goInner(e1.rd),
                    rq: Gt._goInner(e1.rq)
                }, a = "\\x" + Gt._getArrow(e1.r);
                o.rq && (a += "[{" + o.rq + "}]"), t = a += o.rd ? "{" + o.rd + "}" : "{}";
                break;
            case "operator":
                t = Gt._getOperator(e1.kind_);
                break;
            case "space":
                t = " ";
                break;
            case "entitySkip":
            case "pu-space-1":
                t = "~";
                break;
            case "pu-space-2":
                t = "\\mkern3mu ";
                break;
            case "1000 separator":
                t = "\\mkern2mu ";
                break;
            case "commaDecimal":
                t = "{,}";
                break;
            case "comma enumeration L":
                t = "{" + e1.p1 + "}\\mkern6mu ";
                break;
            case "comma enumeration M":
                t = "{" + e1.p1 + "}\\mkern3mu ";
                break;
            case "comma enumeration S":
                t = "{" + e1.p1 + "}\\mkern1mu ";
                break;
            case "hyphen":
                t = "\\text{-}";
                break;
            case "addition compound":
                t = "\\,{\\cdot}\\,";
                break;
            case "electron dot":
                t = "\\mkern1mu \\bullet\\mkern1mu ";
                break;
            case "KV x":
                t = "{\\times}";
                break;
            case "prime":
                t = "\\prime ";
                break;
            case "cdot":
                t = "\\cdot ";
                break;
            case "tight cdot":
                t = "\\mkern1mu{\\cdot}\\mkern1mu ";
                break;
            case "times":
                t = "\\times ";
                break;
            case "circa":
                t = "{\\sim}";
                break;
            case "^":
                t = "uparrow";
                break;
            case "v":
                t = "downarrow";
                break;
            case "ellipsis":
                t = "\\ldots ";
                break;
            case "/":
                t = "/";
                break;
            case " / ":
                t = "\\,/\\,";
                break;
            default:
                throw [
                    "MhchemBugT",
                    "mhchem bug T. Please report."
                ];
        }
        return t;
    },
    _getArrow: function(e1) {
        switch(e1){
            case "->":
            case "→":
            case "⟶":
                return "rightarrow";
            case "<-":
                return "leftarrow";
            case "<->":
                return "leftrightarrow";
            case "<-->":
                return "rightleftarrows";
            case "<=>":
            case "⇌":
                return "rightleftharpoons";
            case "<=>>":
                return "rightequilibrium";
            case "<<=>":
                return "leftequilibrium";
            default:
                throw [
                    "MhchemBugT",
                    "mhchem bug T. Please report."
                ];
        }
    },
    _getBond: function(e1) {
        switch(e1){
            case "-":
            case "1":
                return "{-}";
            case "=":
            case "2":
                return "{=}";
            case "#":
            case "3":
                return "{\\equiv}";
            case "~":
                return "{\\tripledash}";
            case "~-":
                return "{\\mathrlap{\\raisebox{-.1em}{$-$}}\\raisebox{.1em}{$\\tripledash$}}";
            case "~=":
            case "~--":
                return "{\\mathrlap{\\raisebox{-.2em}{$-$}}\\mathrlap{\\raisebox{.2em}{$\\tripledash$}}-}";
            case "-~-":
                return "{\\mathrlap{\\raisebox{-.2em}{$-$}}\\mathrlap{\\raisebox{.2em}{$-$}}\\tripledash}";
            case "...":
                return "{{\\cdot}{\\cdot}{\\cdot}}";
            case "....":
                return "{{\\cdot}{\\cdot}{\\cdot}{\\cdot}}";
            case "->":
                return "{\\rightarrow}";
            case "<-":
                return "{\\leftarrow}";
            case "<":
                return "{<}";
            case ">":
                return "{>}";
            default:
                throw [
                    "MhchemBugT",
                    "mhchem bug T. Please report."
                ];
        }
    },
    _getOperator: function(e1) {
        switch(e1){
            case "+":
                return " {}+{} ";
            case "-":
                return " {}-{} ";
            case "=":
                return " {}={} ";
            case "<":
                return " {}<{} ";
            case ">":
                return " {}>{} ";
            case "<<":
                return " {}\\ll{} ";
            case ">>":
                return " {}\\gg{} ";
            case "\\pm":
                return " {}\\pm{} ";
            case "\\approx":
            case "$\\approx$":
                return " {}\\approx{} ";
            case "v":
            case "(v)":
                return " \\downarrow{} ";
            case "^":
            case "(^)":
                return " \\uparrow{} ";
            default:
                throw [
                    "MhchemBugT",
                    "mhchem bug T. Please report."
                ];
        }
    }
};
class Zt extends ot {
    static fromJson(e1, t) {
        return new Zt(e1.command, e1.delim, t, e1);
    }
    toJson() {
        return {
            ...super.toJson(),
            delim: this.value,
            size: this.size
        };
    }
    render(e1) {
        const t = new Ie(null);
        return t.delim = this.value, t;
    }
    serialize(e1) {
        return 1 === this.value.length ? this.command + this.value : `${this.command}{${this.value}}`;
    }
    constructor(e1, t, i, n){
        super("delim", i, {
            command: e1,
            style: null == n ? void 0 : n.style
        }), this.value = t, this.size = null == n ? void 0 : n.size;
    }
}
class Wt extends ot {
    static fromJson(e1, t) {
        return new Wt(e1.command, e1.delim, t, e1);
    }
    toJson() {
        return {
            ...super.toJson(),
            delim: this.value,
            size: this.size,
            delimClass: this.delimClass
        };
    }
    render(e1) {
        let t = function(e1, t, i, n) {
            var r;
            return void 0 === e1 || "." === e1 ? wt(i, null !== (r = n.type) && void 0 !== r ? r : "minner", n.classes) : ("<" === e1 || "\\lt" === e1 || "⟨" === e1 ? e1 = "\\langle" : ">" !== e1 && "\\gt" !== e1 && "⟩" !== e1 || (e1 = "\\rangle"), pt.has(e1) || gt.has(e1) ? ht(e1, t, !1, i, n) : ft.has(e1) ? mt(e1, yt[t], !1, i, n) : null);
        }(this.value, this.size, e1, {
            classes: this.delimClass
        });
        return t ? (t = this.bind(e1, t), this.caret && (t.caret = this.caret), t) : null;
    }
    serialize(e1) {
        return 1 === this.value.length ? this.command + this.value : `${this.command}{${this.value}}`;
    }
    constructor(e1, t, i, n){
        super("sizeddelim", i, {
            command: e1,
            style: n.style
        }), this.value = t, this.delimClass = n.delimClass, this.size = n.size;
    }
}
class Jt extends ot {
    static fromJson(e1, t) {
        return new Jt(e1.command, e1.body, e1.notation, t, e1);
    }
    toJson() {
        const e1 = {};
        return this.notation.downdiagonalstrike && (e1.downdiagonalstrike = !0), this.notation.updiagonalstrike && (e1.downdiagonalstrike = !0), this.notation.verticalstrike && (e1.downdiagonalstrike = !0), this.notation.horizontalstrike && (e1.downdiagonalstrike = !0), this.notation.updiagonalarrow && (e1.downdiagonalstrike = !0), this.notation.right && (e1.downdiagonalstrike = !0), this.notation.bottom && (e1.downdiagonalstrike = !0), this.notation.left && (e1.downdiagonalstrike = !0), this.notation.top && (e1.downdiagonalstrike = !0), this.notation.circle && (e1.downdiagonalstrike = !0), this.notation.roundedbox && (e1.downdiagonalstrike = !0), this.notation.madruwb && (e1.downdiagonalstrike = !0), this.notation.actuarial && (e1.downdiagonalstrike = !0), this.notation.box && (e1.downdiagonalstrike = !0), {
            ...super.toJson(),
            notation: e1,
            shadow: this.shadow,
            strokeWidth: this.strokeWidth,
            strokeStyle: this.strokeStyle,
            svgStrokeStyle: this.svgStrokeStyle,
            strokeColor: this.strokeColor,
            borderStyle: this.borderStyle,
            padding: this.padding
        };
    }
    serialize(e1) {
        var t;
        let i = null !== (t = this.command) && void 0 !== t ? t : "";
        if ("\\enclose" === this.command) {
            i += "{" + Object.keys(this.notation).join(" ") + "}";
            let e2 = "", t1 = "";
            this.backgroundcolor && "transparent" !== this.backgroundcolor && (e2 += t1 + 'mathbackground="' + this.backgroundcolor + '"', t1 = ","), this.shadow && "auto" !== this.shadow && (e2 += t1 + 'shadow="' + this.shadow + '"', t1 = ","), this.strokeWidth || "solid" !== this.strokeStyle ? (e2 += t1 + this.borderStyle, t1 = ",") : this.strokeColor && "currentColor" !== this.strokeColor && (e2 += t1 + 'mathcolor="' + this.strokeColor + '"', t1 = ","), e2 && (i += `[${e2}]`);
        }
        return i += `{${this.bodyToLatex(e1)}}`, i;
    }
    render(e1) {
        var t;
        const i = new Me(e1, this.style), n = ot.createBox(i, this.body);
        if (!n) return null;
        const r = null !== (t = we(this.padding && "auto" !== this.padding ? Bt(this.padding, {
            ...this.context,
            registers: e1.registers
        }) : i.getRegisterAsDimension("fboxsep"))) && void 0 !== t ? t : 0, o = function(e1) {
            if (!e1) return "1px";
            const t = e1.match(/([0-9][a-zA-Z\%]+)/);
            return null === t ? "1px" : t[1];
        }(this.borderStyle), a = new Ie(null, {
            classes: "ML__notation"
        });
        a.setStyle("position", "absolute"), a.setStyle("z-index", "-1"), a.setStyle("box-sizing", "border-box"), a.setStyle("top", `calc(-${o} / 2 - ${r}em)`), a.setStyle("left", `calc(-${o} / 2 - ${r}em)`), a.setStyle("height", `calc(100% + ${2 * r}em + 2 * ${o})`), a.height = n.height + r, a.depth = n.depth + r, a.setStyle("width", `calc(100% + ${2 * r}em + 2 * ${o})`), this.backgroundcolor && a.setStyle("background-color", this.backgroundcolor), this.notation.box && a.setStyle("border", this.borderStyle), this.notation.actuarial && (a.setStyle("border-top", this.borderStyle), a.setStyle("border-right", this.borderStyle)), this.notation.madruwb && (a.setStyle("border-bottom", this.borderStyle), a.setStyle("border-right", this.borderStyle)), this.notation.roundedbox && (a.setStyle("border-radius", "8px"), a.setStyle("border", this.borderStyle)), this.notation.circle && (a.setStyle("border-radius", "50%"), a.setStyle("border", this.borderStyle)), this.notation.top && a.setStyle("border-top", this.borderStyle), this.notation.left && a.setStyle("border-left", this.borderStyle), this.notation.right && a.setStyle("border-right", this.borderStyle), this.notation.bottom && a.setStyle("border-bottom", this.borderStyle);
        let s = "";
        if (this.notation.horizontalstrike && (s += '<line x1="3%"  y1="50%" x2="97%" y2="50%"', s += ` stroke-width="${this.strokeWidth}" stroke="${this.strokeColor}"`, s += ' stroke-linecap="round"', this.svgStrokeStyle && (s += ` stroke-dasharray="${this.svgStrokeStyle}"`), s += "/>"), this.notation.verticalstrike && (s += '<line x1="50%"  y1="3%" x2="50%" y2="97%"', s += ` stroke-width="${this.strokeWidth}" stroke="${this.strokeColor}"`, s += ' stroke-linecap="round"', this.svgStrokeStyle && (s += ` stroke-dasharray="${this.svgStrokeStyle}"`), s += "/>"), this.notation.updiagonalstrike && (s += '<line x1="3%"  y1="97%" x2="97%" y2="3%"', s += ` stroke-width="${this.strokeWidth}" stroke="${this.strokeColor}"`, s += ' stroke-linecap="round"', this.svgStrokeStyle && (s += ` stroke-dasharray="${this.svgStrokeStyle}"`), s += "/>"), this.notation.downdiagonalstrike && (s += '<line x1="3%"  y1="3%" x2="97%" y2="97%"', s += ` stroke-width="${this.strokeWidth}" stroke="${this.strokeColor}"`, s += ' stroke-linecap="round"', this.svgStrokeStyle && (s += ` stroke-dasharray="${this.svgStrokeStyle}"`), s += "/>"), s) {
            let e2;
            "none" !== this.shadow && (e2 = "auto" === this.shadow ? "filter: drop-shadow(0 0 .5px rgba(255, 255, 255, .7)) drop-shadow(1px 1px 2px #333)" : "filter: drop-shadow(" + this.shadow + ")"), function(e1, t, i) {
                e1.svgOverlay = t, e1.svgStyle = i;
            }(a, s, e2);
        }
        const l = new Ie([
            a,
            n
        ]);
        return l.setStyle("position", "relative"), l.setStyle("display", "inline"), l.height = n.height + r, l.depth = n.depth + r, l.left = r, l.right = r, this.caret && (l.caret = this.caret), l.wrap(i);
    }
    constructor(e1, t, i, n, r){
        super("enclose", n, {
            command: e1,
            style: r.style
        }), this.body = t, this.backgroundcolor = r.backgroundcolor, i.updiagonalarrow && (i.updiagonalstrike = !1), i.box && (i.left = !1, i.right = !1, i.bottom = !1, i.top = !1), this.notation = i, this.shadow = r.shadow, this.strokeWidth = r.strokeWidth, this.strokeStyle = r.strokeStyle, this.svgStrokeStyle = r.svgStrokeStyle, this.strokeColor = r.strokeColor, this.borderStyle = r.borderStyle, this.padding = r.padding, this.captureSelection = !0;
    }
}
class Xt extends ot {
    static fromJson(e1, t) {
        return new Xt(e1.command, e1.above, e1.below, t, e1);
    }
    toJson() {
        const e1 = {};
        return this.continuousFraction && (e1.continuousFraction = !0), this.numerPrefix && (e1.numerPrefix = this.numerPrefix), this.denomPrefix && (e1.denomPrefix = this.denomPrefix), this.leftDelim && (e1.leftDelim = this.leftDelim), this.rightDelim && (e1.rightDelim = this.rightDelim), this.hasBarLine || (e1.hasBarLine = !1), this.mathstyleName && (e1.mathstyleName = this.mathstyleName), {
            ...super.toJson(),
            ...e1
        };
    }
    serialize(e1) {
        return this.command + `{${this.aboveToLatex(e1)}}` + `{${this.belowToLatex(e1)}}`;
    }
    get children() {
        if (this._children) return this._children;
        const e1 = [];
        if ("numerator-denominator" === this.context.fractionNavigationOrder) {
            for (const t of this.above)e1.push(...t.children), e1.push(t);
            for (const t1 of this.below)e1.push(...t1.children), e1.push(t1);
        } else {
            for (const t2 of this.below)e1.push(...t2.children), e1.push(t2);
            for (const t3 of this.above)e1.push(...t3.children), e1.push(t3);
        }
        return this._children = e1, e1;
    }
    render(e1) {
        var t, i;
        const n = new Me(e1, this.style, this.mathstyleName), r = n.metrics, o = new Me(n, this.style, this.continuousFraction ? "" : "numerator"), a = this.numerPrefix ? new Ie([
            new Ie(this.numerPrefix),
            ot.createBox(o, this.above)
        ], {
            isTight: o.isTight,
            newList: !0
        }) : null !== (t = ot.createBox(o, this.above, {
            newList: !0
        })) && void 0 !== t ? t : new Ie(null, {
            newList: !0
        }), s = new Me(n, this.style, this.continuousFraction ? "" : "denominator"), l = this.denomPrefix ? new Ie([
            new Ie(this.denomPrefix),
            ot.createBox(s, this.below, {
                newList: !0
            })
        ]) : null !== (i = ot.createBox(s, this.below, {
            newList: !0
        })) && void 0 !== i ? i : new Ie(null, {
            newList: !0
        }), u = this.hasBarLine ? r.defaultRuleThickness : 0;
        let c, d, h = 0;
        n.isDisplayStyle ? (c = r.num1, h = u > 0 ? 3 * u : 7 * u, d = r.denom1) : (u > 0 ? (c = r.num2, h = u) : (c = r.num3, h = 3 * u), d = r.denom2);
        const m = [];
        this.isSelected && m.push("ML__selected");
        const p = a.depth, f = l.height;
        let g;
        if (u <= 0) {
            const e2 = c - p - (f - d);
            e2 < h && (c += (h - e2) / 2, d += (h - e2) / 2), g = new Ve({
                individualShift: [
                    {
                        box: a,
                        shift: -c,
                        classes: [
                            ...m,
                            "ML__center"
                        ]
                    },
                    {
                        box: l,
                        shift: d,
                        classes: [
                            ...m,
                            "ML__center"
                        ]
                    }
                ]
            }).wrap(n);
        } else {
            const e3 = .25 + u / 2, t1 = .25 - u / 2;
            c < h + p + e3 && (c = h + p + e3), d < h + f - t1 && (d = h + f - t1);
            const i1 = new Ie(null, {
                classes: "ML__frac-line",
                mode: this.mode,
                style: this.style
            });
            i1.height = u / 2, i1.depth = u / 2, g = new Ve({
                individualShift: [
                    {
                        box: l,
                        shift: d,
                        classes: [
                            ...m,
                            "ML__center"
                        ]
                    },
                    {
                        box: i1,
                        shift: u / 2 - t1,
                        classes: m
                    },
                    {
                        box: a,
                        shift: -c,
                        classes: [
                            ...m,
                            "ML__center"
                        ]
                    }
                ]
            }).wrap(n);
        }
        const y = n.isDisplayStyle ? r.delim1 : r.delim2, b = this.isSelected ? " ML__selected" : "", v = this.leftDelim ? this.bind(e1, kt("mopen", this.leftDelim, y, !0, e1, {
            style: this.style,
            mode: this.mode,
            classes: b
        })) : wt(n, "mopen");
        let x = null;
        x = this.continuousFraction ? new Ie(null, {
            type: "mclose"
        }) : this.rightDelim ? this.bind(e1, kt("mclose", this.rightDelim, y, !0, e1, {
            style: this.style,
            mode: this.mode,
            classes: b
        })) : wt(n, "mclose");
        const k = this.bind(e1, new Ie([
            v,
            g,
            x
        ], {
            isTight: n.isTight,
            type: "mord",
            classes: "mfrac"
        }));
        return k ? (this.caret && (k.caret = this.caret), this.attachSupsub(e1, {
            base: k
        })) : null;
    }
    constructor(e1, t, i, n, r){
        var o, a;
        super("genfrac", n, {
            style: r.style,
            command: e1,
            serialize: r.serialize,
            displayContainsHighlight: !0
        }), this.above = t, this.below = i, this.hasBarLine = null === (o = null == r ? void 0 : r.hasBarLine) || void 0 === o || o, this.continuousFraction = null !== (a = null == r ? void 0 : r.continuousFraction) && void 0 !== a && a, this.numerPrefix = null == r ? void 0 : r.numerPrefix, this.denomPrefix = null == r ? void 0 : r.denomPrefix, this.mathstyleName = null == r ? void 0 : r.mathstyleName, this.leftDelim = null == r ? void 0 : r.leftDelim, this.rightDelim = null == r ? void 0 : r.rightDelim;
    }
}
class Yt extends ot {
    static fromJson(e1, t) {
        const i = new Yt(e1.command, t);
        return e1.isSuggestion && (i.isSuggestion = !0), e1.isError && (i.isError = !0), i;
    }
    toJson() {
        const e1 = {};
        return this.isSuggestion && (e1.isSuggestion = !0), this.isError && (e1.isError = !0), {
            ...super.toJson(),
            ...e1
        };
    }
    get computedStyle() {
        return {};
    }
    render(e1) {
        const t = new Ie(this.value, {
            classes: this.isSuggestion ? "ML__suggestion" : this.isError ? "ML__error" : "",
            type: "latex",
            maxFontSize: 1
        });
        return t ? (this.caret && (t.caret = this.caret), this.bind(e1, t)) : null;
    }
    constructor(e1, t, i){
        var n;
        super("latex", t, {
            value: e1,
            mode: "latex"
        }), this.isSuggestion = null !== (n = null == i ? void 0 : i.isSuggestion) && void 0 !== n && n, this.isError = !1, this.verbatimLatex = e1;
    }
}
class Qt extends ot {
    static fromJson(e1, t) {
        return new Qt("", t);
    }
    toJson() {
        return super.toJson();
    }
    render(e1) {
        const t = ot.createBox(e1, this.body, {
            newList: !0
        });
        return t ? (this.caret && (t.caret = this.caret), this.bind(e1, t)) : null;
    }
    serialize(e1) {
        var t, i;
        return null !== (i = null === (t = this.body) || void 0 === t ? void 0 : t.map((e1)=>e1.value).join("")) && void 0 !== i ? i : "";
    }
    constructor(e1, t){
        super("latexgroup", t, {
            mode: "latex"
        }), this.body = [
            ...e1
        ].map((e1)=>new Yt(e1, t)), this.skipBoundary = !1;
    }
}
class ei extends ot {
    static fromJson(e1, t) {
        return new ei(e1.command, e1.body, t, e1);
    }
    toJson() {
        return {
            ...super.toJson(),
            position: this.position
        };
    }
    render(e1) {
        const t = new Me(e1, this.style, "cramp"), i = ot.createBox(t, this.body);
        if (!i) return null;
        const n = t.metrics.defaultRuleThickness / t.scalingFactor, r = new Ie(null, {
            classes: this.position + "-line"
        });
        let o;
        return r.height = n, r.maxFontSize = 1.125 * n * t.scalingFactor, o = "overline" === this.position ? new Ve({
            shift: 0,
            children: [
                {
                    box: i
                },
                3 * n,
                {
                    box: r
                },
                n
            ]
        }) : new Ve({
            top: i.height,
            children: [
                n,
                {
                    box: r
                },
                3 * n,
                {
                    box: i
                }
            ]
        }), this.caret && (o.caret = this.caret), new Ie(o, {
            classes: this.position,
            type: "mord"
        });
    }
    constructor(e1, t, i, n){
        super("line", i, {
            command: e1,
            style: n.style
        }), this.skipBoundary = !0, this.body = t, this.position = n.position;
    }
}
class ti extends ot {
    static fromJson(e1, t) {
        return new ti(e1.command, e1.body ? e1.body : e1.value, t, e1);
    }
    toJson() {
        const e1 = super.toJson();
        return this.hasArgument && (e1.hasArgument = !0), this.variant && (e1.variant = this.variant), this.variantStyle && (e1.variantStyle = this.variantStyle), this.subsupPlacement && (e1.limits = this.subsupPlacement), this.isExtensibleSymbol && (e1.isExtensibleSymbol = !0), this.value && (e1.symbol = this.value), e1;
    }
    render(e1) {
        var t;
        let i, n = 0, r = 0;
        if (this.isExtensibleSymbol) {
            const t1 = e1.isDisplayStyle && "\\smallint" !== this.value;
            if (i = new Ie(this.value, {
                fontFamily: t1 ? "Size2-Regular" : "Size1-Regular",
                classes: "op-symbol " + (t1 ? "large-op" : "small-op"),
                type: "mop",
                maxFontSize: e1.scalingFactor
            }), !i) return null;
            i.right = i.italic, n = (i.height - i.depth) / 2 - .25 * e1.scalingFactor, r = i.italic, i.setStyle("color", this.style.color), i.setStyle("background-color", this.style.backgroundColor);
        } else if (this.body) {
            if (i = ot.createBox(e1, this.body, {
                newList: !0
            }), !i) return null;
            i.setStyle("color", this.style.color), i.setStyle("background-color", this.style.backgroundColor);
        } else i = new Ie(this.value, {
            type: "mop",
            mode: "math",
            maxFontSize: e1.scalingFactor,
            style: {
                color: this.style.color,
                backgroundColor: this.style.backgroundColor,
                letterShapeStyle: e1.letterShapeStyle,
                variant: this.variant,
                variantStyle: this.variantStyle
            }
        });
        this.isExtensibleSymbol && i.setTop(n);
        let o = i;
        if (this.superscript || this.subscript) {
            const a = null !== (t = this.subsupPlacement) && void 0 !== t ? t : "auto";
            o = "over-under" === a || "auto" === a && e1.isDisplayStyle ? this.attachLimits(e1, {
                base: i,
                baseShift: n,
                slant: r
            }) : this.attachSupsub(e1, {
                base: i
            });
        }
        return this.caret && (o.caret = this.caret), new Ie(this.bind(e1, o), {
            type: "mop",
            classes: "op-group" + (this.isSelected ? " ML__selected" : "")
        });
    }
    serialize(e1) {
        if ("​" === this.value) return this.supsubToLatex(e1);
        const t = [];
        return t.push(this.command), this.hasArgument && t.push(`{${this.bodyToLatex(e1)}}`), this.explicitSubsupPlacement && ("over-under" === this.subsupPlacement && t.push("\\limits"), "adjacent" === this.subsupPlacement && t.push("\\nolimits"), "auto" === this.subsupPlacement && t.push("\\displaylimits")), t.push(this.supsubToLatex(e1)), Qe(t);
    }
    constructor(e1, t, i, n){
        var r, o, a, s;
        super(null !== (r = n.type) && void 0 !== r ? r : "mop", i, {
            command: e1,
            style: n.style,
            isFunction: null == n ? void 0 : n.isFunction
        }), "string" == typeof t ? this.value = t : this.body = t, this.captureSelection = null !== (o = n.captureSelection) && void 0 !== o && o, this.hasArgument = null !== (a = n.hasArgument) && void 0 !== a && a, this.variant = null == n ? void 0 : n.variant, this.variantStyle = null == n ? void 0 : n.variantStyle, this.subsupPlacement = null == n ? void 0 : n.limits, this.isExtensibleSymbol = null !== (s = null == n ? void 0 : n.isExtensibleSymbol) && void 0 !== s && s;
    }
}
class ii extends ot {
    static fromJson(e1, t) {
        return new ii(e1.command, e1.body, t, e1);
    }
    toJson() {
        const e1 = {};
        return this.align && (e1.align = this.align), this.boxType && (e1.boxType = this.boxType), {
            ...super.toJson(),
            ...e1
        };
    }
    render(e1) {
        const t = ot.createBox(e1, this.body, {
            classes: "inner"
        });
        return t ? (this.caret && (t.caret = this.caret), this.bind(e1, new Ie([
            t,
            new Ie(null, {
                classes: "fix"
            })
        ], {
            classes: "left" === this.align ? "llap" : "rlap",
            type: this.boxType
        }))) : null;
    }
    constructor(e1, t, i, n){
        var r, o;
        super("overlap", i, {
            command: e1,
            style: null == n ? void 0 : n.style
        }), this.skipBoundary = !0, this.body = "string" == typeof t ? [
            new ot("mord", i, {
                value: t
            })
        ] : t, this.align = null !== (r = null == n ? void 0 : n.align) && void 0 !== r ? r : "left", this.boxType = null !== (o = null == n ? void 0 : n.boxType) && void 0 !== o ? o : "mord";
    }
}
class ni extends ot {
    static fromJson(e1, t) {
        return new ni(e1.command, e1.body, t, e1);
    }
    toJson() {
        const e1 = {};
        return this.isInvisible && (e1.isInvisible = !0), this.smashDepth && (e1.smashDepth = !0), this.smashHeight && (e1.smashHeight = !0), this.smashWidth && (e1.smashWidth = !0), {
            ...super.toJson(),
            ...e1
        };
    }
    render(e1) {
        const t = new Me(e1, {
            isPhantom: !0
        });
        if (!this.smashDepth && !this.smashHeight && !this.smashWidth) return ot.createBox(t, this.body, {
            classes: "inner"
        });
        const i = ot.createBox(this.isInvisible ? t : e1, this.body);
        if (!i) return null;
        if (this.smashWidth) {
            const t1 = new Ie(null, {
                classes: "fix"
            });
            return new Ie([
                i,
                t1
            ], {
                classes: "rlap"
            }).wrap(e1);
        }
        if (!this.smashHeight && !this.smashDepth) return i;
        if (this.smashHeight && (i.height = 0), this.smashDepth && (i.depth = 0), i.children) for (const e2 of i.children)this.smashHeight && (e2.height = 0), this.smashDepth && (e2.depth = 0);
        return new Ve({
            firstBaseline: [
                {
                    box: i
                }
            ]
        }, {
            type: "mord"
        }).wrap(e1);
    }
    constructor(e1, t, i, n){
        var r, o, a, s;
        super("phantom", i, {
            command: e1,
            style: n.style
        }), this.captureSelection = !0, this.body = t, this.isInvisible = null !== (r = n.isInvisible) && void 0 !== r && r, this.smashDepth = null !== (o = n.smashDepth) && void 0 !== o && o, this.smashHeight = null !== (a = n.smashHeight) && void 0 !== a && a, this.smashWidth = null !== (s = n.smashWidth) && void 0 !== s && s;
    }
}
class ri extends ot {
    static fromJson(e1, t) {
        return new ri(e1.command, t, e1);
    }
    toJson() {
        const e1 = {
            height: this.height,
            width: this.width
        };
        return this.shift && (e1.shift = this.shift), {
            ...super.toJson(),
            ...e1
        };
    }
    render(e1) {
        const t = new Me(e1, this.style, "textstyle"), i = we(this.shift), n = we(this.width), r = we(this.height), o = new Ie(null, {
            classes: "rule",
            type: "mord"
        });
        return o.setStyle("border-right-width", n, "em"), o.setStyle("border-top-width", r, "em"), o.setStyle("border-color", this.style.color), o.setStyle("vertical-align", i, "em"), this.isSelected && o.setStyle("opacity", "50%"), o.width = n, o.height = r + i, o.depth = -i, this.bind(e1, o), this.caret && (o.caret = this.caret), o.wrap(t);
    }
    serialize(e1) {
        var t;
        let i = null !== (t = this.command) && void 0 !== t ? t : "";
        return this.shift && (i += `[${Se(this.shift)}]`), i += `{${Se(this.width)}}{${Se(this.height)}}`, i;
    }
    constructor(e1, t, i){
        var n;
        super("rule", t, {
            command: e1,
            style: i.style
        }), this.shift = null !== (n = i.shift) && void 0 !== n ? n : {
            dimension: 0
        }, this.height = i.height, this.width = i.width;
    }
}
class oi extends ot {
    static fromJson(e1, t) {
        return new oi(e1.command, t, {
            ...e1,
            index: e1.above
        });
    }
    toJson() {
        return super.toJson();
    }
    serialize(e1) {
        let t = "";
        return this.above && (t += `[${this.aboveToLatex(e1)}]`), t += `{${this.bodyToLatex(e1)}}`, this.command + t;
    }
    render(e1) {
        var t;
        const i = new Me(e1, this.style, "cramp"), n = null !== (t = ot.createBox(i, this.body, {
            style: this.style,
            newList: !0
        })) && void 0 !== t ? t : new Ie(null), r = i.scalingFactor, o = i.metrics.defaultRuleThickness / r, a = e1.isDisplayStyle ? .431 : o, s = new Ie(null, {
            classes: "ML__sqrt-line",
            style: this.style,
            height: o
        });
        let l = r * (o + a / 4);
        const u = Math.max(2 * r * a, n.height + n.depth) + l + o, c = new Me(e1, this.style), d = this.isSelected ? " ML__selected" : "", h = this.bind(c, new Ie(kt("", "\\surd", u, !1, c, {
            classes: d
        }), {
            classes: "ML__sqrt-sign" + d,
            style: this.style
        }));
        if (!h) return null;
        const m = h.height + h.depth - o;
        m > n.height + n.depth + l && (l = (l + m - (n.height + n.depth)) / 2), h.setTop(h.height - n.height - l);
        const p = this.bind(e1, new Ve({
            firstBaseline: [
                {
                    box: new Ie(n)
                },
                l - 2 * o,
                {
                    box: s
                },
                o
            ]
        }).wrap(e1)), f = ot.createBox(new Me(e1, this.style, "scriptscriptstyle"), this.above, {
            style: this.style,
            newList: !0
        });
        if (!f) {
            const t1 = new Ie([
                h,
                p
            ], {
                classes: this.containsCaret ? "ML__contains-caret" : "",
                type: "mord"
            });
            return this.caret && (t1.caret = this.caret), this.bind(e1, t1.wrap(e1));
        }
        const g = new Ve({
            shift: -0.6 * (Math.max(h.height, p.height) - Math.max(h.depth, p.depth)),
            children: [
                {
                    box: f
                }
            ]
        }), y = new Ie([
            new Ie(g, {
                classes: "ML__sqrt-index"
            }),
            h,
            p
        ], {
            type: "mord",
            classes: this.containsCaret ? "ML__contains-caret" : ""
        });
        return y.height = h.height, y.depth = h.depth, this.caret && (y.caret = this.caret), this.bind(e1, y.wrap(e1));
    }
    constructor(e1, t, i){
        var n;
        super("surd", t, {
            command: e1,
            mode: null !== (n = i.mode) && void 0 !== n ? n : "math",
            style: i.style,
            displayContainsHighlight: !0
        }), this.body = i.body, this.above = i.index;
    }
}
const ai = {
    "p@": "1pt ",
    "z@": "0pt",
    maxdimen: "16383.99999pt",
    hfuzz: "0.1pt",
    vfuzz: "0.1pt",
    overfullrule: "5pt",
    hsize: "6.5in",
    vsize: "8.9in",
    parindent: "20pt",
    maxdepth: "4pt",
    splitmaxdepth: "\\maxdimen",
    boxmaxdepth: "\\maxdimen",
    delimitershortfall: "5pt",
    nulldelimiterspace: "1.2pt",
    scriptspace: "0.5pt",
    topskip: "10pt",
    splittopskip: "10pt",
    normalbaselineskip: "12pt",
    normallineskip: "1pt",
    normallineskiplimit: "0pt",
    jot: "3pt",
    doublerulesep: "2pt",
    arrayrulewidth: "0.4pt",
    arraycolsep: "5pt",
    fboxsep: "3pt",
    fboxrule: "0.4pt"
}, si = {
    "z@skip": "0pt plust0pt minus0pt",
    hideskip: "-1000pt plust 1fill",
    "@flushglue": "0pt plust 1fill",
    parskip: "0pt plus 1pt",
    abovedisplayskip: "12pt plus 3pt minus 9pt",
    abovedisplayshortskip: "0pt plus 3pt",
    belowdisplayskip: "12pt plus 3pt minus 9pt",
    belowdisplayshortskip: "7pt plus 3pt minus 4pt",
    parfillskip: "0pt plus 1fil",
    thinmuskip: "3mu",
    medmuskip: "4mu plus 2mu minus 4mu",
    thickmuskip: "5mu plus 5mu",
    smallskipamount: "3pt plus1pt minus1pt",
    medskipamount: "6pt plus2pt minus2pt",
    bigskipamount: "12pt plus4pt minus4pt"
}, li = {
    pretolerance: 100,
    tolerance: 200,
    hbadness: 1e3,
    vbadness: 1e3,
    linepenalty: 10,
    hyphenpenalty: 50,
    exhyphenpenalty: 50,
    binoppenalty: 700,
    relpenalty: 500,
    clubpenalty: 150,
    widowpenalty: 150,
    displaywidowpenalty: 50,
    brokenpenalty: 100,
    predisplaypenalty: 1e4,
    doublehyphendemerits: 1e4,
    finalhyphendemerits: 5e3,
    adjdemerits: 1e4,
    tracinglostchars: 1,
    uchyph: 1,
    delimiterfactor: 901,
    defaulthyphenchar: "\\-",
    defaultskewchar: -1,
    newlinechar: -1,
    showboxbreadth: 5,
    showboxdepth: 3,
    errorcontextlines: 5,
    interdisplaylinepenalty: 100,
    interfootnotelinepenalty: 100,
    baselineSkip: 1.2,
    arraystretch: "",
    month: (new Date).getMonth() + 1,
    day: (new Date).getDate(),
    year: (new Date).getFullYear()
};
let ui;
function ci(e1) {
    var t, i;
    if (ui) return ui;
    ui = {
        ...li
    };
    for (const i1 of Object.keys(ai))ui[i1] = null !== (t = Bt(ai[i1], e1, ui)) && void 0 !== t ? t : 0;
    for (const t1 of Object.keys(si))ui[t1] = null !== (i = Ft(si[t1], e1, ui)) && void 0 !== i ? i : 0;
    return ui;
}
function di() {
    const e1 = {
        registers: {},
        smartFence: !1,
        fractionNavigationOrder: "numerator-denominator",
        placeholderSymbol: "▢",
        letterShapeStyle: s.locale.startsWith("fr") ? "french" : "tex",
        colorMap: f,
        backgroundColorMap: g,
        getDefinition: hi,
        getMacro: (e1)=>mi(e1, K())
    };
    return {
        ...e1,
        registers: ci(e1)
    };
}
function hi(e1, t = "math") {
    if (!e1 || 0 === e1.length) return null;
    let i = null;
    if (e1.startsWith("\\")) {
        if (i = _[e1], i) return i;
        "math" === t ? i = x[e1] : M[e1] && (i = {
            definitionType: "symbol",
            type: "mord",
            codepoint: M[e1]
        });
    } else if ("math" === t) {
        if (i = x[e1], !i && 1 === e1.length) {
            const t1 = D("math", e1.codePointAt(0));
            return t1.startsWith("\\") ? {
                ...hi(t1, "math"),
                command: t1
            } : null;
        }
    } else M[e1] ? i = {
        definitionType: "symbol",
        type: "mord",
        codepoint: M[e1]
    } : "text" === t && (i = {
        definitionType: "symbol",
        type: "mord",
        codepoint: e1.codePointAt(0)
    });
    return !i || "symbol" !== i.definitionType || "mord" !== i.type || 102 !== i.codepoint && 103 !== i.codepoint && 104 !== i.codepoint || (i.isFunction = !0), null != i ? i : null;
}
function mi(e1, t) {
    return e1.startsWith("\\") ? t[e1.slice(1)] : null;
}
class pi extends ot {
    static fromJson(e1, t) {
        return new pi(e1.body, fi(e1.tooltip, t), t, e1);
    }
    toJson() {
        var e1;
        const t = null === (e1 = this.tooltip.body) || void 0 === e1 ? void 0 : e1.filter((e1)=>"first" !== e1.type).map((e1)=>e1.toJson());
        return {
            ...super.toJson(),
            tooltip: t
        };
    }
    render(e1) {
        const t = ot.createBox(e1, this.body, {
            style: this.style
        });
        if (!t) return null;
        const i = Fe(Pe(new Ie(this.tooltip.render(new Me({
            registers: e1.registers
        }, {
            fontSize: 5
        }, "displaystyle")), {
            classes: "ML__tooltip-content"
        }))), n = new Ie([
            i,
            t
        ], {
            classes: "ML__tooltip-container"
        });
        return this.caret && (n.caret = this.caret), this.bind(e1, n);
    }
    serialize(e1) {
        return `${this.command}{${this.bodyToLatex(e1)}}{${ot.serialize(this.tooltip.body, e1)}}`;
    }
    constructor(e1, t, i, n){
        super("tooltip", i, {
            command: null == n ? void 0 : n.command,
            mode: "math",
            serialize: null == n ? void 0 : n.serialize,
            style: null == n ? void 0 : n.style,
            displayContainsHighlight: !0
        }), this.body = e1;
        const r = di();
        this.tooltip = new ot("root", r, {
            style: {}
        }), this.tooltip.body = t, this.skipBoundary = !0, this.captureSelection = !1;
    }
}
function fi(t, i) {
    if (e1(t)) return t.map((e1)=>fi(e1, i));
    t = {
        ...t
    };
    for (const e2 of it)t[e2] && (t[e2] = fi(t[e2], i));
    t.array && (t.array = fi(t.array, i));
    const n = t.type;
    let r;
    "accent" === n && (r = lt.fromJson(t, i)), "array" === n && (r = Pt.fromJson(t, i)), "box" === n && (r = $t.fromJson(t, i)), "composition" === n && (r = jt.fromJson(t, i)), "chem" === n && (r = Ht.fromJson(t, i)), "choice" === n && (r = gi.fromJson(t, i)), "delim" === n && (r = Zt.fromJson(t, i)), "enclose" === n && (r = Jt.fromJson(t, i)), "error" === n && (r = Et.fromJson(t, i)), "genfrac" === n && (r = Xt.fromJson(t, i)), "group" === n && (r = Mt.fromJson(t, i)), "latex" === n && (r = Yt.fromJson(t, i)), "latexgroup" === n && (r = Qt.fromJson(t, i)), "leftright" === n && (r = Lt.fromJson(t, i)), "line" === n && (r = ei.fromJson(t, i)), "macro" === n && (r = Tt.fromJson(t, i)), "msubsup" === n && (r = At.fromJson(t, i)), "overlap" === n && (r = ii.fromJson(t, i)), "overunder" === n && (r = St.fromJson(t, i)), "placeholder" === n && (t.defaultValue && (t.defaultValue = fi(t.defaultValue, i)), r = Ct.fromJson(t, i)), "phantom" === n && (r = ni.fromJson(t, i)), "rule" === n && (r = ri.fromJson(t, i)), "sizeddelim" === n && (r = Wt.fromJson(t, i)), "spacing" === n && (r = Nt.fromJson(t, i)), "surd" === n && (r = oi.fromJson(t, i)), "text" === n && (r = Dt.fromJson(t, i)), "tooltip" === n && (r = pi.fromJson(t, i)), "mop" === n && (r = ti.fromJson(t, i)), r || (r = ot.fromJson(t, i));
    for (const e3 of it)t[e3] && r.setChildren(t[e3], e3);
    return void 0 !== t.verbatimLatex && (r.verbatimLatex = t.verbatimLatex), t.subsupPlacement && (r.subsupPlacement = t.subsupPlacement), t.explicitSubsupPlacement && (r.explicitSubsupPlacement = !0), t.isFunction && (r.isFunction = !0), t.isExtensibleSymbol && (r.isExtensibleSymbol = !0), t.skipBoundary && (r.skipBoundary = !0), t.captureSelection && (r.captureSelection = !0), r;
}
class gi extends ot {
    static fromJson(e1, t) {
        return new gi([
            fi(e1.choices[0], t),
            fi(e1.choices[1], t),
            fi(e1.choices[2], t),
            fi(e1.choices[3], t)
        ], t);
    }
    toJson() {
        const e1 = [];
        for (const t of this.choices)e1.push(t.filter((e1)=>"first" !== e1.type).map((e1)=>e1.toJson()));
        return {
            ...super.toJson(),
            choices: e1
        };
    }
    render(e1) {
        const t = ot.createBox(e1, this.choices[Math.floor(e1.mathstyle.id / 2)]);
        return t ? (this.caret && (t.caret = this.caret), this.bind(e1, t)) : null;
    }
    serialize(e1) {
        return `\\mathchoice{${ot.serialize(this.choices[0], e1)}}{${ot.serialize(this.choices[1], e1)}}{${ot.serialize(this.choices[2], e1)}}{${ot.serialize(this.choices[3], e1)}}`;
    }
    constructor(e1, t){
        super("choice", t), this.choices = e1, this.skipBoundary = !0;
    }
}
P("mathtip", "{:math}{:math}", {
    createAtom: (e1, t, i, n)=>new pi(t[0], t[1], n, {
            command: e1,
            content: "math",
            style: i
        })
}), P("texttip", "{:math}{:text}", {
    createAtom: (e1, t, i, n)=>new pi(t[0], t[1], n, {
            command: e1,
            content: "text",
            style: i
        })
}), P("error", "{:math}", {
    createAtom: (e1, t, i, n)=>new Mt(t[0], n, {
            mode: "math",
            command: "\\error",
            customClass: "ML__error",
            style: i,
            serialize: (e1, t)=>`\\error{${e1.bodyToLatex(t)}}`
        })
}), P("ensuremath", "{:math}", {
    createAtom: (e1, t, i, n)=>new Mt(t[0], n, {
            mode: "math",
            latexOpen: "\\ensuremath{",
            latexClose: "}",
            style: i
        })
}), P("color", "{:string}", {
    applyStyle: (e1, t, i)=>{
        var n, r;
        const o = t[0];
        return {
            verbatimColor: t[0],
            color: null !== (r = null === (n = i.colorMap) || void 0 === n ? void 0 : n.call(i, o)) && void 0 !== r ? r : o
        };
    }
}), P("textcolor", "{:string}{content:auto*}", {
    applyStyle: (e1, t, i)=>{
        var n, r;
        const o = t[0];
        return {
            verbatimColor: o,
            color: null !== (r = null === (n = i.colorMap) || void 0 === n ? void 0 : n.call(i, o)) && void 0 !== r ? r : o
        };
    }
}), P("boxed", "{content:math}", {
    createAtom: (e1, t, i, n)=>new $t(e1, t[0], n, {
            framecolor: "black",
            style: i
        })
}), P("colorbox", "{:string}{content:auto*}", {
    applyMode: "text",
    applyStyle: (e1, t, i)=>{
        var n, r;
        const o = t[0];
        return {
            verbatimBackgroundColor: t[0],
            backgroundColor: null !== (r = null === (n = i.backgroundColorMap) || void 0 === n ? void 0 : n.call(i, o)) && void 0 !== r ? r : o
        };
    }
}), P("fcolorbox", "{frame-color:string}{background-color:string}{content:auto}", {
    applyMode: "text",
    createAtom: (e1, t, i, n)=>{
        var r, o, a, s;
        const l = t[0], u = t[1];
        return new $t(e1, t[2], n, {
            verbatimFramecolor: l,
            framecolor: null !== (o = null === (r = n.colorMap) || void 0 === r ? void 0 : r.call(n, l)) && void 0 !== o ? o : l,
            verbatimBackgroundcolor: t[1],
            backgroundcolor: null !== (s = null === (a = n.backgroundColorMap) || void 0 === a ? void 0 : a.call(n, u)) && void 0 !== s ? s : u,
            style: i,
            serialize: (e1, t)=>{
                var i, n;
                return `${e1.command}{${null !== (i = e1.verbatimFramecolor) && void 0 !== i ? i : e1.framecolor}{${null !== (n = e1.verbatimBackgroundcolor) && void 0 !== n ? n : e1.backgroundcolor}}{${e1.bodyToLatex(t)}}`;
            }
        });
    }
}), P("bbox", "[:bbox]{body:auto}", {
    createAtom: (e1, t, i, n)=>{
        if (t[0]) {
            const r = t[0];
            return new $t(e1, t[1], n, {
                padding: r.padding,
                border: r.border,
                backgroundcolor: r.backgroundcolor,
                style: i,
                serialize: (t, i)=>{
                    var n;
                    let r = e1;
                    if (Number.isFinite(t.padding) || void 0 !== t.border || void 0 !== t.backgroundcolor) {
                        const e2 = [];
                        t.padding && e2.push(t.padding), t.border && e2.push(`border: ${t.border}`), (t.verbatimBackgroundcolor || t.backgroundcolor) && e2.push(null !== (n = t.verbatimBackgroundcolor) && void 0 !== n ? n : t.backgroundcolor), r += `[${e2.join(",")}]`;
                    }
                    return r + `{${t.bodyToLatex(i)}}`;
                }
            });
        }
        return new $t(e1, t[1], n, {
            style: i
        });
    }
}), P([
    "displaystyle",
    "textstyle",
    "scriptstyle",
    "scriptscriptstyle"
], "{:rest}", {
    createAtom: (e1, t, i, n)=>new Mt(t[0], n, {
            latexOpen: `{${e1} `,
            latexClose: "}",
            style: i,
            mathstyleName: e1.slice(1)
        })
}), P([
    "tiny",
    "scriptsize",
    "footnotesize",
    "small",
    "normalsize",
    "large",
    "Large",
    "LARGE",
    "huge",
    "Huge"
], "", {
    applyStyle: (e1, t)=>({
            fontSize: ({
                "\\tiny": 1,
                "\\scriptsize": 2,
                "\\footnotesize": 3,
                "\\small": 4,
                "\\normalsize": 5,
                "\\large": 6,
                "\\Large": 7,
                "\\LARGE": 8,
                "\\huge": 9,
                "\\Huge": 10
            })[e1]
        })
}), P("fontseries", "{:string}", {
    ifMode: "text",
    applyStyle: (e1, t)=>({
            fontSeries: t[0]
        })
}), P("fontshape", "{:string}", {
    ifMode: "text",
    applyStyle: (e1, t)=>({
            fontShape: t[0]
        })
}), P("fontfamily", "{:string}", {
    ifMode: "text",
    applyStyle: (e1, t)=>({
            fontFamily: t[0]
        })
}), P("selectfont", "", {
    ifMode: "text",
    applyStyle: (e1, t)=>({})
}), P("bf", "", {
    applyStyle: (e1, t)=>({
            fontSeries: "b",
            fontShape: "n",
            fontFamily: "cmr"
        })
}), P([
    "boldsymbol",
    "bm"
], "{:math*}", {
    applyMode: "math",
    createAtom: (e1, t, i, n)=>new Mt(t[0], n, {
            latexOpen: `${e1}{`,
            latexClose: "}",
            style: i,
            customClass: "ML__boldsymbol"
        })
}), P("bold", "{:math*}", {
    applyMode: "math",
    applyStyle: (e1, t)=>({
            variantStyle: "bold"
        })
}), P("bfseries", "", {
    applyMode: "text",
    applyStyle: (e1, t)=>({
            fontSeries: "b"
        })
}), P("mdseries", "", {
    applyMode: "text",
    applyStyle: (e1, t)=>({
            fontSeries: "m"
        })
}), P("upshape", "", {
    applyMode: "text",
    applyStyle: (e1, t)=>({
            fontShape: "n"
        })
}), P("slshape", "", {
    applyMode: "text",
    applyStyle: (e1, t)=>({
            fontShape: "sl"
        })
}), P("scshape", "", {
    applyMode: "text",
    applyStyle: (e1, t)=>({
            fontShape: "sc"
        })
}), P("textbf", "{:text*}", {
    applyMode: "text",
    applyStyle: (e1, t)=>({
            fontSeries: "b"
        })
}), P("textmd", "{:text*}", {
    applyMode: "text",
    applyStyle: (e1, t)=>({
            fontSeries: "m"
        })
}), P("textup", "{:text*}", {
    applyMode: "text",
    applyStyle: (e1, t)=>({
            fontShape: "n"
        })
}), P("textnormal", "{:text*}", {
    applyMode: "text",
    applyStyle: (e1, t)=>({
            fontShape: "n",
            fontSeries: "m"
        })
}), P("textsl", "{:text*}", {
    applyMode: "text",
    applyStyle: (e1, t)=>({
            fontShape: "sl"
        })
}), P("textit", "{:text*}", {
    applyMode: "text",
    applyStyle: (e1, t)=>({
            fontShape: "it"
        })
}), P("textsc", "{:text*}", {
    applyMode: "text",
    applyStyle: (e1, t)=>({
            fontShape: "sc"
        })
}), P("textrm", "{:text*}", {
    applyMode: "text",
    applyStyle: (e1, t)=>({
            fontFamily: "roman"
        })
}), P("textsf", "{:text*}", {
    applyMode: "text",
    applyStyle: (e1, t)=>({
            fontFamily: "sans-serif"
        })
}), P("texttt", "{:text*}", {
    applyMode: "text",
    applyStyle: (e1, t)=>({
            fontFamily: "monospace"
        })
}), P("mathbf", "{:math*}", {
    applyMode: "math",
    applyStyle: (e1, t)=>({
            variant: "normal",
            variantStyle: "bold"
        })
}), P("mathit", "{:math*}", {
    applyMode: "math",
    applyStyle: (e1, t)=>({
            variant: "main",
            variantStyle: "italic"
        })
}), P("mathnormal", "{:math*}", {
    applyMode: "math",
    applyStyle: (e1, t)=>({
            variant: "normal",
            variantStyle: "italic"
        })
}), P("mathbfit", "{:math*}", {
    applyMode: "math",
    applyStyle: (e1, t)=>({
            variant: "main",
            variantStyle: "bolditalic"
        })
}), P("mathrm", "{:math*}", {
    applyMode: "math",
    applyStyle: (e1, t)=>({
            variant: "normal",
            variantStyle: "up"
        })
}), P("mathsf", "{:math*}", {
    applyMode: "math",
    applyStyle: (e1, t)=>({
            variant: "sans-serif",
            variantStyle: "up"
        })
}), P("mathtt", "{:math*}", {
    applyMode: "math",
    applyStyle: (e1, t)=>({
            variant: "monospace",
            variantStyle: "up"
        })
}), P("it", "", {
    applyStyle: (e1, t)=>({
            fontSeries: "m",
            fontShape: "it",
            fontFamily: "cmr",
            variantStyle: "italic"
        })
}), P("rmfamily", "", {
    applyStyle: (e1, t)=>({
            fontFamily: "roman"
        })
}), P("sffamily", "", {
    applyStyle: (e1, t)=>({
            fontFamily: "sans-serif"
        })
}), P("ttfamily", "", {
    applyStyle: (e1, t)=>({
            fontFamily: "monospace"
        })
}), P([
    "Bbb",
    "mathbb"
], "{:math*}", {
    applyStyle: (e1, t)=>({
            variant: "double-struck",
            variantStyle: "up"
        })
}), P([
    "frak",
    "mathfrak"
], "{:math*}", {
    applyStyle: (e1, t)=>({
            variant: "fraktur",
            variantStyle: "up"
        })
}), P("mathcal", "{:math*}", {
    applyStyle: (e1, t)=>({
            variant: "calligraphic",
            variantStyle: "up"
        })
}), P("mathscr", "{:math*}", {
    applyStyle: (e1, t)=>({
            variant: "script",
            variantStyle: "up"
        })
}), P("mbox", "{:text}", {
    ifMode: "math",
    createAtom: (e1, t, i, n)=>new Mt(t[0], n, {
            changeMode: !0,
            style: i,
            mode: "text",
            command: e1,
            serialize: (e1, t)=>`\\mbox{${e1.bodyToLatex({
                    ...t,
                    skipModeCommand: !0
                })}}`
        })
}), P("text", "{:text}", {
    ifMode: "math",
    applyMode: "text"
}), P("class", "{name:string}{content:auto*}", {
    createAtom: (e1, t, i, n)=>new Mt(t[1], n, {
            customClass: t[0],
            style: i
        })
}), P("cssId", "{id:string}{content:auto}", {
    createAtom: (e1, t, i, n)=>new Mt(t[1], n, {
            cssId: t[0],
            style: i
        })
}), P("htmlData", "{data:string}{content:auto}", {
    createAtom: (e1, t, i, n)=>new Mt(t[1], n, {
            htmlData: t[0],
            style: i
        })
}), P("htmlStyle", "{data:string}{content:auto}", {
    createAtom: (e1, t, i, n)=>new Mt(t[1], n, {
            htmlStyle: t[0],
            style: i
        })
}), P("em", "{:auto*}", {
    createAtom: (e1, t, i, n)=>new Mt(t[0], n, {
            latexOpen: "\\em",
            latexClose: "",
            customClass: "ML__emph",
            style: i
        })
}), P("emph", "{:auto}", {
    createAtom: (e1, t, i, n)=>new Mt(t[0], n, {
            latexOpen: "\\emph{",
            latexClose: "}",
            customClass: "ML__emph",
            style: i
        })
});
const yi = {
    "\\bigl": {
        mclass: "mopen",
        size: 1
    },
    "\\Bigl": {
        mclass: "mopen",
        size: 2
    },
    "\\biggl": {
        mclass: "mopen",
        size: 3
    },
    "\\Biggl": {
        mclass: "mopen",
        size: 4
    },
    "\\bigr": {
        mclass: "mclose",
        size: 1
    },
    "\\Bigr": {
        mclass: "mclose",
        size: 2
    },
    "\\biggr": {
        mclass: "mclose",
        size: 3
    },
    "\\Biggr": {
        mclass: "mclose",
        size: 4
    },
    "\\bigm": {
        mclass: "mrel",
        size: 1
    },
    "\\Bigm": {
        mclass: "mrel",
        size: 2
    },
    "\\biggm": {
        mclass: "mrel",
        size: 3
    },
    "\\Biggm": {
        mclass: "mrel",
        size: 4
    },
    "\\big": {
        mclass: "mord",
        size: 1
    },
    "\\Big": {
        mclass: "mord",
        size: 2
    },
    "\\bigg": {
        mclass: "mord",
        size: 3
    },
    "\\Bigg": {
        mclass: "mord",
        size: 4
    }
};
P([
    "bigl",
    "Bigl",
    "biggl",
    "Biggl",
    "bigr",
    "Bigr",
    "biggr",
    "Biggr",
    "bigm",
    "Bigm",
    "biggm",
    "Biggm",
    "big",
    "Big",
    "bigg",
    "Bigg"
], "{:delim}", {
    createAtom: (e1, t, i, n)=>new Wt(e1, t[0], n, {
            size: yi[e1].size,
            delimClass: yi[e1].mclass,
            style: i
        })
}), P([
    "hspace",
    "hspace*"
], "{width:glue}", {
    createAtom: (e1, t, i, n)=>{
        var r;
        return new Nt(e1, i, n, null !== (r = t[0]) && void 0 !== r ? r : {
            glue: {
                dimension: 0
            }
        });
    }
}), P([
    "mkern",
    "kern"
], "{width:glue}", {
    createAtom: (e1, t, i, n)=>{
        var r;
        return new Nt(e1, i, n, null !== (r = t[0]) && void 0 !== r ? r : {
            glue: {
                dimension: 0
            }
        });
    }
}), P("mspace", "{width:glue}", {
    createAtom: (e1, t, i, n)=>{
        var r;
        return new Nt(e1, i, n, null !== (r = t[0]) && void 0 !== r ? r : {
            glue: {
                dimension: 0
            }
        });
    }
}), P("mathop", "{:auto}", {
    createAtom: (e1, t, i, n)=>new ti(e1, t[0], n, {
            type: "mop",
            captureSelection: !0,
            limits: "over-under",
            isFunction: !0,
            hasArgument: !0,
            style: i
        })
}), P("mathchoice", "{:math}{:math}{:math}{:math}", {
    createAtom: (e1, t, i, n)=>new gi(t, n)
}), P([
    "mathbin",
    "mathrel",
    "mathopen",
    "mathclose",
    "mathpunct",
    "mathord",
    "mathinner"
], "{:auto}", {
    createAtom: (e1, t, i, n)=>new ti(e1, t[0], n, {
            type: {
                "\\mathbin": "mbin",
                "\\mathrel": "mrel",
                "\\mathopen": "mopen",
                "\\mathclose": "mclose",
                "\\mathpunct": "mpunct",
                "\\mathord": "mord",
                "\\mathinner": "minner"
            }[e1],
            captureSelection: !0,
            hasArgument: !0,
            style: i
        })
}), P([
    "operatorname",
    "operatorname*"
], "{operator:math}", {
    createAtom: (e1, t, i, n)=>{
        const r = new ti(e1, t[0], n, {
            isFunction: !0,
            hasArgument: !0,
            limits: "\\operatorname" === e1 ? "adjacent" : "over-under",
            style: i
        });
        return r.captureSelection = !0, r.body && r.body.forEach((e1)=>{
            var t;
            "first" !== e1.type && (e1.type = "mord", e1.value = null !== (t = ({
                "∗": "*",
                "−": "-"
            })[e1.value]) && void 0 !== t ? t : e1.value, e1.isFunction = !1, e1.style.variant || e1.style.variantStyle || (e1.style.variant = "main", e1.style.variantStyle = "up"));
        }), r;
    }
});
class bi extends ot {
    serialize(e1) {
        return '\\unicode"' + ("000000" + this.codepoint.toString(16)).toUpperCase().slice(-6);
    }
    constructor(e1, t, i){
        let n = Number.parseInt(e1);
        Number.isFinite(n) || (n = 10067), super("mord", i, {
            value: String.fromCodePoint(n),
            style: t
        }), this.codepoint = n;
    }
}
function vi(e1) {
    if (1 === e1.length) {
        const t = e1[0];
        if ("mbin" === t.type) return "mbin";
        if ("mrel" === t.type) return "mrel";
    }
    return "mord";
}
P("unicode", "{charcode:number}", {
    createAtom: (e1, t, i, n)=>new bi(t[0], i, n)
}), P("rule", "[raise:dimen]{width:dimen}{thickness:dimen}", {
    createAtom: (e1, t, i, n)=>new ri(e1, n, {
            shift: t[0],
            width: t[1],
            height: t[2],
            style: i
        })
}), P("overline", "{:auto}", {
    createAtom: (e1, t, i, n)=>new ei(e1, t[0], n, {
            position: "overline",
            style: i
        })
}), P("underline", "{:auto}", {
    createAtom: (e1, t, i, n)=>new ei(e1, t[0], n, {
            position: "underline",
            style: i
        })
}), P("overset", "{above:auto}{base:auto}", {
    createAtom: (e1, t, i, n)=>new St(e1, n, {
            above: t[0],
            body: t[1],
            skipBoundary: !1,
            style: i,
            boxType: vi(t[1]),
            serialize: (e1, t)=>`${e1.command}{${e1.aboveToLatex(t)}}{${e1.bodyToLatex(t)}}`
        })
}), P("underset", "{below:auto}{base:auto}", {
    createAtom: (e1, t, i, n)=>new St(e1, n, {
            below: t[0],
            body: t[1],
            skipBoundary: !1,
            style: i,
            boxType: vi(t[1]),
            serialize: (t, i)=>`${e1}{${t.belowToLatex(i)}}{${t.bodyToLatex(i)}}`
        })
}), P("overunderset", "{above:auto}{below:auto}{base:auto}", {
    createAtom: (e1, t, i, n)=>new St(e1, n, {
            above: t[0],
            below: t[1],
            body: t[2],
            skipBoundary: !1,
            style: i,
            boxType: vi(t[2]),
            serialize: (e1, t)=>`${e1.command}{${e1.aboveToLatex(t)}}{${e1.bodyToLatex(t)}}`
        })
}), P([
    "stackrel",
    "stackbin"
], "[below:auto]{above:auto}{base:auto}", {
    createAtom: (e1, t, i, n)=>new St(e1, n, {
            body: t[2],
            above: t[1],
            below: t[0],
            skipBoundary: !1,
            style: i,
            boxType: "\\stackrel" === e1 ? "mrel" : "mbin",
            serialize: (e1, t)=>`${e1.command}{${e1.aboveToLatex(t)}}{${e1.bodyToLatex(t)}}`
        })
}), P("smash", "[:string]{:auto}", {
    createAtom: (e1, t, i, n)=>t[0] ? new ni(e1, t[1], n, {
            smashHeight: t[0].includes("t"),
            smashDepth: t[0].includes("b"),
            style: i
        }) : new ni(e1, t[1], n, {
            smashHeight: !0,
            smashDepth: !0,
            style: i
        })
}), P([
    "vphantom"
], "{:auto*}", {
    createAtom: (e1, t, i, n)=>new ni(e1, t[1], n, {
            isInvisible: !0,
            smashWidth: !0,
            style: i
        })
}), P([
    "hphantom"
], "{:auto*}", {
    createAtom: (e1, t, i, n)=>new ni(e1, t[1], n, {
            isInvisible: !0,
            smashHeight: !0,
            smashDepth: !0,
            style: i
        })
}), P([
    "phantom"
], "{:auto*}", {
    createAtom: (e1, t, i, n)=>new ni(e1, t[1], n, {
            isInvisible: !0,
            style: i
        })
}), P("not", "{:math}", {
    createAtom: (e1, t, i, n)=>{
        if (t.length < 1 || null === t[0]) return new ot("mrel", n, {
            command: e1,
            style: i,
            value: ""
        });
        const r = t[0];
        return new Mt([
            new ii(e1, "", n, {
                align: "right",
                style: i,
                boxType: "mrel"
            }),
            ...r
        ], n, {
            boxType: "mrel",
            captureSelection: !0,
            command: "\\not",
            serialize: (e1, t)=>{
                const i = ot.serialize(r, t);
                return 1 !== i.length || /[a-zA-Z]/.test(i) ? `\\not{${i}}` : "\\not" + i;
            }
        });
    }
}), P([
    "ne",
    "neq"
], "", {
    createAtom: (e1, t, i, n)=>new Mt([
            new ii(e1, "", n, {
                align: "right",
                style: i,
                boxType: "mrel"
            }),
            new ot("mrel", n, {
                style: i,
                value: "="
            })
        ], n, {
            boxType: "mrel",
            captureSelection: !0,
            serialize: ()=>e1,
            command: e1
        })
}), P("rlap", "{:auto}", {
    createAtom: (e1, t, i, n)=>new ii(e1, t[0], n, {
            align: "right",
            style: i
        })
}), P("llap", "{:auto}", {
    createAtom: (e1, t, i, n)=>new ii(e1, t[0], n, {
            style: i
        })
}), P("mathllap", "{:auto}", {
    createAtom: (e1, t, i, n)=>new ii(e1, t[0], n, {
            style: i
        })
}), P("mathrlap", "{:auto}", {
    createAtom: (e1, t, i, n)=>new ii(e1, t[0], n, {
            align: "right",
            style: i
        })
});
const xi = {
    acute: 714,
    grave: 715,
    dot: 729,
    ddot: 168,
    mathring: 730,
    tilde: 126,
    bar: 713,
    breve: 728,
    check: 711,
    hat: 94,
    vec: 8407
};
function ki(e1) {
    for (const t of e1)for (const e2 of t)if (e2.length > 0) return !1;
    return !0;
}
P(Object.keys(xi), "{body:auto}", {
    createAtom: (e1, t, i, n)=>new lt(e1, t[0], n, {
            accentChar: xi[e1.slice(1)],
            style: i
        })
}), P([
    "widehat",
    "widecheck",
    "widetilde"
], "{body:auto}", {
    createAtom: (e1, t, i, n)=>{
        const r = F(t[0]);
        return new lt(e1, t[0], n, {
            style: i,
            svgAccent: e1.slice(1) + (r.length > 5 ? "4" : [
                "1",
                "1",
                "2",
                "2",
                "3",
                "3"
            ][r.length])
        });
    }
}), P([
    "overarc",
    "overparen",
    "wideparen"
], "{body:auto}", {
    createAtom: (e1, t, i, n)=>new lt(e1, t[0], n, {
            style: i,
            svgAccent: "overarc"
        })
}), P([
    "underarc",
    "underparen"
], "{body:auto}", {
    createAtom: (e1, t, i, n)=>new St(e1, n, {
            body: t[0],
            style: i,
            svgBelow: "underarc"
        })
}), P("utilde", "{body:auto}", {
    createAtom: (e1, t, i, n)=>{
        const r = F(t[0]), o = "widetilde" + (r.length > 5 ? "4" : [
            "1",
            "1",
            "2",
            "2",
            "3",
            "3"
        ][r.length]);
        return new St(e1, n, {
            body: t[0],
            svgBelow: o,
            style: i,
            boxType: vi(t[0])
        });
    }
}), P("^", "{:string}", {
    createAtom: (e1, t, i, n)=>{
        var r;
        return new ot("mord", n, {
            command: e1,
            isFunction: !1,
            limits: "adjacent",
            style: i,
            value: t[0] && null !== (r = ({
                a: "\xe2",
                e: "\xea",
                i: "\xee",
                o: "\xf4",
                u: "\xfb",
                A: "\xc2",
                E: "\xca",
                I: "\xce",
                O: "\xd4",
                U: "\xdb"
            })[t[0]]) && void 0 !== r ? r : "^"
        });
    }
}), P("`", "{:string}", {
    createAtom: (e1, t, i, n)=>{
        var r;
        return new ot("mord", n, {
            command: e1,
            isFunction: !1,
            limits: "adjacent",
            style: i,
            value: t[0] && null !== (r = ({
                a: "\xe0",
                e: "\xe8",
                i: "\xec",
                o: "\xf2",
                u: "\xf9",
                A: "\xc0",
                E: "\xc8",
                I: "\xcc",
                O: "\xd2",
                U: "\xd9"
            })[t[0]]) && void 0 !== r ? r : "`"
        });
    }
}), P("'", "{:string}", {
    createAtom: (e1, t, i, n)=>{
        var r;
        return new ot("mord", n, {
            command: e1,
            isFunction: !1,
            limits: "adjacent",
            style: i,
            value: t[0] && null !== (r = ({
                a: "\xe1",
                e: "\xe9",
                i: "\xed",
                o: "\xf3",
                u: "\xfa",
                A: "\xc1",
                E: "\xc9",
                I: "\xcd",
                O: "\xd3",
                U: "\xda"
            })[t[0]]) && void 0 !== r ? r : "^"
        });
    }
}), P("~", "{:string}", {
    createAtom: (e1, t, i, n)=>{
        var r;
        return new ot("mord", n, {
            command: e1,
            isFunction: !1,
            limits: "adjacent",
            style: i,
            value: t[0] && null !== (r = ({
                n: "\xf1",
                N: "\xd1",
                a: "\xe3",
                o: "\xf5",
                A: "\xc3",
                O: "\xd5"
            })[t[0]]) && void 0 !== r ? r : "\xb4"
        });
    }
}), P("c", "{:string}", {
    createAtom: (e1, t, i, n)=>{
        var r;
        return new ot("mord", n, {
            command: e1,
            isFunction: !1,
            limits: "adjacent",
            style: i,
            value: t[0] && null !== (r = ({
                c: "\xe7",
                C: "\xc7"
            })[t[0]]) && void 0 !== r ? r : ""
        });
    }
}), P("enclose", "{notation:string}[style:string]{body:auto}", {
    createAtom: (e1, t, i, n)=>{
        var r;
        const o = {
            strokeColor: "currentColor",
            strokeWidth: "",
            strokeStyle: "solid",
            backgroundcolor: "transparent",
            padding: "auto",
            shadow: "auto",
            svgStrokeStyle: void 0,
            borderStyle: void 0,
            style: i
        };
        if (t[1]) {
            const e2 = t[1].split(/,(?![^(]*\)(?:(?:[^(]*\)){2})*[^"]*$)/);
            for (const t1 of e2){
                const e3 = t1.match(/\s*(\S+)\s+(\S+)\s+(.*)/);
                if (e3) o.strokeWidth = e3[1], o.strokeStyle = e3[2], o.strokeColor = e3[3];
                else {
                    const e4 = t1.match(/\s*([a-z]*)\s*=\s*"(.*)"/);
                    e4 && ("mathbackground" === e4[1] ? o.backgroundcolor = e4[2] : "mathcolor" === e4[1] ? o.strokeColor = e4[2] : "padding" === e4[1] ? o.padding = e4[2] : "shadow" === e4[1] && (o.shadow = e4[2]));
                }
            }
            "dashed" === o.strokeStyle ? o.svgStrokeStyle = "5,5" : "dotted" === o.strokeStyle && (o.svgStrokeStyle = "1,5");
        }
        o.borderStyle = `${o.strokeWidth} ${o.strokeStyle} ${o.strokeColor}`;
        const a = {};
        return (null !== (r = t[0]) && void 0 !== r ? r : "").split(/[, ]/).filter((e1)=>e1.length > 0).forEach((e1)=>{
            a[e1.toLowerCase()] = !0;
        }), new Jt(e1, t[2], a, n, o);
    }
}), P("cancel", "{body:auto}", {
    createAtom: (e1, t, i, n)=>new Jt(e1, t[0], {
            updiagonalstrike: !0
        }, n, {
            strokeColor: "currentColor",
            strokeWidth: "",
            strokeStyle: "solid",
            borderStyle: "1px solid currentColor",
            backgroundcolor: "transparent",
            padding: "auto",
            shadow: "auto",
            style: i
        })
}), P("bcancel", "{body:auto}", {
    createAtom: (e1, t, i, n)=>new Jt(e1, t[0], {
            downdiagonalstrike: !0
        }, n, {
            strokeColor: "currentColor",
            strokeWidth: "",
            strokeStyle: "solid",
            borderStyle: "1px solid currentColor",
            backgroundcolor: "transparent",
            padding: "auto",
            shadow: "auto",
            style: i
        })
}), P("xcancel", "{body:auto}", {
    createAtom: (e1, t, i, n)=>new Jt(e1, t[0], {
            updiagonalstrike: !0,
            downdiagonalstrike: !0
        }, n, {
            strokeColor: "currentColor",
            strokeWidth: "",
            strokeStyle: "solid",
            borderStyle: "1px solid currentColor",
            backgroundcolor: "transparent",
            padding: "auto",
            shadow: "auto",
            style: i
        })
}), B("math", "", (e1, t, i, n)=>(ki(i) && (i = [
        [
            [
                new ot("first", e1),
                new Ct(e1)
            ]
        ]
    ]), new Pt(e1, t, i, n, {
        mathstyleName: "textstyle"
    }))), B("displaymath", "", (e1, t, i, n)=>(ki(i) && (i = [
        [
            [
                new ot("first", e1),
                new Ct(e1)
            ]
        ]
    ]), new Pt(e1, t, i, n, {
        mathstyleName: "textstyle"
    }))), $("array", "{columns:colspec}", (e1, t, i, n, r)=>(ki(i) && (i = [
        [
            [
                new ot("first", e1),
                new Ct(e1)
            ]
        ]
    ]), new Pt(e1, t, i, n, {
        columns: r[0],
        mathstyleName: "textstyle"
    }))), $([
    "equation",
    "equation*",
    "subequations"
], "", (e1, t, i, n)=>(ki(i) && (i = [
        [
            [
                new ot("first", e1),
                new Ct(e1)
            ]
        ]
    ]), new Pt(e1, t, i, n, {
        columns: [
            {
                align: "c"
            }
        ]
    }))), $("multline", "", (e1, t, i, n)=>(ki(i) && (i = [
        [
            [
                new ot("first", e1),
                new Ct(e1)
            ]
        ]
    ]), new Pt(e1, t, i, n, {
        columns: [
            {
                align: "m"
            }
        ]
    }))), $([
    "align",
    "align*",
    "aligned",
    "eqnarray"
], "", (e1, t, i, n)=>{
    let r = 0;
    ki(i) && (i = [
        [
            [
                new ot("first", e1),
                new Ct(e1)
            ],
            [
                new ot("first", e1),
                new Ct(e1)
            ]
        ]
    ]);
    for (const e2 of i)r = Math.max(r, e2.length);
    const o = [
        {
            gap: 0
        },
        {
            align: "r"
        },
        {
            gap: .25
        },
        {
            align: "l"
        }
    ];
    let a = 2;
    for(; a < r;)o.push({
        gap: 1
    }), o.push({
        align: "r"
    }), o.push({
        gap: .25
    }), o.push({
        align: "l"
    }), a += 2;
    return o.push({
        gap: 0
    }), new Pt(e1, t, i, n, {
        arraycolsep: 0,
        columns: o,
        colSeparationType: "align",
        jot: .3,
        minColumns: 2
    });
}), $("split", "", (e1, t, i, n)=>(ki(i) && (i = [
        [
            [
                new ot("first", e1),
                new Ct(e1)
            ],
            [
                new ot("first", e1),
                new Ct(e1)
            ]
        ]
    ]), new Pt(e1, t, i, n, {
        columns: [
            {
                align: "r"
            },
            {
                align: "l"
            }
        ],
        minColumns: 2
    }))), $([
    "gather",
    "gathered"
], "", (e1, t, i, n)=>(ki(i) && (i = [
        [
            [
                new ot("first", e1),
                new Ct(e1)
            ]
        ]
    ]), new Pt(e1, t, i, n, {
        columns: [
            {
                gap: .25
            },
            {
                align: "c"
            },
            {
                gap: 0
            }
        ],
        colSeparationType: "gather"
    }))), $([
    "matrix",
    "pmatrix",
    "bmatrix",
    "Bmatrix",
    "vmatrix",
    "Vmatrix",
    "matrix*",
    "pmatrix*",
    "bmatrix*",
    "Bmatrix*",
    "vmatrix*",
    "Vmatrix*"
], "[columns:colspec]", (e1, t, i, n, r)=>{
    var o;
    ki(i) && (i = [
        [
            [
                new ot("first", e1),
                new Ct(e1)
            ]
        ]
    ]);
    let a = ".", s = ".";
    switch(t){
        case "pmatrix":
        case "pmatrix*":
            a = "(", s = ")";
            break;
        case "bmatrix":
        case "bmatrix*":
            a = "[", s = "]";
            break;
        case "Bmatrix":
        case "Bmatrix*":
            a = "\\lbrace", s = "\\rbrace";
            break;
        case "vmatrix":
        case "vmatrix*":
            a = "\\vert", s = "\\vert";
            break;
        case "Vmatrix":
        case "Vmatrix*":
            a = "\\Vert", s = "\\Vert";
            break;
        case "matrix":
        case "matrix*":
            a = ".", s = ".";
    }
    return new Pt(e1, t, i, n, {
        mathstyleName: "textstyle",
        leftDelim: a,
        rightDelim: s,
        columns: null !== (o = r[0]) && void 0 !== o ? o : [
            {
                align: "c"
            },
            {
                align: "c"
            },
            {
                align: "c"
            },
            {
                align: "c"
            },
            {
                align: "c"
            },
            {
                align: "c"
            },
            {
                align: "c"
            },
            {
                align: "c"
            },
            {
                align: "c"
            },
            {
                align: "c"
            }
        ]
    });
}), $([
    "smallmatrix",
    "smallmatrix*"
], "[columns:colspec]", (e1, t, i, n, r)=>{
    var o;
    return ki(i) && (i = [
        [
            [
                new ot("first", e1),
                new Ct(e1)
            ]
        ]
    ]), new Pt(e1, t, i, n, {
        mathstyleName: "scriptstyle",
        columns: null !== (o = r[0]) && void 0 !== o ? o : [
            {
                align: "c"
            },
            {
                align: "c"
            },
            {
                align: "c"
            },
            {
                align: "c"
            },
            {
                align: "c"
            },
            {
                align: "c"
            },
            {
                align: "c"
            },
            {
                align: "c"
            },
            {
                align: "c"
            },
            {
                align: "c"
            }
        ],
        colSeparationType: "small",
        arraystretch: .5
    });
}), $([
    "cases",
    "dcases"
], "", (e1, t, i, n)=>(ki(i) && (i = [
        [
            [
                new ot("first", e1),
                new Ct(e1)
            ]
        ]
    ]), new Pt(e1, t, i, n, {
        mathstyleName: "dcases" === t ? "displaystyle" : "textstyle",
        arraystretch: 1.2,
        leftDelim: "\\lbrace",
        rightDelim: ".",
        columns: [
            {
                align: "l"
            },
            {
                gap: 1
            },
            {
                align: "l"
            }
        ]
    }))), $("rcases", "", (e1, t, i, n)=>(ki(i) && (i = [
        [
            [
                new ot("first", e1),
                new Ct(e1)
            ]
        ]
    ]), new Pt(e1, t, i, n, {
        arraystretch: 1.2,
        leftDelim: ".",
        rightDelim: "\\rbrace",
        columns: [
            {
                align: "l"
            },
            {
                gap: 1
            },
            {
                align: "l"
            }
        ]
    }))), B("center", "", (e1, t, i, n)=>(ki(i) && (i = [
        [
            [
                new ot("first", e1),
                new Ct(e1)
            ]
        ]
    ]), new Pt(e1, t, i, n, {
        columns: [
            {
                align: "c"
            }
        ]
    }))), P([
    "overrightarrow",
    "overleftarrow",
    "Overrightarrow",
    "overleftharpoon",
    "overrightharpoon",
    "overleftrightarrow",
    "overlinesegment",
    "overgroup"
], "{:auto}", {
    createAtom: (e1, t, i, n)=>new St(e1, n, {
            body: t[0],
            skipBoundary: !1,
            supsubPlacement: "over-under",
            paddedBody: !0,
            boxType: "mrel",
            style: i,
            svgAbove: e1.slice(1)
        })
}), P("overbrace", "{:auto}", {
    createAtom: (e1, t, i, n)=>new St(e1, n, {
            body: t[0],
            skipBoundary: !1,
            supsubPlacement: "over-under",
            paddedBody: !0,
            boxType: "mord",
            style: i,
            svgAbove: e1.slice(1)
        })
}), P([
    "underrightarrow",
    "underleftarrow",
    "underleftrightarrow",
    "underlinesegment",
    "undergroup"
], "{:auto}", {
    createAtom: (e1, t, i, n)=>new St(e1, n, {
            body: t[0],
            skipBoundary: !1,
            supsubPlacement: "over-under",
            paddedBody: !0,
            boxType: "mrel",
            style: i,
            svgBelow: e1.slice(1)
        })
}), P([
    "underbrace"
], "{:auto}", {
    createAtom: (e1, t, i, n)=>new St(e1, n, {
            body: t[0],
            skipBoundary: !1,
            supsubPlacement: "over-under",
            paddedBody: !0,
            boxType: "mord",
            style: i,
            svgBelow: e1.slice(1)
        })
}), P([
    "xrightarrow",
    "xleftarrow",
    "xRightarrow",
    "xLeftarrow",
    "xleftharpoonup",
    "xleftharpoondown",
    "xrightharpoonup",
    "xrightharpoondown",
    "xlongequal",
    "xtwoheadleftarrow",
    "xtwoheadrightarrow",
    "xleftrightarrow",
    "xLeftrightarrow",
    "xrightleftharpoons",
    "xleftrightharpoons",
    "xhookleftarrow",
    "xhookrightarrow",
    "xmapsto",
    "xtofrom",
    "xrightleftarrows",
    "xrightequilibrium",
    "xleftequilibrium"
], "[:auto]{:auto}", {
    createAtom: (e1, t, i, n)=>{
        var r, o;
        return new St(e1, n, {
            style: i,
            svgBody: e1.slice(1),
            above: 0 === (null === (r = t[1]) || void 0 === r ? void 0 : r.length) ? void 0 : t[1],
            below: null !== (o = t[0]) && void 0 !== o ? o : null,
            skipBoundary: !1,
            supsubPlacement: "over-under",
            paddedBody: !0,
            paddedLabels: !0,
            boxType: "mrel",
            serialize: (t, i)=>e1 + (t.hasEmptyBranch("below") ? "" : `[${t.belowToLatex(i)}]`) + `{${t.aboveToLatex(i)}}`
        });
    }
}), P([
    "arccos",
    "arcsin",
    "arctan",
    "arctg",
    "arcctg",
    "arg",
    "ch",
    "cos",
    "cosh",
    "cot",
    "cotg",
    "coth",
    "ctg",
    "cth",
    "csc",
    "cosec",
    "dim",
    "exp",
    "hom",
    "inf",
    "ker",
    "lb",
    "lg",
    "ln",
    "log",
    "Pr",
    "sec",
    "sh",
    "sin",
    "sinh",
    "sup",
    "tan",
    "tanh",
    "tg",
    "th",
    "arcsec",
    "arccsc",
    "arsinh",
    "arcosh",
    "artanh",
    "arcsech",
    "arccsch"
], "", {
    isFunction: !0,
    createAtom: (e1, t, i, n)=>new ti(e1, e1.slice(1), n, {
            limits: "adjacent",
            isFunction: !0,
            variant: "main",
            variantStyle: "up",
            style: i
        })
}), P([
    "liminf",
    "limsup"
], "", {
    createAtom: (e1, t, i, n)=>new ti(e1, {
            "\\liminf": "lim inf",
            "\\limsup": "lim sup"
        }[e1], n, {
            limits: "over-under",
            variant: "main",
            style: i
        })
}), P([
    "lim",
    "mod"
], "", {
    createAtom: (e1, t, i, n)=>new ti(e1, e1.slice(1), n, {
            limits: "over-under",
            variant: "main",
            style: i
        })
}), P([
    "det",
    "max",
    "min"
], "", {
    isFunction: !0,
    createAtom: (e1, t, i, n)=>new ti(e1, e1.slice(1), n, {
            limits: "over-under",
            isFunction: !0,
            variant: "main",
            style: i
        })
}), P([
    "ang"
], "{:math}", {
    isFunction: !0,
    createAtom: (e1, t, i, n)=>new Mt([
            ...t[0],
            new ot("mord", n, {
                value: "\xb0",
                style: i
            })
        ], n, {
            mode: "math",
            latexOpen: "\\ang{",
            latexClose: "}",
            style: i
        })
}), P("sqrt", "[index:auto]{radicand:auto}", {
    createAtom: (e1, t, i, n)=>new oi(e1, n, {
            body: t[1],
            index: t[0],
            style: i
        })
}), P([
    "frac",
    "dfrac",
    "tfrac",
    "cfrac",
    "binom",
    "dbinom",
    "tbinom"
], "{numerator}{denominator}", {
    createAtom: (e1, t, i, n)=>{
        const r = {
            style: i
        };
        switch(e1){
            case "\\dfrac":
            case "\\frac":
            case "\\tfrac":
                r.hasBarLine = !0;
                break;
            case "\\atopfrac":
                r.hasBarLine = !1;
                break;
            case "\\dbinom":
            case "\\binom":
            case "\\tbinom":
                r.hasBarLine = !1, r.leftDelim = "(", r.rightDelim = ")";
        }
        switch(e1){
            case "\\dfrac":
            case "\\dbinom":
                r.mathstyleName = "displaystyle";
                break;
            case "\\tfrac":
            case "\\tbinom":
                r.mathstyleName = "textstyle";
                break;
            case "\\cfrac":
                r.hasBarLine = !0, r.continuousFraction = !0;
        }
        return new Xt(e1, t[0], t[1], n, r);
    }
}), P([
    "brace",
    "brack"
], "", {
    infix: !0,
    createAtom: (e1, t, i, n)=>new Xt(e1, t[0], t[1], n, {
            hasBarLine: !1,
            leftDelim: "\\brace" === e1 ? "\\lbrace" : "\\lbrack",
            rightDelim: "\\brace" === e1 ? "\\rbrace" : "\\rbrack",
            style: i,
            serialize: (e1, t)=>Qe([
                    e1.aboveToLatex(t),
                    e1.command,
                    e1.belowToLatex(t)
                ])
        })
}), P([
    "over",
    "atop",
    "choose"
], "", {
    infix: !0,
    createAtom: (e1, t, i, n)=>{
        let r, o;
        return "\\choose" === e1 && (r = "(", o = ")"), new Xt(e1, t[0], t[1], n, {
            hasBarLine: "\\over" === e1,
            leftDelim: r,
            rightDelim: o,
            style: i,
            serialize: (e1, t)=>Qe([
                    e1.aboveToLatex(t),
                    e1.command,
                    e1.belowToLatex(t)
                ])
        });
    }
}), P([
    "overwithdelims",
    "atopwithdelims"
], "{numer:auto}{denom:auto}{left-delim:delim}{right-delim:delim}", {
    infix: !0,
    createAtom: (e1, t, i, n)=>new Xt(e1, t[0], t[1], n, {
            leftDelim: t[2],
            rightDelim: t[3],
            hasBarLine: !1,
            style: i,
            serialize: (e1, t)=>`${e1.aboveToLatex(t)} ${e1.command}${e1.leftDelim}${e1.rightDelim}${e1.belowToLatex(t)}`
        })
}), P("pdiff", "{numerator}{denominator}", {
    createAtom: (e1, t, i, n)=>new Xt(e1, t[0], t[1], n, {
            hasBarLine: !0,
            numerPrefix: "∂",
            denomPrefix: "∂",
            style: i
        })
}), P([
    "sum",
    "prod",
    "bigcup",
    "bigcap",
    "coprod",
    "bigvee",
    "bigwedge",
    "biguplus",
    "bigotimes",
    "bigoplus",
    "bigodot",
    "bigsqcup",
    "smallint",
    "intop"
], "", {
    createAtom: (e1, t, i, n)=>new ti(e1, {
            coprod: "∐",
            bigvee: "⋁",
            bigwedge: "⋀",
            biguplus: "⨄",
            bigcap: "⋂",
            bigcup: "⋃",
            intop: "∫",
            prod: "∏",
            sum: "∑",
            bigotimes: "⨂",
            bigoplus: "⨁",
            bigodot: "⨀",
            bigsqcup: "⨆",
            smallint: "∫"
        }[e1.slice(1)], n, {
            isExtensibleSymbol: !0,
            limits: "auto",
            variant: "main",
            style: i
        })
});
const _i = {
    int: "∫",
    iint: "∬",
    iiint: "∭",
    oint: "∮",
    oiint: "∯",
    oiiint: "∰",
    intclockwise: "∱",
    varointclockwise: "∲",
    ointctrclockwise: "∳",
    intctrclockwise: "⨑",
    sqcup: "⊔",
    sqcap: "⊓",
    uplus: "⊎",
    wr: "≀",
    amalg: "⨿",
    Cap: "⋒",
    Cup: "⋓",
    doublecap: "⋒",
    doublecup: "⋓"
};
function wi(e1, t) {
    return e1[0] === t[0] && e1[1] === t[1] ? "equal" : "different";
}
function Si(e1) {
    let t = 1 / 0, i = -1 / 0;
    for (const n of e1.ranges)t = Math.min(t, n[0], n[1]), i = Math.max(i, n[0], n[1]);
    return [
        t,
        i
    ];
}
function Mi(e1, t, i) {
    return i ? function(e1, t) {
        if (!t) return "";
        if ("string" == typeof t) return t;
        if (!e1 || void 0 === t.after) return t.value;
        let i = !1, n = !1, r = !1, o = !1, a = !1, s = !1, l = !1, u = !1, c = !1, d = !1, h = !1, m = !1, p = !1, f = !1, g = !1, y = e1[0], b = 0;
        for(; y && /msubsup|placeholder/.test(y.type);)b += 1, y = e1[b];
        return i = !y || "first" === y.type, y && (f = "text" === y.mode, n = !f && "mord" === y.type && L.test(y.value), r = !f && "mord" === y.type && /\d+$/.test(y.value), o = !f && y.isFunction, a = "genfrac" === y.type, s = "surd" === y.type, l = "mbin" === y.type, u = "mrel" === y.type, c = "mop" === y.type, d = "mpunct" === y.type || "minner" === y.type, h = "array" === y.type, m = "mopen" === y.type, p = "mclose" === y.type || "leftright" === y.type, g = "space" === y.type), t.after.includes("nothing") && i || t.after.includes("letter") && n || t.after.includes("digit") && r || t.after.includes("function") && o || t.after.includes("frac") && a || t.after.includes("surd") && s || t.after.includes("binop") && l || t.after.includes("relop") && u || t.after.includes("operator") && c || t.after.includes("punct") && d || t.after.includes("array") && h || t.after.includes("openfence") && m || t.after.includes("closefence") && p || t.after.includes("text") && f || t.after.includes("space") && g ? t.value : "";
    }(e1, i[t]) : "";
}
P(Object.keys(_i), "", {
    createAtom: (e1, t, i, n)=>new ti(e1, _i[e1.slice(1)], n, {
            limits: "adjacent",
            isExtensibleSymbol: !0,
            style: i,
            variant: {
                "⋒": "ams",
                "⋓": "ams"
            }[_i[e1.slice(1)]]
        })
}), P([
    "Re",
    "Im"
], "", {
    createAtom: (e1, t, i, n)=>new ti(e1, {
            "\\Re": "ℜ",
            "\\Im": "ℑ"
        }[e1], n, {
            limits: "adjacent",
            style: i,
            isFunction: !0,
            variant: "fraktur"
        })
}), P("middle", "{:delim}", {
    createAtom: (e1, t, i, n)=>new Zt(e1, t[0], n, {
            size: 1,
            style: i
        })
}), E("0123456789/@.?!"), T(65, 90), T(97, 122), E([
    [
        "\\forall",
        8704
    ],
    [
        "\\exists",
        8707
    ],
    [
        "\\nexists",
        8708,
        "mord",
        "ams"
    ],
    [
        "\\mid",
        8739,
        "mrel"
    ],
    [
        "\\top",
        8868
    ],
    [
        "\\bot",
        8869
    ]
]), E([
    [
        "\\sharp",
        9839
    ],
    [
        "\\flat",
        9837
    ],
    [
        "\\natural",
        9838
    ],
    [
        "\\#",
        35
    ],
    [
        "\\&",
        38
    ],
    [
        "\\clubsuit",
        9827
    ],
    [
        "\\heartsuit",
        9825
    ],
    [
        "\\spadesuit",
        9824
    ],
    [
        "\\diamondsuit",
        9826
    ],
    [
        "\\parallelogram",
        9649
    ]
]), E([
    [
        "\\backslash",
        92
    ],
    [
        "\\nabla",
        8711
    ],
    [
        "\\partial",
        8706
    ],
    [
        "\\ell",
        8467
    ],
    [
        "\\hbar",
        8463
    ],
    [
        "\\Q",
        81,
        "mord",
        "double-struck"
    ],
    [
        "\\C",
        67,
        "mord",
        "double-struck"
    ],
    [
        "\\P",
        80,
        "mord",
        "double-struck"
    ],
    [
        "\\pounds",
        163
    ],
    [
        "\\euro",
        8364
    ]
]), E([
    [
        "\\rightarrow",
        8594
    ],
    [
        "\\to",
        8594
    ],
    [
        "\\leftarrow",
        8592
    ],
    [
        "\\gets",
        8592
    ],
    [
        "\\Rightarrow",
        8658
    ],
    [
        "\\Leftarrow",
        8656
    ],
    [
        "\\longrightarrow",
        10230
    ],
    [
        "\\longleftarrow",
        10229
    ],
    [
        "\\Longrightarrow",
        10233
    ],
    [
        "\\implies",
        10233
    ],
    [
        "\\Longleftarrow",
        10232
    ],
    [
        "\\impliedby",
        10232
    ],
    [
        "\\longleftrightarrow",
        10231
    ],
    [
        "\\biconditional",
        10231
    ],
    [
        "\\Longleftrightarrow",
        10234
    ],
    [
        "\\mapsto",
        8614
    ],
    [
        "\\longmapsto",
        10236
    ],
    [
        "\\uparrow",
        8593
    ],
    [
        "\\downarrow",
        8595
    ],
    [
        "\\Uparrow",
        8657
    ],
    [
        "\\Downarrow",
        8659
    ],
    [
        "\\updownarrow",
        8597
    ],
    [
        "\\Updownarrow",
        8661
    ],
    [
        "\\hookrightarrow",
        8618
    ],
    [
        "\\hookleftarrow",
        8617
    ],
    [
        "\\rightharpoonup",
        8640
    ],
    [
        "\\leftharpoonup",
        8636
    ],
    [
        "\\rightharpoondown",
        8641
    ],
    [
        "\\leftharpoondown",
        8637
    ],
    [
        "\\searrow",
        8600
    ],
    [
        "\\nearrow",
        8599
    ],
    [
        "\\swarrow",
        8601
    ],
    [
        "\\nwarrow",
        8598
    ],
    [
        "\\originalof",
        8886
    ],
    [
        "\\laplace",
        8886
    ],
    [
        "\\imageof",
        8887
    ],
    [
        "\\Laplace",
        8887
    ]
], "mrel"), E([
    [
        "\\lbrace",
        123,
        "mopen"
    ],
    [
        "\\rbrace",
        125,
        "mclose"
    ],
    [
        "\\lparen",
        40,
        "mopen"
    ],
    [
        "\\rparen",
        41,
        "mclose"
    ],
    [
        "\\langle",
        10216,
        "mopen"
    ],
    [
        "\\rangle",
        10217,
        "mclose"
    ],
    [
        "\\lfloor",
        8970,
        "mopen"
    ],
    [
        "\\rfloor",
        8971,
        "mclose"
    ],
    [
        "\\lceil",
        8968,
        "mopen"
    ],
    [
        "\\rceil",
        8969,
        "mclose"
    ],
    [
        "\\vert",
        8739
    ],
    [
        "\\lvert",
        8739,
        "mopen"
    ],
    [
        "\\rvert",
        8739,
        "mclose"
    ],
    [
        "\\|",
        8741
    ],
    [
        "\\Vert",
        8741
    ],
    [
        "\\mVert",
        8741
    ],
    [
        "\\lVert",
        8741,
        "mopen"
    ],
    [
        "\\rVert",
        8741,
        "mclose"
    ],
    [
        "\\lbrack",
        91,
        "mopen"
    ],
    [
        "\\rbrack",
        93,
        "mclose"
    ],
    [
        "\\{",
        123,
        "mopen"
    ],
    [
        "\\}",
        125,
        "mclose"
    ],
    [
        "(",
        40,
        "mopen"
    ],
    [
        ")",
        41,
        "mclose"
    ],
    [
        "[",
        91,
        "mopen"
    ],
    [
        "]",
        93,
        "mclose"
    ],
    [
        "\\ulcorner",
        9484,
        "mopen",
        "ams"
    ],
    [
        "\\urcorner",
        9488,
        "mclose",
        "ams"
    ],
    [
        "\\llcorner",
        9492,
        "mopen",
        "ams"
    ],
    [
        "\\lrcorner",
        9496,
        "mclose",
        "ams"
    ],
    [
        "\\lgroup",
        10222,
        "mopen"
    ],
    [
        "\\rgroup",
        10223,
        "mclose"
    ],
    [
        "\\lmoustache",
        9136,
        "mopen"
    ],
    [
        "\\rmoustache",
        9137,
        "mclose"
    ]
]), E([
    [
        "\\dashrightarrow",
        8674
    ],
    [
        "\\dashleftarrow",
        8672
    ],
    [
        "\\Rrightarrow",
        8667
    ],
    [
        "\\Lleftarrow",
        8666
    ],
    [
        "\\leftrightarrows",
        8646
    ],
    [
        "\\rightleftarrows",
        8644
    ],
    [
        "\\curvearrowright",
        8631
    ],
    [
        "\\curvearrowleft",
        8630
    ],
    [
        "\\rightrightarrows",
        8649
    ],
    [
        "\\leftleftarrows",
        8647
    ],
    [
        "\\upuparrows",
        8648
    ],
    [
        "\\downdownarrows",
        8650
    ],
    [
        "\\vartriangle",
        9651
    ],
    [
        "\\triangleq",
        8796
    ],
    [
        "\\vartriangleleft",
        8882
    ],
    [
        "\\trianglelefteq",
        8884
    ],
    [
        "\\ntriangleleft",
        8938
    ],
    [
        "\\ntrianglelefteq",
        8940
    ],
    [
        "\\vartriangleright",
        8883
    ],
    [
        "\\trianglerighteq",
        8885
    ],
    [
        "\\ntriangleright",
        8939
    ],
    [
        "\\ntrianglerighteq",
        8941
    ],
    [
        "\\blacktriangleleft",
        9664
    ],
    [
        "\\blacktriangleright",
        9654
    ],
    [
        "\\leftarrowtail",
        8610
    ],
    [
        "\\rightarrowtail",
        8611
    ],
    [
        "\\looparrowright",
        8620
    ],
    [
        "\\looparrowleft",
        8619
    ],
    [
        "\\twoheadleftarrow",
        8606
    ],
    [
        "\\twoheadrightarrow",
        8608
    ],
    [
        "\\rightleftharpoons",
        8652
    ],
    [
        "\\leftrightharpoons",
        8651
    ],
    [
        "\\Rsh",
        8625
    ],
    [
        "\\Lsh",
        8624
    ],
    [
        "\\circlearrowright",
        8635
    ],
    [
        "\\circlearrowleft",
        8634
    ],
    [
        "\\restriction",
        8638
    ],
    [
        "\\upharpoonright",
        8638
    ],
    [
        "\\upharpoonleft",
        8639
    ],
    [
        "\\downharpoonright",
        8642
    ],
    [
        "\\downharpoonleft",
        8643
    ],
    [
        "\\rightsquigarrow",
        8669
    ],
    [
        "\\leadsto",
        8669
    ],
    [
        "\\leftrightsquigarrow",
        8621
    ],
    [
        "\\multimap",
        8888
    ],
    [
        "\\nrightarrow",
        8603
    ],
    [
        "\\nleftarrow",
        8602
    ],
    [
        "\\nRightarrow",
        8655
    ],
    [
        "\\nLeftarrow",
        8653
    ],
    [
        "\\nleftrightarrow",
        8622
    ],
    [
        "\\nLeftrightarrow",
        8654
    ],
    [
        "\\shortparallel",
        8741
    ],
    [
        "\\nless",
        8814
    ],
    [
        "\\nleqslant",
        57360
    ],
    [
        "\\lneq",
        10887
    ],
    [
        "\\lneqq",
        8808
    ],
    [
        "\\nleqq",
        57361
    ],
    [
        "\\lvertneqq",
        57356
    ],
    [
        "\\lnsim",
        8934
    ],
    [
        "\\lnapprox",
        10889
    ],
    [
        "\\nprec",
        8832
    ],
    [
        "\\npreceq",
        8928
    ],
    [
        "\\precnsim",
        8936
    ],
    [
        "\\precnapprox",
        10937
    ],
    [
        "\\nsim",
        8769
    ],
    [
        "\\nshortmid",
        57350
    ],
    [
        "\\nmid",
        8740
    ],
    [
        "\\nvdash",
        8876
    ],
    [
        "\\nvDash",
        8877
    ],
    [
        "\\ngtr",
        8815
    ],
    [
        "\\ngeqslant",
        57359
    ],
    [
        "\\ngeqq",
        57358
    ],
    [
        "\\gneq",
        10888
    ],
    [
        "\\gneqq",
        8809
    ],
    [
        "\\gvertneqq",
        57357
    ],
    [
        "\\gnsim",
        8935
    ],
    [
        "\\gnapprox",
        10890
    ],
    [
        "\\nsucc",
        8833
    ],
    [
        "\\nsucceq",
        8929
    ],
    [
        "\\succnsim",
        8937
    ],
    [
        "\\succnapprox",
        10938
    ],
    [
        "\\ncong",
        8774
    ],
    [
        "\\nshortparallel",
        57351
    ],
    [
        "\\nparallel",
        8742
    ],
    [
        "\\nVDash",
        8879
    ],
    [
        "\\nsupseteqq",
        57368
    ],
    [
        "\\supsetneq",
        8843
    ],
    [
        "\\varsupsetneq",
        57371
    ],
    [
        "\\supsetneqq",
        10956
    ],
    [
        "\\varsupsetneqq",
        57369
    ],
    [
        "\\nVdash",
        8878
    ],
    [
        "\\precneqq",
        10933
    ],
    [
        "\\succneqq",
        10934
    ],
    [
        "\\nsubseteqq",
        57366
    ],
    [
        "\\leqslant",
        10877
    ],
    [
        "\\geqslant",
        10878
    ],
    [
        "\\gtrsim",
        8819
    ],
    [
        "\\approxeq",
        8778
    ],
    [
        "\\thickapprox",
        8776
    ],
    [
        "\\lessapprox",
        10885
    ],
    [
        "\\gtrapprox",
        10886
    ],
    [
        "\\precapprox",
        10935
    ],
    [
        "\\succapprox",
        10936
    ],
    [
        "\\thicksim",
        8764
    ],
    [
        "\\succsim",
        8831
    ],
    [
        "\\precsim",
        8830
    ],
    [
        "\\backsim",
        8765
    ],
    [
        "\\eqsim",
        8770
    ],
    [
        "\\backsimeq",
        8909
    ],
    [
        "\\lesssim",
        8818
    ],
    [
        "\\nleq",
        8816
    ],
    [
        "\\ngeq",
        8817
    ],
    [
        "\\smallsmile",
        8995
    ],
    [
        "\\smallfrown",
        8994
    ],
    [
        "\\leqq",
        8806
    ],
    [
        "\\eqslantless",
        10901
    ],
    [
        "\\lll",
        8920
    ],
    [
        "\\lessgtr",
        8822
    ],
    [
        "\\lesseqgtr",
        8922
    ],
    [
        "\\lesseqqgtr",
        10891
    ],
    [
        "\\risingdotseq",
        8787
    ],
    [
        "\\fallingdotseq",
        8786
    ],
    [
        "\\subseteqq",
        10949
    ],
    [
        "\\Subset",
        8912
    ],
    [
        "\\sqsubset",
        8847
    ],
    [
        "\\preccurlyeq",
        8828
    ],
    [
        "\\curlyeqprec",
        8926
    ],
    [
        "\\vDash",
        8872
    ],
    [
        "\\Vvdash",
        8874
    ],
    [
        "\\bumpeq",
        8783
    ],
    [
        "\\Bumpeq",
        8782
    ],
    [
        "\\geqq",
        8807
    ],
    [
        "\\eqslantgtr",
        10902
    ],
    [
        "\\ggg",
        8921
    ],
    [
        "\\gtrless",
        8823
    ],
    [
        "\\gtreqless",
        8923
    ],
    [
        "\\gtreqqless",
        10892
    ],
    [
        "\\supseteqq",
        10950
    ],
    [
        "\\Supset",
        8913
    ],
    [
        "\\sqsupset",
        8848
    ],
    [
        "\\succcurlyeq",
        8829
    ],
    [
        "\\curlyeqsucc",
        8927
    ],
    [
        "\\Vdash",
        8873
    ],
    [
        "\\shortmid",
        8739
    ],
    [
        "\\between",
        8812
    ],
    [
        "\\pitchfork",
        8916
    ],
    [
        "\\varpropto",
        8733
    ],
    [
        "\\backepsilon",
        8717
    ],
    [
        "\\llless",
        8920
    ],
    [
        "\\gggtr",
        8921
    ],
    [
        "\\doteqdot",
        8785
    ],
    [
        "\\Doteq",
        8785
    ],
    [
        "\\eqcirc",
        8790
    ],
    [
        "\\circeq",
        8791
    ],
    [
        "\\therefore",
        8756
    ],
    [
        "\\because",
        8757
    ]
], "mrel", "ams"), E([
    [
        "+",
        43
    ],
    [
        "-",
        8722
    ],
    [
        "−",
        8722
    ],
    [
        "\\pm",
        177
    ],
    [
        "\\mp",
        8723
    ],
    [
        "*",
        8727
    ],
    [
        "\\times",
        215
    ],
    [
        "\\div",
        247
    ],
    [
        "\\divides",
        8739
    ],
    [
        "\\cdot",
        8901
    ],
    [
        "\\cap",
        8745
    ],
    [
        "\\cup",
        8746
    ],
    [
        "\\setminus",
        8726
    ],
    [
        "\\land",
        8743
    ],
    [
        "\\wedge",
        8743
    ],
    [
        "\\lor",
        8744
    ],
    [
        "\\vee",
        8744
    ],
    [
        "\\circ",
        8728
    ],
    [
        "\\bigcirc",
        9711
    ],
    [
        "\\bullet",
        8729
    ],
    [
        "\\oplus",
        8853
    ],
    [
        "\\ominus",
        8854
    ],
    [
        "\\otimes",
        8855
    ],
    [
        "\\odot",
        8857
    ],
    [
        "\\oslash",
        8856
    ],
    [
        "\\bigtriangleup",
        9651
    ],
    [
        "\\bigtriangledown",
        9661
    ],
    [
        "\\triangleleft",
        9667
    ],
    [
        "\\triangleright",
        9657
    ],
    [
        "\\And",
        38
    ],
    [
        "\\dagger",
        8224
    ],
    [
        "\\dag",
        8224
    ],
    [
        "\\ddag",
        8225
    ],
    [
        "\\ddagger",
        8225
    ],
    [
        "\\ast",
        8727
    ],
    [
        "\\star",
        8902
    ],
    [
        "\\bigstar",
        9733
    ],
    [
        "\\diamond",
        8900
    ]
], "mbin"), E([
    [
        "\\lhd",
        8882
    ],
    [
        "\\rhd",
        8883
    ],
    [
        "\\lessdot",
        8918
    ],
    [
        "\\gtrdot",
        8919
    ],
    [
        "\\ltimes",
        8905
    ],
    [
        "\\rtimes",
        8906
    ],
    [
        "\\leftthreetimes",
        8907
    ],
    [
        "\\rightthreetimes",
        8908
    ],
    [
        "\\intercal",
        8890
    ],
    [
        "\\dotplus",
        8724
    ],
    [
        "\\doublebarwedge",
        10846
    ],
    [
        "\\divideontimes",
        8903
    ],
    [
        "\\centerdot",
        8901
    ],
    [
        "\\smallsetminus",
        8726
    ],
    [
        "\\barwedge",
        8892
    ],
    [
        "\\veebar",
        8891
    ],
    [
        "\\nor",
        8891
    ],
    [
        "\\curlywedge",
        8911
    ],
    [
        "\\curlyvee",
        8910
    ],
    [
        "\\boxminus",
        8863
    ],
    [
        "\\boxplus",
        8862
    ],
    [
        "\\boxtimes",
        8864
    ],
    [
        "\\boxdot",
        8865
    ],
    [
        "\\circleddash",
        8861
    ],
    [
        "\\circledast",
        8859
    ],
    [
        "\\circledcirc",
        8858
    ],
    [
        "\\unlhd",
        8884
    ],
    [
        "\\unrhd",
        8885
    ]
], "mbin", "ams"), E([
    [
        "\\surd",
        8730
    ],
    [
        "\\infty",
        8734
    ],
    [
        "\\prime",
        8242
    ],
    [
        "\\doubleprime",
        8243
    ],
    [
        "\\angle",
        8736
    ],
    [
        "`",
        8216
    ],
    [
        "\\$",
        36
    ],
    [
        "\\%",
        37
    ],
    [
        "\\_",
        95
    ],
    [
        "\\alpha",
        945
    ],
    [
        "\\beta",
        946
    ],
    [
        "\\gamma",
        947
    ],
    [
        "\\delta",
        948
    ],
    [
        "\\epsilon",
        1013
    ],
    [
        "\\varepsilon",
        949
    ],
    [
        "\\zeta",
        950
    ],
    [
        "\\eta",
        951
    ],
    [
        "\\theta",
        952
    ],
    [
        "\\vartheta",
        977
    ],
    [
        "\\iota",
        953
    ],
    [
        "\\kappa",
        954
    ],
    [
        "\\varkappa",
        1008,
        "mord",
        "ams"
    ],
    [
        "\\lambda",
        955
    ],
    [
        "\\mu",
        956
    ],
    [
        "\\nu",
        957
    ],
    [
        "\\xi",
        958
    ],
    [
        "\\omicron",
        111
    ],
    [
        "\\pi",
        960
    ],
    [
        "\\varpi",
        982
    ],
    [
        "\\rho",
        961
    ],
    [
        "\\varrho",
        1009
    ],
    [
        "\\sigma",
        963
    ],
    [
        "\\varsigma",
        962
    ],
    [
        "\\tau",
        964
    ],
    [
        "\\phi",
        981
    ],
    [
        "\\varphi",
        966
    ],
    [
        "\\upsilon",
        965
    ],
    [
        "\\chi",
        967
    ],
    [
        "\\psi",
        968
    ],
    [
        "\\omega",
        969
    ],
    [
        "\\Gamma",
        915
    ],
    [
        "\\Delta",
        916
    ],
    [
        "\\Theta",
        920
    ],
    [
        "\\Lambda",
        923
    ],
    [
        "\\Xi",
        926
    ],
    [
        "\\Pi",
        928
    ],
    [
        "\\Sigma",
        931
    ],
    [
        "\\Upsilon",
        933
    ],
    [
        "\\Phi",
        934
    ],
    [
        "\\Psi",
        936
    ],
    [
        "\\Omega",
        937
    ],
    [
        "\\digamma",
        989,
        "mord",
        "ams"
    ],
    [
        "\\emptyset",
        8709
    ]
]), E([
    [
        "=",
        61
    ],
    [
        "<",
        60
    ],
    [
        "\\lt",
        60
    ],
    [
        ">",
        62
    ],
    [
        "\\gt",
        62
    ],
    [
        "\\le",
        8804
    ],
    [
        "\\leq",
        8804
    ],
    [
        "\\ge",
        8805
    ],
    [
        "\\geq",
        8805
    ],
    [
        "\\ll",
        8810
    ],
    [
        "\\gg",
        8811
    ],
    [
        "\\coloneq",
        8788
    ],
    [
        "\\measeq",
        8797
    ],
    [
        "\\eqdef",
        8798
    ],
    [
        "\\questeq",
        8799
    ],
    [
        ":",
        58
    ],
    [
        "\\cong",
        8773
    ],
    [
        "\\equiv",
        8801
    ],
    [
        "\\prec",
        8826
    ],
    [
        "\\preceq",
        10927
    ],
    [
        "\\succ",
        8827
    ],
    [
        "\\succeq",
        10928
    ],
    [
        "\\perp",
        8869
    ],
    [
        "\\propto",
        8733
    ],
    [
        "\\Colon",
        8759
    ],
    [
        "\\smile",
        8995
    ],
    [
        "\\frown",
        8994
    ],
    [
        "\\sim",
        8764
    ],
    [
        "\\doteq",
        8784
    ],
    [
        "\\bowtie",
        8904
    ],
    [
        "\\Join",
        8904
    ],
    [
        "\\asymp",
        8781
    ],
    [
        "\\sqsubseteq",
        8849
    ],
    [
        "\\sqsupseteq",
        8850
    ],
    [
        "\\approx",
        8776
    ],
    [
        "\\~",
        126
    ],
    [
        "\\leftrightarrow",
        8596
    ],
    [
        "\\Leftrightarrow",
        8660
    ],
    [
        "\\models",
        8872
    ],
    [
        "\\vdash",
        8866
    ],
    [
        "\\dashv",
        8867
    ],
    [
        "\\roundimplies",
        10608
    ],
    [
        "\\in",
        8712
    ],
    [
        "\\notin",
        8713
    ],
    [
        "\\ni",
        8715
    ],
    [
        "\\owns",
        8715
    ],
    [
        "\\subset",
        8834
    ],
    [
        "\\supset",
        8835
    ],
    [
        "\\subseteq",
        8838
    ],
    [
        "\\supseteq",
        8839
    ],
    [
        "\\differencedelta",
        8710
    ],
    [
        "\\mvert",
        8739
    ],
    [
        "\\parallel",
        8741
    ],
    [
        "\\simeq",
        8771
    ]
], "mrel"), E([
    [
        "\\lnot",
        172
    ],
    [
        "\\neg",
        172
    ],
    [
        "\\triangle",
        9651
    ],
    [
        "\\subsetneq",
        8842
    ],
    [
        "\\varsubsetneq",
        57370
    ],
    [
        "\\subsetneqq",
        10955
    ],
    [
        "\\varsubsetneqq",
        57367
    ],
    [
        "\\nsubset",
        8836
    ],
    [
        "\\nsupset",
        8837
    ],
    [
        "\\nsubseteq",
        8840
    ],
    [
        "\\nsupseteq",
        8841
    ]
], "mrel", "ams"), E([
    [
        "\\wp",
        8472
    ],
    [
        "\\aleph",
        8501
    ]
]), E([
    [
        "\\blacktriangle",
        9650
    ],
    [
        "\\hslash",
        8463
    ],
    [
        "\\Finv",
        8498
    ],
    [
        "\\Game",
        8513
    ],
    [
        "\\eth",
        240
    ],
    [
        "\\mho",
        8487
    ],
    [
        "\\Bbbk",
        107
    ],
    [
        "\\yen",
        165
    ],
    [
        "\\square",
        9633
    ],
    [
        "\\Box",
        9633
    ],
    [
        "\\blacksquare",
        9632
    ],
    [
        "\\circledS",
        9416
    ],
    [
        "\\circledR",
        174
    ],
    [
        "\\triangledown",
        9661
    ],
    [
        "\\blacktriangledown",
        9660
    ],
    [
        "\\checkmark",
        10003
    ],
    [
        "\\diagup",
        9585
    ],
    [
        "\\measuredangle",
        8737
    ],
    [
        "\\sphericalangle",
        8738
    ],
    [
        "\\backprime",
        8245
    ],
    [
        "\\backdoubleprime",
        8246
    ],
    [
        "\\Diamond",
        9674
    ],
    [
        "\\lozenge",
        9674
    ],
    [
        "\\blacklozenge",
        10731
    ],
    [
        "\\varnothing",
        8709
    ],
    [
        "\\complement",
        8705
    ],
    [
        "\\maltese",
        10016
    ],
    [
        "\\beth",
        8502
    ],
    [
        "\\daleth",
        8504
    ],
    [
        "\\gimel",
        8503
    ]
], "mord", "ams"), E([
    [
        "\\ ",
        160
    ],
    [
        "~",
        160
    ],
    [
        "\\space",
        160
    ]
], "space"), P([
    "!",
    ",",
    ":",
    ";",
    "enskip",
    "enspace",
    "quad",
    "qquad"
], "", {
    createAtom: (e1, t, i, n)=>new Nt(e1, i, n)
}), E([
    [
        "\\colon",
        58
    ],
    [
        "\\cdotp",
        8901
    ],
    [
        "\\vdots",
        8942,
        "mord"
    ],
    [
        "\\ldotp",
        46
    ],
    [
        ",",
        44
    ],
    [
        ";",
        59
    ]
], "mpunct"), E([
    [
        "\\cdots",
        8943
    ],
    [
        "\\ddots",
        8945
    ],
    [
        "\\ldots",
        8230
    ],
    [
        "\\mathellipsis",
        8230
    ]
], "minner"), E([
    [
        "\\/",
        47
    ],
    [
        "|",
        8739,
        "mord"
    ],
    [
        "\\imath",
        305
    ],
    [
        "\\jmath",
        567
    ],
    [
        "\\degree",
        176
    ],
    [
        "'",
        8242
    ],
    [
        '"',
        8221
    ]
]);
const Ni = {
    "&": "\\&",
    "%": "\\%",
    "''": "^{\\doubleprime}",
    alpha: "\\alpha",
    delta: "\\delta",
    Delta: "\\Delta",
    pi: "\\pi",
    Pi: "\\Pi",
    theta: "\\theta",
    Theta: "\\Theta",
    ii: {
        after: "nothing+digit+function+frac+surd+binop+relop+punct+array+openfence+closefence+space+text",
        value: "\\imaginaryI"
    },
    jj: {
        after: "nothing+digit+function+frac+surd+binop+relop+punct+array+openfence+closefence+space+text",
        value: "\\imaginaryJ"
    },
    ee: {
        after: "nothing+digit+function+frac+surd+binop+relop+punct+array+openfence+closefence+space+text",
        value: "\\exponentialE"
    },
    nabla: "\\nabla",
    grad: "\\nabla",
    del: "\\partial",
    deg: {
        after: "digit+space",
        value: "\\degree"
    },
    infty: "\\infty",
    "∞": "\\infty",
    oo: {
        after: "nothing+digit+frac+surd+binop+relop+punct+array+openfence+closefence+space",
        value: "\\infty"
    },
    "∑": "\\sum",
    sum: "\\sum_{#?}^{#?}",
    int: "\\int_{#?}^{#?}",
    prod: "\\prod_{#?}^{#?}",
    sqrt: "\\sqrt{#?}",
    "∆": "\\differentialD",
    "∂": "\\differentialD",
    arcsin: "\\arcsin",
    arccos: "\\arccos",
    arctan: "\\arctan",
    arcsec: "\\arcsec",
    arccsc: "\\arccsc",
    arsinh: "\\arsinh",
    arcosh: "\\arcosh",
    artanh: "\\artanh",
    arcsech: "\\arcsech",
    arccsch: "\\arccsch",
    arg: "\\arg",
    ch: "\\ch",
    cosec: "\\cosec",
    cosh: "\\cosh",
    cot: "\\cot",
    cotg: "\\cotg",
    coth: "\\coth",
    csc: "\\csc",
    ctg: "\\ctg",
    cth: "\\cth",
    sec: "\\sec",
    sinh: "\\sinh",
    sh: "\\sh",
    tanh: "\\tanh",
    tg: "\\tg",
    th: "\\th",
    sin: "\\sin",
    cos: "\\cos",
    tan: "\\tan",
    lg: "\\lg",
    lb: "\\lb",
    log: "\\log",
    ln: "\\ln",
    exp: "\\exp",
    lim: "\\lim_{#?}",
    dx: {
        after: "nothing+digit+function+frac+surd+binop+relop+punct+array+openfence+closefence+space+text",
        value: "\\differentialD x"
    },
    dy: {
        after: "nothing+digit+function+frac+surd+binop+relop+punct+array+openfence+closefence+space+text",
        value: "\\differentialD y"
    },
    dt: {
        after: "nothing+digit+function+frac+surd+binop+relop+punct+array+openfence+closefence+space+text",
        value: "\\differentialD t"
    },
    AA: "\\forall",
    EE: "\\exists",
    "!EE": "\\nexists",
    "&&": "\\land",
    xin: {
        after: "nothing+text+relop+punct+openfence+space",
        value: "x \\in"
    },
    in: {
        after: "nothing+letter+closefence",
        value: "\\in"
    },
    "!in": "\\notin",
    NN: "\\mathbb{N}",
    ZZ: "\\Z",
    QQ: "\\Q",
    RR: "\\R",
    CC: "\\C",
    xx: "\\times",
    "+-": "\\pm",
    "≠": "\\ne",
    "!=": "\\ne",
    "≥": "\\ge",
    ">=": "\\ge",
    "≤": "\\le",
    "<=": "\\le",
    "<<": "\\ll",
    ">>": "\\gg",
    "~~": "\\approx",
    "≈": "\\approx",
    "?=": "\\questeq",
    "\xf7": "\\div",
    "\xac": "\\neg",
    ":=": "\\coloneq",
    "::": "\\Colon",
    "(:": "\\langle",
    ":)": "\\rangle",
    beta: "\\beta",
    chi: "\\chi",
    epsilon: "\\epsilon",
    varepsilon: "\\varepsilon",
    eta: {
        after: "nothing+digit+function+frac+surd+binop+relop+punct+array+openfence+closefence+space+text",
        value: "\\eta"
    },
    gamma: "\\gamma",
    Gamma: "\\Gamma",
    iota: "\\iota",
    kappa: "\\kappa",
    lambda: "\\lambda",
    Lambda: "\\Lambda",
    mu: {
        after: "nothing+digit+function+frac+surd+binop+relop+punct+array+openfence+closefence+space+text",
        value: "\\mu"
    },
    nu: {
        after: "nothing+digit+function+frac+surd+binop+relop+punct+array+openfence+closefence+space+text",
        value: "\\nu"
    },
    µ: "\\mu",
    phi: {
        after: "nothing+digit+function+frac+surd+binop+relop+punct+array+openfence+closefence+space+text",
        value: "\\phi"
    },
    Phi: {
        after: "nothing+digit+function+frac+surd+binop+relop+punct+array+openfence+closefence+space+text",
        value: "\\Phi"
    },
    varphi: "\\varphi",
    psi: {
        after: "nothing+digit+function+frac+surd+binop+relop+punct+array+openfence+closefence+space+text",
        value: "\\psi"
    },
    Psi: {
        after: "nothing+digit+function+frac+surd+binop+relop+punct+array+openfence+closefence+space+text",
        value: "\\Psi"
    },
    rho: {
        after: "nothing+digit+function+frac+surd+binop+relop+punct+array+openfence+closefence+space+text",
        value: "\\rho"
    },
    sigma: "\\sigma",
    Sigma: "\\Sigma",
    tau: {
        after: "nothing+digit+function+frac+surd+binop+relop+punct+array+openfence+closefence+space+text",
        value: "\\tau"
    },
    vartheta: "\\vartheta",
    upsilon: "\\upsilon",
    xi: {
        after: "nothing+digit+function+frac+surd+binop+relop+punct+array+openfence+closefence+space",
        value: "\\xi"
    },
    Xi: {
        after: "nothing+digit+function+frac+surd+binop+relop+punct+array+openfence+closefence+space+text",
        value: "\\Xi"
    },
    zeta: "\\zeta",
    omega: "\\omega",
    Omega: "\\Omega",
    Ω: "\\omega",
    forall: "\\forall",
    exists: "\\exists",
    "!exists": "\\nexists",
    ":.": "\\therefore",
    liminf: "\\liminf_{#?}",
    limsup: "\\limsup_{#?}",
    argmin: "\\operatorname*{arg~min}_{#?}",
    argmax: "\\operatorname*{arg~max}_{#?}",
    det: "\\det",
    mod: "\\mod",
    max: "\\max",
    min: "\\min",
    erf: "\\operatorname{erf}",
    erfc: "\\operatorname{erfc}",
    bessel: "\\operatorname{bessel}",
    mean: "\\operatorname{mean}",
    median: "\\operatorname{median}",
    fft: "\\operatorname{fft}",
    lcm: "\\operatorname{lcm}",
    gcd: "\\operatorname{gcd}",
    randomReal: "\\operatorname{randomReal}",
    randomInteger: "\\operatorname{randomInteger}",
    Re: "\\operatorname{Re}",
    Im: "\\operatorname{Im}",
    mm: {
        after: "nothing+digit+operator",
        value: "\\operatorname{mm}"
    },
    cm: {
        after: "nothing+digit+operator",
        value: "\\operatorname{cm}"
    },
    km: {
        after: "nothing+digit+operator",
        value: "\\operatorname{km}"
    },
    kg: {
        after: "nothing+digit+operator",
        value: "\\operatorname{kg}"
    },
    "...": "\\ldots",
    "+...": "+\\cdots",
    "-...": "-\\cdots",
    "->...": "\\to\\cdots",
    "->": "\\to",
    "|->": "\\mapsto",
    "-->": "\\longrightarrow",
    "<--": "\\longleftarrow",
    "=>": "\\Rightarrow",
    "==>": "\\Longrightarrow",
    "<=>": "\\Leftrightarrow",
    "<->": "\\leftrightarrow",
    "(.)": "\\odot",
    "(+)": "\\oplus",
    "(/)": "\\oslash",
    "(*)": "\\otimes",
    "(-)": "\\ominus",
    "||": "\\Vert",
    "{": "\\{",
    "}": "\\}",
    "*": "\\cdot"
};
function Li(e1, t) {
    var i;
    let n = null !== (i = null == t ? void 0 : t.format) && void 0 !== i ? i : "auto";
    return "auto" === n && ([n, e1] = function(e1) {
        if ((e1 = e1.trim()).length <= 1) return [
            "latex",
            e1
        ];
        let t;
        return [t, e1] = Di(e1), t ? [
            "latex",
            e1
        ] : e1.startsWith("`") && e1.endsWith("`") ? [
            "ascii-math",
            e1 = e1.substring(1, e1.length - 1)
        ] : e1.includes("\\") ? [
            "latex",
            e1
        ] : /\$.+\$/.test(e1) ? [
            "latex",
            `\\text{${e1}}`
        ] : [
            void 0,
            e1
        ];
    }(e1)), "ascii-math" === n ? [
        "ascii-math",
        Ai(e1 = (e1 = (e1 = (e1 = (e1 = (e1 = e1.replace(/\u2061/gu, "")).replace(/\u3016/gu, "{")).replace(/\u3017/gu, "}")).replace(/([^\\])sinx/g, "$1\\sin x")).replace(/([^\\])cosx/g, "$1\\cos x ")).replace(/\u2013/g, "-"), {
            inlineShortcuts: null == t ? void 0 : t.inlineShortcuts
        })
    ] : [
        "latex",
        e1
    ];
}
function Ai(e1, t) {
    var i, n, r;
    if (!e1) return "";
    let o, a = !1;
    const s = null !== (i = t.inlineShortcuts) && void 0 !== i ? i : Ni;
    if (a || !e1.startsWith("^") && !e1.startsWith("_") || (o = Ci(e1.slice(1), {
        inlineShortcuts: s,
        noWrap: !0
    }), e1 = e1[0] + "{" + o.match + "}", e1 += Ai(o.rest, t), a = !0), !a && (o = e1.match(/^(sqrt|\u221A)(.*)/), o) && (o = Ci(o[2], {
        inlineShortcuts: s,
        noWrap: !0
    }), e1 = "\\sqrt{" + (null !== (n = o.match) && void 0 !== n ? n : "\\placeholder{}") + "}", e1 += Ai(o.rest, t), a = !0), !a && (o = e1.match(/^(\\cbrt|\u221B)(.*)/), o) && (o = Ci(o[2], {
        inlineShortcuts: s,
        noWrap: !0
    }), e1 = "\\sqrt[3]{" + (null !== (r = o.match) && void 0 !== r ? r : "\\placeholder{}") + "}", e1 += Ai(o.rest, t), a = !0), a || (o = e1.match(/^abs(.*)/), o && (o = Ci(o[1], {
        inlineShortcuts: s,
        noWrap: !0
    }), e1 = "\\left|" + o.match + "\\right|", e1 += Ai(o.rest, t), a = !0)), a || (o = e1.match(/^["\u201d\u201c](.*?)["\u201d\u201c](.*)/), o && (e1 = "\\text{" + o[1] + "}", e1 += Ai(o[2], t), a = !0)), a || (o = e1.match(/^([^a-zA-Z\(\{\[\_\^\\\s"]+)(.*)/), o && (e1 = Ei(o[1], s), e1 += Ai(o[2], t), a = !0)), !a && /^([fgh])[^a-zA-Z]/.test(e1) && (o = Ci(e1.slice(1), {
        inlineShortcuts: s,
        noWrap: !0
    }), e1 = "(" === e1[1] ? e1[0] + "\\left(" + o.match + "\\right)" : e1[0] + o.match, e1 += Ai(o.rest, t), a = !0), a || (o = e1.match(/^([a-zA-Z]+)(.*)/), o && (e1 = Ei(o[1], s), e1 += Ai(o[2], t), a = !0)), !a) {
        if (o = Ci(e1, {
            inlineShortcuts: s,
            noWrap: !0
        }), o.match && "/" === o.rest[0]) {
            const i1 = Ci(o.rest.slice(1), {
                inlineShortcuts: s,
                noWrap: !0
            });
            i1.match && (e1 = "\\frac{" + o.match + "}{" + i1.match + "}" + Ai(i1.rest, t)), a = !0;
        } else o.match && (e1 = e1.startsWith("(") ? "\\left(" + o.match + "\\right)" + Ai(o.rest, t) : o.match + Ai(o.rest, t), a = !0);
    }
    return a || (o = e1.match(/^(\s+)(.*)$/), o && (e1 = " " + Ai(o[2], t), a = !0)), e1;
}
function Ci(e1, t) {
    let i = "", n = e1 = e1.trim(), r = e1.charAt(0), o = {
        "(": ")",
        "{": "}",
        "[": "]"
    }[r];
    if (o) {
        let a = 1, s = 1;
        for(; s < e1.length && a > 0;)e1[s] === r && a++, e1[s] === o && a--, s++;
        0 === a ? (t.noWrap && "(" === r ? i = Ai(e1.substring(1, s - 1), t) : ("{" === r && "}" === o && (r = "\\{", o = "\\}"), i = "\\left" + r + Ai(e1.substring(1, s - 1), t) + "\\right" + o), n = e1.slice(Math.max(0, s))) : (i = e1.substring(1, s), n = "");
    } else {
        let r1 = e1.match(/^([a-zA-Z]+)/);
        if (r1) {
            let i1 = Mi(null, e1, t.inlineShortcuts);
            if (i1) return i1 = i1.replace("_{#?}", ""), i1 = i1.replace("^{#?}", ""), {
                match: i1,
                rest: e1.slice(i1.length)
            };
        }
        if (r1 = e1.match(/^([a-zA-Z])/), r1) return {
            match: r1[1],
            rest: e1.slice(1)
        };
        if (r1 = e1.match(/^(-)?\d+(\.\d*)?/), r1) return {
            match: r1[0],
            rest: e1.slice(r1[0].length)
        };
        /^\\(left|right)/.test(e1) || (r1 = e1.match(/^(\\[a-zA-Z]+)/), r1 && (n = e1.slice(r1[1].length), i = r1[1]));
    }
    return {
        match: i,
        rest: n
    };
}
function Ei(e1, t) {
    let i = Mi(null, e1, t);
    return i ? (i = i.replace("_{#?}", ""), i = i.replace("^{#?}", ""), i += " ") : i = e1, i;
}
const Ti = [
    [
        "\\[",
        "\\]"
    ],
    [
        "\\(",
        "\\)"
    ],
    [
        "$$",
        "$$"
    ],
    [
        "$",
        "$"
    ],
    [
        "\\begin{math}",
        "\\end{math}"
    ],
    [
        "\\begin{displaymath}",
        "\\end{displaymath}"
    ],
    [
        "\\begin{equation}",
        "\\end{equation}"
    ],
    [
        "\\begin{equation*}",
        "\\end{equation*}"
    ]
];
function Di(e1) {
    const t = e1.trim();
    for (const e2 of Ti)if (t.startsWith(e2[0]) && t.endsWith(e2[1])) return [
        !0,
        t.substring(e2[0].length, t.length - e2[1].length)
    ];
    return [
        !1,
        e1
    ];
}
const zi = (e1, t, i)=>(Ti.some((e1)=>t.startsWith(e1[0]) && t.endsWith(e1[1])) || (t = `$$ ${t} $$`), t);
class qi {
    static onPaste(e1, t, i) {
        var n;
        const r = new ClipboardEvent("paste", {
            clipboardData: i.clipboardData,
            cancelable: !0
        });
        return !!(null === (n = t.host) || void 0 === n ? void 0 : n.dispatchEvent(r)) && qi._registry[e1].onPaste(t, i);
    }
    static onCopy(e1, t) {
        if (!t.clipboardData) return;
        const i = e1.model, n = i.selectionIsCollapsed ? [
            0,
            i.lastOffset
        ] : Si(i.selection);
        let r = i.getAtoms(n);
        if (r.every((e1)=>"text" === e1.mode || !e1.mode)) t.clipboardData.setData("text/plain", r.filter((e1)=>e1 instanceof Dt).map((e1)=>e1.value).join(""));
        else if (r.every((e1)=>"latex" === e1.mode)) t.clipboardData.setData("text/plain", i.getAtoms(n, {
            includeChildren: !0
        }).map((e1)=>{
            var t;
            return null !== (t = e1.value) && void 0 !== t ? t : "";
        }).join(""));
        else {
            let o;
            o = 1 === r.length && void 0 !== r[0].verbatimLatex ? r[0].verbatimLatex : i.getValue(n, "latex-expanded"), t.clipboardData.setData("application/x-latex", o);
            try {
                t.clipboardData.setData("text/plain", e1.options.onExport(e1, o, n));
            } catch  {}
            1 !== r.length || "root" !== r[0].type && "group" !== r[0].type || (r = r[0].body.filter((e1)=>"first" !== e1.type));
            try {
                t.clipboardData.setData("application/json+mathlive", JSON.stringify(r.map((e1)=>e1.toJson())));
            } catch  {}
            const a = e1.computeEngine;
            if (a) try {
                a.jsonSerializationOptions = {
                    metadata: [
                        "latex"
                    ]
                };
                const e2 = a.parse(o), i1 = JSON.stringify(e2.json);
                i1 && t.clipboardData.setData("application/json", i1);
            } catch  {}
        }
        t.preventDefault();
    }
    static insert(e1, t, i, n = {}) {
        return qi._registry[e1].insert(t, i, n);
    }
    onPaste(e1, t) {
        return !1;
    }
    insert(e1, t, i) {
        return !1;
    }
    constructor(e1){
        qi._registry[e1] = this;
    }
}
qi._registry = {};
const Ii = {
    "\\ne": "<mo>&ne;</mo>",
    "\\neq": "<mo>&neq;</mo>",
    "\\pm": "&#177;",
    "\\times": "&#215;",
    "\\colon": ":",
    "\\vert": "|",
    "\\Vert": "∥",
    "\\mid": "∣",
    "\\lbrace": "{",
    "\\rbrace": "}",
    "\\lparen": "(",
    "\\rparen": ")",
    "\\langle": "⟨",
    "\\rangle": "⟩",
    "\\lfloor": "⌊",
    "\\rfloor": "⌋",
    "\\lceil": "⌈",
    "\\rceil": "⌉",
    "\\vec": "&#x20d7;",
    "\\acute": "&#x00b4;",
    "\\grave": "&#x0060;",
    "\\dot": "&#x02d9;",
    "\\ddot": "&#x00a8;",
    "\\tilde": "&#x007e;",
    "\\bar": "&#x00af;",
    "\\breve": "&#x02d8;",
    "\\check": "&#x02c7;",
    "\\hat": "&#x005e;"
};
function Oi(e1) {
    return e1.replace(/"/g, "&quot;").replace(/'/g, "&#39;").replace(/</g, "&lt;").replace(/>/g, "&gt;");
}
function Fi(e1, t) {
    return e1 && t.generateID ? ` extid="${e1}"` : "";
}
function Bi(e1, t, i) {
    let n = !1;
    t = null != t ? t : e1.atoms.length;
    let r = "", o = "";
    const a = e1.atoms[e1.index];
    return e1.index < t && ("mord" === a.type || "macro" === a.type) && !a.isDigit() && (o = Zi(a, i), e1.index += 1), o.length > 0 && (n = !0, r = o, "mi" !== e1.lastType && "mn" !== e1.lastType && "mtext" !== e1.lastType && "fence" !== e1.lastType || /^<mo>(.*)<\/mo>$/.test(r) || (r = `<mo>&#8290;</mo>${r}`), o.endsWith(">f</mi>") || o.endsWith(">g</mi>") ? (r += "<mo>&#x2061;</mo>", e1.lastType = "applyfunction") : e1.lastType = /^<mo>(.*)<\/mo>$/.test(r) ? "mo" : "mi", Pi(o, e1, i) || (e1.mathML += r)), n;
}
function $i(e1) {
    return e1.index < e1.atoms.length && e1.atoms[e1.index].superscript && "msubsup" === e1.atoms[e1.index].type;
}
function Pi(e1, t, i) {
    let n = t.atoms[t.index - 1];
    if (!n) return !1;
    if (n.superscript || n.subscript || ($i(t) || function(e1) {
        return e1.index < e1.atoms.length && e1.atoms[e1.index].subscript && "msubsup" === e1.atoms[e1.index].type;
    }(t)) && (n = t.atoms[t.index], t.index += 1), !n) return !1;
    const r = Hi(n.superscript, 0, 0, i).mathML, o = Hi(n.subscript, 0, 0, i).mathML;
    if (!r && !o) return !1;
    let a = "";
    return r && o ? a = `<msubsup>${e1}${o}${r}</msubsup>` : r ? a = `<msup>${e1}${r}</msup>` : o && (a = `<msub>${e1}${o}</msub>`), t.mathML += a, t.lastType = "", !0;
}
function Ri(e1, t, i) {
    t = null != t ? t : e1.atoms.length;
    const n = e1.index;
    let r = "";
    for(; e1.index < t && "text" === e1.atoms[e1.index].mode;)r += e1.atoms[e1.index].value ? e1.atoms[e1.index].value : " ", e1.index += 1;
    return r.length > 0 && (e1.mathML += `<mtext ${Fi(e1.atoms[n].id, i)}\n      >${r}</mtext>`, e1.lastType = "mtext", !0);
}
function Ki(e1, t, i) {
    t = null != t ? t : e1.atoms.length;
    const n = e1.index;
    let r = "", o = function(e1) {
        let t = -1, i = e1.index, n = !1, r = !1;
        for(; i < e1.atoms.length && !n && !r;){
            const t1 = e1.atoms[i];
            n = !t1.isDigit(), r = !n && void 0 !== t1.superscript, i++;
        }
        return r && (t = i - 1), t;
    }(e1);
    for(o >= 0 && o < t && (t = o); e1.index < t && e1.atoms[e1.index].isDigit();)r += e1.atoms[e1.index].asDigit(), e1.index += 1;
    return !(r.length <= 0 || (r = "<mn" + Fi(e1.atoms[n].id, i) + ">" + r + "</mn>", o < 0 && $i(e1) && (o = e1.index, e1.index += 1), Pi(r, e1, i) || (e1.mathML += r, e1.lastType = "mn"), 0));
}
function Vi(e1, t, i) {
    let n = !1;
    t = null != t ? t : e1.atoms.length;
    let r = "", o = "";
    if (e1.index < t && "mopen" === e1.atoms[e1.index].type) {
        let a = !1, s = 0;
        const l = e1.index;
        let u = -1, c = l + 1;
        for(; c < t && !a;)"mopen" === e1.atoms[c].type ? s += 1 : "mclose" === e1.atoms[c].type && (s -= 1), -1 === s && (a = !0, u = c), c += 1;
        a && (r = "<mrow>", r += Ui(e1.atoms[l], i), r += Hi(e1.atoms, l + 1, u, i).mathML, r += Ui(e1.atoms[u], i), r += "</mrow>", "mi" !== e1.lastType && "mn" !== e1.lastType && "mfrac" !== e1.lastType && "fence" !== e1.lastType || (r = `<mo>&#8290;</mo>${r}`), e1.index = u + 1, Pi(r, e1, i) && (n = !0, e1.lastType = "", r = ""), o = "fence");
    }
    return r.length > 0 && (n = !0, e1.mathML += r, e1.lastType = o), n;
}
function ji(e1, t, i) {
    let n = !1;
    t = null != t ? t : e1.atoms.length;
    let r = "", o = "";
    const a = e1.atoms[e1.index];
    if (e1.index < t && ("mbin" === a.type || "mrel" === a.type)) r += Zi(e1.atoms[e1.index], i), e1.index += 1, o = "mo";
    else if (e1.index < t && "mop" === a.type) {
        if ("over-under" === a.subsupPlacement && (a.superscript || a.subscript)) {
            const e2 = Ui(a, i);
            a.superscript && a.subscript ? (r += "<munderover>" + e2, r += Hi(a.subscript, 0, 0, i).mathML, r += Hi(a.superscript, 0, 0, i).mathML, r += "</munderover>") : a.superscript ? (r += "<mover>" + e2, r += Hi(a.superscript, 0, 0, i).mathML, r += "</mover>") : (r += "<munder>" + e2, r += Hi(a.subscript, 0, 0, i).mathML, r += "</munder>"), o = "mo";
        } else {
            const t1 = e1.atoms[e1.index], n1 = "\\operatorname" === t1.value, a1 = n1 ? '<mi class="MathML-Unit"' + Fi(t1.id, i) + ">" + Gi(t1.value) + "</mi>" : Ui(t1, i);
            r += a1, n1 || /^<mo>(.*)<\/mo>$/.test(a1) ? o = n1 ? "mi" : "mo" : (r += "<mo>&#x2061;</mo>", o = "applyfunction");
        }
        "mi" !== e1.lastType && "mn" !== e1.lastType || /^<mo>(.*)<\/mo>$/.test(r) || (r = `<mo>&#8290;</mo>${r}`), e1.index += 1;
    }
    return Pi(r, e1, i) || r.length > 0 && (n = !0, e1.mathML += r, e1.lastType = o), n;
}
function Hi(e1, t, i, n) {
    const r = {
        atoms: [],
        index: null != t ? t : 0,
        mathML: "",
        lastType: ""
    };
    if ("number" == typeof e1 || "boolean" == typeof e1) r.mathML = e1.toString();
    else if ("string" == typeof e1) r.mathML = e1;
    else if (e1 instanceof ot) r.mathML = Zi(e1, n);
    else if (Array.isArray(e1)) {
        r.atoms = e1;
        let t1 = 0;
        for(i = i || (e1 ? e1.length : 0); r.index < i;)if (Ri(r, i, n) || Ki(r, i, n) || Bi(r, i, n) || ji(r, i, n) || Vi(r, i, n)) t1 += 1;
        else if (r.index < i) {
            let e2 = Zi(r.atoms[r.index], n);
            "mn" === r.lastType && e2.length > 0 && "genfrac" === r.atoms[r.index].type && (e2 = "<mo>&#x2064;</mo>" + e2), "genfrac" === r.atoms[r.index].type ? r.lastType = "mfrac" : r.lastType = "", r.index += 1, Pi(e2, r, n) ? t1 += 2 : e2.length > 0 && (r.mathML += e2, t1 += 1);
        }
        t1 > 1 && (r.mathML = "<mrow>" + r.mathML + "</mrow>");
    }
    return r;
}
function Ui(e1, t) {
    let i = "";
    const n = Gi(e1.value);
    return n && (i = "<mo" + Fi(e1.id, t) + ">" + n + "</mo>"), i;
}
function Gi(e1) {
    if (!e1) return "";
    if ("string" == typeof e1) return Oi(e1);
    if (!Array.isArray(e1) && "string" == typeof e1.body) return Oi(e1.body);
    let t = "";
    for (const i of e1)"string" == typeof i.value && (t += i.value);
    return Oi(t);
}
function Zi(e1, t) {
    var i, n, r, o, a, s, l, u, c, d, h, m, p, f, g, y;
    const b = {
        widehat: "^",
        widecheck: "ˇ",
        widetilde: "~",
        utilde: "~",
        overleftarrow: "←",
        underleftarrow: "←",
        xleftarrow: "←",
        overrightarrow: "→",
        underrightarrow: "→",
        xrightarrow: "→",
        underbrace: "⏟",
        overbrace: "⏞",
        overgroup: "⏠",
        undergroup: "⏡",
        overleftrightarrow: "↔",
        underleftrightarrow: "↔",
        xleftrightarrow: "↔",
        Overrightarrow: "⇒",
        xRightarrow: "⇒",
        overleftharpoon: "↼",
        xleftharpoonup: "↼",
        overrightharpoon: "⇀",
        xrightharpoonup: "⇀",
        xLeftarrow: "⇐",
        xLeftrightarrow: "⇔",
        xhookleftarrow: "↩",
        xhookrightarrow: "↪",
        xmapsto: "↦",
        xrightharpoondown: "⇁",
        xleftharpoondown: "↽",
        xrightleftharpoons: "⇌",
        xleftrightharpoons: "⇋",
        xtwoheadleftarrow: "↞",
        xtwoheadrightarrow: "↠",
        xlongequal: "=",
        xtofrom: "⇄",
        xrightleftarrows: "⇄",
        xrightequilibrium: "⇌",
        xleftequilibrium: "⇋"
    }, v = {
        "\\exponentialE": "&#x02147;",
        "\\imaginaryI": "&#x2148;",
        "\\differentialD": "&#x2146;",
        "\\capitalDifferentialD": "&#x2145;",
        "\\alpha": "&#x03b1;",
        "\\pi": "&#x03c0;",
        "\\infty": "&#x221e;",
        "\\forall": "&#x2200;",
        "\\nexists": "&#x2204;",
        "\\exists": "&#x2203;",
        "\\hbar": "ℏ",
        "\\cdotp": "⋅",
        "\\ldots": "…",
        "\\cdots": "⋯",
        "\\ddots": "⋱",
        "\\vdots": "⋮",
        "\\ldotp": "."
    }, x = {
        "\\!": -3 / 18,
        "\\ ": 6 / 18,
        "\\,": 3 / 18,
        "\\:": 4 / 18,
        "\\;": 5 / 18,
        "\\enspace": .5,
        "\\quad": 1,
        "\\qquad": 2,
        "\\enskip": .5
    };
    let k, _, w, S, M, N, L = "", A = "", C = null !== (n = ({
        cal: "script",
        frak: "fraktur",
        bb: "double-struck",
        scr: "script",
        cmtt: "monospace",
        cmss: "sans-serif"
    })[null !== (i = e1.fontFamily) && void 0 !== i ? i : e1.font]) && void 0 !== n ? n : "";
    C && (C = ` mathvariant="${C}"`);
    const { command: E  } = e1;
    if ("text" === e1.mode) L = `<mi${Fi(e1.id, t)}>${e1.value}</mi>`;
    else switch(e1.type){
        case "first":
        case "line":
        case "overlap":
        case "msubsup":
        case "phantom":
        case "composition":
        case "rule":
        case "chem":
        case "error":
            break;
        case "group":
        case "root":
            L = Ii[e1.command] ? Ii[e1.command] : Hi(e1.body, 0, 0, t).mathML;
            break;
        case "array":
            if ((e1.leftDelim && "." !== e1.leftDelim || e1.rightDelim && "." !== e1.rightDelim) && (L += "<mrow>", e1.leftDelim && "." !== e1.leftDelim && (L += "<mo>" + (Ii[e1.leftDelim] || e1.leftDelim) + "</mo>")), L += "<mtable", e1.colFormat) {
                for(L += ' columnalign="', w = 0; w < e1.colFormat.length; w++)e1.colFormat[w].align && (L += ({
                    l: "left",
                    c: "center",
                    r: "right"
                })[e1.colFormat[w].align] + " ");
                L += '"';
            }
            for(L += ">", _ = 0; _ < e1.array.length; _++){
                for(L += "<mtr>", k = 0; k < e1.array[_].length; k++)L += "<mtd>" + Hi(e1.array[_][k], 0, 0, t).mathML + "</mtd>";
                L += "</mtr>";
            }
            L += "</mtable>", (e1.leftDelim && "." !== e1.leftDelim || e1.rightDelim && "." !== e1.rightDelim) && (e1.rightDelim && "." !== e1.rightDelim && (L += "<mo>" + (Ii[e1.leftDelim] || e1.rightDelim) + "</mo>"), L += "</mrow>");
            break;
        case "genfrac":
            (e1.leftDelim || e1.rightDelim) && (L += "<mrow>"), e1.leftDelim && "." !== e1.leftDelim && (L += "<mo" + Fi(e1.id, t) + ">" + (Ii[e1.leftDelim] || e1.leftDelim) + "</mo>"), e1.hasBarLine ? (L += "<mfrac>", L += Hi(e1.above, 0, 0, t).mathML || "<mi>&nbsp;</mi>", L += Hi(e1.below, 0, 0, t).mathML || "<mi>&nbsp;</mi>", L += "</mfrac>") : (L += "<mtable" + Fi(e1.id, t) + ">", L += "<mtr>" + Hi(e1.above, 0, 0, t).mathML + "</mtr>", L += "<mtr>" + Hi(e1.below, 0, 0, t).mathML + "</mtr>", L += "</mtable>"), e1.rightDelim && "." !== e1.rightDelim && (L += "<mo" + Fi(e1.id, t) + ">" + (Ii[e1.rightDelim] || e1.rightDelim) + "</mo>"), (e1.leftDelim || e1.rightDelim) && (L += "</mrow>");
            break;
        case "surd":
            e1.hasEmptyBranch("above") ? (L += "<msqrt" + Fi(e1.id, t) + ">", L += Hi(e1.body, 0, 0, t).mathML, L += "</msqrt>") : (L += "<mroot" + Fi(e1.id, t) + ">", L += Hi(e1.body, 0, 0, t).mathML, L += Hi(e1.above, 0, 0, t).mathML, L += "</mroot>");
            break;
        case "leftright":
            L = "<mrow>", e1.leftDelim && "." !== e1.leftDelim && (L += "<mo" + Fi(e1.id, t) + ">" + (null !== (r = Ii[e1.leftDelim]) && void 0 !== r ? r : e1.leftDelim) + "</mo>"), e1.body && (L += Hi(e1.body, 0, 0, t).mathML), e1.rightDelim && "." !== e1.rightDelim && (L += "<mo" + Fi(e1.id, t) + ">" + (null !== (o = Ii[e1.rightDelim]) && void 0 !== o ? o : e1.rightDelim) + "</mo>"), L += "</mrow>";
            break;
        case "sizeddelim":
        case "delim":
            L += '<mo separator="true"' + Fi(e1.id, t) + ">" + (Ii[e1.delim] || e1.delim) + "</mo>";
            break;
        case "accent":
            L += '<mover accent="true"' + Fi(e1.id, t) + ">", L += Hi(e1.body, 0, 0, t).mathML, L += "<mo>" + (Ii[E] || e1.accent) + "</mo>", L += "</mover>";
            break;
        case "overunder":
            M = e1.above, S = e1.below, (e1.svgAbove || M) && (e1.svgBelow || S) ? N = e1.body : M && M.length > 0 ? (N = e1.body, (null === (s = null === (a = e1.body) || void 0 === a ? void 0 : a[0]) || void 0 === s ? void 0 : s.below) ? (S = e1.body[0].below, N = e1.body[0].body) : "first" === (null === (u = null === (l = e1.body) || void 0 === l ? void 0 : l[0]) || void 0 === u ? void 0 : u.type) && (null === (d = null === (c = e1.body) || void 0 === c ? void 0 : c[1]) || void 0 === d ? void 0 : d.below) && (S = e1.body[1].below, N = e1.body[1].body)) : S && S.length > 0 && (N = e1.body, (null === (m = null === (h = e1.body) || void 0 === h ? void 0 : h[0]) || void 0 === m ? void 0 : m.above) ? (M = e1.body[0].above, N = e1.body[0].body) : "first" === (null === (f = null === (p = e1.body) || void 0 === p ? void 0 : p[0]) || void 0 === f ? void 0 : f.type) && (null === (y = null === (g = e1.body) || void 0 === g ? void 0 : g[1]) || void 0 === y ? void 0 : y.above) && (M = e1.body[1].overscript, N = e1.body[1].body)), (e1.svgAbove || M) && (e1.svgBelow || S) ? (L += `<munderover ${C} ${Fi(e1.id, t)}>`, L += b[e1.svgBody] || Hi(N, 0, 0, t).mathML, L += b[e1.svgBelow] || Hi(S, 0, 0, t).mathML, L += b[e1.svgAbove] || Hi(M, 0, 0, t).mathML, L += "</munderover>") : e1.svgAbove || M ? (L += `<mover ${C} ${Fi(e1.id, t)}>` + (b[e1.svgBody] || Hi(N, 0, 0, t).mathML), L += b[e1.svgAbove] || Hi(M, 0, 0, t).mathML, L += "</mover>") : (e1.svgBelow || S) && (L += `<munder ${C} ${Fi(e1.id, t)}>` + (b[e1.svgBody] || Hi(N, 0, 0, t).mathML), L += b[e1.svgBelow] || Hi(S, 0, 0, t).mathML, L += "</munder>");
            break;
        case "placeholder":
        case "mord":
            {
                L = v[E] || E || ("string" == typeof e1.value ? e1.value : "");
                const i1 = E ? E.match(/{?\\char"([\dabcdefABCDEF]*)}?/) : null;
                i1 ? L = "&#x" + i1[1] + ";" : L.length > 0 && L.startsWith("\\") && (L = "string" == typeof e1.value && e1.value.charCodeAt(0) > 255 ? "&#x" + ("000000" + e1.value.charCodeAt(0).toString(16)).slice(-4) + ";" : "string" == typeof e1.value ? e1.value.charAt(0) : "");
                const n1 = /\d/.test(L) ? "mn" : "mi";
                L = `<${n1}${C}${Fi(e1.id, t)}>${Oi(L)}</${n1}>`;
                break;
            }
        case "mbin":
        case "mrel":
        case "minner":
            L = E && v[E] ? "<mi" + Fi(e1.id, t) + ">" + v[E] + "</mi>" : E && Ii[E] ? "<mo" + Fi(e1.id, t) + ">" + Ii[E] + "</mo>" : Ui(e1, t);
            break;
        case "mpunct":
            L = '<mo separator="true"' + Fi(e1.id, t) + ">" + (Ii[E] || E) + "</mo>";
            break;
        case "mop":
            "​" !== e1.body && (L = "<mo" + Fi(e1.id, t) + ">", L += "\\operatorname" === E ? e1.body : E || e1.body, L += "</mo>");
            break;
        case "box":
            L = '<menclose notation="box"', e1.backgroundcolor && (L += ' mathbackground="' + e1.backgroundcolor + '"'), L += Fi(e1.id, t) + ">" + Hi(e1.body, 0, 0, t).mathML + "</menclose>";
            break;
        case "spacing":
            L += '<mspace width="' + (x[E] || 0) + 'em"/>';
            break;
        case "enclose":
            L = '<menclose notation="';
            for(const t1 in e1.notation)Object.prototype.hasOwnProperty.call(e1.notation, t1) && e1.notation[t1] && (L += A + t1, A = " ");
            L += Fi(e1.id, t) + '">' + Hi(e1.body, 0, 0, t).mathML + "</menclose>";
            break;
        case "space":
            L += "&nbsp;";
            break;
        case "mopen":
        case "mclose":
            L += Ui(e1, t);
            break;
        case "macro":
            {
                const i2 = e1.command + Gi(e1.macroArgs);
                i2 && (L += `<mo ${Fi(e1.id, t)}>${i2}</mo>`);
            }
            break;
        case "latex":
            L += "<mtext" + Fi(e1.id, t) + ">" + e1.value + "</mtext>";
    }
    return L;
}
function Wi(e1, t) {
    return Hi(e1, 0, 0, t).mathML;
}
const Ji = {
    "\\alpha": "alpha ",
    "\\mu": "mew ",
    "\\sigma": "sigma ",
    "\\pi": "pie ",
    "\\imaginaryI": "eye ",
    "\\sum": "Summation ",
    "\\prod": "Product ",
    a: '<phoneme alphabet="ipa" ph="eɪ">a</phoneme>',
    A: 'capital <phoneme alphabet="ipa" ph="eɪ">A</phoneme>',
    "+": "plus ",
    "-": "minus ",
    ";": '<break time="150ms"/> semi-colon <break time="150ms"/>',
    ",": '<break time="150ms"/> comma  <break time="150ms"/>',
    "|": '<break time="150ms"/>Vertical bar<break time="150ms"/>',
    "(": '<break time="150ms"/>Open paren. <break time="150ms"/>',
    ")": '<break time="150ms"/> Close paren. <break time="150ms"/>',
    "=": "equals ",
    "<": "is less than ",
    "\\lt": "is less than ",
    "<=": "is less than or equal to ",
    "\\le": "is less than or equal to ",
    "\\gt": "is greater than ",
    ">": "is greater than ",
    "\\ge": "is greater than or equal to ",
    "\\geq": "is greater than or equal to ",
    "\\leq": "is less than or equal to ",
    "!": "factorial ",
    "\\sin": "sine ",
    "\\cos": "cosine ",
    "​": "",
    "−": "minus ",
    ":": '<break time="150ms"/> such that <break time="200ms"/> ',
    "\\colon": '<break time="150ms"/> such that <break time="200ms"/> ',
    "\\hbar": "etch bar ",
    "\\iff": '<break time="200ms"/>if, and only if, <break time="200ms"/>',
    "\\Longleftrightarrow": '<break time="200ms"/>if, and only if, <break time="200ms"/>',
    "\\land": "and ",
    "\\lor": "or ",
    "\\neg": "not ",
    "\\div": "divided by ",
    "\\forall": "for all ",
    "\\exists": "there exists ",
    "\\nexists": "there does not exists ",
    "\\in": "element of ",
    "\\N": 'the set <break time="150ms"/><say-as interpret-as="character">n</say-as>',
    "\\C": 'the set <break time="150ms"/><say-as interpret-as="character">c</say-as>',
    "\\Z": 'the set <break time="150ms"/><say-as interpret-as="character">z</say-as>',
    "\\Q": 'the set <break time="150ms"/><say-as interpret-as="character">q</say-as>',
    "\\infty": "infinity ",
    "\\nabla": "nabla ",
    "\\partial": "partial derivative of ",
    "\\cdot": "times ",
    "\\cdots": "dot dot dot ",
    "\\Rightarrow": "implies ",
    "\\lparen": '<break time="150ms"/>open paren<break time="150ms"/>',
    "\\rparen": '<break time="150ms"/>close paren<break time="150ms"/>',
    "\\lbrace": '<break time="150ms"/>open brace<break time="150ms"/>',
    "\\{": '<break time="150ms"/>open brace<break time="150ms"/>',
    "\\rbrace": '<break time="150ms"/>close brace<break time="150ms"/>',
    "\\}": '<break time="150ms"/>close brace<break time="150ms"/>',
    "\\langle": '<break time="150ms"/>left angle bracket<break time="150ms"/>',
    "\\rangle": '<break time="150ms"/>right angle bracket<break time="150ms"/>',
    "\\lfloor": '<break time="150ms"/>open floor<break time="150ms"/>',
    "\\rfloor": '<break time="150ms"/>close floor<break time="150ms"/>',
    "\\lceil": '<break time="150ms"/>open ceiling<break time="150ms"/>',
    "\\rceil": '<break time="150ms"/>close ceiling<break time="150ms"/>',
    "\\vert": '<break time="150ms"/>vertical bar<break time="150ms"/>',
    "\\mvert": '<break time="150ms"/>divides<break time="150ms"/>',
    "\\lvert": '<break time="150ms"/>left vertical bar<break time="150ms"/>',
    "\\rvert": '<break time="150ms"/>right vertical bar<break time="150ms"/>',
    "\\lbrack": '<break time="150ms"/> open square bracket <break time="150ms"/>',
    "\\rbrack": '<break time="150ms"/> close square bracket <break time="150ms"/>',
    mm: "millimeters",
    cm: "centimeters",
    km: "kilometers",
    kg: "kilograms"
};
function Xi(t) {
    let i = 0;
    if (e1(t)) for (const e2 of t)"first" !== e2.type && (i += 1);
    return 1 === i;
}
function Yi(t) {
    let i = "";
    if (e1(t)) for (const e2 of t)"first" !== e2.type && "string" == typeof e2.value && (i += e2.value);
    return i;
}
function Qi(t, i, n) {
    var r, o, a, s;
    function l(e1) {
        return "<emphasis>" + e1 + "</emphasis>";
    }
    if (!i) return "";
    let u = "";
    if (e1(i)) {
        let e2 = !1, o1 = !1;
        for(let a1 = 0; a1 < i.length; a1++)"text" !== i[a1].mode && (o1 = !1), a1 < i.length - 2 && "mopen" === i[a1].type && "mclose" === i[a1 + 2].type && "mord" === i[a1 + 1].type ? (u += " of ", u += l(Qi(t, i[a1 + 1], n)), a1 += 2) : "text" === i[a1].mode ? o1 ? u += null !== (r = i[a1].value) && void 0 !== r ? r : " " : (o1 = !0, u += Qi("text", i[a1], n)) : i[a1].isDigit() ? e2 ? u += i[a1].asDigit() : (e2 = !0, u += Qi(t, i[a1], n)) : (e2 = !1, u += Qi(t, i[a1], n));
    } else if ("text" === i.mode) i.id && "math" === t && (u += '<mark name="' + i.id.toString() + '"/>'), u += i.value;
    else {
        i.id && "math" === t && (u += '<mark name="' + i.id.toString() + '"/>');
        let r1 = "", d = "", h = "", m = !1;
        switch(i.type){
            case "group":
            case "root":
                u += Qi("math", i.body, n);
                break;
            case "genfrac":
                if (r1 = Qi("math", i.above, n), d = Qi("math", i.below, n), Xi(i.above) && Xi(i.below)) {
                    const e3 = {
                        "1/2": " half ",
                        "1/3": " one third ",
                        "2/3": " two third",
                        "1/4": " one quarter ",
                        "3/4": " three quarter ",
                        "1/5": " one fifth ",
                        "2/5": " two fifths ",
                        "3/5": " three fifths ",
                        "4/5": " four fifths ",
                        "1/6": " one sixth ",
                        "5/6": " five sixths ",
                        "1/8": " one eight ",
                        "3/8": " three eights ",
                        "5/8": " five eights ",
                        "7/8": " seven eights ",
                        "1/9": " one ninth ",
                        "2/9": " two ninths ",
                        "4/9": " four ninths ",
                        "5/9": " five ninths ",
                        "7/9": " seven ninths ",
                        "8/9": " eight ninths "
                    }[Yi(i.above) + "/" + Yi(i.below)];
                    e3 ? u = e3 : u += r1 + " over " + d;
                } else u += ' the fraction <break time="150ms"/>' + r1 + ', over <break time="150ms"/>' + d + '.<break time="150ms"/> End fraction.<break time="150ms"/>';
                break;
            case "surd":
                if (h = Qi("math", i.body, n), i.hasEmptyBranch("above")) u += Xi(i.body) ? " the square root of " + h + " , " : ' the square root of <break time="200ms"/>' + h + '. <break time="200ms"/> End square root';
                else {
                    let e4 = Qi("math", i.above, n);
                    e4 = e4.trim();
                    const t1 = e4.replace(/<mark([^/]*)\/>/g, "");
                    u += "3" === t1 ? ' the cube root of <break time="200ms"/>' + h + '. <break time="200ms"/> End cube root' : "n" === t1 ? ' the nth root of <break time="200ms"/>' + h + '. <break time="200ms"/> End root' : ' the root with index: <break time="200ms"/>' + e4 + ', of <break time="200ms"/>' + h + '. <break time="200ms"/> End root';
                }
                break;
            case "leftright":
                {
                    const e5 = i;
                    u += null !== (o = e5.leftDelim ? Ji[e5.leftDelim] : void 0) && void 0 !== o ? o : e5.leftDelim, u += Qi("math", i.body, n), u += null !== (a = e5.rightDelim ? Ji[e5.rightDelim] : void 0) && void 0 !== a ? a : e5.rightDelim;
                }
                break;
            case "rule":
            case "overunder":
            case "overlap":
                break;
            case "placeholder":
                u += "placeholder ";
                break;
            case "delim":
            case "sizeddelim":
            case "mord":
            case "minner":
            case "mbin":
            case "mrel":
            case "mpunct":
            case "mopen":
            case "mclose":
                {
                    const { command: e6  } = i;
                    if ("\\mathbin" === e6 || "\\mathrel" === e6 || "\\mathopen" === e6 || "\\mathclose" === e6 || "\\mathpunct" === e6 || "\\mathord" === e6 || "\\mathinner" === e6) {
                        u = Qi(t, i.body, n);
                        break;
                    }
                    let r2 = i.isDigit() ? i.asDigit() : i.value, o2 = i.command;
                    if ("delim" !== i.type && "sizeddelim" !== i.type || (o2 = i.value, r2 = o2), "text" === t) u += r2;
                    else {
                        if ("mbin" === i.type && (u += '<break time="150ms"/>'), r2) {
                            const e7 = Ji[r2] || (o2 ? Ji[o2.trim()] : "");
                            if (e7) u += " " + e7;
                            else {
                                const e8 = o2 ? function(e1) {
                                    let t = "";
                                    return e1.startsWith("\\") && (t = " " + e1.replace("\\", "") + " "), t;
                                }(o2.trim()) : "";
                                u += e8 || function(e1) {
                                    return n.textToSpeechMarkup ? /[a-z]/.test(e1) ? ` <say-as interpret-as="character">${e1}</say-as>` : /[A-Z]/.test(e1) ? `capital <say-as interpret-as="character">${e1.toLowerCase()}</say-as>` : e1 : /[a-z]/.test(e1) ? " '" + e1.toUpperCase() + "'" : /[A-Z]/.test(e1) ? " 'capital " + e1.toUpperCase() + "'" : e1;
                                }(r2);
                            }
                        } else u += Qi("math", i.body, n);
                        "mbin" === i.type && (u += '<break time="150ms"/>');
                    }
                    break;
                }
            case "mop":
                if ("​" !== i.value) {
                    const e9 = i.command;
                    if ("\\sum" === e9) {
                        if (i.hasEmptyBranch("superscript") || i.hasEmptyBranch("subscript")) {
                            if (i.hasEmptyBranch("subscript")) u += " the summation of";
                            else {
                                let e10 = Qi("math", i.subscript, n);
                                e10 = e10.trim(), u += ' the summation from <break time="200ms"/>' + e10 + '<break time="200ms"/> of <break time="150ms"/>', m = !0;
                            }
                        } else {
                            let e11 = Qi("math", i.superscript, n);
                            e11 = e11.trim();
                            let t2 = Qi("math", i.subscript, n);
                            t2 = t2.trim(), u += ' the summation from <break time="200ms"/>' + t2 + '<break time="200ms"/> to  <break time="200ms"/>' + e11 + '<break time="200ms"/> of <break time="150ms"/>', m = !0;
                        }
                    } else if ("\\prod" === e9) {
                        if (i.hasEmptyBranch("superscript") || i.hasEmptyBranch("subscript")) {
                            if (i.hasEmptyBranch("subscript")) u += " the product  of ";
                            else {
                                let e12 = Qi("math", i.subscript, n);
                                e12 = e12.trim(), u += ' the product from <break time="200ms"/>' + e12 + '<break time="200ms"/> of <break time="150ms"/>', m = !0;
                            }
                        } else {
                            let e13 = Qi("math", i.superscript, n);
                            e13 = e13.trim();
                            let t3 = Qi("math", i.subscript, n);
                            t3 = t3.trim(), u += ' the product from <break time="200ms"/>' + t3 + '<break time="200ms"/> to <break time="200ms"/>' + e13 + '<break time="200ms"/> of <break time="150ms"/>', m = !0;
                        }
                    } else if ("\\int" === e9) {
                        if (i.hasEmptyBranch("superscript") || i.hasEmptyBranch("subscript")) u += ' the integral of <break time="200ms"/> ';
                        else {
                            let e14 = Qi("math", i.superscript, n);
                            e14 = e14.trim();
                            let t4 = Qi("math", i.subscript, n);
                            t4 = t4.trim(), u += ' the integral from <break time="200ms"/>' + l(t4) + '<break time="200ms"/> to <break time="200ms"/>' + l(e14) + ' <break time="200ms"/> of ', m = !0;
                        }
                    } else "string" == typeof i.value ? u += (null !== (s = Ji[i.value]) && void 0 !== s ? s : i.command ? Ji[i.command] : void 0) || " " + i.value : i.command && ("\\mathop" === i.command ? u += Qi("math", i.body, n) : "\\operatorname" === i.command ? u += (c = i.body) ? c.map((e1)=>e1.value).join("") : "" : u += i.command.startsWith("\\") ? " " + i.command.slice(1) : " " + i.command);
                }
                break;
            case "enclose":
                h = Qi("math", i.body, n), u += " crossed out " + h + ". End crossed out.";
        }
        if (!m && !i.hasEmptyBranch("superscript")) {
            let r3 = Qi(t, i.superscript, n);
            r3 = r3.trim();
            const o3 = r3.replace(/<[^>]*>/g, "");
            if (Xi(i.superscript)) {
                if ("math" === t) {
                    const t5 = function(t) {
                        if (e1(t)) {
                            for (const e2 of t)if ("first" !== e2.type && e2.id) return e2.id.toString();
                        }
                        return "";
                    }(i.superscript);
                    t5 && (u += '<mark name="' + t5 + '"/>');
                }
                "′" === o3 ? u += " prime " : "2" === o3 ? u += " squared " : "3" === o3 ? u += " cubed " : Number.isNaN(Number.parseInt(o3)) ? u += " to the " + r3 + "; " : u += ' to the <say-as interpret-as="ordinal">' + o3 + "</say-as> power; ";
            } else Number.isNaN(Number.parseInt(o3)) ? u += " raised to the " + r3 + "; " : u += ' raised to the <say-as interpret-as="ordinal">' + o3 + "</say-as> power; ";
        }
        if (!m && !i.hasEmptyBranch("subscript")) {
            let e15 = Qi("math", i.subscript, n);
            e15 = e15.trim(), u += Xi(i.subscript) ? " sub " + e15 : " subscript " + e15 + ". End subscript. ";
        }
    }
    var c;
    return u;
}
function en(e1, t) {
    var i;
    const n = {
        ...t,
        textToSpeechRulesOptions: {
            ...t.textToSpeechRulesOptions
        }
    };
    if ("sre" === n.textToSpeechRules && "sre" in globalThis) {
        const t1 = Wi(e1, n);
        return t1 ? (n.textToSpeechMarkup && (n.textToSpeechRulesOptions = null !== (i = n.textToSpeechRulesOptions) && void 0 !== i ? i : {}, n.textToSpeechRulesOptions.markup = n.textToSpeechMarkup, "ssml" === n.textToSpeechRulesOptions.markup && (n.textToSpeechRulesOptions.markup = "ssml_step"), n.textToSpeechRulesOptions.rate = n.speechEngineRate), n.textToSpeechRulesOptions && globalThis.sre.System.getInstance().setupEngine(n.textToSpeechRulesOptions), globalThis.sre.System.getInstance().toSpeech(t1)) : "";
    }
    let r = Qi("math", e1, n);
    if ("ssml" === n.textToSpeechMarkup) {
        let e2 = "";
        n.speechEngineRate && (e2 = '<prosody rate="' + n.speechEngineRate + '">'), r = '<?xml version="1.0"?><speak version="1.1" xmlns="http://www.w3.org/2001/10/synthesis" xml:lang="en-US"><amazon:auto-breaths>' + e2 + "<p><s>" + r + "</s></p>" + (e2 ? "</prosody>" : "") + "</amazon:auto-breaths></speak>";
    } else r = "mac" === n.textToSpeechMarkup && "macos" === o() ? r.replace(/<mark([^/]*)\/>/g, "").replace(/<emphasis>/g, "[[emph+]]").replace(/<\/emphasis>/g, "").replace(/<break time="(\d*)ms"\/>/g, "[[slc $1]]").replace(/<say-as[^>]*>/g, "").replace(/<\/say-as>/g, "") : r.replace(/<[^>]*>/g, "").replace(/\s{2,}/g, " ");
    return r;
}
function tn(e1, t, i, n) {
    const r = t.split(" ");
    for (const t1 of r){
        const r1 = t1.match(/(.*):(.*)/);
        if (r1) {
            const t2 = null != n ? n : {};
            "active" === r1[2] ? t2.passive = !1 : t2[r1[2]] = !0, e1.addEventListener(r1[1], i, t2);
        } else e1.addEventListener(t1, i, n);
    }
}
function nn(e1, t, i, n) {
    const r = t.split(" ");
    for (const t1 of r){
        const r1 = t1.match(/(.*):(.*)/);
        if (r1) {
            const t2 = null != n ? n : {};
            "active" === r1[2] ? t2.passive = !1 : t2[r1[2]] = !0, e1.removeEventListener(r1[1], i, t2);
        } else e1.removeEventListener(t1, i, n);
    }
}
function rn(e1) {
    var t;
    i();
    let n = document.getElementById(e1);
    return n ? n.dataset.refcount = Number(Number.parseInt(null !== (t = n.getAttribute("data-refcount")) && void 0 !== t ? t : "0") + 1).toString() : (n = document.createElement("div"), n.setAttribute("aria-hidden", "true"), n.dataset.refcount = "1", n.id = e1, document.body.append(n)), n;
}
function on(e1) {
    var t;
    if (!e1) return;
    const i = Number.parseInt(null !== (t = e1.getAttribute("data-refcount")) && void 0 !== t ? t : "0");
    i <= 1 ? e1.remove() : e1.dataset.refcount = Number(i - 1).toString();
}
function an(e1) {
    var t;
    return (null === (t = e1.element) || void 0 === t ? void 0 : t.mathfield) === e1;
}
function sn(e1) {
    const t = function(e1) {
        var t, i;
        return null !== (i = null !== (t = e1.querySelector(".ML__caret")) && void 0 !== t ? t : e1.querySelector(".ML__text-caret")) && void 0 !== i ? i : e1.querySelector(".ML__latex-caret");
    }(e1);
    if (!t) return null;
    const i = t.getBoundingClientRect();
    return {
        x: i.right,
        y: i.bottom,
        height: i.height
    };
}
function ln(e1) {
    var t;
    if (!e1.parent) return "root";
    let i = null !== (t = e1.parent.id) && void 0 !== t ? t : "";
    return i += "string" == typeof e1.treeBranch ? "-" + e1.treeBranch : `-${e1.treeBranch[0]}/${e1.treeBranch[0]}`, i;
}
function un(e1, t) {
    if (!t) return null;
    const i = e1.field.getBoundingClientRect(), n = t.right - t.left, r = t.bottom - t.top, o = Math.ceil(t.left - i.left + e1.field.scrollLeft), a = Math.ceil(t.top - i.top);
    return {
        left: o,
        right: o + n,
        top: a,
        bottom: a + r
    };
}
function cn(e1) {
    const t = e1.getBoundingClientRect(), i = parseInt(getComputedStyle(e1).marginRight), n = {
        top: t.top - 1,
        bottom: t.bottom,
        left: t.left,
        right: t.right - 1 + i
    };
    if (0 === e1.children.length || "SVG" === e1.tagName.toUpperCase()) return n;
    for (const t1 of e1.children)if (1 === t1.nodeType && "atomId" in t1.dataset && !t1.classList.contains("pstrut")) {
        const e2 = cn(t1);
        n.left = Math.min(n.left, e2.left), n.right = Math.max(n.right, e2.right), n.top = Math.min(n.top, e2.top), n.bottom = Math.max(n.bottom, e2.bottom);
    }
    return n;
}
function dn(e1, t) {
    var i, n;
    if (!t.id) return null;
    let r = null !== (n = null === (i = e1.atomBoundsCache) || void 0 === i ? void 0 : i.get(t.id)) && void 0 !== n ? n : null;
    if (null !== r) return r;
    const o = e1.field.querySelector(`[data-atom-id="${t.id}"]`);
    return r = o ? cn(o) : null, e1.atomBoundsCache && (r ? e1.atomBoundsCache.set(t.id, r) : e1.atomBoundsCache.delete(t.id)), null != r ? r : null;
}
function hn(e1, t) {
    return e1.model.selection.ranges.reduce((i, n)=>i.concat(...function(e1, t, i) {
            const n = new Map;
            for (const r of e1.model.getAtoms(t, {
                includeChildren: !0
            })){
                if ((null == i ? void 0 : i.excludeAtomsWithBackground) && r.style.backgroundColor) break;
                const t1 = un(e1, dn(e1, r));
                if (t1) {
                    const e2 = ln(r);
                    if (n.has(e2)) {
                        const i1 = n.get(e2);
                        n.set(e2, {
                            left: Math.min(i1.left, t1.left),
                            right: Math.max(i1.right, t1.right),
                            top: Math.min(i1.top, t1.top),
                            bottom: Math.max(i1.bottom, t1.bottom)
                        });
                    } else n.set(e2, t1);
                }
            }
            return [
                ...n.values()
            ];
        }(e1, n, t)), []);
}
function mn(e1, t) {
    return "*" === e1 || "none" === t || ("same-origin" === t ? !globalThis.origin || e1 === globalThis.origin : "function" == typeof t && t(e1));
}
function pn(e1) {
    let t = 0, i = 0;
    const n = e1.offsetWidth, r = e1.offsetHeight;
    for(; e1 instanceof HTMLElement;)t += e1.offsetTop, i += e1.offsetLeft, e1 = e1.offsetParent;
    return new DOMRect(i, t, n, r);
}
const fn = {
    main: [
        "Main-Regular",
        "ML__cmr"
    ],
    "main-italic": [
        "Main-Italic",
        "ML__cmr ML__it"
    ],
    "main-bold": [
        "Main-Bold",
        "ML__cmr ML__bold"
    ],
    "main-bolditalic": [
        "Main-BoldItalic",
        "ML__cmr ML__bold ML__it"
    ],
    normal: [
        "Main-Regular",
        "ML__cmr"
    ],
    "normal-bold": [
        "Main-Bold",
        "ML__mathbf"
    ],
    "normal-italic": [
        "Math-Italic",
        "ML__mathit"
    ],
    "normal-bolditalic": [
        "Math-BoldItalic",
        "ML__mathbfit"
    ],
    ams: [
        "AMS-Regular",
        "ML__ams"
    ],
    "ams-bold": [
        "AMS-Regular",
        "ML__ams"
    ],
    "ams-italic": [
        "AMS-Regular",
        "ML__ams"
    ],
    "ams-bolditalic": [
        "AMS-Regular",
        "ML__ams"
    ],
    "sans-serif": [
        "SansSerif-Regular",
        "ML__sans"
    ],
    "sans-serif-bold": [
        "SansSerif-Regular",
        "ML__sans ML__bold"
    ],
    "sans-serif-italic": [
        "SansSerif-Regular",
        "ML__sans"
    ],
    "sans-serif-bolditalic": [
        "SansSerif-Regular",
        "ML__sans"
    ],
    calligraphic: [
        "Caligraphic-Regular",
        "ML__cal"
    ],
    "calligraphic-bold": [
        "Caligraphic-Regular",
        "ML__cal ML__bold"
    ],
    "calligraphic-italic": [
        "Caligraphic-Regular",
        "ML__cal ML__it"
    ],
    "calligraphic-bolditalic": [
        "Caligraphic-Regular",
        "ML__cal ML__bold ML__it"
    ],
    script: [
        "Script-Regular",
        "ML__script"
    ],
    "script-bold": [
        "Script-Regular",
        "ML__script ML__bold"
    ],
    "script-italic": [
        "Script-Regular",
        "ML__script ML__it"
    ],
    "script-bolditalic": [
        "Script-Regular",
        "ML__script ML__bold ML__it"
    ],
    fraktur: [
        "Fraktur-Regular",
        "ML__frak"
    ],
    "fraktur-bold": [
        "Fraktur-Regular",
        "ML__frak"
    ],
    "fraktur-italic": [
        "Fraktur-Regular",
        "ML__frak"
    ],
    "fraktur-bolditalic": [
        "Fraktur-Regular",
        "ML__frak"
    ],
    monospace: [
        "Typewriter-Regular",
        "ML__tt"
    ],
    "monospace-bold": [
        "Typewriter-Regular",
        "ML__tt ML__bold"
    ],
    "monospace-italic": [
        "Typewriter-Regular",
        "ML__tt ML__it"
    ],
    "monospace-bolditalic": [
        "Typewriter-Regular",
        "ML__tt ML__bold ML__it"
    ],
    "double-struck": [
        "AMS-Regular",
        "ML__bb"
    ],
    "double-struck-bold": [
        "AMS-Regular",
        "ML__bb"
    ],
    "double-struck-italic": [
        "AMS-Regular",
        "ML__bb"
    ],
    "double-struck-bolditalic": [
        "AMS-Regular",
        "ML__bb"
    ]
}, gn = {
    "double-struck": /^[A-Z ]$/,
    script: /^[A-Z ]$/,
    calligraphic: /^[\dA-Z ]$/,
    fraktur: /^[\dA-Za-z ]$|^[!"#$%&'()*+,\-./:;=?[]^\u2019\u2018]$/,
    monospace: /^[\dA-Za-z ]$|^[!"&'()*+,\-./:;=?@[\]^_~\u0131\u0237\u0393\u0394\u0398\u039B\u039E\u03A0\u03A3\u03A5\u03A8\u03A9]$/,
    "sans-serif": /^[\dA-Za-z ]$|^[!"&'()*+,\-./:;=?@[\]^_~\u0131\u0237\u0393\u0394\u0398\u039B\u039E\u03A0\u03A3\u03A5\u03A8\u03A9]$/
}, yn = /^[\u03B1-\u03C9]|\u03D1|\u03D5|\u03D6|\u03F1|\u03F5]$/, bn = [
    /^[a-z]$/,
    /^[A-Z]$/,
    yn,
    /^[\u0393|\u0394\u0398\u039B\u039E\u03A0\u03A3\u03A5\u03A6\u03A8\u03A9]$/
], vn = {
    iso: [
        "it",
        "it",
        "it",
        "it"
    ],
    tex: [
        "it",
        "it",
        "it",
        "up"
    ],
    french: [
        "it",
        "up",
        "up",
        "up"
    ],
    upright: [
        "up",
        "up",
        "up",
        "up"
    ]
};
function xn(e1) {
    if (!e1) return "";
    const { style: t  } = e1;
    if (void 0 === t.variant) return "";
    let i = t.variant;
    return t.variantStyle && "up" !== t.variantStyle && (i += "-" + t.variantStyle), i;
}
function kn(e1) {
    return [
        Qe(e1.map((e1)=>e1[0])),
        e1.map((e1)=>e1[1]).some((e1)=>!0 === e1)
    ];
}
new class extends Ce {
    createAtom(e1, t, i) {
        var n, r, o, a, s;
        const l = t.getDefinition(e1, "math");
        if (null === l) return new ot("mord", t, {
            mode: "math",
            command: e1,
            value: e1,
            style: i
        });
        if ("symbol" === l.definitionType) {
            const a1 = new ot(null !== (n = l.type) && void 0 !== n ? n : "mord", t, {
                mode: "math",
                command: null !== (r = l.command) && void 0 !== r ? r : e1,
                value: String.fromCodePoint(l.codepoint),
                style: i
            });
            return null !== (o = l.isFunction) && void 0 !== o && o && (a1.isFunction = !0), e1.startsWith("\\") && (a1.verbatimLatex = e1), a1;
        }
        const u = new ot("mord", t, {
            mode: "math",
            command: null !== (a = l.command) && void 0 !== a ? a : e1,
            value: e1,
            style: i
        });
        return null !== (s = l.isFunction) && void 0 !== s && s && (u.isFunction = !0), e1.startsWith("\\") && (u.verbatimLatex = e1), u;
    }
    serialize(e1, t) {
        const { parent: i  } = e1[0], n = null == i ? void 0 : i.computedStyle.fontSize;
        return Qe(Ee(e1, "fontSize").map((e1)=>{
            const r = function(e1, t) {
                const { parent: i  } = e1[0], n = null == i ? void 0 : i.computedStyle.backgroundColor;
                return Qe(Ee(e1, "backgroundColor").map((e1)=>{
                    var r, o;
                    let a = function(e1, t) {
                        const { parent: i  } = e1[0], n = null == i ? void 0 : i.computedStyle.color;
                        return Qe(Ee(e1, "color").map((e1)=>{
                            var r, o;
                            const a = function(e1, t) {
                                var i;
                                const { parent: n  } = e1[0], r = xn(n), o = null !== (i = null == n ? void 0 : n.mode) && void 0 !== i ? i : "math";
                                return Qe(Ee(e1, "variant").map((e1)=>{
                                    const i = xn(e1[0]);
                                    if (e1.every((e1)=>{
                                        const t = e1.context.getDefinition(e1.command, o);
                                        return !(!t || "function" === t.definitionType || !t.variant) && xn(e1) === i;
                                    })) return Qe(e1.map((e1)=>ot.serialize(e1, t)));
                                    let n = "";
                                    return i && i !== r && (n = ({
                                        calligraphic: "\\mathcal{",
                                        fraktur: "\\mathfrak{",
                                        "double-struck": "\\mathbb{",
                                        script: "\\mathscr{",
                                        monospace: "\\mathtt{",
                                        "sans-serif": "\\mathsf{",
                                        normal: "\\mathrm{",
                                        "normal-italic": "\\mathnormal{",
                                        "normal-bold": "\\mathbf{",
                                        "normal-bolditalic": "\\mathbfit{",
                                        ams: "",
                                        "ams-italic": "\\mathit{",
                                        "ams-bold": "\\mathbf{",
                                        "ams-bolditalic": "\\mathbfit{",
                                        main: "",
                                        "main-italic": "\\mathit{",
                                        "main-bold": "\\mathbf{",
                                        "main-bolditalic": "\\mathbfit{"
                                    })[i]), n ? n + Qe(e1.map((e1)=>ot.serialize(e1, t))) + "}" : Qe(e1.map((e1)=>ot.serialize(e1, t)));
                                }));
                            }(e1, t), s = e1[0].computedStyle;
                            return null !== (r = t.skipStyles) && void 0 !== r && r || !s.color || i && n === s.color ? a : "\\textcolor{" + (null !== (o = s.verbatimColor) && void 0 !== o ? o : s.color) + "}{" + a + "}";
                        }));
                    }(e1, t);
                    const s = e1[0].computedStyle;
                    return null !== (r = t.skipStyles) && void 0 !== r && r || !a.trim() || !s.backgroundColor || i && n === s.backgroundColor || !(e1.length > 0) && e1[0] instanceof $t || (a = `\\ensuremath{${a}}`, a = `\\colorbox{${null !== (o = s.verbatimBackgroundColor) && void 0 !== o ? o : s.backgroundColor}}{${a}}`), a;
                }));
            }(e1, t), o = e1[0].computedStyle.fontSize;
            return !o || i && n === o ? r : "\\" + [
                "",
                "tiny",
                "scriptsize",
                "footnotesize",
                "small",
                "normalsize",
                "large",
                "Large",
                "LARGE",
                "huge",
                "Huge"
            ][o] + " " + r;
        }));
    }
    applyStyle(e1, t) {
        if (void 0 === t.variant) return "";
        const i = "auto" !== t.letterShapeStyle && t.letterShapeStyle ? t.letterShapeStyle : "tex";
        let { variant: n  } = t, { variantStyle: r  } = t;
        "normal" === n && !r && /[\u00A3\u0131\u0237]/.test(e1.value) && (n = "main", r = "italic"), "normal" !== n || r || 1 !== e1.value.length || bn.forEach((t, n)=>{
            t.test(e1.value) && "it" === vn[i][n] && (r = "italic");
        }), "up" === r && (r = void 0);
        const o = r ? n + "-" + r : n, [a, s] = fn[o];
        return gn[n] && !gn[n].test(e1.value) ? (e1.value = function(e1, t, i) {
            if (!/[A-Za-z\d]/.test(e1)) return e1;
            if (!t && !i) return e1;
            const n = e1.codePointAt(0);
            if (void 0 === n) return e1;
            for (const e2 of q)if ((!t || e2.variant === t) && (!i || e2.style === i) && n >= e2.offset && n < e2.offset + e2.len) {
                const t1 = e2.start + n - e2.offset;
                return String.fromCodePoint(z[t1] || t1);
            }
            return e1;
        }(e1.value, n, r), null) : (yn.test(e1.value) && (e1.classes += " lcGreek"), s && (e1.classes += " " + s), a);
    }
    constructor(){
        super("math");
    }
};
const _n = {
    roman: "",
    "sans-serif": "ML__sans",
    monospace: "ML__tt"
};
function wn(e1) {
    let t = 0;
    for(let i = 0; i < e1.length; i++)t = Math.imul(31, t) + e1.charCodeAt(i) | 0;
    return Math.abs(t);
}
function Sn(e1, t, n) {
    var r, o;
    if (i(), !t) return null;
    let a = null !== (r = null == e1 ? void 0 : e1.getRootNode()) && void 0 !== r ? r : null === document || void 0 === document ? void 0 : document.head;
    if (!a) return null;
    a === document && (a = document.head);
    const s = a.querySelector(`style[data-id="${n}"]`);
    if (s) {
        const e2 = Number.parseFloat(null !== (o = s.getAttribute("data-refcount")) && void 0 !== o ? o : "0");
        s.dataset.refcount = Number(e2 + 1).toString();
    } else {
        const e3 = document.createElement("style");
        e3.dataset.id = n, e3.dataset.refcount = "1", e3.append(document.createTextNode(t)), a.appendChild(e3);
    }
    return {
        release: ()=>{
            var e1;
            const t = document.head.querySelector(`style[data-id="${n}"]`);
            if (t) {
                const i = Number.parseFloat(null !== (e1 = t.getAttribute("data-refcount")) && void 0 !== e1 ? e1 : "0");
                1 === i ? t.remove() : t.dataset.refcount = Number(i - 1).toString();
            }
        }
    };
}
function Mn(e1) {
    const t = e1.split("+"), i = {
        shift: !1,
        alt: !1,
        cmd: !1,
        win: !1,
        meta: !1,
        ctrl: !1,
        key: t.pop()
    };
    return t.includes("shift") && (i.shift = !0), t.includes("alt") && (i.alt = !0), t.includes("ctrl") && (i.ctrl = !0), t.includes("cmd") && (i.cmd = !0), t.includes("win") && (i.win = !0), t.includes("meta") && (i.meta = !0), i;
}
function Nn(e1) {
    let t = "";
    return e1.shift && (t += "shift+"), e1.alt && (t += "alt+"), e1.ctrl && (t += "ctrl+"), e1.cmd && (t += "cmd+"), e1.win && (t += "win+"), e1.meta && (t += "meta+"), t + e1.key;
}
new class extends Ce {
    createAtom(e1, t, i) {
        const n = t.getDefinition(e1, "text");
        return n && "symbol" === n.definitionType ? new Dt(e1, String.fromCodePoint(n.codepoint), null != i ? i : {}, t) : null;
    }
    serialize(e1, t) {
        var i;
        let [n, r] = function(e1, t) {
            return kn(Ee(e1, "backgroundColor").map((e1)=>{
                var i, n;
                const [r, o] = function(e1, t) {
                    var i;
                    if (!e1 || 0 === e1.length) return [
                        "",
                        !1
                    ];
                    const n = null === (i = e1[0].parent) || void 0 === i ? void 0 : i.style.color;
                    return kn(Ee(e1, "color").map((e1)=>{
                        var i, r;
                        const [o, a] = function(e1, t) {
                            return function(e1, t) {
                                return kn(Ee(e1, "fontFamily").map((e1)=>{
                                    var i, n;
                                    const [r, o] = function(e1, t) {
                                        return kn(Ee(e1, "fontSize").map((e1)=>{
                                            var i, n;
                                            const [r, o] = function(e1, t) {
                                                return kn(Ee(e1, "fontSeries").map((e1)=>{
                                                    const [i, n] = function(e1, t) {
                                                        return kn(Ee(e1, "fontShape").map((e1)=>{
                                                            const [i, n] = function(e1, t) {
                                                                return [
                                                                    Qe(e1.map((e1)=>ot.serialize(e1, t))),
                                                                    !0
                                                                ];
                                                            }(e1, t), { fontShape: r  } = e1[0].style;
                                                            return "it" === r ? [
                                                                "\\textit{" + i + "}",
                                                                !1
                                                            ] : "sl" === r ? [
                                                                "\\textsl{" + i + "}",
                                                                !1
                                                            ] : "sc" === r ? [
                                                                "\\textsc{" + i + "}",
                                                                !1
                                                            ] : "n" === r ? [
                                                                "\\textup{" + i + "}",
                                                                !1
                                                            ] : r ? [
                                                                `{\\fontshape{${e1[0].style.fontShape}}${i}`,
                                                                !1
                                                            ] : [
                                                                i,
                                                                n
                                                            ];
                                                        }));
                                                    }(e1, t), { fontSeries: r  } = e1[0].style;
                                                    return "b" === r ? [
                                                        `\\textbf{${i}}`,
                                                        !1
                                                    ] : "l" === r ? [
                                                        `\\textlf{${i}}`,
                                                        !1
                                                    ] : "m" === r ? [
                                                        `\\textmd{${i}}`,
                                                        !1
                                                    ] : r ? [
                                                        `\\fontseries{${r}}${i}`,
                                                        !1
                                                    ] : [
                                                        i,
                                                        n
                                                    ];
                                                }));
                                            }(e1, t), a = null !== (n = [
                                                "",
                                                "tiny",
                                                "scriptsize",
                                                "footnotesize",
                                                "small",
                                                "normalsize",
                                                "large",
                                                "Large",
                                                "LARGE",
                                                "huge",
                                                "Huge"
                                            ][null !== (i = e1[0].style.fontSize) && void 0 !== i ? i : ""]) && void 0 !== n ? n : "";
                                            return a ? [
                                                `{\\${a} ${r}}`,
                                                o
                                            ] : [
                                                r,
                                                o
                                            ];
                                        }));
                                    }(e1, t), a = null !== (n = ({
                                        roman: "textrm",
                                        monospace: "texttt",
                                        "sans-serif": "textsf"
                                    })[null !== (i = e1[0].style.fontFamily) && void 0 !== i ? i : ""]) && void 0 !== n ? n : "";
                                    return a ? [
                                        `\\${a}{${r}}`,
                                        !1
                                    ] : e1[0].style.fontFamily ? [
                                        `\\fontfamily{${e1[0].style.fontFamily}}${r}`,
                                        o
                                    ] : [
                                        r,
                                        o
                                    ];
                                }));
                            }(e1, t);
                        }(e1, t);
                        return null !== (i = t.skipStyles) && void 0 !== i && i || !e1[0].style.color || "none" === e1[0].style.color || n === e1[0].style.color ? [
                            o,
                            a
                        ] : [
                            `\\textcolor{${null !== (r = e1[0].style.verbatimColor) && void 0 !== r ? r : e1[0].style.color}}{${o}}`,
                            !1
                        ];
                    }));
                }(e1, t), a = e1[0].computedStyle;
                return null !== (i = t.skipStyles) && void 0 !== i && i || !a.backgroundColor || "none" === a.backgroundColor ? [
                    r,
                    o
                ] : [
                    `\\colorbox{${null !== (n = a.verbatimBackgroundColor) && void 0 !== n ? n : a.backgroundColor}}{${r}}`,
                    !1
                ];
            }));
        }(e1, t);
        return !0 === (null !== (i = t.skipModeCommand) && void 0 !== i && i) && (r = !1), r && (n = `\\text{${n}}`), n;
    }
    applyStyle(e1, t) {
        var i, n, r, o, a, s;
        const { fontFamily: l  } = t;
        if (_n[l] ? e1.classes += (i = " " + _n[l], void 0 !== i) ? i : "" : l && e1.setStyle("font-family", l), t.fontShape && (e1.classes += " ", e1.classes += null !== (n = ({
            it: "ML__it",
            sl: "ML__shape_sl",
            sc: "ML__shape_sc",
            ol: "ML__shape_ol"
        })[t.fontShape]) && void 0 !== n ? n : ""), t.fontSeries) {
            const i1 = t.fontSeries.match(/(.?[lbm])?(.?[cx])?/);
            i1 && (e1.classes += " ", e1.classes += null !== (o = ({
                ul: "ML__series_ul",
                el: "ML__series_el",
                l: "ML__series_l",
                sl: "ML__series_sl",
                m: "",
                sb: "ML__series_sb",
                b: "ML__bold",
                eb: "ML__series_eb",
                ub: "ML__series_ub"
            })[null !== (r = i1[1]) && void 0 !== r ? r : ""]) && void 0 !== o ? o : "", e1.classes += " ", e1.classes += null !== (s = ({
                uc: "ML__series_uc",
                ec: "ML__series_ec",
                c: "ML__series_c",
                sc: "ML__series_sc",
                n: "",
                sx: "ML__series_sx",
                x: "ML__series_x",
                ex: "ML__series_ex",
                ux: "ML__series_ux"
            })[null !== (a = i1[2]) && void 0 !== a ? a : ""]) && void 0 !== s ? s : "");
        }
        return "Main-Regular";
    }
    constructor(){
        super("text");
    }
}, new class extends Ce {
    createAtom(e1, t, i) {
        return new Yt(e1, t);
    }
    serialize(e1, t) {
        return e1.filter((e1)=>e1 instanceof Yt && !e1.isSuggestion).map((e1)=>e1.value).join("");
    }
    applyStyle() {
        return null;
    }
    constructor(){
        super("latex");
    }
};
const Ln = "apple" === En() ? {
    id: "apple.en-intl",
    displayName: "English (international)",
    virtualLayout: "qwerty",
    platform: "apple",
    locale: "en",
    score: 0,
    mapping: {
        KeyA: [
            "a",
            "A",
            "\xe5",
            "\xc5"
        ],
        KeyB: [
            "b",
            "B",
            "∫",
            "ı"
        ],
        KeyC: [
            "c",
            "C",
            "\xe7",
            "\xc7"
        ],
        KeyD: [
            "d",
            "D",
            "∂",
            "\xce"
        ],
        KeyE: [
            "e",
            "E",
            "\xb4",
            "\xb4"
        ],
        KeyF: [
            "f",
            "F",
            "ƒ",
            "\xcf"
        ],
        KeyG: [
            "g",
            "G",
            "\xa9",
            "˝"
        ],
        KeyH: [
            "h",
            "H",
            "˙",
            "\xd3"
        ],
        KeyI: [
            "i",
            "I",
            "ˆ",
            "ˆ"
        ],
        KeyJ: [
            "j",
            "J",
            "∆",
            "\xd4"
        ],
        KeyK: [
            "k",
            "K",
            "˚",
            ""
        ],
        KeyL: [
            "l",
            "L",
            "\xac",
            "\xd2"
        ],
        KeyM: [
            "m",
            "M",
            "\xb5",
            "\xc2"
        ],
        KeyN: [
            "n",
            "N",
            "˜",
            "˜"
        ],
        KeyO: [
            "o",
            "O",
            "\xf8",
            "\xd8"
        ],
        KeyP: [
            "p",
            "P",
            "π",
            "∏"
        ],
        KeyQ: [
            "q",
            "Q",
            "œ",
            "Œ"
        ],
        KeyR: [
            "r",
            "R",
            "\xae",
            "‰"
        ],
        KeyS: [
            "s",
            "S",
            "\xdf",
            "\xcd"
        ],
        KeyT: [
            "t",
            "T",
            "†",
            "ˇ"
        ],
        KeyU: [
            "u",
            "U",
            "\xa8",
            "\xa8"
        ],
        KeyV: [
            "v",
            "V",
            "√",
            "◊"
        ],
        KeyW: [
            "w",
            "W",
            "∑",
            "„"
        ],
        KeyX: [
            "x",
            "X",
            "≈",
            "˛"
        ],
        KeyY: [
            "y",
            "Y",
            "\xa5",
            "\xc1"
        ],
        KeyZ: [
            "z",
            "Z",
            "Ω",
            "\xb8"
        ],
        Digit1: [
            "1",
            "!",
            "\xa1",
            "⁄"
        ],
        Digit2: [
            "2",
            "@",
            "™",
            "€"
        ],
        Digit3: [
            "3",
            "#",
            "\xa3",
            "‹"
        ],
        Digit4: [
            "4",
            "$",
            "\xa2",
            "›"
        ],
        Digit5: [
            "5",
            "%",
            "∞",
            "ﬁ"
        ],
        Digit6: [
            "6",
            "^",
            "\xa7",
            "ﬂ"
        ],
        Digit7: [
            "7",
            "&",
            "\xb6",
            "‡"
        ],
        Digit8: [
            "8",
            "*",
            "•",
            "\xb0"
        ],
        Digit9: [
            "9",
            "(",
            "\xaa",
            "\xb7"
        ],
        Digit0: [
            "0",
            ")",
            "\xba",
            "‚"
        ],
        Space: [
            " ",
            " ",
            " ",
            " "
        ],
        Minus: [
            "-",
            "_",
            "–",
            "—"
        ],
        Equal: [
            "=",
            "+",
            "≠",
            "\xb1"
        ],
        BracketLeft: [
            "[",
            "{",
            "“",
            "”"
        ],
        BracketRight: [
            "]",
            "}",
            "‘",
            "’"
        ],
        Backslash: [
            "\\",
            "|",
            "\xab",
            "\xbb"
        ],
        Semicolon: [
            ";",
            ":",
            "…",
            "\xda"
        ],
        Quote: [
            "'",
            '"',
            "\xe6",
            "\xc6"
        ],
        Backquote: [
            "`",
            "˜",
            "`",
            "`"
        ],
        Comma: [
            ",",
            "<",
            "≤",
            "\xaf"
        ],
        Period: [
            ".",
            ">",
            "≥",
            "˘"
        ],
        Slash: [
            "/",
            "?",
            "\xf7",
            "\xbf"
        ],
        NumpadDivide: [
            "/",
            "/",
            "/",
            "/"
        ],
        NumpadMultiply: [
            "*",
            "*",
            "*",
            "*"
        ],
        NumpadSubtract: [
            "-",
            "-",
            "-",
            "-"
        ],
        NumpadAdd: [
            "+",
            "+",
            "+",
            "+"
        ],
        Numpad1: [
            "1",
            "1",
            "1",
            "1"
        ],
        Numpad2: [
            "2",
            "2",
            "2",
            "2"
        ],
        Numpad3: [
            "3",
            "3",
            "3",
            "3"
        ],
        Numpad4: [
            "4",
            "4",
            "4",
            "4"
        ],
        Numpad5: [
            "5",
            "5",
            "5",
            "5"
        ],
        Numpad6: [
            "6",
            "6",
            "6",
            "6"
        ],
        Numpad7: [
            "7",
            "7",
            "7",
            "7"
        ],
        Numpad8: [
            "8",
            "8",
            "8",
            "8"
        ],
        Numpad9: [
            "9",
            "9",
            "9",
            "9"
        ],
        Numpad0: [
            "0",
            "0",
            "0",
            "0"
        ],
        NumpadDecimal: [
            ".",
            ".",
            ".",
            "."
        ],
        IntlBackslash: [
            "\xa7",
            "\xb1",
            "\xa7",
            "\xb1"
        ],
        NumpadEqual: [
            "=",
            "=",
            "=",
            "="
        ],
        AudioVolumeUp: [
            "",
            "=",
            "",
            "="
        ]
    }
} : "windows" === En() ? {
    id: "windows.en-intl",
    displayName: "English (international)",
    platform: "windows",
    virtualLayout: "qwerty",
    locale: "en",
    score: 0,
    mapping: {
        KeyA: [
            "a",
            "A",
            "\xe1",
            "\xc1"
        ],
        KeyB: [
            "b",
            "B",
            "",
            ""
        ],
        KeyC: [
            "c",
            "C",
            "\xa9",
            "\xa2"
        ],
        KeyD: [
            "d",
            "D",
            "\xf0",
            "\xd0"
        ],
        KeyE: [
            "e",
            "E",
            "\xe9",
            "\xc9"
        ],
        KeyF: [
            "f",
            "F",
            "",
            ""
        ],
        KeyG: [
            "g",
            "G",
            "",
            ""
        ],
        KeyH: [
            "h",
            "H",
            "",
            ""
        ],
        KeyI: [
            "i",
            "I",
            "\xed",
            "\xcd"
        ],
        KeyJ: [
            "j",
            "J",
            "",
            ""
        ],
        KeyK: [
            "k",
            "K",
            "",
            ""
        ],
        KeyL: [
            "l",
            "L",
            "\xf8",
            "\xd8"
        ],
        KeyM: [
            "m",
            "M",
            "\xb5",
            ""
        ],
        KeyN: [
            "n",
            "N",
            "\xf1",
            "\xd1"
        ],
        KeyO: [
            "o",
            "O",
            "\xf3",
            "\xd3"
        ],
        KeyP: [
            "p",
            "P",
            "\xf6",
            "\xd6"
        ],
        KeyQ: [
            "q",
            "Q",
            "\xe4",
            "\xc4"
        ],
        KeyR: [
            "r",
            "R",
            "\xae",
            ""
        ],
        KeyS: [
            "s",
            "S",
            "\xdf",
            "\xa7"
        ],
        KeyT: [
            "t",
            "T",
            "\xfe",
            "\xde"
        ],
        KeyU: [
            "u",
            "U",
            "\xfa",
            "\xda"
        ],
        KeyV: [
            "v",
            "V",
            "",
            ""
        ],
        KeyW: [
            "w",
            "W",
            "\xe5",
            "\xc5"
        ],
        KeyX: [
            "x",
            "X",
            "",
            ""
        ],
        KeyY: [
            "y",
            "Y",
            "\xfc",
            "\xdc"
        ],
        KeyZ: [
            "z",
            "Z",
            "\xe6",
            "\xc6"
        ],
        Digit1: [
            "1",
            "!",
            "\xa1",
            "\xb9"
        ],
        Digit2: [
            "2",
            "@",
            "\xb2",
            ""
        ],
        Digit3: [
            "3",
            "#",
            "\xb3",
            ""
        ],
        Digit4: [
            "4",
            "$",
            "\xa4",
            "\xa3"
        ],
        Digit5: [
            "5",
            "%",
            "€",
            ""
        ],
        Digit6: [
            "6",
            "^",
            "\xbc",
            ""
        ],
        Digit7: [
            "7",
            "&",
            "\xbd",
            ""
        ],
        Digit8: [
            "8",
            "*",
            "\xbe",
            ""
        ],
        Digit9: [
            "9",
            "(",
            "‘",
            ""
        ],
        Digit0: [
            "0",
            ")",
            "’",
            ""
        ],
        Space: [
            " ",
            " ",
            "",
            ""
        ],
        Minus: [
            "-",
            "_",
            "\xa5",
            ""
        ],
        Equal: [
            "=",
            "+",
            "\xd7",
            "\xf7"
        ],
        BracketLeft: [
            "[",
            "{",
            "\xab",
            ""
        ],
        BracketRight: [
            "]",
            "}",
            "\xbb",
            ""
        ],
        Backslash: [
            "\\",
            "|",
            "\xac",
            "\xa6"
        ],
        Semicolon: [
            ";",
            ":",
            "\xb6",
            "\xb0"
        ],
        Quote: [
            "'",
            '"',
            "\xb4",
            "\xa8"
        ],
        Backquote: [
            "`",
            "~",
            "",
            ""
        ],
        Comma: [
            ",",
            "<",
            "\xe7",
            "\xc7"
        ],
        Period: [
            ".",
            ">",
            "",
            ""
        ],
        Slash: [
            "/",
            "?",
            "\xbf",
            ""
        ],
        NumpadDivide: [
            "/",
            "/",
            "",
            ""
        ],
        NumpadMultiply: [
            "*",
            "*",
            "",
            ""
        ],
        NumpadSubtract: [
            "-",
            "-",
            "",
            ""
        ],
        NumpadAdd: [
            "+",
            "+",
            "",
            ""
        ],
        IntlBackslash: [
            "\\",
            "|",
            "",
            ""
        ]
    }
} : {
    id: "linux.en",
    displayName: "English",
    platform: "linux",
    virtualLayout: "qwerty",
    locale: "en",
    score: 0,
    mapping: {
        KeyA: [
            "a",
            "A",
            "a",
            "A"
        ],
        KeyB: [
            "b",
            "B",
            "b",
            "B"
        ],
        KeyC: [
            "c",
            "C",
            "c",
            "C"
        ],
        KeyD: [
            "d",
            "D",
            "d",
            "D"
        ],
        KeyE: [
            "e",
            "E",
            "e",
            "E"
        ],
        KeyF: [
            "f",
            "F",
            "f",
            "F"
        ],
        KeyG: [
            "g",
            "G",
            "g",
            "G"
        ],
        KeyH: [
            "h",
            "H",
            "h",
            "H"
        ],
        KeyI: [
            "i",
            "I",
            "i",
            "I"
        ],
        KeyJ: [
            "j",
            "J",
            "j",
            "J"
        ],
        KeyK: [
            "k",
            "K",
            "k",
            "K"
        ],
        KeyL: [
            "l",
            "L",
            "l",
            "L"
        ],
        KeyM: [
            "m",
            "M",
            "m",
            "M"
        ],
        KeyN: [
            "n",
            "N",
            "n",
            "N"
        ],
        KeyO: [
            "o",
            "O",
            "o",
            "O"
        ],
        KeyP: [
            "p",
            "P",
            "p",
            "P"
        ],
        KeyQ: [
            "q",
            "Q",
            "q",
            "Q"
        ],
        KeyR: [
            "r",
            "R",
            "r",
            "R"
        ],
        KeyS: [
            "s",
            "S",
            "s",
            "S"
        ],
        KeyT: [
            "t",
            "T",
            "t",
            "T"
        ],
        KeyU: [
            "u",
            "U",
            "u",
            "U"
        ],
        KeyV: [
            "v",
            "V",
            "v",
            "V"
        ],
        KeyW: [
            "w",
            "W",
            "w",
            "W"
        ],
        KeyX: [
            "x",
            "X",
            "x",
            "X"
        ],
        KeyY: [
            "y",
            "Y",
            "y",
            "Y"
        ],
        KeyZ: [
            "z",
            "Z",
            "z",
            "Z"
        ],
        Digit1: [
            "1",
            "!",
            "1",
            "!"
        ],
        Digit2: [
            "2",
            "@",
            "2",
            "@"
        ],
        Digit3: [
            "3",
            "#",
            "3",
            "#"
        ],
        Digit4: [
            "4",
            "$",
            "4",
            "$"
        ],
        Digit5: [
            "5",
            "%",
            "5",
            "%"
        ],
        Digit6: [
            "6",
            "^",
            "6",
            "^"
        ],
        Digit7: [
            "7",
            "&",
            "7",
            "&"
        ],
        Digit8: [
            "8",
            "*",
            "8",
            "*"
        ],
        Digit9: [
            "9",
            "(",
            "9",
            "("
        ],
        Digit0: [
            "0",
            ")",
            "0",
            ")"
        ],
        Space: [
            " ",
            " ",
            " ",
            " "
        ],
        Minus: [
            "-",
            "_",
            "-",
            "_"
        ],
        Equal: [
            "=",
            "+",
            "=",
            "+"
        ],
        BracketLeft: [
            "[",
            "{",
            "[",
            "{"
        ],
        BracketRight: [
            "]",
            "}",
            "]",
            "}"
        ],
        Backslash: [
            "\\",
            "|",
            "\\",
            "|"
        ],
        Semicolon: [
            ";",
            ":",
            ";",
            ":"
        ],
        Quote: [
            "'",
            '"',
            "'",
            '"'
        ],
        Backquote: [
            "`",
            "~",
            "`",
            "~"
        ],
        Comma: [
            ",",
            "<",
            ",",
            "<"
        ],
        Period: [
            ".",
            ">",
            ".",
            ">"
        ],
        Slash: [
            "/",
            "?",
            "/",
            "?"
        ],
        NumpadDivide: [
            "/",
            "/",
            "/",
            "/"
        ],
        NumpadMultiply: [
            "*",
            "*",
            "*",
            "*"
        ],
        NumpadSubtract: [
            "-",
            "-",
            "-",
            "-"
        ],
        NumpadAdd: [
            "+",
            "+",
            "+",
            "+"
        ],
        Numpad1: [
            "1",
            "1",
            "1",
            "1"
        ],
        Numpad2: [
            "2",
            "2",
            "2",
            "2"
        ],
        Numpad3: [
            "3",
            "3",
            "3",
            "3"
        ],
        Numpad4: [
            "4",
            "4",
            "4",
            "4"
        ],
        Numpad5: [
            "5",
            "5",
            "5",
            "5"
        ],
        Numpad6: [
            "6",
            "6",
            "6",
            "6"
        ],
        Numpad7: [
            "7",
            "7",
            "7",
            "7"
        ],
        Numpad8: [
            "8",
            "8",
            "8",
            "8"
        ],
        Numpad9: [
            "9",
            "9",
            "9",
            "9"
        ],
        Numpad0: [
            "0",
            "0",
            "0",
            "0"
        ],
        NumpadDecimal: [
            "",
            ".",
            "",
            "."
        ],
        IntlBackslash: [
            "<",
            ">",
            "|",
            "\xa6"
        ],
        NumpadEqual: [
            "=",
            "=",
            "=",
            "="
        ],
        NumpadComma: [
            ".",
            ".",
            ".",
            "."
        ],
        NumpadParenLeft: [
            "(",
            "(",
            "(",
            "("
        ],
        NumpadParenRight: [
            ")",
            ")",
            ")",
            ")"
        ]
    }
}, An = {
    enter: "[Enter]",
    escape: "[Escape]",
    backspace: "[Backspace]",
    tab: "[Tab]",
    space: "[Space]",
    pausebreak: "[Pause]",
    insert: "[Insert]",
    home: "[Home]",
    pageup: "[PageUp]",
    delete: "[Delete]",
    end: "[End]",
    pagedown: "[PageDown]",
    right: "[ArrowRight]",
    left: "[ArrowLeft]",
    down: "[ArrowDown]",
    up: "[ArrowUp]",
    numpad0: "[Numpad0]",
    numpad1: "[Numpad1]",
    numpad2: "[Numpad2]",
    numpad3: "[Numpad3]",
    numpad4: "[Numpad4]",
    numpad5: "[Numpad5]",
    numpad6: "[Numpad6]",
    numpad7: "[Numpad7]",
    numpad8: "[Numpad8]",
    numpad9: "[Numpad9]",
    numpad_divide: "[NumpadDivide]",
    numpad_multiply: "[NumpadMultiply]",
    numpad_subtract: "[NumpadSubtract]",
    numpad_add: "[NumpadAdd]",
    numpad_decimal: "[NumpadDecimal]",
    numpad_separator: "[NumpadComma]",
    capslock: "[Capslock]",
    f1: "[F1]",
    f2: "[F2]",
    f3: "[F3]",
    f4: "[F4]",
    f5: "[F5]",
    f6: "[F6]",
    f7: "[F7]",
    f8: "[F8]",
    f9: "[F9]",
    f10: "[F10]",
    f11: "[F11]",
    f12: "[F12]",
    f13: "[F13]",
    f14: "[F14]",
    f15: "[F15]",
    f16: "[F16]",
    f17: "[F17]",
    f18: "[F18]",
    f19: "[F19]"
}, Cn = [];
function En() {
    switch(o()){
        case "macos":
        case "ios":
            return "apple";
        case "windows":
            return "windows";
    }
    return "linux";
}
function Tn(e1) {
    e1.platform && e1.platform !== En() || Cn.push(e1);
}
function Dn() {
    return Cn[0];
}
Tn(Ln), Tn({
    id: "apple.french",
    locale: "fr",
    displayName: "French",
    platform: "apple",
    virtualLayout: "azerty",
    score: 0,
    mapping: {
        KeyA: [
            "q",
            "Q",
            "‡",
            "Ω"
        ],
        KeyB: [
            "b",
            "B",
            "\xdf",
            "∫"
        ],
        KeyC: [
            "c",
            "C",
            "\xa9",
            "\xa2"
        ],
        KeyD: [
            "d",
            "D",
            "∂",
            "∆"
        ],
        KeyE: [
            "e",
            "E",
            "\xea",
            "\xca"
        ],
        KeyF: [
            "f",
            "F",
            "ƒ",
            "\xb7"
        ],
        KeyG: [
            "g",
            "G",
            "ﬁ",
            "ﬂ"
        ],
        KeyH: [
            "h",
            "H",
            "\xcc",
            "\xce"
        ],
        KeyI: [
            "i",
            "I",
            "\xee",
            "\xef"
        ],
        KeyJ: [
            "j",
            "J",
            "\xcf",
            "\xcd"
        ],
        KeyK: [
            "k",
            "K",
            "\xc8",
            "\xcb"
        ],
        KeyL: [
            "l",
            "L",
            "\xac",
            "|"
        ],
        KeyM: [
            ",",
            "?",
            "∞",
            "\xbf"
        ],
        KeyN: [
            "n",
            "N",
            "~",
            "ı"
        ],
        KeyO: [
            "o",
            "O",
            "œ",
            "Œ"
        ],
        KeyP: [
            "p",
            "P",
            "π",
            "∏"
        ],
        KeyQ: [
            "a",
            "A",
            "\xe6",
            "\xc6"
        ],
        KeyR: [
            "r",
            "R",
            "\xae",
            "‚"
        ],
        KeyS: [
            "s",
            "S",
            "\xd2",
            "∑"
        ],
        KeyT: [
            "t",
            "T",
            "†",
            "™"
        ],
        KeyU: [
            "u",
            "U",
            "\xba",
            "\xaa"
        ],
        KeyV: [
            "v",
            "V",
            "◊",
            "√"
        ],
        KeyW: [
            "z",
            "Z",
            "\xc2",
            "\xc5"
        ],
        KeyX: [
            "x",
            "X",
            "≈",
            "⁄"
        ],
        KeyY: [
            "y",
            "Y",
            "\xda",
            "Ÿ"
        ],
        KeyZ: [
            "w",
            "W",
            "‹",
            "›"
        ],
        Digit1: [
            "&",
            "1",
            "",
            "\xb4"
        ],
        Digit2: [
            "\xe9",
            "2",
            "\xeb",
            "„"
        ],
        Digit3: [
            '"',
            "3",
            "“",
            "”"
        ],
        Digit4: [
            "'",
            "4",
            "‘",
            "’"
        ],
        Digit5: [
            "(",
            "5",
            "{",
            "["
        ],
        Digit6: [
            "\xa7",
            "6",
            "\xb6",
            "\xe5"
        ],
        Digit7: [
            "\xe8",
            "7",
            "\xab",
            "\xbb"
        ],
        Digit8: [
            "!",
            "8",
            "\xa1",
            "\xdb"
        ],
        Digit9: [
            "\xe7",
            "9",
            "\xc7",
            "\xc1"
        ],
        Digit0: [
            "\xe0",
            "0",
            "\xf8",
            "\xd8"
        ],
        Space: [
            " ",
            " ",
            " ",
            " "
        ],
        Minus: [
            ")",
            "\xb0",
            "}",
            "]"
        ],
        Equal: [
            "-",
            "_",
            "—",
            "–"
        ],
        BracketLeft: [
            "^",
            "\xa8",
            "\xf4",
            "\xd4"
        ],
        BracketRight: [
            "$",
            "*",
            "€",
            "\xa5"
        ],
        Backslash: [
            "`",
            "\xa3",
            "@",
            "#"
        ],
        Semicolon: [
            "m",
            "M",
            "\xb5",
            "\xd3"
        ],
        Quote: [
            "\xf9",
            "%",
            "\xd9",
            "‰"
        ],
        Backquote: [
            "<",
            ">",
            "≤",
            "≥"
        ],
        Comma: [
            ";",
            ".",
            "…",
            "•"
        ],
        Period: [
            ":",
            "/",
            "\xf7",
            "\\"
        ],
        Slash: [
            "=",
            "+",
            "≠",
            "\xb1"
        ],
        NumpadDivide: [
            "/",
            "/",
            "/",
            "/"
        ],
        NumpadMultiply: [
            "*",
            "*",
            "*",
            "*"
        ],
        NumpadSubtract: [
            "-",
            "-",
            "-",
            "-"
        ],
        NumpadAdd: [
            "+",
            "+",
            "+",
            "+"
        ],
        NumpadDecimal: [
            ",",
            ".",
            ",",
            "."
        ],
        IntlBackslash: [
            "@",
            "#",
            "•",
            "Ÿ"
        ],
        NumpadEqual: [
            "=",
            "=",
            "=",
            "="
        ]
    }
}), Tn({
    id: "apple.spanish",
    locale: "es",
    displayName: "Spanish ISO",
    platform: "apple",
    virtualLayout: "qwerty",
    score: 0,
    mapping: {
        KeyA: [
            "a",
            "A",
            "\xe5",
            "\xc5"
        ],
        KeyB: [
            "b",
            "B",
            "\xdf",
            ""
        ],
        KeyC: [
            "c",
            "C",
            "\xa9",
            " "
        ],
        KeyD: [
            "d",
            "D",
            "∂",
            "∆"
        ],
        KeyE: [
            "e",
            "E",
            "€",
            "€"
        ],
        KeyF: [
            "f",
            "F",
            "ƒ",
            "ﬁ"
        ],
        KeyG: [
            "g",
            "G",
            "",
            "ﬂ"
        ],
        KeyH: [
            "h",
            "H",
            "™",
            " "
        ],
        KeyI: [
            "i",
            "I",
            " ",
            " "
        ],
        KeyJ: [
            "j",
            "J",
            "\xb6",
            "\xaf"
        ],
        KeyK: [
            "k",
            "K",
            "\xa7",
            "ˇ"
        ],
        KeyL: [
            "l",
            "L",
            " ",
            "˘"
        ],
        KeyM: [
            "m",
            "M",
            "\xb5",
            "˚"
        ],
        KeyN: [
            "n",
            "N",
            " ",
            "˙"
        ],
        KeyO: [
            "o",
            "O",
            "\xf8",
            "\xd8"
        ],
        KeyP: [
            "p",
            "P",
            "π",
            "∏"
        ],
        KeyQ: [
            "q",
            "Q",
            "œ",
            "Œ"
        ],
        KeyR: [
            "r",
            "R",
            "\xae",
            " "
        ],
        KeyS: [
            "s",
            "S",
            "∫",
            " "
        ],
        KeyT: [
            "t",
            "T",
            "†",
            "‡"
        ],
        KeyU: [
            "u",
            "U",
            " ",
            " "
        ],
        KeyV: [
            "v",
            "V",
            "√",
            "◊"
        ],
        KeyW: [
            "w",
            "W",
            "\xe6",
            "\xc6"
        ],
        KeyX: [
            "x",
            "X",
            "∑",
            "›"
        ],
        KeyY: [
            "y",
            "Y",
            "\xa5",
            " "
        ],
        KeyZ: [
            "z",
            "Z",
            "Ω",
            "‹"
        ],
        Digit1: [
            "1",
            "!",
            "|",
            "ı"
        ],
        Digit2: [
            "2",
            '"',
            "@",
            "˝"
        ],
        Digit3: [
            "3",
            "\xb7",
            "#",
            "•"
        ],
        Digit4: [
            "4",
            "$",
            "\xa2",
            "\xa3"
        ],
        Digit5: [
            "5",
            "%",
            "∞",
            "‰"
        ],
        Digit6: [
            "6",
            "&",
            "\xac",
            " "
        ],
        Digit7: [
            "7",
            "/",
            "\xf7",
            "⁄"
        ],
        Digit8: [
            "8",
            "(",
            "“",
            "‘"
        ],
        Digit9: [
            "9",
            ")",
            "”",
            "’"
        ],
        Digit0: [
            "0",
            "=",
            "≠",
            "≈"
        ],
        Space: [
            " ",
            " ",
            " ",
            " "
        ],
        Minus: [
            "'",
            "?",
            "\xb4",
            "\xb8"
        ],
        Equal: [
            "\xa1",
            "\xbf",
            "‚",
            "˛"
        ],
        BracketLeft: [
            "`",
            "^",
            "[",
            "ˆ"
        ],
        BracketRight: [
            "+",
            "*",
            "]",
            "\xb1"
        ],
        Backslash: [
            "\xe7",
            "\xc7",
            "}",
            "\xbb"
        ],
        Semicolon: [
            "\xf1",
            "\xd1",
            "~",
            "˜"
        ],
        Quote: [
            "\xb4",
            "\xa8",
            "{",
            "\xab"
        ],
        Backquote: [
            "<",
            ">",
            "≤",
            "≥"
        ],
        Comma: [
            ",",
            ";",
            "„",
            ""
        ],
        Period: [
            ".",
            ":",
            "…",
            "…"
        ],
        Slash: [
            "-",
            "_",
            "–",
            "—"
        ],
        NumpadDivide: [
            "/",
            "/",
            "/",
            "/"
        ],
        NumpadMultiply: [
            "*",
            "*",
            "*",
            "*"
        ],
        NumpadSubtract: [
            "-",
            "-",
            "-",
            "-"
        ],
        NumpadAdd: [
            "+",
            "+",
            "+",
            "+"
        ],
        Numpad1: [
            "1",
            "1",
            "1",
            "1"
        ],
        Numpad2: [
            "2",
            "2",
            "2",
            "2"
        ],
        Numpad3: [
            "3",
            "3",
            "3",
            "3"
        ],
        Numpad4: [
            "4",
            "4",
            "4",
            "4"
        ],
        Numpad5: [
            "5",
            "5",
            "5",
            "5"
        ],
        Numpad6: [
            "6",
            "6",
            "6",
            "6"
        ],
        Numpad7: [
            "7",
            "7",
            "7",
            "7"
        ],
        Numpad8: [
            "8",
            "8",
            "8",
            "8"
        ],
        Numpad9: [
            "9",
            "9",
            "9",
            "9"
        ],
        Numpad0: [
            "0",
            "0",
            "0",
            "0"
        ],
        NumpadDecimal: [
            ",",
            ",",
            ",",
            ","
        ],
        IntlBackslash: [
            "\xba",
            "\xaa",
            "\\",
            "\xb0"
        ]
    }
}), Tn({
    id: "windows.spanish",
    locale: "es",
    displayName: "Spanish",
    platform: "windows",
    virtualLayout: "qwerty",
    score: 0,
    mapping: {
        KeyA: [
            "a",
            "A",
            "",
            ""
        ],
        KeyB: [
            "b",
            "B",
            "",
            ""
        ],
        KeyC: [
            "c",
            "C",
            "",
            ""
        ],
        KeyD: [
            "d",
            "D",
            "",
            ""
        ],
        KeyE: [
            "e",
            "E",
            "€",
            ""
        ],
        KeyF: [
            "f",
            "F",
            "",
            ""
        ],
        KeyG: [
            "g",
            "G",
            "",
            ""
        ],
        KeyH: [
            "h",
            "H",
            "",
            ""
        ],
        KeyI: [
            "i",
            "I",
            "",
            ""
        ],
        KeyJ: [
            "j",
            "J",
            "",
            ""
        ],
        KeyK: [
            "k",
            "K",
            "",
            ""
        ],
        KeyL: [
            "l",
            "L",
            "",
            ""
        ],
        KeyM: [
            "m",
            "M",
            "",
            ""
        ],
        KeyN: [
            "n",
            "N",
            "",
            ""
        ],
        KeyO: [
            "o",
            "O",
            "",
            ""
        ],
        KeyP: [
            "p",
            "P",
            "",
            ""
        ],
        KeyQ: [
            "q",
            "Q",
            "",
            ""
        ],
        KeyR: [
            "r",
            "R",
            "",
            ""
        ],
        KeyS: [
            "s",
            "S",
            "",
            ""
        ],
        KeyT: [
            "t",
            "T",
            "",
            ""
        ],
        KeyU: [
            "u",
            "U",
            "",
            ""
        ],
        KeyV: [
            "v",
            "V",
            "",
            ""
        ],
        KeyW: [
            "w",
            "W",
            "",
            ""
        ],
        KeyX: [
            "x",
            "X",
            "",
            ""
        ],
        KeyY: [
            "y",
            "Y",
            "",
            ""
        ],
        KeyZ: [
            "z",
            "Z",
            "",
            ""
        ],
        Digit1: [
            "1",
            "!",
            "|",
            ""
        ],
        Digit2: [
            "2",
            '"',
            "@",
            ""
        ],
        Digit3: [
            "3",
            "\xb7",
            "#",
            ""
        ],
        Digit4: [
            "4",
            "$",
            "~",
            ""
        ],
        Digit5: [
            "5",
            "%",
            "€",
            ""
        ],
        Digit6: [
            "6",
            "&",
            "\xac",
            ""
        ],
        Digit7: [
            "7",
            "/",
            "",
            ""
        ],
        Digit8: [
            "8",
            "(",
            "",
            ""
        ],
        Digit9: [
            "9",
            ")",
            "",
            ""
        ],
        Digit0: [
            "0",
            "=",
            "",
            ""
        ],
        Space: [
            " ",
            " ",
            "",
            ""
        ],
        Minus: [
            "'",
            "?",
            "",
            ""
        ],
        Equal: [
            "\xa1",
            "\xbf",
            "",
            ""
        ],
        BracketLeft: [
            "`",
            "^",
            "[",
            ""
        ],
        BracketRight: [
            "+",
            "*",
            "]",
            ""
        ],
        Backslash: [
            "\xe7",
            "\xc7",
            "}",
            ""
        ],
        Semicolon: [
            "\xf1",
            "\xd1",
            "",
            ""
        ],
        Quote: [
            "\xb4",
            "\xa8",
            "{",
            ""
        ],
        Backquote: [
            "\xba",
            "\xaa",
            "\\",
            ""
        ],
        Comma: [
            ",",
            ";",
            "",
            ""
        ],
        Period: [
            ".",
            ":",
            "",
            ""
        ],
        Slash: [
            "-",
            "_",
            "",
            ""
        ],
        NumpadDivide: [
            "/",
            "/",
            "",
            ""
        ],
        NumpadMultiply: [
            "*",
            "*",
            "",
            ""
        ],
        NumpadSubtract: [
            "-",
            "-",
            "",
            ""
        ],
        NumpadAdd: [
            "+",
            "+",
            "",
            ""
        ],
        IntlBackslash: [
            "<",
            ">",
            "",
            ""
        ]
    }
}), Tn({
    id: "linux.spanish",
    locale: "es",
    displayName: "Spanish",
    platform: "linux",
    virtualLayout: "qwerty",
    score: 0,
    mapping: {
        KeyA: [
            "a",
            "A",
            "\xe6",
            "\xc6"
        ],
        KeyB: [
            "b",
            "B",
            "”",
            "’"
        ],
        KeyC: [
            "c",
            "C",
            "\xa2",
            "\xa9"
        ],
        KeyD: [
            "d",
            "D",
            "\xf0",
            "\xd0"
        ],
        KeyE: [
            "e",
            "E",
            "€",
            "\xa2"
        ],
        KeyF: [
            "f",
            "F",
            "đ",
            "\xaa"
        ],
        KeyG: [
            "g",
            "G",
            "ŋ",
            "Ŋ"
        ],
        KeyH: [
            "h",
            "H",
            "ħ",
            "Ħ"
        ],
        KeyI: [
            "i",
            "I",
            "→",
            "ı"
        ],
        KeyJ: [
            "j",
            "J",
            "̉",
            "̛"
        ],
        KeyK: [
            "k",
            "K",
            "ĸ",
            "&"
        ],
        KeyL: [
            "l",
            "L",
            "ł",
            "Ł"
        ],
        KeyM: [
            "m",
            "M",
            "\xb5",
            "\xba"
        ],
        KeyN: [
            "n",
            "N",
            "n",
            "N"
        ],
        KeyO: [
            "o",
            "O",
            "\xf8",
            "\xd8"
        ],
        KeyP: [
            "p",
            "P",
            "\xfe",
            "\xde"
        ],
        KeyQ: [
            "q",
            "Q",
            "@",
            "Ω"
        ],
        KeyR: [
            "r",
            "R",
            "\xb6",
            "\xae"
        ],
        KeyS: [
            "s",
            "S",
            "\xdf",
            "\xa7"
        ],
        KeyT: [
            "t",
            "T",
            "ŧ",
            "Ŧ"
        ],
        KeyU: [
            "u",
            "U",
            "↓",
            "↑"
        ],
        KeyV: [
            "v",
            "V",
            "“",
            "‘"
        ],
        KeyW: [
            "w",
            "W",
            "ł",
            "Ł"
        ],
        KeyX: [
            "x",
            "X",
            "\xbb",
            ">"
        ],
        KeyY: [
            "y",
            "Y",
            "←",
            "\xa5"
        ],
        KeyZ: [
            "z",
            "Z",
            "\xab",
            "<"
        ],
        Digit1: [
            "1",
            "!",
            "|",
            "\xa1"
        ],
        Digit2: [
            "2",
            '"',
            "@",
            "⅛"
        ],
        Digit3: [
            "3",
            "\xb7",
            "#",
            "\xa3"
        ],
        Digit4: [
            "4",
            "$",
            "~",
            "$"
        ],
        Digit5: [
            "5",
            "%",
            "\xbd",
            "⅜"
        ],
        Digit6: [
            "6",
            "&",
            "\xac",
            "⅝"
        ],
        Digit7: [
            "7",
            "/",
            "{",
            "⅞"
        ],
        Digit8: [
            "8",
            "(",
            "[",
            "™"
        ],
        Digit9: [
            "9",
            ")",
            "]",
            "\xb1"
        ],
        Digit0: [
            "0",
            "=",
            "}",
            "\xb0"
        ],
        Enter: [
            "\r",
            "\r",
            "\r",
            "\r"
        ],
        Escape: [
            "\x1b",
            "\x1b",
            "\x1b",
            "\x1b"
        ],
        Backspace: [
            "\b",
            "\b",
            "\b",
            "\b"
        ],
        Tab: [
            "	",
            "",
            "	",
            ""
        ],
        Space: [
            " ",
            " ",
            " ",
            " "
        ],
        Minus: [
            "'",
            "?",
            "\\",
            "\xbf"
        ],
        Equal: [
            "\xa1",
            "\xbf",
            "̃",
            "~"
        ],
        BracketLeft: [
            "̀",
            "̂",
            "[",
            "̊"
        ],
        BracketRight: [
            "+",
            "*",
            "]",
            "̄"
        ],
        Backslash: [
            "\xe7",
            "\xc7",
            "}",
            "̆"
        ],
        Semicolon: [
            "\xf1",
            "\xd1",
            "~",
            "̋"
        ],
        Quote: [
            "́",
            "̈",
            "{",
            "{"
        ],
        Backquote: [
            "\xba",
            "\xaa",
            "\\",
            "\\"
        ],
        Comma: [
            ",",
            ";",
            "─",
            "\xd7"
        ],
        Period: [
            ".",
            ":",
            "\xb7",
            "\xf7"
        ],
        Slash: [
            "-",
            "_",
            "̣",
            "̇"
        ],
        NumpadDivide: [
            "/",
            "/",
            "/",
            "/"
        ],
        NumpadMultiply: [
            "*",
            "*",
            "*",
            "*"
        ],
        NumpadSubtract: [
            "-",
            "-",
            "-",
            "-"
        ],
        NumpadAdd: [
            "+",
            "+",
            "+",
            "+"
        ],
        NumpadEnter: [
            "\r",
            "\r",
            "\r",
            "\r"
        ],
        Numpad1: [
            "",
            "1",
            "",
            "1"
        ],
        Numpad2: [
            "",
            "2",
            "",
            "2"
        ],
        Numpad3: [
            "",
            "3",
            "",
            "3"
        ],
        Numpad4: [
            "",
            "4",
            "",
            "4"
        ],
        Numpad5: [
            "",
            "5",
            "",
            "5"
        ],
        Numpad6: [
            "",
            "6",
            "",
            "6"
        ],
        Numpad7: [
            "",
            "7",
            "",
            "7"
        ],
        Numpad8: [
            "",
            "8",
            "",
            "8"
        ],
        Numpad9: [
            "",
            "9",
            "",
            "9"
        ],
        Numpad0: [
            "",
            "0",
            "",
            "0"
        ],
        NumpadDecimal: [
            "",
            ".",
            "",
            "."
        ],
        IntlBackslash: [
            "<",
            ">",
            "|",
            "\xa6"
        ],
        NumpadEqual: [
            "=",
            "=",
            "=",
            "="
        ],
        NumpadComma: [
            ".",
            ".",
            ".",
            "."
        ],
        NumpadParenLeft: [
            "(",
            "(",
            "(",
            "("
        ],
        NumpadParenRight: [
            ")",
            ")",
            ")",
            ")"
        ]
    }
}), Tn({
    id: "linux.french",
    locale: "fr",
    displayName: "French",
    virtualLayout: "azerty",
    platform: "linux",
    score: 0,
    mapping: {
        KeyA: [
            "q",
            "Q",
            "@",
            "Ω"
        ],
        KeyB: [
            "b",
            "B",
            "”",
            "’"
        ],
        KeyC: [
            "c",
            "C",
            "\xa2",
            "\xa9"
        ],
        KeyD: [
            "d",
            "D",
            "\xf0",
            "\xd0"
        ],
        KeyE: [
            "e",
            "E",
            "€",
            "\xa2"
        ],
        KeyF: [
            "f",
            "F",
            "đ",
            "\xaa"
        ],
        KeyG: [
            "g",
            "G",
            "ŋ",
            "Ŋ"
        ],
        KeyH: [
            "h",
            "H",
            "ħ",
            "Ħ"
        ],
        KeyI: [
            "i",
            "I",
            "→",
            "ı"
        ],
        KeyJ: [
            "j",
            "J",
            "̉",
            "̛"
        ],
        KeyK: [
            "k",
            "K",
            "ĸ",
            "&"
        ],
        KeyL: [
            "l",
            "L",
            "ł",
            "Ł"
        ],
        KeyM: [
            ",",
            "?",
            "́",
            "̋"
        ],
        KeyN: [
            "n",
            "N",
            "n",
            "N"
        ],
        KeyO: [
            "o",
            "O",
            "\xf8",
            "\xd8"
        ],
        KeyP: [
            "p",
            "P",
            "\xfe",
            "\xde"
        ],
        KeyQ: [
            "a",
            "A",
            "\xe6",
            "\xc6"
        ],
        KeyR: [
            "r",
            "R",
            "\xb6",
            "\xae"
        ],
        KeyS: [
            "s",
            "S",
            "\xdf",
            "\xa7"
        ],
        KeyT: [
            "t",
            "T",
            "ŧ",
            "Ŧ"
        ],
        KeyU: [
            "u",
            "U",
            "↓",
            "↑"
        ],
        KeyV: [
            "v",
            "V",
            "“",
            "‘"
        ],
        KeyW: [
            "z",
            "Z",
            "\xab",
            "<"
        ],
        KeyX: [
            "x",
            "X",
            "\xbb",
            ">"
        ],
        KeyY: [
            "y",
            "Y",
            "←",
            "\xa5"
        ],
        KeyZ: [
            "w",
            "W",
            "ł",
            "Ł"
        ],
        Digit1: [
            "&",
            "1",
            "\xb9",
            "\xa1"
        ],
        Digit2: [
            "\xe9",
            "2",
            "~",
            "⅛"
        ],
        Digit3: [
            '"',
            "3",
            "#",
            "\xa3"
        ],
        Digit4: [
            "'",
            "4",
            "{",
            "$"
        ],
        Digit5: [
            "(",
            "5",
            "[",
            "⅜"
        ],
        Digit6: [
            "-",
            "6",
            "|",
            "⅝"
        ],
        Digit7: [
            "\xe8",
            "7",
            "`",
            "⅞"
        ],
        Digit8: [
            "_",
            "8",
            "\\",
            "™"
        ],
        Digit9: [
            "\xe7",
            "9",
            "^",
            "\xb1"
        ],
        Digit0: [
            "\xe0",
            "0",
            "@",
            "\xb0"
        ],
        Enter: [
            "\r",
            "\r",
            "\r",
            "\r"
        ],
        Escape: [
            "\x1b",
            "\x1b",
            "\x1b",
            "\x1b"
        ],
        Backspace: [
            "\b",
            "\b",
            "\b",
            "\b"
        ],
        Tab: [
            "	",
            "",
            "	",
            ""
        ],
        Space: [
            " ",
            " ",
            " ",
            " "
        ],
        Minus: [
            ")",
            "\xb0",
            "]",
            "\xbf"
        ],
        Equal: [
            "=",
            "+",
            "}",
            "̨"
        ],
        BracketLeft: [
            "̂",
            "̈",
            "̈",
            "̊"
        ],
        BracketRight: [
            "$",
            "\xa3",
            "\xa4",
            "̄"
        ],
        Backslash: [
            "*",
            "\xb5",
            "̀",
            "̆"
        ],
        Semicolon: [
            "m",
            "M",
            "\xb5",
            "\xba"
        ],
        Quote: [
            "\xf9",
            "%",
            "̂",
            "̌"
        ],
        Backquote: [
            "\xb2",
            "~",
            "\xac",
            "\xac"
        ],
        Comma: [
            ";",
            ".",
            "─",
            "\xd7"
        ],
        Period: [
            ":",
            "/",
            "\xb7",
            "\xf7"
        ],
        Slash: [
            "!",
            "\xa7",
            "̣",
            "̇"
        ],
        NumpadMultiply: [
            "*",
            "*",
            "*",
            "*"
        ],
        NumpadSubtract: [
            "-",
            "-",
            "-",
            "-"
        ],
        NumpadAdd: [
            "+",
            "+",
            "+",
            "+"
        ],
        NumpadDecimal: [
            "",
            ".",
            "",
            "."
        ],
        IntlBackslash: [
            "<",
            ">",
            "|",
            "\xa6"
        ]
    }
}), Tn({
    id: "windows.french",
    locale: "fr",
    displayName: "French",
    virtualLayout: "azerty",
    platform: "windows",
    score: 0,
    mapping: {
        KeyA: [
            "q",
            "Q",
            "",
            ""
        ],
        KeyB: [
            "b",
            "B",
            "",
            ""
        ],
        KeyC: [
            "c",
            "C",
            "",
            ""
        ],
        KeyD: [
            "d",
            "D",
            "",
            ""
        ],
        KeyE: [
            "e",
            "E",
            "€",
            ""
        ],
        KeyF: [
            "f",
            "F",
            "",
            ""
        ],
        KeyG: [
            "g",
            "G",
            "",
            ""
        ],
        KeyH: [
            "h",
            "H",
            "",
            ""
        ],
        KeyI: [
            "i",
            "I",
            "",
            ""
        ],
        KeyJ: [
            "j",
            "J",
            "",
            ""
        ],
        KeyK: [
            "k",
            "K",
            "",
            ""
        ],
        KeyL: [
            "l",
            "L",
            "",
            ""
        ],
        KeyM: [
            ",",
            "?",
            "",
            ""
        ],
        KeyN: [
            "n",
            "N",
            "",
            ""
        ],
        KeyO: [
            "o",
            "O",
            "",
            ""
        ],
        KeyP: [
            "p",
            "P",
            "",
            ""
        ],
        KeyQ: [
            "a",
            "A",
            "",
            ""
        ],
        KeyR: [
            "r",
            "R",
            "",
            ""
        ],
        KeyS: [
            "s",
            "S",
            "",
            ""
        ],
        KeyT: [
            "t",
            "T",
            "",
            ""
        ],
        KeyU: [
            "u",
            "U",
            "",
            ""
        ],
        KeyV: [
            "v",
            "V",
            "",
            ""
        ],
        KeyW: [
            "z",
            "Z",
            "",
            ""
        ],
        KeyX: [
            "x",
            "X",
            "",
            ""
        ],
        KeyY: [
            "y",
            "Y",
            "",
            ""
        ],
        KeyZ: [
            "w",
            "W",
            "",
            ""
        ],
        Digit1: [
            "&",
            "1",
            "",
            ""
        ],
        Digit2: [
            "\xe9",
            "2",
            "~",
            ""
        ],
        Digit3: [
            '"',
            "3",
            "#",
            ""
        ],
        Digit4: [
            "'",
            "4",
            "{",
            ""
        ],
        Digit5: [
            "(",
            "5",
            "[",
            ""
        ],
        Digit6: [
            "-",
            "6",
            "|",
            ""
        ],
        Digit7: [
            "\xe8",
            "7",
            "`",
            ""
        ],
        Digit8: [
            "_",
            "8",
            "\\",
            ""
        ],
        Digit9: [
            "\xe7",
            "9",
            "^",
            ""
        ],
        Digit0: [
            "\xe0",
            "0",
            "@",
            ""
        ],
        Space: [
            " ",
            " ",
            "",
            ""
        ],
        Minus: [
            ")",
            "\xb0",
            "]",
            ""
        ],
        Equal: [
            "=",
            "+",
            "}",
            ""
        ],
        BracketLeft: [
            "^",
            "\xa8",
            "",
            ""
        ],
        BracketRight: [
            "$",
            "\xa3",
            "\xa4",
            ""
        ],
        Backslash: [
            "*",
            "\xb5",
            "",
            ""
        ],
        Semicolon: [
            "m",
            "M",
            "",
            ""
        ],
        Quote: [
            "\xf9",
            "%",
            "",
            ""
        ],
        Backquote: [
            "\xb2",
            "",
            "",
            ""
        ],
        Comma: [
            ";",
            ".",
            "",
            ""
        ],
        Period: [
            ":",
            "/",
            "",
            ""
        ],
        Slash: [
            "!",
            "\xa7",
            "",
            ""
        ],
        NumpadDivide: [
            "/",
            "/",
            "",
            ""
        ],
        NumpadMultiply: [
            "*",
            "*",
            "",
            ""
        ],
        NumpadSubtract: [
            "-",
            "-",
            "",
            ""
        ],
        NumpadAdd: [
            "+",
            "+",
            "",
            ""
        ],
        IntlBackslash: [
            "<",
            ">",
            "",
            ""
        ]
    }
}), Tn({
    id: "windows.german",
    locale: "de",
    displayName: "German",
    platform: "windows",
    virtualLayout: "qwertz",
    score: 0,
    mapping: {
        KeyA: [
            "a",
            "A",
            "",
            ""
        ],
        KeyB: [
            "b",
            "B",
            "",
            ""
        ],
        KeyC: [
            "c",
            "C",
            "",
            ""
        ],
        KeyD: [
            "d",
            "D",
            "",
            ""
        ],
        KeyE: [
            "e",
            "E",
            "€",
            ""
        ],
        KeyF: [
            "f",
            "F",
            "",
            ""
        ],
        KeyG: [
            "g",
            "G",
            "",
            ""
        ],
        KeyH: [
            "h",
            "H",
            "",
            ""
        ],
        KeyI: [
            "i",
            "I",
            "",
            ""
        ],
        KeyJ: [
            "j",
            "J",
            "",
            ""
        ],
        KeyK: [
            "k",
            "K",
            "",
            ""
        ],
        KeyL: [
            "l",
            "L",
            "",
            ""
        ],
        KeyM: [
            "m",
            "M",
            "\xb5",
            ""
        ],
        KeyN: [
            "n",
            "N",
            "",
            ""
        ],
        KeyO: [
            "o",
            "O",
            "",
            ""
        ],
        KeyP: [
            "p",
            "P",
            "",
            ""
        ],
        KeyQ: [
            "q",
            "Q",
            "@",
            ""
        ],
        KeyR: [
            "r",
            "R",
            "",
            ""
        ],
        KeyS: [
            "s",
            "S",
            "",
            ""
        ],
        KeyT: [
            "t",
            "T",
            "",
            ""
        ],
        KeyU: [
            "u",
            "U",
            "",
            ""
        ],
        KeyV: [
            "v",
            "V",
            "",
            ""
        ],
        KeyW: [
            "w",
            "W",
            "",
            ""
        ],
        KeyX: [
            "x",
            "X",
            "",
            ""
        ],
        KeyY: [
            "z",
            "Z",
            "",
            ""
        ],
        KeyZ: [
            "y",
            "Y",
            "",
            ""
        ],
        Digit1: [
            "1",
            "!",
            "",
            ""
        ],
        Digit2: [
            "2",
            '"',
            "\xb2",
            ""
        ],
        Digit3: [
            "3",
            "\xa7",
            "\xb3",
            ""
        ],
        Digit4: [
            "4",
            "$",
            "",
            ""
        ],
        Digit5: [
            "5",
            "%",
            "",
            ""
        ],
        Digit6: [
            "6",
            "&",
            "",
            ""
        ],
        Digit7: [
            "7",
            "/",
            "{",
            ""
        ],
        Digit8: [
            "8",
            "(",
            "[",
            ""
        ],
        Digit9: [
            "9",
            ")",
            "]",
            ""
        ],
        Digit0: [
            "0",
            "=",
            "}",
            ""
        ],
        Space: [
            " ",
            " ",
            "",
            ""
        ],
        Minus: [
            "\xdf",
            "?",
            "\\",
            "ẞ"
        ],
        Equal: [
            "\xb4",
            "`",
            "",
            ""
        ],
        BracketLeft: [
            "\xfc",
            "\xdc",
            "",
            ""
        ],
        BracketRight: [
            "+",
            "*",
            "~",
            ""
        ],
        Backslash: [
            "#",
            "'",
            "",
            ""
        ],
        Semicolon: [
            "\xf6",
            "\xd6",
            "",
            ""
        ],
        Quote: [
            "\xe4",
            "\xc4",
            "",
            ""
        ],
        Backquote: [
            "^",
            "\xb0",
            "",
            ""
        ],
        Comma: [
            ",",
            ";",
            "",
            ""
        ],
        Period: [
            ".",
            ":",
            "",
            ""
        ],
        Slash: [
            "-",
            "_",
            "",
            ""
        ],
        NumpadDivide: [
            "/",
            "/",
            "",
            ""
        ],
        NumpadMultiply: [
            "*",
            "*",
            "",
            ""
        ],
        NumpadSubtract: [
            "-",
            "-",
            "",
            ""
        ],
        NumpadAdd: [
            "+",
            "+",
            "",
            ""
        ],
        IntlBackslash: [
            "<",
            ">",
            "|",
            ""
        ]
    }
}), Tn({
    id: "apple.german",
    locale: "de",
    displayName: "German",
    virtualLayout: "qwertz",
    platform: "apple",
    score: 0,
    mapping: {
        KeyA: [
            "a",
            "A",
            "\xe5",
            "\xc5"
        ],
        KeyB: [
            "b",
            "B",
            "∫",
            "‹"
        ],
        KeyC: [
            "c",
            "C",
            "\xe7",
            "\xc7"
        ],
        KeyD: [
            "d",
            "D",
            "∂",
            "™"
        ],
        KeyE: [
            "e",
            "E",
            "€",
            "‰"
        ],
        KeyF: [
            "f",
            "F",
            "ƒ",
            "\xcf"
        ],
        KeyG: [
            "g",
            "G",
            "\xa9",
            "\xcc"
        ],
        KeyH: [
            "h",
            "H",
            "\xaa",
            "\xd3"
        ],
        KeyI: [
            "i",
            "I",
            "⁄",
            "\xdb"
        ],
        KeyJ: [
            "j",
            "J",
            "\xba",
            "ı"
        ],
        KeyK: [
            "k",
            "K",
            "∆",
            "ˆ"
        ],
        KeyL: [
            "l",
            "L",
            "@",
            "ﬂ"
        ],
        KeyM: [
            "m",
            "M",
            "\xb5",
            "˘"
        ],
        KeyN: [
            "n",
            "N",
            "~",
            "›"
        ],
        KeyO: [
            "o",
            "O",
            "\xf8",
            "\xd8"
        ],
        KeyP: [
            "p",
            "P",
            "π",
            "∏"
        ],
        KeyQ: [
            "q",
            "Q",
            "\xab",
            "\xbb"
        ],
        KeyR: [
            "r",
            "R",
            "\xae",
            "\xb8"
        ],
        KeyS: [
            "s",
            "S",
            "‚",
            "\xcd"
        ],
        KeyT: [
            "t",
            "T",
            "†",
            "˝"
        ],
        KeyU: [
            "u",
            "U",
            "\xa8",
            "\xc1"
        ],
        KeyV: [
            "v",
            "V",
            "√",
            "◊"
        ],
        KeyW: [
            "w",
            "W",
            "∑",
            "„"
        ],
        KeyX: [
            "x",
            "X",
            "≈",
            "\xd9"
        ],
        KeyY: [
            "z",
            "Z",
            "Ω",
            "ˇ"
        ],
        KeyZ: [
            "y",
            "Y",
            "\xa5",
            "‡"
        ],
        Digit1: [
            "1",
            "!",
            "\xa1",
            "\xac"
        ],
        Digit2: [
            "2",
            '"',
            "“",
            "”"
        ],
        Digit3: [
            "3",
            "\xa7",
            "\xb6",
            "#"
        ],
        Digit4: [
            "4",
            "$",
            "\xa2",
            "\xa3"
        ],
        Digit5: [
            "5",
            "%",
            "[",
            "ﬁ"
        ],
        Digit6: [
            "6",
            "&",
            "]",
            "^"
        ],
        Digit7: [
            "7",
            "/",
            "|",
            "\\"
        ],
        Digit8: [
            "8",
            "(",
            "{",
            "˜"
        ],
        Digit9: [
            "9",
            ")",
            "}",
            "\xb7"
        ],
        Digit0: [
            "0",
            "=",
            "≠",
            "\xaf"
        ],
        Space: [
            " ",
            " ",
            " ",
            " "
        ],
        Minus: [
            "\xdf",
            "?",
            "\xbf",
            "˙"
        ],
        Equal: [
            "\xb4",
            "`",
            "'",
            "˚"
        ],
        BracketLeft: [
            "\xfc",
            "\xdc",
            "•",
            "\xb0"
        ],
        BracketRight: [
            "+",
            "*",
            "\xb1",
            ""
        ],
        Backslash: [
            "#",
            "'",
            "‘",
            "’"
        ],
        Semicolon: [
            "\xf6",
            "\xd6",
            "œ",
            "Œ"
        ],
        Quote: [
            "\xe4",
            "\xc4",
            "\xe6",
            "\xc6"
        ],
        Backquote: [
            "<",
            ">",
            "≤",
            "≥"
        ],
        Comma: [
            ",",
            ";",
            "∞",
            "˛"
        ],
        Period: [
            ".",
            ":",
            "…",
            "\xf7"
        ],
        Slash: [
            "-",
            "_",
            "–",
            "—"
        ],
        NumpadDivide: [
            "/",
            "/",
            "/",
            "/"
        ],
        NumpadMultiply: [
            "*",
            "*",
            "*",
            "*"
        ],
        NumpadSubtract: [
            "-",
            "-",
            "-",
            "-"
        ],
        NumpadAdd: [
            "+",
            "+",
            "+",
            "+"
        ],
        NumpadDecimal: [
            ",",
            ",",
            ".",
            "."
        ],
        IntlBackslash: [
            "^",
            "\xb0",
            "„",
            "“"
        ],
        NumpadEqual: [
            "=",
            "=",
            "=",
            "="
        ]
    }
}), Tn({
    id: "dvorak",
    locale: "en",
    displayName: "Dvorak",
    virtualLayout: "dvorak",
    platform: "",
    score: 0,
    mapping: {
        KeyA: [
            "a",
            "A",
            "\xe5",
            "\xc5"
        ],
        KeyB: [
            "x",
            "X",
            "≈",
            "˛"
        ],
        KeyC: [
            "j",
            "J",
            "∆",
            "\xd4"
        ],
        KeyD: [
            "e",
            "E",
            "\xb4",
            "\xb4"
        ],
        KeyE: [
            ".",
            ">",
            "≥",
            "˘"
        ],
        KeyF: [
            "u",
            "U",
            "\xa8",
            "\xa8"
        ],
        KeyG: [
            "i",
            "I",
            "ˆ",
            "ˆ"
        ],
        KeyH: [
            "d",
            "D",
            "∂",
            "\xce"
        ],
        KeyI: [
            "c",
            "C",
            "\xe7",
            "\xc7"
        ],
        KeyJ: [
            "h",
            "H",
            "˙",
            "\xd3"
        ],
        KeyK: [
            "t",
            "T",
            "†",
            "ˇ"
        ],
        KeyL: [
            "n",
            "N",
            "˜",
            "˜"
        ],
        KeyM: [
            "m",
            "M",
            "\xb5",
            "\xc2"
        ],
        KeyN: [
            "b",
            "B",
            "∫",
            "ı"
        ],
        KeyO: [
            "r",
            "R",
            "\xae",
            "‰"
        ],
        KeyP: [
            "l",
            "L",
            "\xac",
            "\xd2"
        ],
        KeyQ: [
            "'",
            '"',
            "\xe6",
            "\xc6"
        ],
        KeyR: [
            "p",
            "P",
            "π",
            "∏"
        ],
        KeyS: [
            "o",
            "O",
            "\xf8",
            "\xd8"
        ],
        KeyT: [
            "y",
            "Y",
            "\xa5",
            "\xc1"
        ],
        KeyU: [
            "g",
            "G",
            "\xa9",
            "˝"
        ],
        KeyV: [
            "k",
            "K",
            "˚",
            ""
        ],
        KeyW: [
            ",",
            "<",
            "≤",
            "\xaf"
        ],
        KeyX: [
            "q",
            "Q",
            "œ",
            "Œ"
        ],
        KeyY: [
            "f",
            "F",
            "ƒ",
            "\xcf"
        ],
        KeyZ: [
            ";",
            ":",
            "…",
            "\xda"
        ],
        Digit1: [
            "1",
            "!",
            "\xa1",
            "⁄"
        ],
        Digit2: [
            "2",
            "@",
            "™",
            "€"
        ],
        Digit3: [
            "3",
            "#",
            "\xa3",
            "‹"
        ],
        Digit4: [
            "4",
            "$",
            "\xa2",
            "›"
        ],
        Digit5: [
            "5",
            "%",
            "∞",
            "ﬁ"
        ],
        Digit6: [
            "6",
            "^",
            "\xa7",
            "ﬂ"
        ],
        Digit7: [
            "7",
            "&",
            "\xb6",
            "‡"
        ],
        Digit8: [
            "8",
            "*",
            "•",
            "\xb0"
        ],
        Digit9: [
            "9",
            "(",
            "\xaa",
            "\xb7"
        ],
        Digit0: [
            "0",
            ")",
            "\xba",
            "‚"
        ],
        Space: [
            " ",
            " ",
            " ",
            " "
        ],
        Minus: [
            "[",
            "{",
            "“",
            "”"
        ],
        Equal: [
            "]",
            "}",
            "‘",
            "’"
        ],
        BracketLeft: [
            "/",
            "?",
            "\xf7",
            "\xbf"
        ],
        BracketRight: [
            "=",
            "+",
            "≠",
            "\xb1"
        ],
        Backslash: [
            "\\",
            "|",
            "\xab",
            "\xbb"
        ],
        Semicolon: [
            "s",
            "S",
            "\xdf",
            "\xcd"
        ],
        Quote: [
            "-",
            "_",
            "–",
            "—"
        ],
        Backquote: [
            "`",
            "~",
            "`",
            "`"
        ],
        Comma: [
            "w",
            "W",
            "∑",
            "„"
        ],
        Period: [
            "v",
            "V",
            "√",
            "◊"
        ],
        Slash: [
            "z",
            "Z",
            "Ω",
            "\xb8"
        ],
        NumpadDivide: [
            "/",
            "/",
            "/",
            "/"
        ],
        NumpadMultiply: [
            "*",
            "*",
            "*",
            "*"
        ],
        NumpadSubtract: [
            "-",
            "-",
            "-",
            "-"
        ],
        NumpadAdd: [
            "+",
            "+",
            "+",
            "+"
        ],
        Numpad1: [
            "1",
            "1",
            "1",
            "1"
        ],
        Numpad2: [
            "2",
            "2",
            "2",
            "2"
        ],
        Numpad3: [
            "3",
            "3",
            "3",
            "3"
        ],
        Numpad4: [
            "4",
            "4",
            "4",
            "4"
        ],
        Numpad5: [
            "5",
            "5",
            "5",
            "5"
        ],
        Numpad6: [
            "6",
            "6",
            "6",
            "6"
        ],
        Numpad7: [
            "7",
            "7",
            "7",
            "7"
        ],
        Numpad8: [
            "8",
            "8",
            "8",
            "8"
        ],
        Numpad9: [
            "9",
            "9",
            "9",
            "9"
        ],
        Numpad0: [
            "0",
            "0",
            "0",
            "0"
        ],
        NumpadDecimal: [
            ".",
            ".",
            ".",
            "."
        ],
        IntlBackslash: [
            "\xa7",
            "\xb1",
            "\xa7",
            "\xb1"
        ],
        NumpadEqual: [
            "=",
            "=",
            "=",
            "="
        ],
        AudioVolumeUp: [
            "",
            "=",
            "",
            "="
        ]
    }
});
const zn = [
    {
        key: "left",
        command: "moveToPreviousChar"
    },
    {
        key: "right",
        command: "moveToNextChar"
    },
    {
        key: "up",
        command: "moveUp"
    },
    {
        key: "down",
        command: "moveDown"
    },
    {
        key: "shift+[ArrowLeft]",
        command: "extendSelectionBackward"
    },
    {
        key: "shift+[ArrowRight]",
        command: "extendSelectionForward"
    },
    {
        key: "shift+[ArrowUp]",
        command: "extendSelectionUpward"
    },
    {
        key: "shift+[ArrowDown]",
        command: "extendSelectionDownward"
    },
    {
        key: "[Backspace]",
        command: "deleteBackward"
    },
    {
        key: "alt+[Delete]",
        command: "deleteBackward"
    },
    {
        key: "[Delete]",
        command: "deleteForward"
    },
    {
        key: "alt+[Backspace]",
        command: "deleteForward"
    },
    {
        key: "alt+[ArrowLeft]",
        command: "moveToPreviousWord"
    },
    {
        key: "alt+[ArrowRight]",
        command: "moveToNextWord"
    },
    {
        key: "shift+alt+[ArrowLeft]",
        command: "extendToPreviousWord"
    },
    {
        key: "shift+alt+[ArrowRight]",
        command: "extendToNextWord"
    },
    {
        key: "ctrl+[ArrowLeft]",
        command: "moveToGroupStart"
    },
    {
        key: "ctrl+[ArrowRight]",
        command: "moveToGroupEnd"
    },
    {
        key: "shift+ctrl+[ArrowLeft]",
        command: "extendToGroupStart"
    },
    {
        key: "shift+ctrl+[ArrowRight]",
        command: "extendToGroupEnd"
    },
    {
        key: "[Space]",
        ifMode: "math",
        command: "moveAfterParent"
    },
    {
        key: "shift+[Space]",
        ifMode: "math",
        command: "moveBeforeParent"
    },
    {
        key: "[Home]",
        command: "moveToMathFieldStart"
    },
    {
        key: "cmd+[ArrowLeft]",
        command: "moveToMathFieldStart"
    },
    {
        key: "shift+[Home]",
        command: "extendToMathFieldStart"
    },
    {
        key: "shift+cmd+[ArrowLeft]",
        command: "extendToMathFieldStart"
    },
    {
        key: "[End]",
        command: "moveToMathFieldEnd"
    },
    {
        key: "cmd+[ArrowRight]",
        command: "moveToMathFieldEnd"
    },
    {
        key: "shift+[End]",
        command: "extendToMathFieldEnd"
    },
    {
        key: "shift+cmd+[ArrowRight]",
        command: "extendToMathFieldEnd"
    },
    {
        key: "[Pageup]",
        command: "moveToGroupStart"
    },
    {
        key: "[Pagedown]",
        command: "moveToGroupEnd"
    },
    {
        key: "[Tab]",
        ifMode: "math",
        command: "moveToNextPlaceholder"
    },
    {
        key: "shift+[Tab]",
        ifMode: "math",
        command: "moveToPreviousPlaceholder"
    },
    {
        key: "[Tab]",
        ifMode: "text",
        command: "moveToNextPlaceholder"
    },
    {
        key: "shift+[Tab]",
        ifMode: "text",
        command: "moveToPreviousPlaceholder"
    },
    {
        key: "[Escape]",
        ifMode: "math",
        command: [
            "switchMode",
            "latex"
        ]
    },
    {
        key: "[Escape]",
        ifMode: "text",
        command: [
            "switchMode",
            "latex"
        ]
    },
    {
        key: "\\",
        ifMode: "math",
        command: [
            "switchMode",
            "latex",
            "\\"
        ]
    },
    {
        key: "[IntlBackslash]",
        ifMode: "math",
        command: [
            "switchMode",
            "latex",
            "\\"
        ]
    },
    {
        key: "[Escape]",
        ifMode: "latex",
        command: [
            "complete",
            "complete",
            {
                selectItem: "true"
            }
        ]
    },
    {
        key: "[Tab]",
        ifMode: "latex",
        command: [
            "complete",
            "accept-suggestion"
        ]
    },
    {
        key: "[Return]",
        ifMode: "latex",
        command: "complete"
    },
    {
        key: "[Enter]",
        ifMode: "latex",
        command: "complete"
    },
    {
        key: "shift+[Escape]",
        ifMode: "latex",
        command: [
            "complete",
            "reject"
        ]
    },
    {
        key: "[ArrowDown]",
        ifMode: "latex",
        command: "nextSuggestion"
    },
    {
        key: "[ArrowUp]",
        ifMode: "latex",
        command: "previousSuggestion"
    },
    {
        key: "ctrl+a",
        ifPlatform: "!macos",
        command: "selectAll"
    },
    {
        key: "cmd+a",
        command: "selectAll"
    },
    {
        key: "[Cut]",
        command: "cutToClipboard"
    },
    {
        key: "[Copy]",
        command: "copyToClipboard"
    },
    {
        key: "[Paste]",
        command: "pasteFromClipboard"
    },
    {
        key: "[Clear]",
        command: "deleteBackward"
    },
    {
        key: "ctrl+z",
        ifPlatform: "!macos",
        command: "undo"
    },
    {
        key: "cmd+z",
        command: "undo"
    },
    {
        key: "[Undo]",
        command: "undo"
    },
    {
        key: "ctrl+y",
        ifPlatform: "!macos",
        command: "redo"
    },
    {
        key: "shift+cmd+y",
        command: "redo"
    },
    {
        key: "shift+ctrl+z",
        ifPlatform: "!macos",
        command: "redo"
    },
    {
        key: "shift+cmd+z",
        command: "redo"
    },
    {
        key: "[Redo]",
        command: "redo"
    },
    {
        key: "[EraseEof]",
        command: "deleteToGroupEnd"
    },
    {
        key: "ctrl+b",
        ifPlatform: "macos",
        command: "moveToPreviousChar"
    },
    {
        key: "ctrl+f",
        ifPlatform: "macos",
        command: "moveToNextChar"
    },
    {
        key: "ctrl+p",
        ifPlatform: "macos",
        command: "moveUp"
    },
    {
        key: "ctrl+n",
        ifPlatform: "macos",
        command: "moveDown"
    },
    {
        key: "ctrl+a",
        ifPlatform: "macos",
        command: "moveToMathFieldStart"
    },
    {
        key: "ctrl+e",
        ifPlatform: "macos",
        command: "moveToMathFieldEnd"
    },
    {
        key: "shift+ctrl+b",
        ifPlatform: "macos",
        command: "extendSelectionBackward"
    },
    {
        key: "shift+ctrl+f",
        ifPlatform: "macos",
        command: "extendSelectionForward"
    },
    {
        key: "shift+ctrl+p",
        ifPlatform: "macos",
        command: "extendSelectionUpward"
    },
    {
        key: "shift+ctrl+n",
        ifPlatform: "macos",
        command: "extendSelectionDownward"
    },
    {
        key: "shift+ctrl+a",
        ifPlatform: "macos",
        command: "extendToMathFieldStart"
    },
    {
        key: "shift+ctrl+e",
        ifPlatform: "macos",
        command: "extendToMathFieldEnd"
    },
    {
        key: "alt+ctrl+b",
        ifPlatform: "macos",
        command: "moveToPreviousWord"
    },
    {
        key: "alt+ctrl+f",
        ifPlatform: "macos",
        command: "moveToNextWord"
    },
    {
        key: "shift+alt+ctrl+b",
        ifPlatform: "macos",
        command: "extendToPreviousWord"
    },
    {
        key: "shift+alt+ctrl+f",
        ifPlatform: "macos",
        command: "extendToNextWord"
    },
    {
        key: "ctrl+h",
        ifPlatform: "macos",
        command: "deleteBackward"
    },
    {
        key: "ctrl+d",
        ifPlatform: "macos",
        command: "deleteForward"
    },
    {
        key: "ctrl+l",
        ifPlatform: "macos",
        command: "scrollIntoView"
    },
    {
        key: "ctrl+[Digit2]",
        ifMode: "math",
        command: [
            "insert",
            "\\sqrt{#0}"
        ]
    },
    {
        key: "ctrl+[Digit5]",
        ifMode: "math",
        command: "moveToOpposite"
    },
    {
        key: "ctrl+[Digit6]",
        ifMode: "math",
        command: "moveToSuperscript"
    },
    {
        key: "ctrl+[Return]",
        ifMode: "math",
        command: "addRowAfter"
    },
    {
        key: "ctrl+[Enter]",
        ifMode: "math",
        command: "addRowAfter"
    },
    {
        key: "cmd+[Return]",
        ifMode: "math",
        command: "addRowAfter"
    },
    {
        key: "cmd+[Enter]",
        ifMode: "math",
        command: "addRowAfter"
    },
    {
        key: "alt+p",
        ifMode: "math",
        command: [
            "insert",
            "\\pi"
        ]
    },
    {
        key: "alt+v",
        ifMode: "math",
        command: [
            "insert",
            "\\sqrt{#0}"
        ]
    },
    {
        key: "alt+w",
        ifMode: "math",
        command: [
            "insert",
            "\\sum_{i=#?}^{#?}"
        ]
    },
    {
        key: "alt+b",
        command: [
            "insert",
            "\\int_{#?}^{#?}"
        ]
    },
    {
        key: "alt+u",
        ifMode: "math",
        command: [
            "insert",
            "\\cup"
        ]
    },
    {
        key: "alt+n",
        ifMode: "math",
        command: [
            "insert",
            "\\cap"
        ]
    },
    {
        key: "alt+o",
        ifMode: "math",
        command: [
            "insert",
            "\\emptyset"
        ]
    },
    {
        key: "alt+d",
        ifMode: "math",
        command: [
            "insert",
            "\\differentialD"
        ]
    },
    {
        key: "shift+alt+o",
        ifMode: "math",
        command: [
            "insert",
            "\\varnothing"
        ]
    },
    {
        key: "shift+alt+d",
        ifMode: "math",
        command: [
            "insert",
            "\\partial"
        ]
    },
    {
        key: "shift+alt+p",
        ifMode: "math",
        command: [
            "insert",
            "\\prod_{i=#?}^{#?}"
        ]
    },
    {
        key: "shift+alt+u",
        ifMode: "math",
        command: [
            "insert",
            "\\bigcup"
        ]
    },
    {
        key: "shift+alt+n",
        ifMode: "math",
        command: [
            "insert",
            "\\bigcap"
        ]
    },
    {
        key: "shift+alt+a",
        ifMode: "math",
        command: [
            "insert",
            "\\forall"
        ]
    },
    {
        key: "shift+alt+e",
        ifMode: "math",
        command: [
            "insert",
            "\\exists"
        ]
    },
    {
        key: "alt+[Backslash]",
        ifMode: "math",
        command: [
            "insert",
            "\\backslash"
        ]
    },
    {
        key: "[NumpadDivide]",
        ifMode: "math",
        command: [
            "insert",
            "\\frac{#@}{#?}"
        ]
    },
    {
        key: "alt+[NumpadDivide]",
        ifMode: "math",
        command: [
            "insert",
            "\\frac{#?}{#@}"
        ]
    },
    {
        key: "shift+alt+k",
        command: "toggleKeystrokeCaption"
    },
    {
        key: "alt+[Space]",
        command: "toggleVirtualKeyboard"
    },
    {
        key: "alt+ctrl+[ArrowUp]",
        command: [
            "speak",
            "all",
            {
                withHighlighting: !1
            }
        ]
    },
    {
        key: "alt+ctrl+[ArrowDown]",
        command: [
            "speak",
            "selection",
            {
                withHighlighting: !1
            }
        ]
    },
    {
        key: "alt+[Equal]",
        ifLayout: [
            "apple.en-intl",
            "windows.en-intl",
            "linux.en"
        ],
        ifMode: "math",
        command: [
            "applyStyle",
            {
                mode: "text"
            }
        ]
    },
    {
        key: "alt+[Equal]",
        ifLayout: [
            "apple.en-intl",
            "windows.en-intl",
            "linux.en"
        ],
        ifMode: "text",
        command: [
            "applyStyle",
            {
                mode: "math"
            }
        ]
    },
    {
        key: "shift+[Quote]",
        ifLayout: [
            "apple.en-intl",
            "windows.en-intl",
            "linux.en"
        ],
        ifMode: "math",
        command: [
            "switchMode",
            "text",
            "",
            ""
        ]
    },
    {
        key: "shift+[Quote]",
        ifLayout: [
            "apple.en-intl",
            "windows.en-intl",
            "linux.en"
        ],
        ifMode: "text",
        command: [
            "switchMode",
            "math",
            "",
            ""
        ]
    },
    {
        key: "/",
        ifMode: "math",
        command: [
            "insert",
            "\\frac{#@}{#?}"
        ]
    },
    {
        key: "alt+/",
        ifLayout: [
            "apple.en-intl",
            "windows.en-intl",
            "linux.en"
        ],
        ifMode: "math",
        command: [
            "insert",
            "\\/"
        ]
    },
    {
        key: "alt+[BracketLeft]",
        ifLayout: [
            "apple.en-intl",
            "windows.en-intl",
            "linux.en"
        ],
        ifMode: "math",
        command: [
            "insert",
            "\\left\\lbrack #0 \\right\\rbrack"
        ]
    },
    {
        key: "ctrl+[Minus]",
        ifLayout: [
            "apple.en-intl",
            "windows.en-intl",
            "linux.en"
        ],
        ifMode: "math",
        command: "moveToSubscript"
    },
    {
        key: "shift+alt+[BracketLeft]",
        ifLayout: [
            "apple.en-intl",
            "windows.en-intl",
            "linux.en"
        ],
        ifMode: "math",
        command: [
            "insert",
            "\\left\\lbrace #0 \\right\\rbrace"
        ]
    },
    {
        key: "ctrl+;",
        ifLayout: [
            "apple.en-intl",
            "windows.en-intl",
            "linux.en"
        ],
        ifMode: "math",
        command: "addRowAfter"
    },
    {
        key: "cmd+;",
        ifLayout: [
            "apple.en-intl",
            "windows.en-intl",
            "linux.en"
        ],
        ifMode: "math",
        command: "addRowAfter"
    },
    {
        key: "shift+ctrl+;",
        ifLayout: [
            "apple.en-intl",
            "windows.en-intl",
            "linux.en"
        ],
        ifMode: "math",
        command: "addRowBefore"
    },
    {
        key: "shift+cmd+;",
        ifLayout: [
            "apple.en-intl",
            "windows.en-intl",
            "linux.en"
        ],
        ifMode: "math",
        command: "addRowBefore"
    },
    {
        key: "ctrl+[Backspace]",
        ifMode: "math",
        command: "removeRow"
    },
    {
        key: "cmd+[Backspace]",
        ifMode: "math",
        command: "removeRow"
    },
    {
        key: "ctrl+[Comma]",
        ifLayout: [
            "apple.en-intl",
            "windows.en-intl",
            "linux.en"
        ],
        ifMode: "math",
        command: "addColumnAfter"
    },
    {
        key: "cmd+[Comma]",
        ifLayout: [
            "apple.en-intl",
            "windows.en-intl",
            "linux.en"
        ],
        ifMode: "math",
        command: "addColumnAfter"
    },
    {
        key: "shift+ctrl+[Comma]",
        ifLayout: [
            "apple.en-intl",
            "windows.en-intl",
            "linux.en"
        ],
        ifMode: "math",
        command: "addColumnBefore"
    },
    {
        key: "shift+cmd+[Comma]",
        ifLayout: [
            "apple.en-intl",
            "windows.en-intl",
            "linux.en"
        ],
        ifMode: "math",
        command: "addColumnBefore"
    },
    {
        key: "shift+[Backspace]",
        ifMode: "math",
        command: "removeColumn"
    },
    {
        key: "alt+[Digit5]",
        ifLayout: [
            "apple.en-intl",
            "windows.en-intl",
            "linux.en"
        ],
        ifMode: "math",
        command: [
            "insert",
            "$\\infty"
        ]
    },
    {
        key: "alt+[Digit6]",
        ifLayout: [
            "apple.en-intl",
            "windows.en-intl",
            "linux.en"
        ],
        ifMode: "math",
        command: [
            "insert",
            "\\wedge"
        ]
    },
    {
        key: "shift+alt+[Digit6]",
        ifLayout: [
            "apple.en-intl",
            "windows.en-intl",
            "linux.en"
        ],
        ifMode: "math",
        command: [
            "insert",
            "\\vee"
        ]
    },
    {
        key: "alt+[Digit9]",
        ifLayout: [
            "apple.en-intl",
            "windows.en-intl",
            "linux.en"
        ],
        ifMode: "math",
        command: [
            "insert",
            "("
        ]
    },
    {
        key: "alt+[Digit0]",
        ifLayout: [
            "apple.en-intl",
            "windows.en-intl",
            "linux.en"
        ],
        ifMode: "math",
        command: [
            "insert",
            ")"
        ]
    },
    {
        key: "alt+|",
        ifLayout: [
            "apple.en-intl",
            "windows.en-intl",
            "linux.en"
        ],
        ifMode: "math",
        command: [
            "insert",
            "|"
        ]
    },
    {
        key: "shift+[Backquote]",
        ifLayout: [
            "apple.en-intl",
            "windows.en-intl",
            "linux.en"
        ],
        ifMode: "math",
        command: [
            "insert",
            "\\~"
        ]
    },
    {
        key: "[Backquote]",
        ifLayout: [
            "windows.french",
            "linux.french"
        ],
        ifMode: "math",
        command: [
            "insert",
            "^2"
        ]
    }
], qn = {
    "\\theta": "alt+q",
    "\\sqrt": [
        "alt+v",
        "ctrl+[Digit2]"
    ],
    "\\pi": "alt+p",
    "\\prod": "shift+alt+p",
    "\\sum": "alt+w",
    "\\int": "alt+b",
    "\\cup": "alt+u",
    "\\cap": "alt+n",
    "\\bigcup": "shift+alt+u",
    "\\bigcap": "shift+alt+n",
    "\\forall": "shift+alt+a",
    "\\exists": "shift+alt+e",
    "\\infty": "alt+[Digit5]",
    "\\wedge": "alt+[Digit6]",
    "\\vee": "shift+alt+[Digit6]",
    "\\differentialD": "alt+d",
    "\\partial": "shift+alt+d",
    "\\frac": "Slash",
    "\\emptyset": "alt+o",
    "\\varnothing": "shift+alt+o",
    "\\~": "~"
};
function In(t) {
    let i = t;
    return e1(i) && (i = i.length > 0 ? i[0] + "(" + i.slice(1).join("") + ")" : ""), i;
}
function On(t, i) {
    let n = [];
    if ("string" == typeof i) {
        const t1 = qn[i];
        e1(t1) ? n = t1.slice() : t1 && n.push(t1);
    }
    const r = In(i), o = new RegExp("^" + r.replace("\\", "\\\\").replace("|", "\\|").replace("*", "\\*").replace("$", "\\$").replace("^", "\\^") + "([^*a-zA-Z]|$)");
    for (const e2 of t)o.test(In(e2.command)) && n.push(e2.key);
    return n.map(Fn);
}
function Fn(e1) {
    var t;
    const i = /macos|ios|/.test(o()), n = e1.split("+");
    let r = "";
    for (const e2 of n)!i && r && (r += '<span class="ML__shortcut-join">+</span>'), e2.startsWith("[Key") ? r += e2.slice(4, 5) : e2.startsWith("Key") ? r += e2.slice(3, 4) : e2.startsWith("[Digit") ? r += e2.slice(6, 7) : e2.startsWith("Digit") ? r += e2.slice(5, 6) : r += null !== (t = ({
        cmd: "⌘",
        meta: i ? "⌘" : "command",
        shift: i ? "⇧" : "shift",
        alt: i ? "⌥" : "alt",
        ctrl: i ? "⌃" : "control",
        "\n": i ? "⏎" : "return",
        "[return]": i ? "⏎" : "return",
        "[enter]": i ? "⌤" : "enter",
        "[tab]": i ? "⇥" : "tab",
        "[escape]": "esc",
        "[backspace]": i ? "⌫" : "backspace",
        "[delete]": i ? "⌦" : "del",
        "[pageup]": i ? "⇞" : "page up",
        "[pagedown]": i ? "⇟" : "page down",
        "[home]": i ? "⤒" : "home",
        "[end]": i ? "⤓" : "end",
        "[space]": "space",
        "[equal]": "=",
        "[minus]": "-",
        "[comma]": ",",
        "[slash]": "/",
        "[backslash]": "\\",
        "[bracketleft]": "[",
        "[bracketright]": "]",
        semicolon: ";",
        period: ".",
        comma: ",",
        minus: "-",
        equal: "=",
        quote: "'",
        bracketLeft: "[",
        bracketRight: "]",
        backslash: "\\",
        intlbackslash: "\\",
        backquote: "`",
        slash: "/",
        numpadmultiply: "* &#128290;",
        numpaddivide: "/ &#128290;",
        numpadsubtract: "- &#128290;",
        numpadadd: "+ &#128290;",
        numpaddecimal: ". &#128290;",
        numpadcomma: ", &#128290;",
        help: "help",
        left: "⇠",
        up: "⇡",
        right: "⇢",
        down: "⇣",
        "[arrowleft]": "⇠",
        "[arrowup]": "⇡",
        "[arrowright]": "⇢",
        "[arrowdown]": "⇣",
        "[digit0]": "0",
        "[digit1]": "1",
        "[digit2]": "2",
        "[digit3]": "3",
        "[digit4]": "4",
        "[digit5]": "5",
        "[digit6]": "6",
        "[digit7]": "7",
        "[digit8]": "8",
        "[digit9]": "9"
    })[e2.toLowerCase()]) && void 0 !== t ? t : e2.toUpperCase();
    return r;
}
function Bn(e1, i) {
    if (e1.ifPlatform && !/^!?(macos|windows|android|ios|chromeos|other)$/.test(e1.ifPlatform)) throw new Error(`Unexpected platform "${e1.ifPlatform}" for keybinding ${e1.key}`);
    if (void 0 !== e1.ifLayout && (0 === i.score || !e1.ifLayout.includes(i.id))) return;
    const n = Mn(e1.key);
    let r = e1.ifPlatform;
    if (n.cmd) {
        if (r && "macos" !== r && "ios" !== r) throw new Error('Unexpected "cmd" modifier with platform "' + r + '"\n"cmd" modifier can only be used with macOS or iOS platform.');
        r || (r = "ios" === o() ? "ios" : "macos"), n.win = !1, n.cmd = !1, n.meta = !0;
    }
    if (n.win) {
        if (r && "windows" !== r) throw new Error('Unexpected "win" modifier with platform "' + r + '"\n"win" modifier can only be used with Windows platform.');
        r = "windows", n.win = !1, n.cmd = !1, n.meta = !0;
    }
    if (r && !function(e1) {
        if (t()) {
            const t1 = o(), i = e1.startsWith("!"), n = e1.endsWith(t1);
            if (i && !n) return !0;
            if (!i && n) return !0;
        }
        return "!other" !== e1 && "other" === e1;
    }(r)) return;
    if (/^\[.+\]$/.test(n.key)) return {
        ...e1,
        ifPlatform: r,
        key: Nn(n)
    };
    const a = function(e1, t) {
        var i;
        const n = {
            shift: !1,
            alt: !1,
            cmd: !1,
            win: !1,
            meta: !1,
            ctrl: !1,
            key: ""
        };
        if (!e1) return n;
        for (const [i1, r] of Object.entries(t.mapping)){
            if (r[0] === e1) return n.key = `[${i1}]`, n;
            if (r[1] === e1) return n.shift = !0, n.key = `[${i1}]`, n;
            if (r[2] === e1) return n.alt = !0, n.key = `[${i1}]`, n;
            if (r[3] === e1) return n.shift = !0, n.alt = !0, n.key = `[${i1}]`, n;
        }
        return n.key = null !== (i = An[e1]) && void 0 !== i ? i : "", n;
    }(n.key, i);
    if (!a) throw new Error('Invalid keybinding key "' + e1.key + '"');
    if (a.shift && n.shift || a.alt && n.alt) throw new Error(`The keybinding ${e1.key} (${$n(e1.command)}) is conflicting with the key combination ${Nn(a)} using the ${i.displayName} keyboard layout`);
    return a.shift = a.shift || n.shift, a.alt = a.alt || n.alt, a.meta = n.meta, a.ctrl = n.ctrl, {
        ...e1,
        ifPlatform: r,
        key: Nn(a)
    };
}
function $n(e1) {
    if (Array.isArray(e1)) {
        const t = [
            ...e1
        ];
        return t.shift() + "(" + t.map((e1)=>"string" == typeof e1 ? `"${e1}"` : e1.toString()).join(", ") + ")";
    }
    return e1;
}
var Pn = '#mathlive-popover-panel{background-color:rgba(97,97,97,.95);border-radius:8px;box-shadow:0 14px 28px rgba(0,0,0,.25),0 10px 10px rgba(0,0,0,.22);color:#fff;display:flex;flex-direction:column;justify-content:center;position:fixed;text-align:center;transition:all .2s cubic-bezier(.64,.09,.08,1);visibility:hidden;z-index:1}#mathlive-popover-panel:after{border-bottom:5px solid rgba(97,97,97,.9);border-left:5px solid transparent;border-right:5px solid transparent;content:"";font-size:1rem;height:0;left:calc(50% - 3px);position:absolute;top:-5px;width:0}#mathlive-popover-panel.is-visible{animation:ML__fade-in .15s cubic-bezier(0,0,.2,1);visibility:inherit}@keyframes ML__fade-in{0%{opacity:0}to{opacity:1}}#mathlive-popover-panel ul{align-items:flex-start;display:flex;flex-flow:column;justify-content:center;list-style:none;margin:0;padding:0}#mathlive-popover-panel li{border-radius:8px;column-gap:1em;cursor:pointer;display:flex;flex-direction:row;justify-content:space-between;margin:8px;padding:8px;width:calc(100% - 32px)}#mathlive-popover-panel li a{color:#5ea6fd;display:block;margin-top:.4em;padding-top:.3em}#mathlive-popover-panel li a:hover{color:#5ea6fd;text-decoration:underline}#mathlive-popover-panel li.is-active,#mathlive-popover-panel li.is-pressed,#mathlive-popover-panel li:hover{background:hsla(0,0%,100%,.1)}.ML__popover__command{font-family:KaTeX_Main;font-size:1.6rem}.ML__popover__latex{align-self:center;font-family:IBM Plex Mono,Source Code Pro,Consolas,Roboto Mono,Menlo,Bitstream Vera Sans Mono,DejaVu Sans Mono,Monaco,Courier,monospace}.ML__popover__keybinding{font-family:system-ui,-apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Oxygen,Ubuntu,Cantarell,Fira Sans,Droid Sans,Helvetica Neue,sans-serif;font-size:.8em;opacity:.7}.ML__shortcut-join{opacity:.5}', Rn = '.ML__sr-only{clip:rect(0,0,0,0);border:0;-webkit-clip-path:inset(50%);clip-path:inset(50%);height:1px;margin:-1px;overflow:hidden;padding:0;position:absolute;white-space:nowrap;width:1px}.ML__base,.ML__isInline{display:inline-block}.ML__base{border:0;box-sizing:content-box;cursor:text;font-family:inherit;font-style:inherit;font-weight:inherit;margin:0;outline:0;padding:0;position:relative;text-decoration:none;vertical-align:baseline;visibility:inherit;width:min-content}body.ML__fonts-loading .ML__base{visibility:hidden}.ML__strut,.ML__strut--bottom{display:inline-block;min-height:.5em}.ML__small-delim{font-family:KaTeX_Main}.ML__text{font-family:var(--text-font-family,system-ui,-apple-system,BlinkMacSystemFont,"Segoe UI","Roboto","Oxygen","Ubuntu","Cantarell","Fira Sans","Droid Sans","Helvetica Neue",sans-serif);white-space:pre}.ML__cmr{font-family:KaTeX_Main;font-style:normal}.ML__mathit{font-family:KaTeX_Math;font-style:italic}.ML__mathbf{font-family:KaTeX_Main;font-weight:700}.lcGreek.ML__mathbf{font-family:KaTeX_Math;font-weight:400}.ML__mathbfit{font-family:KaTeX_Math;font-style:italic;font-weight:700}.ML__ams,.ML__bb{font-family:KaTeX_AMS}.ML__cal{font-family:KaTeX_Caligraphic}.ML__frak{font-family:KaTeX_Fraktur}.ML__tt{font-family:KaTeX_Typewriter}.ML__script{font-family:KaTeX_Script}.ML__sans{font-family:KaTeX_SansSerif}.ML__series_el,.ML__series_ul{font-weight:100}.ML__series_l{font-weight:200}.ML__series_sl{font-weight:300}.ML__series_sb{font-weight:500}.ML__bold,.ML__boldsymbol{font-weight:700}.ML__series_eb{font-weight:800}.ML__series_ub{font-weight:900}.ML__series_uc{font-stretch:ultra-condensed}.ML__series_ec{font-stretch:extra-condensed}.ML__series_c{font-stretch:condensed}.ML__series_sc{font-stretch:semi-condensed}.ML__series_sx{font-stretch:semi-expanded}.ML__series_x{font-stretch:expanded}.ML__series_ex{font-stretch:extra-expanded}.ML__series_ux{font-stretch:ultra-expanded}.ML__it{font-style:italic}.ML__shape_ol{-webkit-text-stroke:1px #000;text-stroke:1px #000;color:transparent}.ML__shape_sc{font-variant:small-caps}.ML__shape_sl{font-style:oblique}.ML__emph{color:#bc2612}.ML__emph .ML__emph{color:#0c7f99}.ML__highlight{background:#edd1b0;color:#007cb2}.ML__center{text-align:center}.ML__label_padding{padding:0 .5em}.ML__frac-line{min-height:1px;width:100%}.ML__frac-line:after{background:currentColor;box-sizing:content-box;content:"";display:block;margin-top:-.04em;min-height:.04em;transform:translate(0)}.ML__sqrt,.ML__sqrt-sign{display:inline-block}.ML__sqrt-sign{font-family:KaTeX_Main;position:relative}.ML__sqrt-line{display:inline-block;height:.04em;width:100%}.ML__sqrt-line:before{background:currentColor;content:"";display:block;margin-top:-.04em;min-height:.04em;transform:translate(0)}.ML__sqrt-line:after{border-bottom-width:1px;content:" ";display:block;margin-top:-.1em}.ML__sqrt-index{margin-left:.27777778em;margin-right:-.55555556em}.ML__delim-size1{font-family:KaTeX_Size1}.ML__delim-size2{font-family:KaTeX_Size2}.ML__delim-size3{font-family:KaTeX_Size3}.ML__delim-size4{font-family:KaTeX_Size4}.ML__delim-mult .delim-size1>span{font-family:KaTeX_Size1}.ML__delim-mult .delim-size4>span{font-family:KaTeX_Size4}.ML__accent-body>span{font-family:KaTeX_Main;width:0}.ML__accent-vec>span{left:.24em;position:relative}.ML__mathlive{word-wrap:normal;direction:ltr;display:inline-block;font-family:KaTeX_Main,Times New Roman,serif;font-size-adjust:none;font-stretch:normal;font-style:normal;font-variant-caps:normal;letter-spacing:normal;line-height:1.2;text-align:left;text-indent:0;text-rendering:auto;text-shadow:none;-webkit-user-select:none;user-select:none;white-space:nowrap;width:min-content;word-spacing:normal}.ML__mathlive .style-wrap{position:relative}.ML__mathlive .left-right,.ML__mathlive .mfrac{display:inline-block}.ML__mathlive .vlist-t{border-collapse:collapse;display:inline-table;table-layout:fixed}.ML__mathlive .vlist-r{display:table-row}.ML__mathlive .vlist{display:table-cell;position:relative;vertical-align:bottom}.ML__mathlive .vlist>span{display:block;height:0;position:relative}.ML__mathlive .vlist>span>span{display:inline-block}.ML__mathlive .vlist>span>.pstrut{overflow:hidden;width:0}.ML__mathlive .vlist-t2{margin-right:-2px}.ML__mathlive .vlist-s{display:table-cell;font-size:1px;min-width:2px;vertical-align:bottom;width:2px}.ML__mathlive .msubsup{text-align:left}.ML__mathlive .negativethinspace{display:inline-block;height:.71em;margin-left:-.16667em}.ML__mathlive .thinspace{display:inline-block;height:.71em;width:.16667em}.ML__mathlive .mediumspace{display:inline-block;height:.71em;width:.22222em}.ML__mathlive .thickspace{display:inline-block;height:.71em;width:.27778em}.ML__mathlive .enspace{display:inline-block;height:.71em;width:.5em}.ML__mathlive .quad{display:inline-block;height:.71em;width:1em}.ML__mathlive .qquad{display:inline-block;height:.71em;width:2em}.ML__mathlive .llap,.ML__mathlive .rlap{display:inline-block;position:relative;width:0}.ML__mathlive .llap>.inner,.ML__mathlive .rlap>.inner{position:absolute}.ML__mathlive .llap>.fix,.ML__mathlive .rlap>.fix{display:inline-block}.ML__mathlive .llap>.inner{right:0}.ML__mathlive .rlap>.inner{left:0}.ML__mathlive .rule{border:0 solid;box-sizing:border-box;display:inline-block;position:relative}.ML__mathlive .overline .overline-line,.ML__mathlive .underline .underline-line{width:100%}.ML__mathlive .overline .overline-line:before,.ML__mathlive .underline .underline-line:before{border-bottom-style:solid;border-bottom-width:.04em;content:"";display:block}.ML__mathlive .overline .overline-line:after,.ML__mathlive .underline .underline-line:after{border-bottom-style:solid;border-bottom-width:.04em;content:"";display:block;margin-top:-1px;min-height:thin}.ML__mathlive .stretchy{display:block;left:0;overflow:hidden;position:absolute;width:100%}.ML__mathlive .stretchy:after,.ML__mathlive .stretchy:before{content:""}.ML__mathlive .stretchy svg{fill:currentColor;stroke:currentColor;fill-rule:nonzero;fill-opacity:1;stroke-width:1;stroke-linecap:butt;stroke-linejoin:miter;stroke-miterlimit:4;stroke-dasharray:none;stroke-dashoffset:0;stroke-opacity:1;display:block;height:inherit;position:absolute;width:100%}.ML__mathlive .slice-1-of-2{left:0}.ML__mathlive .slice-1-of-2,.ML__mathlive .slice-2-of-2{display:inline-flex;overflow:hidden;position:absolute;width:50.2%}.ML__mathlive .slice-2-of-2{right:0}.ML__mathlive .slice-1-of-3{display:inline-flex;left:0;overflow:hidden;position:absolute;width:25.1%}.ML__mathlive .slice-2-of-3{display:inline-flex;left:25%;overflow:hidden;position:absolute;width:50%}.ML__mathlive .slice-3-of-3{display:inline-flex;overflow:hidden;position:absolute;right:0;width:25.1%}.ML__mathlive .slice-1-of-1{display:inline-flex;left:0;overflow:hidden;position:absolute;width:100%}.ML__mathlive .nulldelimiter{display:inline-block;width:.12em}.ML__mathlive .op-group{display:inline-block}.ML__mathlive .op-symbol{position:relative}.ML__mathlive .op-symbol.small-op{font-family:KaTeX_Size1}.ML__mathlive .op-symbol.large-op{font-family:KaTeX_Size2}.ML__mathlive .accent>.vlist>span{text-align:center}.ML__mathlive .mtable .vertical-separator{box-sizing:border-box;display:inline-block;min-width:1px}.ML__mathlive .mtable .arraycolsep{display:inline-block}.ML__mathlive .mtable .col-align-m>.vlist-t{text-align:center}.ML__mathlive .mtable .col-align-c>.vlist-t{text-align:center}.ML__mathlive .mtable .col-align-l>.vlist-t{text-align:left}.ML__mathlive .mtable .col-align-r>.vlist-t{text-align:right}.ML__error{background-color:rgba(204,0,65,.1);background-image:radial-gradient(ellipse at center,#cc0041,transparent 70%);background-position:0 100%;background-repeat:repeat-x;background-size:3px 3px;display:inline-block;padding-bottom:3px}.ML__error>.ML__error{background:transparent;padding:0}.ML__composition{background:#fff1c2;color:#000;-webkit-text-decoration:underline var(--caret-color-computed,var(--ML__caret-color));text-decoration:underline var(--caret-color-computed,var(--ML__caret-color))}@media (prefers-color-scheme:dark){.ML__composition{background:#69571c;color:#fff}}.ML__placeholder{color:var(--placeholder-color,var(--ML__placeholder-color));font-family:system-ui,-apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Oxygen,Ubuntu,Cantarell,Fira Sans,Droid Sans,Helvetica Neue,sans-serif;opacity:var(--placeholder-opacity,.4);padding-left:.4ex;padding-right:.4ex}.ML__placeholdercontainer{display:none}.ML__placeholdercontainer math-field{border:1px solid var(--editable-border);border-radius:4px;display:inline-block;min-width:32px;padding-left:4px;padding-right:4px;position:absolute;z-index:1001}.ML__isReadOnly .ML__placeholdercontainer{display:block}.ML__container{min-height:auto!important}';
function Kn(e1) {
    var t;
    "function" != typeof (null === (t = e1.listeners) || void 0 === t ? void 0 : t.onSelectionDidChange) || e1.suppressChangeNotifications || (e1.suppressChangeNotifications = !0, e1.listeners.onSelectionDidChange(e1), e1.suppressChangeNotifications = !1);
}
function Vn(e1, t = {}) {
    if (e1.suppressChangeNotifications || !e1.mathfield.host) return !0;
    e1.suppressChangeNotifications = !0;
    const i = e1.mathfield.host.dispatchEvent(new InputEvent("beforeinput", {
        ...t,
        cancelable: !0,
        bubbles: !0,
        composed: !0
    }));
    return e1.suppressChangeNotifications = !1, i;
}
function jn(e1, t) {
    !e1.suppressChangeNotifications && e1.mathfield.host && (e1.suppressChangeNotifications = !0, e1.mathfield.host.dispatchEvent(new InputEvent("input", {
        ...t,
        bubbles: !0,
        composed: !0
    })), e1.suppressChangeNotifications = !1);
}
function Hn(e1) {
    var t, i;
    const n = e1.atoms.find((e1)=>e1 instanceof Qt);
    return n && null !== (i = null === (t = n.body) || void 0 === t ? void 0 : t.filter((e1)=>e1 instanceof Yt)) && void 0 !== i ? i : [];
}
function Un(e1, t) {
    var i;
    let n = 0, r = !1;
    const o = Number.isFinite(null == t ? void 0 : t.before) ? null !== (i = null == t ? void 0 : t.before) && void 0 !== i ? i : 0 : e1.lastOffset;
    for(; n <= o && !r;){
        const t1 = e1.at(n);
        r = t1 instanceof Yt && t1.isSuggestion, r || n++;
    }
    if (!r) return [
        void 0,
        void 0
    ];
    let a = n, s = !1;
    for(; a <= o && !s;){
        const t2 = e1.at(a);
        s = !(t2 instanceof Yt && t2.isSuggestion), s || a++;
    }
    return [
        n - 1,
        a - 1
    ];
}
function Gn(e1) {
    const t = Hn(e1.model).filter((e1)=>e1.isSuggestion);
    if (0 !== t.length) {
        e1.model.position = e1.model.offsetOf(t[0].leftSibling);
        for (const e2 of t)e2.parent.removeChild(e2);
    }
}
function Zn(e1, t) {
    var i;
    const { model: n  } = e1;
    Gn(e1);
    for (const e2 of Hn(n))e2.isError = !1;
    if (!n.selectionIsCollapsed) return void nr(e1);
    const r = [];
    let o = n.at(n.position);
    for(; o && o instanceof Yt && /^[a-zA-Z\*]$/.test(o.value);)o = o.leftSibling;
    if (o && o instanceof Yt && "\\" === o.value) for(r.push(o), o = o.rightSibling; o && o instanceof Yt && /^[a-zA-Z\*]$/.test(o.value);)r.push(o), o = o.rightSibling;
    const a = r.map((e1)=>e1.value).join(""), s = a ? function(e1, t) {
        var i, n;
        if ("\\" === t) return [];
        if (!t.startsWith("\\")) return [];
        const r = [];
        for(const e2 in _)e2.startsWith(t) && !_[e2].infix && r.push({
            match: e2,
            frequency: null !== (i = _[e2].frequency) && void 0 !== i ? i : 0
        });
        for(const e3 in x)e3.startsWith(t) && r.push({
            match: e3,
            frequency: null !== (n = x[e3].frequency) && void 0 !== n ? n : 0
        });
        const o = t.substring(1);
        for (const t1 of Object.keys(e1.options.macros))t1.startsWith(o) && r.push({
            match: "\\" + t1,
            frequency: 0
        });
        return r.sort((e1, t)=>{
            var i, n;
            return e1.frequency === t.frequency ? e1.match.length === t.match.length ? e1.match < t.match ? -1 : 1 : e1.match.length - t.match.length : (null !== (i = t.frequency) && void 0 !== i ? i : 0) - (null !== (n = e1.frequency) && void 0 !== n ? n : 0);
        }), r.map((e1)=>e1.match);
    }(e1, a) : [];
    if (0 === s.length) return /^\\[a-zA-Z\*]+$/.test(a) && r.forEach((e1)=>{
        e1.isError = !0;
    }), void nr(e1);
    e1.suggestionIndex = null !== (i = null == t ? void 0 : t.atIndex) && void 0 !== i ? i : 0, e1.suggestionIndex < 0 && (e1.suggestionIndex = s.length - 1);
    const l = s[e1.suggestionIndex % s.length];
    if (l !== a) {
        const t1 = r[r.length - 1];
        t1.parent.addChildrenAfter([
            ...l.slice(a.length - l.length)
        ].map((t)=>new Yt(t, e1, {
                isSuggestion: !0
            })), t1), or(e1);
    }
    !function(e1, t) {
        if (0 === t.length || !1 === e1.options.enablePopover) return void nr(e1);
        t = t.slice(0, 10);
        let i = "<ul>";
        for (const n of t){
            const t1 = n, r = er(e1, n), o = On(e1.keybindings, t1).join("<br>");
            i += `<li role="button" data-command="${t1}"><span class="ML__popover__latex">${t1}</span><span class="ML__popover__command">${r}</span>`, o && (i += `<span class="ML__popover__keybinding">${o}</span>`), i += "</li>";
        }
        i += "</ul>", e1.popover = function(e1, t) {
            return e1.popover ? (e1.popover.innerHTML = e1.options.createHTML(t), e1.popover) : (e1.popover = rn("mathlive-popover-panel"), void 0 === Xn && (Xn = wn(Pn).toString(36)), Yn = Sn(null, Pn, Xn), Qn = Sn(null, Rn, wn(Rn).toString(36)), e1.popover.innerHTML = e1.options.createHTML(t), e1.popover);
        }(e1, i);
        const n1 = e1.popover.querySelectorAll("ul li");
        for (const t2 of n1)t2.addEventListener("pointerdown", (e1)=>{
            e1.preventDefault();
        }), t2.addEventListener("click", (i)=>{
            Jn(e1, "reject"), qi.insert("math", e1.model, t2.dataset.command, {
                selectionMode: "placeholder",
                format: "latex"
            }), e1.dirty = !0, e1.scrollIntoView(), e1.focus();
        });
        setTimeout(()=>{
            const t = sn(e1.field);
            t && ir(e1, t), e1.popover && (e1.popover.classList.add("is-visible"), e1.popoverVisible = !0);
        }, 32);
    }(e1, s);
}
function Wn(e1) {
    const [t, i] = Un(e1, {
        before: e1.position
    });
    if (void 0 === t || void 0 === i) return !1;
    let n = !1;
    return e1.getAtoms([
        t,
        i
    ]).forEach((e1)=>{
        e1.isSuggestion && (e1.isSuggestion = !1, n = !0);
    }), n;
}
function Jn(e1, t = "accept", i) {
    var n, r;
    nr(e1);
    const o = e1.model.atoms.find((e1)=>e1 instanceof Qt);
    if (!o) return !1;
    if ("accept-suggestion" === t) {
        const t1 = Hn(e1.model).filter((e1)=>e1.isSuggestion);
        if (0 === t1.length) return !1;
        for (const e2 of t1)e2.isSuggestion = !1;
        return e1.model.position = e1.model.offsetOf(t1[t1.length - 1]), !0;
    }
    const a = Hn(e1.model).filter((e1)=>!e1.isSuggestion), s = a.map((e1)=>e1.value).join(""), l = o.leftSibling;
    return o.parent.removeChild(o), e1.model.position = e1.model.offsetOf(l), e1.mode = null !== (n = null == i ? void 0 : i.mode) && void 0 !== n ? n : "math", "reject" === t || (qi.insert("math", e1.model, s, {
        selectionMode: null !== (r = null == i ? void 0 : i.selectItem) && void 0 !== r && r ? "item" : "placeholder",
        format: "latex"
    }), e1.snapshot(), e1.model.announce("replacement")), !0;
}
let Xn;
new class extends qi {
    createAtom(e1, t, i) {
        return new Yt(e1, t);
    }
    onPaste(e1, t) {
        if (!t.clipboardData) return !1;
        let i = t.clipboardData.getData("text/x-latex");
        return i || (i = t.clipboardData.getData("text/plain")), !(!i || !Vn(e1.model, {
            inputType: "insertFromPaste",
            data: i
        }) || (e1.snapshot(), this.insert(e1.model, i) && (jn(e1.model, {
            inputType: "insertFromPaste"
        }), or(e1)), t.preventDefault(), t.stopPropagation(), 0));
    }
    insert(e1, t, i) {
        if (!Vn(e1, {
            data: t,
            inputType: "insertText"
        })) return !1;
        i || (i = {}), i.insertionMode || (i.insertionMode = "replaceSelection"), i.selectionMode || (i.selectionMode = "placeholder");
        const { suppressChangeNotifications: n  } = e1;
        i.suppressChangeNotifications && (e1.suppressChangeNotifications = !0);
        const r = e1.suppressChangeNotifications;
        e1.suppressChangeNotifications = !0, "replaceSelection" !== i.insertionMode || e1.selectionIsCollapsed ? "replaceAll" === i.insertionMode ? (e1.root.setChildren([], "body"), e1.position = 0) : "insertBefore" === i.insertionMode ? e1.collapseSelection("backward") : "insertAfter" === i.insertionMode && e1.collapseSelection("forward") : e1.deleteAtoms(Si(e1.selection));
        const o = [];
        for (const i1 of t)N.test(i1) && o.push(new Yt(i1, e1.mathfield));
        let a = e1.at(e1.position);
        if (a instanceof Qt && (a = a.lastChild), !(a.parent instanceof Qt)) {
            const t1 = new Qt("", e1.mathfield);
            a.parent.addChildAfter(t1, a), a = t1.firstChild;
        }
        const s = a.parent.addChildrenAfter(o, a);
        return e1.suppressChangeNotifications = r, "before" === i.selectionMode || ("item" === i.selectionMode ? e1.setSelection(e1.anchor, e1.offsetOf(s)) : s && (e1.position = e1.offsetOf(s))), jn(e1, {
            data: t,
            inputType: "insertText"
        }), e1.suppressChangeNotifications = n, !0;
    }
    constructor(){
        super("latex");
    }
};
let Yn = null, Qn = null;
function er(e1, t) {
    const i = e1, n = new ot("root", i);
    return n.body = It(t, i, {
        parseMode: "math"
    }), Re(Fe(Pe(new Ie(n.render(new Me({
        registers: i.registers
    }, {
        fontSize: 5
    }, "displaystyle")), {
        classes: "ML__base"
    }))), {
        classes: "ML__mathlive"
    }).toMarkup();
}
function tr(e1, t) {
    var i;
    if (e1.element && e1.element.mathfield === e1 && e1.popover && e1.popoverVisible) {
        if (null == t ? void 0 : t.deferred) setTimeout(()=>tr(e1), 100);
        else if ("latex" !== (null === (i = e1.model.at(e1.model.position)) || void 0 === i ? void 0 : i.type)) nr(e1);
        else {
            const t1 = sn(e1.field);
            t1 && ir(e1, t1);
        }
    }
}
function ir(e1, t) {
    if (i(), !e1.popover || !e1.popoverVisible) return;
    const n = window.innerHeight || document.documentElement.clientHeight || document.body.clientHeight, r = window.innerWidth || document.documentElement.clientWidth || document.body.clientWidth, o = window.innerWidth - document.documentElement.clientWidth, a = window.innerHeight - document.documentElement.clientHeight, s = e1.virtualKeyboard.height;
    t.x + e1.popover.offsetWidth / 2 > r - o ? e1.popover.style.left = r - e1.popover.offsetWidth - o + "px" : t.x - e1.popover.offsetWidth / 2 < 0 ? e1.popover.style.left = "0" : e1.popover.style.left = t.x - e1.popover.offsetWidth / 2 + "px", t.y + e1.popover.offsetHeight + 5 > n - a - s ? (e1.popover.classList.add("ML__popover--reverse-direction"), e1.popover.style.top = t.y - t.height - e1.popover.offsetHeight - 5 + "px") : (e1.popover.classList.remove("ML__popover--reverse-direction"), e1.popover.style.top = `${t.y + 5}px`);
}
function nr(e1) {
    e1.suggestionIndex = 0, e1.popoverVisible = !1, e1.popover && (e1.popover.classList.remove("is-visible"), e1.popover.innerHTML = "");
}
function rr(e1) {
    let t = 0;
    for(let i = 0; i < e1.length; i++)t = 31 * t + e1.charCodeAt(i), t |= 0;
    return Math.abs(t);
}
function or(e1, t) {
    e1.dirty || (e1.dirty = !0, requestAnimationFrame(()=>{
        an(e1) && e1.dirty && (e1.atomBoundsCache = new Map, ar(e1, t), e1.atomBoundsCache = void 0);
    }));
}
function ar(e1, t) {
    var n, r;
    if (i(), !an(e1)) return;
    t = null != t ? t : {}, e1.dirty = !1;
    const { model: o  } = e1;
    o.root.caret = "", o.root.isSelected = !1, o.root.containsCaret = !0;
    for (const e2 of o.atoms)e2.caret = "", e2.isSelected = !1, e2.containsCaret = !1;
    const a = !e1.options.readOnly && e1.hasFocus();
    if (o.selectionIsCollapsed) o.at(o.position).caret = a ? e1.mode : "";
    else {
        const e3 = o.getAtoms(o.selection, {
            includeChildren: !0
        });
        for (const t1 of e3)t1.isSelected = !0;
    }
    if (a) {
        let e4 = o.at(o.position).parent;
        for(; e4;)e4.containsCaret = !0, e4 = e4.parent;
    }
    const s = o.root.render(new Me({
        registers: e1.registers,
        atomIdsSettings: {
            seed: t.forHighlighting ? rr(ot.serialize(o.root, {
                expandMacro: !1,
                defaultMode: e1.options.defaultMode
            })) : "random",
            groupNumbers: null !== (n = t.forHighlighting) && void 0 !== n && n
        },
        renderPlaceholder: e1.options.readOnly ? (t, i)=>{
            if (i.placeholderId) {
                const n = e1.getPlaceholderField(i.placeholderId);
                return i.createMathfieldBox(t, {
                    placeholderId: i.placeholderId,
                    element: n
                });
            }
            return i.createBox(t);
        } : void 0
    }, {
        fontSize: 5,
        letterShapeStyle: e1.options.letterShapeStyle
    }, "inline-math" === e1.options.defaultMode ? "textstyle" : "displaystyle")), l = Re(Pe(s, e1.options.horizontalSpacingScale), {
        classes: "ML__mathlive",
        attributes: {
            translate: "no",
            "aria-hidden": "true"
        }
    }), u = e1.field, c = u.classList.contains("ML__focused");
    c && !a ? u.classList.remove("ML__focused") : !c && a && u.classList.add("ML__focused"), u.innerHTML = e1.options.createHTML(l.toMarkup()), e1.fieldContent = u.querySelector(".ML__mathlive"), e1.accessibleNode.innerHTML = e1.options.createHTML('<math xmlns="http://www.w3.org/1998/Math/MathML">' + Wi(o.root, e1.options) + "</math>"), sr(e1), e1.options.readOnly && e1.attachNestedMathfield(), null !== (r = t.interactive) && void 0 !== r && r || setTimeout(()=>sr(e1), 32);
}
function sr(e1) {
    i();
    const t = e1.field;
    if (!t) return;
    for (const e2 of t.querySelectorAll(".ML__selection, .ML__contains-highlight"))e2.remove();
    if (!e1.hasFocus()) return;
    const n = e1.model, r = parseFloat(getComputedStyle(t).width);
    let o = t.getBoundingClientRect().width / r;
    if (o = isNaN(o) ? 1 : o, n.selectionIsCollapsed) {
        setTimeout(()=>tr(e1), 32);
        let i1 = n.at(n.position);
        for(; i1 && (!i1.containsCaret || !i1.displayContainsHighlight);)i1 = i1.parent;
        if ((null == i1 ? void 0 : i1.containsCaret) && i1.displayContainsHighlight) {
            const n1 = un(e1, dn(e1, i1));
            if (n1) {
                n1.left /= o, n1.right /= o, n1.top /= o, n1.bottom /= o;
                const e3 = document.createElement("div");
                e3.classList.add("ML__contains-highlight"), e3.style.position = "absolute", e3.style.left = `${n1.left}px`, e3.style.top = `${n1.top}px`, e3.style.width = `${Math.ceil(n1.right - n1.left)}px`, e3.style.height = `${Math.ceil(n1.bottom - n1.top - 1)}px`, t.insertBefore(e3, t.childNodes[0]);
            }
        }
    } else for (const i2 of function(e1) {
        let t = [];
        for (const i of e1){
            let e2 = !1;
            for (const n of t)if (i.left === n.left && i.right === n.right && i.top === n.top && i.bottom === n.bottom) {
                e2 = !0;
                break;
            }
            e2 || t.push(i);
        }
        e1 = t, t = [];
        for (const i1 of e1){
            let n1 = 0;
            for (const t1 of e1)if (i1.left >= t1.left && i1.right <= t1.right && i1.top >= t1.top && i1.bottom <= t1.bottom && (n1 += 1, n1 > 1)) break;
            1 === n1 && t.push(i1);
        }
        return t;
    }(hn(e1, {
        excludeAtomsWithBackground: !0
    }))){
        i2.left /= o, i2.right /= o, i2.top /= o, i2.bottom /= o;
        const e4 = document.createElement("div");
        e4.classList.add("ML__selection"), e4.style.position = "absolute", e4.style.left = `${i2.left}px`, e4.style.top = `${i2.top}px`, e4.style.width = `${Math.ceil(i2.right - i2.left)}px`, e4.style.height = `${Math.ceil(i2.bottom - i2.top - 1)}px`, t.insertBefore(e4, t.childNodes[0]);
    }
}
const lr = {};
function ur(e1, t) {
    t = null != t ? t : {
        target: "mathfield",
        canUndo: !1
    };
    for (const i of Object.keys(e1))lr[i] = {
        ...t,
        fn: e1[i]
    };
}
function cr(t) {
    var i;
    let n;
    return n = e1(t) ? t[0] : t, n = n.replace(/-\w/g, (e1)=>e1[1].toUpperCase()), null === (i = lr[n]) || void 0 === i ? void 0 : i.target;
}
function dr(e1, t, i) {
    return t + en(i, {
        ...e1,
        textToSpeechMarkup: "",
        textToSpeechRulesOptions: {
            ...e1.textToSpeechRulesOptions,
            markup: "none"
        }
    });
}
function hr(e1, i) {
    var n, r, o;
    if (t() && (null != i || (i = null !== (n = gm().config) && void 0 !== n ? n : {}), i)) {
        if (i.speechEngine && "local" !== i.speechEngine) {
            if ("amazon" === i.speechEngine) {
                if ("AWS" in window) {
                    const t1 = new globalThis.AWS.Polly({
                        apiVersion: "2016-06-10"
                    }), n1 = {
                        OutputFormat: "mp3",
                        VoiceId: null !== (r = i.speechEngineVoice) && void 0 !== r ? r : "Joanna",
                        Engine: [
                            "Amy",
                            "Emma",
                            "Brian",
                            "Ivy",
                            "Joanna",
                            "Kendra",
                            "Kimberly",
                            "Salli",
                            "Joey",
                            "Justin",
                            "Matthew"
                        ].includes(null !== (o = i.speechEngineVoice) && void 0 !== o ? o : "Joanna") ? "neural" : "standard",
                        Text: e1,
                        TextType: "ssml"
                    };
                    t1.synthesizeSpeech(n1, (e1, t)=>{
                        if (e1) ;
                        else if (null == t ? void 0 : t.AudioStream) {
                            const e2 = new Uint8Array(t.AudioStream), i = new Blob([
                                e2.buffer
                            ], {
                                type: "audio/mpeg"
                            }), n = URL.createObjectURL(i);
                            new Audio(n).play().catch((e1)=>{});
                        }
                    });
                }
            } else i.speechEngine;
        } else {
            const t2 = new SpeechSynthesisUtterance(e1);
            window.speechSynthesis.speak(t2);
        }
    }
}
function mr(e1) {
    if (e1 && (e1.classList.remove("ML__highlight"), e1.children)) for (const t of e1.children)mr(t);
}
function pr(e1, t) {
    var i;
    e1 && (t && (null === (i = e1.dataset) || void 0 === i ? void 0 : i.atomId) !== t ? (e1.classList.remove("ML__highlight"), e1.children && e1.children.length > 0 && [
        ...e1.children
    ].forEach((e1)=>{
        e1 instanceof HTMLElement && pr(e1, t);
    })) : (e1.classList.add("ML__highlight"), e1.children && e1.children.length > 0 && [
        ...e1.children
    ].forEach((e1)=>{
        e1 instanceof HTMLElement && pr(e1);
    })));
}
function fr(e1, i, n) {
    var r;
    if (!t()) return;
    if (null != n || (n = gm().config), "amazon" !== n.speechEngine) return void (n.speakHook && n.speakHook(i, n));
    if (!globalThis.AWS) return;
    const o = new globalThis.AWS.Polly({
        apiVersion: "2016-06-10"
    }), a = {
        OutputFormat: "json",
        VoiceId: null !== (r = n.speechEngineVoice) && void 0 !== r ? r : "Joanna",
        Engine: "standard",
        Text: i,
        TextType: "ssml",
        SpeechMarkTypes: [
            "ssml"
        ]
    };
    gm().readAloudElement = e1, o.synthesizeSpeech(a, (e1, t)=>{
        if (e1) return;
        if (!(null == t ? void 0 : t.AudioStream)) return;
        const i = new TextDecoder("utf-8").decode(new Uint8Array(t.AudioStream));
        gm().readAloudMarks = i.split("\n").map((e1)=>e1 ? JSON.parse(e1) : {}), gm().readAloudTokens = [];
        for (const e2 of gm().readAloudMarks)e2.value && gm().readAloudTokens.push(e2.value);
        gm().readAloudCurrentMark = "", a.OutputFormat = "mp3", a.SpeechMarkTypes = [], o.synthesizeSpeech(a, (e1, t)=>{
            if (e1) return;
            if (!(null == t ? void 0 : t.AudioStream)) return;
            const i = new Uint8Array(t.AudioStream), n = new Blob([
                i.buffer
            ], {
                type: "audio/mpeg"
            }), r = URL.createObjectURL(n), o = gm();
            o.readAloudAudio ? o.readAloudAudio.pause() : (o.readAloudAudio = new Audio, o.readAloudAudio.addEventListener("ended", ()=>{
                const e1 = o.readAloudMathField;
                o.readAloudStatus = "ended", document.body.dispatchEvent(new Event("read-aloud-status-change", {
                    bubbles: !0,
                    composed: !0
                })), e1 ? (ar(e1), o.readAloudElement = null, o.readAloudMathField = null, o.readAloudTokens = [], o.readAloudMarks = [], o.readAloudCurrentMark = "") : mr(o.readAloudElement);
            }), o.readAloudAudio.addEventListener("timeupdate", ()=>{
                let e1 = "";
                const t = 1e3 * o.readAloudAudio.currentTime + 100;
                for (const i of o.readAloudMarks)i.time < t && (e1 = i.value);
                o.readAloudCurrentMark !== e1 && (o.readAloudCurrentToken = e1, e1 && e1 === o.readAloudFinalToken ? o.readAloudAudio.pause() : (o.readAloudCurrentMark = e1, pr(o.readAloudElement, o.readAloudCurrentMark)));
            })), o.readAloudAudio.src = r, o.readAloudStatus = "playing", document.body.dispatchEvent(new Event("read-aloud-status-change", {
                bubbles: !0,
                composed: !0
            })), o.readAloudAudio.play();
        });
    });
}
function gr(i, r) {
    var o, a, l;
    const u = yr(i, Object.keys(i));
    for (const i1 of Object.keys(r))switch(i1){
        case "scriptDepth":
            if (e1(r.scriptDepth)) u.scriptDepth = [
                r.scriptDepth[0],
                r.scriptDepth[1]
            ];
            else {
                if ("number" != typeof r.scriptDepth) throw new TypeError("Unexpected value for scriptDepth");
                u.scriptDepth = [
                    r.scriptDepth,
                    r.scriptDepth
                ];
            }
            break;
        case "locale":
            "auto" === r.locale ? u.locale = t() ? navigator.language.slice(0, 5) : "en" : u.locale = r.locale, s.locale = u.locale;
            break;
        case "strings":
            s.merge(r.strings), u.strings = s.strings;
            break;
        case "virtualKeyboardLayout":
            u.virtualKeyboardLayout = r.virtualKeyboardLayout;
            break;
        case "virtualKeyboardMode":
            const c = r.virtualKeyboardMode.toLowerCase();
            u.virtualKeyboardMode = "auto" === c ? n() ? "onfocus" : "off" : c;
            break;
        case "customVirtualKeyboardLayers":
            u.customVirtualKeyboardLayers = {
                ...u.customVirtualKeyboardLayers,
                ...r.customVirtualKeyboardLayers
            };
            break;
        case "customVirtualKeyboards":
            u.customVirtualKeyboards = {
                ...u.customVirtualKeyboards,
                ...r.customVirtualKeyboards
            };
            break;
        case "letterShapeStyle":
            "auto" === r.letterShapeStyle ? s.locale.startsWith("fr") ? u.letterShapeStyle = "french" : u.letterShapeStyle = "tex" : u.letterShapeStyle = r.letterShapeStyle;
            break;
        case "plonkSound":
            void 0 !== r.plonkSound && (u.plonkSound = r.plonkSound);
            break;
        case "keypressSound":
            null === r.keypressSound ? u.keypressSound = {
                default: null,
                delete: null,
                return: null,
                spacebar: null
            } : "string" == typeof r.keypressSound ? u.keypressSound = {
                delete: r.keypressSound,
                return: r.keypressSound,
                spacebar: r.keypressSound,
                default: r.keypressSound
            } : "object" == typeof r.keypressSound && "default" in r.keypressSound && (u.keypressSound = {
                ...r.keypressSound
            }, u.keypressSound.delete = null !== (o = u.keypressSound.delete) && void 0 !== o ? o : r.keypressSound.default, u.keypressSound.return = null !== (a = u.keypressSound.return) && void 0 !== a ? a : r.keypressSound.default, u.keypressSound.spacebar = null !== (l = u.keypressSound.spacebar) && void 0 !== l ? l : r.keypressSound.default);
            break;
        case "computeEngine":
            u.computeEngine = r.computeEngine;
            break;
        case "virtualKeyboardContainer":
            u.virtualKeyboardContainer = r.virtualKeyboardContainer;
            break;
        case "macros":
            u.macros = j(r.macros);
            break;
        default:
            e1(r[i1]) ? u[i1] = [
                ...r[i1]
            ] : "object" == typeof r[i1] ? u[i1] = {
                ...r[i1]
            } : u[i1] = r[i1];
    }
    return u;
}
function yr(t, i) {
    let n;
    n = "string" == typeof i ? [
        i
    ] : void 0 === i ? Object.keys(t) : i;
    const r = {};
    for (const i1 of n)e1(t[i1]) ? r[i1] = [
        ...t[i1]
    ] : t[i1] instanceof HTMLElement ? r[i1] = t[i1] : null === t[i1] ? r[i1] = null : "object" == typeof t[i1] ? r[i1] = {
        ...t[i1]
    } : r[i1] = t[i1];
    return "string" == typeof i ? r[i] : r;
}
ur({
    performWithFeedback: (e1, t)=>(function(e1, t) {
            e1.focus(), e1.options.keypressVibration && r() && navigator.vibrate(3), t = t.replace(/-\w/g, (e1)=>e1[1].toUpperCase()), "moveToNextPlaceholder" === t || "moveToPreviousPlaceholder" === t || "complete" === t ? e1.playSound("return") : "deleteBackward" === t || "deleteForward" === t || "deletePreviousWord" === t || "deleteNextWord" === t || "deleteToGroupStart" === t || "deleteToGroupEnd" === t || "deleteToMathFieldStart" === t || "deleteToMathFieldEnd" === t ? e1.playSound("delete") : e1.playSound("keypress");
            const i = e1.executeCommand(t);
            return e1.scrollIntoView(), i;
        })(e1, t)
}), ur({
    complete: Jn,
    nextSuggestion: function(e1) {
        return Zn(e1, {
            atIndex: e1.suggestionIndex + 1
        }), !1;
    },
    previousSuggestion: function(e1) {
        return Zn(e1, {
            atIndex: e1.suggestionIndex - 1
        }), !1;
    }
}, {
    target: "mathfield",
    category: "autocomplete"
}), ur({
    speak: (e1, i, n)=>(function(e1, i, n) {
            var r, o;
            n = null != n ? n : {
                withHighlighting: !1
            };
            const { model: a  } = e1, s = function(e1) {
                let t = null;
                switch(e1){
                    case "all":
                    default:
                        t = a.root;
                        break;
                    case "selection":
                        t = a.getAtoms(a.selection);
                        break;
                    case "left":
                        t = a.getAtoms(a.offsetOf(a.at(a.position).leftSibling), a.position);
                        break;
                    case "right":
                        t = a.getAtoms(a.position, a.offsetOf(a.at(a.position).rightSibling));
                        break;
                    case "group":
                        t = a.getAtoms(a.getSiblingsRange(a.position));
                        break;
                    case "parent":
                        {
                            const { parent: e2  } = a.at(a.position);
                            t = e2 && "root" !== e2.type ? e2 : a.root;
                            break;
                        }
                }
                return t;
            }(i);
            if (null === s) return null === (o = (r = e1.options).speakHook) || void 0 === o || o.call(r, function(e1) {
                let t = "";
                switch(e1){
                    case "all":
                    case "group":
                    default:
                        break;
                    case "selection":
                        t = "no selection";
                        break;
                    case "left":
                        t = "at start";
                        break;
                    case "right":
                        t = "at end";
                        break;
                    case "parent":
                        t = "no parent";
                }
                return t;
            }(i), e1.options), !1;
            const l = {
                ...e1.options
            };
            (n.withHighlighting || "amazon" === l.speechEngine) && (l.textToSpeechMarkup = globalThis.sre && "sre" === l.textToSpeechRules ? "ssml_step" : "ssml"), l.textToSpeechMarkup || /firefox/i.test(navigator.userAgent) || (l.textToSpeechMarkup = "ssml");
            const u = en(s, l);
            return t() && n.withHighlighting ? (gm().readAloudMathField = e1, ar(e1, {
                forHighlighting: !0
            }), e1.options.readAloudHook && e1.options.readAloudHook(e1.field, u, e1.options)) : e1.options.speakHook && e1.options.speakHook(u, l), !1;
        })(e1, i, n)
}, {
    target: "mathfield",
    category: "speech"
});
const br = '<span style="width: 21px; margin-top: 4px;"><svg style="width: 21px;" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 576 512"><path d="M528 64H48C21.49 64 0 85.49 0 112v288c0 26.51 21.49 48 48 48h480c26.51 0 48-21.49 48-48V112c0-26.51-21.49-48-48-48zm16 336c0 8.823-7.177 16-16 16H48c-8.823 0-16-7.177-16-16V112c0-8.823 7.177-16 16-16h480c8.823 0 16 7.177 16 16v288zM168 268v-24c0-6.627-5.373-12-12-12h-24c-6.627 0-12 5.373-12 12v24c0 6.627 5.373 12 12 12h24c6.627 0 12-5.373 12-12zm96 0v-24c0-6.627-5.373-12-12-12h-24c-6.627 0-12 5.373-12 12v24c0 6.627 5.373 12 12 12h24c6.627 0 12-5.373 12-12zm96 0v-24c0-6.627-5.373-12-12-12h-24c-6.627 0-12 5.373-12 12v24c0 6.627 5.373 12 12 12h24c6.627 0 12-5.373 12-12zm96 0v-24c0-6.627-5.373-12-12-12h-24c-6.627 0-12 5.373-12 12v24c0 6.627 5.373 12 12 12h24c6.627 0 12-5.373 12-12zm-336 80v-24c0-6.627-5.373-12-12-12H84c-6.627 0-12 5.373-12 12v24c0 6.627 5.373 12 12 12h24c6.627 0 12-5.373 12-12zm384 0v-24c0-6.627-5.373-12-12-12h-24c-6.627 0-12 5.373-12 12v24c0 6.627 5.373 12 12 12h24c6.627 0 12-5.373 12-12zM120 188v-24c0-6.627-5.373-12-12-12H84c-6.627 0-12 5.373-12 12v24c0 6.627 5.373 12 12 12h24c6.627 0 12-5.373 12-12zm96 0v-24c0-6.627-5.373-12-12-12h-24c-6.627 0-12 5.373-12 12v24c0 6.627 5.373 12 12 12h24c6.627 0 12-5.373 12-12zm96 0v-24c0-6.627-5.373-12-12-12h-24c-6.627 0-12 5.373-12 12v24c0 6.627 5.373 12 12 12h24c6.627 0 12-5.373 12-12zm96 0v-24c0-6.627-5.373-12-12-12h-24c-6.627 0-12 5.373-12 12v24c0 6.627 5.373 12 12 12h24c6.627 0 12-5.373 12-12zm96 0v-24c0-6.627-5.373-12-12-12h-24c-6.627 0-12 5.373-12 12v24c0 6.627 5.373 12 12 12h24c6.627 0 12-5.373 12-12zm-96 152v-8c0-6.627-5.373-12-12-12H180c-6.627 0-12 5.373-12 12v8c0 6.627 5.373 12 12 12h216c6.627 0 12-5.373 12-12z"/></svg></span>';
function vr() {
    var e1, i, n;
    return {
        readOnly: !1,
        createHTML: (e1)=>e1,
        fontsDirectory: "./fonts",
        soundsDirectory: "./sounds",
        computeEngine: void 0,
        defaultMode: "math",
        macros: K(),
        registers: {},
        colorMap: f,
        backgroundColorMap: g,
        horizontalSpacingScale: 1,
        letterShapeStyle: s.locale.startsWith("fr") ? "french" : "tex",
        smartMode: !1,
        smartFence: !0,
        smartSuperscript: !0,
        scriptDepth: [
            1 / 0,
            1 / 0
        ],
        removeExtraneousParentheses: !0,
        mathModeSpace: "",
        decimalSeparator: ".",
        fractionNavigationOrder: "numerator-denominator",
        placeholderSymbol: "▢",
        enablePopover: !0,
        locale: s.locale,
        strings: s.strings,
        keybindings: zn,
        inlineShortcuts: Ni,
        inlineShortcutTimeout: 0,
        virtualKeyboardToggleGlyph: br,
        virtualKeyboardMode: "auto",
        virtualKeyboards: "all",
        virtualKeyboardLayout: "auto",
        customVirtualKeyboardLayers: {},
        customVirtualKeyboards: {},
        virtualKeyboardTheme: t() && /android|cros/i.test(navigator.userAgent) ? "material" : "apple",
        keypressVibration: !0,
        keypressSound: null,
        plonkSound: null,
        virtualKeyboardToolbar: "default",
        virtualKeyboardContainer: null !== (i = null === (e1 = globalThis.document) || void 0 === e1 ? void 0 : e1.body) && void 0 !== i ? i : null,
        useSharedVirtualKeyboard: !1,
        sharedVirtualKeyboardTargetOrigin: null === (n = globalThis.window) || void 0 === n ? void 0 : n.origin,
        originValidator: "same-origin",
        textToSpeechRules: "mathlive",
        textToSpeechMarkup: "",
        textToSpeechRulesOptions: {},
        speechEngine: "local",
        speechEngineVoice: "Joanna",
        speechEngineRate: "100%",
        speakHook: hr,
        readAloudHook: fr,
        onInlineShortcut: ()=>"",
        onExport: zi,
        value: ""
    };
}
function xr(e1) {
    return "inline-math" === e1.defaultMode ? "math" : e1.defaultMode;
}
function kr(e1) {
    return !("kind" in e1) || "symbol" === e1.kind;
}
function _r(e1) {
    return !("kind" in e1) || "function" === e1.kind;
}
function wr(e1) {
    return "kind" in e1 && "matchfix" === e1.kind;
}
function Sr(e1) {
    return "kind" in e1 && "infix" === e1.kind;
}
function Mr(e1) {
    return "kind" in e1 && "prefix" === e1.kind;
}
function Nr(e1) {
    return "kind" in e1 && "postfix" === e1.kind;
}
function Lr(e1) {
    return "kind" in e1 && "environment" === e1.kind;
}
var Ar, Cr, Er = 9e15, Tr = "0123456789abcdef", Dr = "2.3025850929940456840179914546843642076011014886287729760333279009675726096773524802359972050895982983419677840422862486334095254650828067566662873690987816894829072083255546808437998948262331985283935053089653777326288461633662222876982198867465436674744042432743651550489343149393914796194044002221051017141748003688084012647080685567743216228355220114804663715659121373450747856947683463616792101806445070648000277502684916746550586856935673420670581136429224554405758925724208241314695689016758940256776311356919292033376587141660230105703089634572075440370847469940168269282808481184289314848524948644871927809676271275775397027668605952496716674183485704422507197965004714951050492214776567636938662976979522110718264549734772662425709429322582798502585509785265383207606726317164309505995087807523710333101197857547331541421808427543863591778117054309827482385045648019095610299291824318237525357709750539565187697510374970888692180205189339507238539205144634197265287286965110862571492198849978748873771345686209167058", zr = "3.1415926535897932384626433832795028841971693993751058209749445923078164062862089986280348253421170679821480865132823066470938446095505822317253594081284811174502841027019385211055596446229489549303819644288109756659334461284756482337867831652712019091456485669234603486104543266482133936072602491412737245870066063155881748815209209628292540917153643678925903600113305305488204665213841469519415116094330572703657595919530921861173819326117931051185480744623799627495673518857527248912279381830119491298336733624406566430860213949463952247371907021798609437027705392171762931767523846748184676694051320005681271452635608277857713427577896091736371787214684409012249534301465495853710507922796892589235420199561121290219608640344181598136297747713099605187072113499999983729780499510597317328160963185950244594553469083026425223082533446850352619311881710100031378387528865875332083814206171776691473035982534904287554687311595628638823537875937519577818577805321712268066130019278766111959092164201989380952572010654858632789", qr = {
    precision: 20,
    rounding: 4,
    modulo: 1,
    toExpNeg: -7,
    toExpPos: 21,
    minE: -Er,
    maxE: Er,
    crypto: !1
}, Ir = !0, Or = "[DecimalError] Invalid argument: ", Fr = "[object Decimal]", Br = Math.floor, $r = Math.pow, Pr = /^0b([01]+(\.[01]*)?|\.[01]+)(p[+-]?\d+)?$/i, Rr = /^0x([0-9a-f]+(\.[0-9a-f]*)?|\.[0-9a-f]+)(p[+-]?\d+)?$/i, Kr = /^0o([0-7]+(\.[0-7]*)?|\.[0-7]+)(p[+-]?\d+)?$/i, Vr = /^(\d+(\.\d*)?|\.\d+)(e[+-]?\d+)?$/i, jr = 1e7, Hr = Dr.length - 1, Ur = zr.length - 1, Gr = {
    toStringTag: Fr
};
function Zr(e1) {
    var t, i, n, r = e1.length - 1, o = "", a = e1[0];
    if (r > 0) {
        for(o += a, t = 1; t < r; t++)(i = 7 - (n = e1[t] + "").length) && (o += oo(i)), o += n;
        (i = 7 - (n = (a = e1[t]) + "").length) && (o += oo(i));
    } else if (0 === a) return "0";
    for(; a % 10 == 0;)a /= 10;
    return o + a;
}
function Wr(e1, t, i) {
    if (e1 !== ~~e1 || e1 < t || e1 > i) throw Error(Or + e1);
}
function Jr(e1, t, i, n) {
    var r, o, a, s;
    for(o = e1[0]; o >= 10; o /= 10)--t;
    return --t < 0 ? (t += 7, r = 0) : (r = Math.ceil((t + 1) / 7), t %= 7), o = $r(10, 7 - t), s = e1[r] % o | 0, null == n ? t < 3 ? (0 == t ? s = s / 100 | 0 : 1 == t && (s = s / 10 | 0), a = i < 4 && 99999 == s || i > 3 && 49999 == s || 5e4 == s || 0 == s) : a = (i < 4 && s + 1 == o || i > 3 && s + 1 == o / 2) && (e1[r + 1] / o / 100 | 0) == $r(10, t - 2) - 1 || (s == o / 2 || 0 == s) && 0 == (e1[r + 1] / o / 100 | 0) : t < 4 ? (0 == t ? s = s / 1e3 | 0 : 1 == t ? s = s / 100 | 0 : 2 == t && (s = s / 10 | 0), a = (n || i < 4) && 9999 == s || !n && i > 3 && 4999 == s) : a = ((n || i < 4) && s + 1 == o || !n && i > 3 && s + 1 == o / 2) && (e1[r + 1] / o / 1e3 | 0) == $r(10, t - 3) - 1, a;
}
function Xr(e1, t, i) {
    for(var n, r, o = [
        0
    ], a = 0, s = e1.length; a < s;){
        for(r = o.length; r--;)o[r] *= t;
        for(o[0] += Tr.indexOf(e1.charAt(a++)), n = 0; n < o.length; n++)o[n] > i - 1 && (void 0 === o[n + 1] && (o[n + 1] = 0), o[n + 1] += o[n] / i | 0, o[n] %= i);
    }
    return o.reverse();
}
Gr.absoluteValue = Gr.abs = function() {
    var e1 = new this.constructor(this);
    return e1.s < 0 && (e1.s = 1), Qr(e1);
}, Gr.ceil = function() {
    return Qr(new this.constructor(this), this.e + 1, 2);
}, Gr.clampedTo = Gr.clamp = function(e1, t) {
    var i = this, n = i.constructor;
    if (e1 = new n(e1), t = new n(t), !e1.s || !t.s) return new n(NaN);
    if (e1.gt(t)) throw Error(Or + t);
    return i.cmp(e1) < 0 ? e1 : i.cmp(t) > 0 ? t : new n(i);
}, Gr.comparedTo = Gr.cmp = function(e1) {
    var t, i, n, r, o = this, a = o.d, s = (e1 = new o.constructor(e1)).d, l = o.s, u = e1.s;
    if (!a || !s) return l && u ? l !== u ? l : a === s ? 0 : !a ^ l < 0 ? 1 : -1 : NaN;
    if (!a[0] || !s[0]) return a[0] ? l : s[0] ? -u : 0;
    if (l !== u) return l;
    if (o.e !== e1.e) return o.e > e1.e ^ l < 0 ? 1 : -1;
    for(t = 0, i = (n = a.length) < (r = s.length) ? n : r; t < i; ++t)if (a[t] !== s[t]) return a[t] > s[t] ^ l < 0 ? 1 : -1;
    return n === r ? 0 : n > r ^ l < 0 ? 1 : -1;
}, Gr.cosine = Gr.cos = function() {
    var e1, t, i = this, n = i.constructor;
    return i.d ? i.d[0] ? (e1 = n.precision, t = n.rounding, n.precision = e1 + Math.max(i.e, i.sd()) + 7, n.rounding = 1, i = function(e1, t) {
        var i, n, r;
        if (t.isZero()) return t;
        (n = t.d.length) < 32 ? r = "" + 1 / fo(4, i = Math.ceil(n / 3)) : (i = 16, r = "2.3283064365386962890625e-10"), e1.precision += i, t = po(e1, 1, t.times(r), new e1(1));
        for(var o = i; o--;){
            var a = t.times(t);
            t = a.times(a).minus(a).times(8).plus(1);
        }
        return e1.precision -= i, t;
    }(n, go(n, i)), n.precision = e1, n.rounding = t, Qr(2 == Cr || 3 == Cr ? i.neg() : i, e1, t, !0)) : new n(1) : new n(NaN);
}, Gr.cubeRoot = Gr.cbrt = function() {
    var e1, t, i, n, r, o, a, s, l, u, c = this, d = c.constructor;
    if (!c.isFinite() || c.isZero()) return new d(c);
    for(Ir = !1, (o = c.s * $r(c.s * c, 1 / 3)) && Math.abs(o) != 1 / 0 ? n = new d(o.toString()) : (i = Zr(c.d), (o = ((e1 = c.e) - i.length + 1) % 3) && (i += 1 == o || -2 == o ? "0" : "00"), o = $r(i, 1 / 3), e1 = Br((e1 + 1) / 3) - (e1 % 3 == (e1 < 0 ? -1 : 2)), (n = new d(i = o == 1 / 0 ? "5e" + e1 : (i = o.toExponential()).slice(0, i.indexOf("e") + 1) + e1)).s = c.s), a = (e1 = d.precision) + 3;;)if (u = (l = (s = n).times(s).times(s)).plus(c), n = Yr(u.plus(c).times(s), u.plus(l), a + 2, 1), Zr(s.d).slice(0, a) === (i = Zr(n.d)).slice(0, a)) {
        if ("9999" != (i = i.slice(a - 3, a + 1)) && (r || "4999" != i)) {
            +i && (+i.slice(1) || "5" != i.charAt(0)) || (Qr(n, e1 + 1, 1), t = !n.times(n).times(n).eq(c));
            break;
        }
        if (!r && (Qr(s, e1 + 1, 0), s.times(s).times(s).eq(c))) {
            n = s;
            break;
        }
        a += 4, r = 1;
    }
    return Ir = !0, Qr(n, e1, d.rounding, t);
}, Gr.decimalPlaces = Gr.dp = function() {
    var e1, t = this.d, i = NaN;
    if (t) {
        if (i = 7 * ((e1 = t.length - 1) - Br(this.e / 7)), e1 = t[e1]) for(; e1 % 10 == 0; e1 /= 10)i--;
        i < 0 && (i = 0);
    }
    return i;
}, Gr.dividedBy = Gr.div = function(e1) {
    return Yr(this, new this.constructor(e1));
}, Gr.dividedToIntegerBy = Gr.divToInt = function(e1) {
    var t = this.constructor;
    return Qr(Yr(this, new t(e1), 0, 1, 1), t.precision, t.rounding);
}, Gr.equals = Gr.eq = function(e1) {
    return 0 === this.cmp(e1);
}, Gr.floor = function() {
    return Qr(new this.constructor(this), this.e + 1, 3);
}, Gr.greaterThan = Gr.gt = function(e1) {
    return this.cmp(e1) > 0;
}, Gr.greaterThanOrEqualTo = Gr.gte = function(e1) {
    var t = this.cmp(e1);
    return 1 == t || 0 === t;
}, Gr.hyperbolicCosine = Gr.cosh = function() {
    var e1, t, i, n, r, o = this, a = o.constructor, s = new a(1);
    if (!o.isFinite()) return new a(o.s ? 1 / 0 : NaN);
    if (o.isZero()) return s;
    i = a.precision, n = a.rounding, a.precision = i + Math.max(o.e, o.sd()) + 4, a.rounding = 1, (r = o.d.length) < 32 ? t = "" + 1 / fo(4, e1 = Math.ceil(r / 3)) : (e1 = 16, t = "2.3283064365386962890625e-10"), o = po(a, 1, o.times(t), new a(1), !0);
    for(var l, u = e1, c = new a(8); u--;)l = o.times(o), o = s.minus(l.times(c.minus(l.times(c))));
    return Qr(o, a.precision = i, a.rounding = n, !0);
}, Gr.hyperbolicSine = Gr.sinh = function() {
    var e1, t, i, n, r = this, o = r.constructor;
    if (!r.isFinite() || r.isZero()) return new o(r);
    if (t = o.precision, i = o.rounding, o.precision = t + Math.max(r.e, r.sd()) + 4, o.rounding = 1, (n = r.d.length) < 3) r = po(o, 2, r, r, !0);
    else {
        e1 = (e1 = 1.4 * Math.sqrt(n)) > 16 ? 16 : 0 | e1, r = po(o, 2, r = r.times(1 / fo(5, e1)), r, !0);
        for(var a, s = new o(5), l = new o(16), u = new o(20); e1--;)a = r.times(r), r = r.times(s.plus(a.times(l.times(a).plus(u))));
    }
    return o.precision = t, o.rounding = i, Qr(r, t, i, !0);
}, Gr.hyperbolicTangent = Gr.tanh = function() {
    var e1, t, i = this, n = i.constructor;
    return i.isFinite() ? i.isZero() ? new n(i) : (e1 = n.precision, t = n.rounding, n.precision = e1 + 7, n.rounding = 1, Yr(i.sinh(), i.cosh(), n.precision = e1, n.rounding = t)) : new n(i.s);
}, Gr.inverseCosine = Gr.acos = function() {
    var e1, t = this, i = t.constructor, n = t.abs().cmp(1), r = i.precision, o = i.rounding;
    return -1 !== n ? 0 === n ? t.isNeg() ? no(i, r, o) : new i(0) : new i(NaN) : t.isZero() ? no(i, r + 4, o).times(.5) : (i.precision = r + 6, i.rounding = 1, t = t.asin(), e1 = no(i, r + 4, o).times(.5), i.precision = r, i.rounding = o, e1.minus(t));
}, Gr.inverseHyperbolicCosine = Gr.acosh = function() {
    var e1, t, i = this, n = i.constructor;
    return i.lte(1) ? new n(i.eq(1) ? 0 : NaN) : i.isFinite() ? (e1 = n.precision, t = n.rounding, n.precision = e1 + Math.max(Math.abs(i.e), i.sd()) + 4, n.rounding = 1, Ir = !1, i = i.times(i).minus(1).sqrt().plus(i), Ir = !0, n.precision = e1, n.rounding = t, i.ln()) : new n(i);
}, Gr.inverseHyperbolicSine = Gr.asinh = function() {
    var e1, t, i = this, n = i.constructor;
    return !i.isFinite() || i.isZero() ? new n(i) : (e1 = n.precision, t = n.rounding, n.precision = e1 + 2 * Math.max(Math.abs(i.e), i.sd()) + 6, n.rounding = 1, Ir = !1, i = i.times(i).plus(1).sqrt().plus(i), Ir = !0, n.precision = e1, n.rounding = t, i.ln());
}, Gr.inverseHyperbolicTangent = Gr.atanh = function() {
    var e1, t, i, n, r = this, o = r.constructor;
    return r.isFinite() ? r.e >= 0 ? new o(r.abs().eq(1) ? r.s / 0 : r.isZero() ? r : NaN) : (e1 = o.precision, t = o.rounding, n = r.sd(), Math.max(n, e1) < 2 * -r.e - 1 ? Qr(new o(r), e1, t, !0) : (o.precision = i = n - r.e, r = Yr(r.plus(1), new o(1).minus(r), i + e1, 1), o.precision = e1 + 4, o.rounding = 1, r = r.ln(), o.precision = e1, o.rounding = t, r.times(.5))) : new o(NaN);
}, Gr.inverseSine = Gr.asin = function() {
    var e1, t, i, n, r = this, o = r.constructor;
    return r.isZero() ? new o(r) : (t = r.abs().cmp(1), i = o.precision, n = o.rounding, -1 !== t ? 0 === t ? ((e1 = no(o, i + 4, n).times(.5)).s = r.s, e1) : new o(NaN) : (o.precision = i + 6, o.rounding = 1, r = r.div(new o(1).minus(r.times(r)).sqrt().plus(1)).atan(), o.precision = i, o.rounding = n, r.times(2)));
}, Gr.inverseTangent = Gr.atan = function() {
    var e1, t, i, n, r, o, a, s, l, u = this, c = u.constructor, d = c.precision, h = c.rounding;
    if (u.isFinite()) {
        if (u.isZero()) return new c(u);
        if (u.abs().eq(1) && d + 4 <= Ur) return (a = no(c, d + 4, h).times(.25)).s = u.s, a;
    } else {
        if (!u.s) return new c(NaN);
        if (d + 4 <= Ur) return (a = no(c, d + 4, h).times(.5)).s = u.s, a;
    }
    for(c.precision = s = d + 10, c.rounding = 1, e1 = i = Math.min(28, s / 7 + 2 | 0); e1; --e1)u = u.div(u.times(u).plus(1).sqrt().plus(1));
    for(Ir = !1, t = Math.ceil(s / 7), n = 1, l = u.times(u), a = new c(u), r = u; -1 !== e1;)if (r = r.times(l), o = a.minus(r.div(n += 2)), r = r.times(l), void 0 !== (a = o.plus(r.div(n += 2))).d[t]) for(e1 = t; a.d[e1] === o.d[e1] && e1--;);
    return i && (a = a.times(2 << i - 1)), Ir = !0, Qr(a, c.precision = d, c.rounding = h, !0);
}, Gr.isFinite = function() {
    return !!this.d;
}, Gr.isInteger = Gr.isInt = function() {
    return !!this.d && Br(this.e / 7) > this.d.length - 2;
}, Gr.isNaN = function() {
    return !this.s;
}, Gr.isNegative = Gr.isNeg = function() {
    return this.s < 0;
}, Gr.isPositive = Gr.isPos = function() {
    return this.s > 0;
}, Gr.isZero = function() {
    return !!this.d && 0 === this.d[0];
}, Gr.lessThan = Gr.lt = function(e1) {
    return this.cmp(e1) < 0;
}, Gr.lessThanOrEqualTo = Gr.lte = function(e1) {
    return this.cmp(e1) < 1;
}, Gr.logarithm = Gr.log = function(e1) {
    var t, i, n, r, o, a, s, l, u = this, c = u.constructor, d = c.precision, h = c.rounding;
    if (null == e1) e1 = new c(10), t = !0;
    else {
        if (i = (e1 = new c(e1)).d, e1.s < 0 || !i || !i[0] || e1.eq(1)) return new c(NaN);
        t = e1.eq(10);
    }
    if (i = u.d, u.s < 0 || !i || !i[0] || u.eq(1)) return new c(i && !i[0] ? -1 / 0 : 1 != u.s ? NaN : i ? 0 : 1 / 0);
    if (t) {
        if (i.length > 1) o = !0;
        else {
            for(r = i[0]; r % 10 == 0;)r /= 10;
            o = 1 !== r;
        }
    }
    if (Ir = !1, a = co(u, s = d + 5), n = t ? io(c, s + 10) : co(e1, s), Jr((l = Yr(a, n, s, 1)).d, r = d, h)) do if (a = co(u, s += 10), n = t ? io(c, s + 10) : co(e1, s), l = Yr(a, n, s, 1), !o) {
        +Zr(l.d).slice(r + 1, r + 15) + 1 == 1e14 && (l = Qr(l, d + 1, 0));
        break;
    }
    while (Jr(l.d, r += 10, h));
    return Ir = !0, Qr(l, d, h);
}, Gr.minus = Gr.sub = function(e1) {
    var t, i, n, r, o, a, s, l, u, c, d, h, m = this, p = m.constructor;
    if (e1 = new p(e1), !m.d || !e1.d) return m.s && e1.s ? m.d ? e1.s = -e1.s : e1 = new p(e1.d || m.s !== e1.s ? m : NaN) : e1 = new p(NaN), e1;
    if (m.s != e1.s) return e1.s = -e1.s, m.plus(e1);
    if (u = m.d, h = e1.d, s = p.precision, l = p.rounding, !u[0] || !h[0]) {
        if (h[0]) e1.s = -e1.s;
        else {
            if (!u[0]) return new p(3 === l ? -0 : 0);
            e1 = new p(m);
        }
        return Ir ? Qr(e1, s, l) : e1;
    }
    if (i = Br(e1.e / 7), c = Br(m.e / 7), u = u.slice(), o = c - i) {
        for((d = o < 0) ? (t = u, o = -o, a = h.length) : (t = h, i = c, a = u.length), o > (n = Math.max(Math.ceil(s / 7), a) + 2) && (o = n, t.length = 1), t.reverse(), n = o; n--;)t.push(0);
        t.reverse();
    } else {
        for((d = (n = u.length) < (a = h.length)) && (a = n), n = 0; n < a; n++)if (u[n] != h[n]) {
            d = u[n] < h[n];
            break;
        }
        o = 0;
    }
    for(d && (t = u, u = h, h = t, e1.s = -e1.s), a = u.length, n = h.length - a; n > 0; --n)u[a++] = 0;
    for(n = h.length; n > o;){
        if (u[--n] < h[n]) {
            for(r = n; r && 0 === u[--r];)u[r] = jr - 1;
            --u[r], u[n] += jr;
        }
        u[n] -= h[n];
    }
    for(; 0 === u[--a];)u.pop();
    for(; 0 === u[0]; u.shift())--i;
    return u[0] ? (e1.d = u, e1.e = to(u, i), Ir ? Qr(e1, s, l) : e1) : new p(3 === l ? -0 : 0);
}, Gr.modulo = Gr.mod = function(e1) {
    var t, i = this, n = i.constructor;
    return e1 = new n(e1), !i.d || !e1.s || e1.d && !e1.d[0] ? new n(NaN) : !e1.d || i.d && !i.d[0] ? Qr(new n(i), n.precision, n.rounding) : (Ir = !1, 9 == n.modulo ? (t = Yr(i, e1.abs(), 0, 3, 1)).s *= e1.s : t = Yr(i, e1, 0, n.modulo, 1), t = t.times(e1), Ir = !0, i.minus(t));
}, Gr.naturalExponential = Gr.exp = function() {
    return uo(this);
}, Gr.naturalLogarithm = Gr.ln = function() {
    return co(this);
}, Gr.negated = Gr.neg = function() {
    var e1 = new this.constructor(this);
    return e1.s = -e1.s, Qr(e1);
}, Gr.plus = Gr.add = function(e1) {
    var t, i, n, r, o, a, s, l, u, c, d = this, h = d.constructor;
    if (e1 = new h(e1), !d.d || !e1.d) return d.s && e1.s ? d.d || (e1 = new h(e1.d || d.s === e1.s ? d : NaN)) : e1 = new h(NaN), e1;
    if (d.s != e1.s) return e1.s = -e1.s, d.minus(e1);
    if (u = d.d, c = e1.d, s = h.precision, l = h.rounding, !u[0] || !c[0]) return c[0] || (e1 = new h(d)), Ir ? Qr(e1, s, l) : e1;
    if (o = Br(d.e / 7), n = Br(e1.e / 7), u = u.slice(), r = o - n) {
        for(r < 0 ? (i = u, r = -r, a = c.length) : (i = c, n = o, a = u.length), r > (a = (o = Math.ceil(s / 7)) > a ? o + 1 : a + 1) && (r = a, i.length = 1), i.reverse(); r--;)i.push(0);
        i.reverse();
    }
    for((a = u.length) - (r = c.length) < 0 && (r = a, i = c, c = u, u = i), t = 0; r;)t = (u[--r] = u[r] + c[r] + t) / jr | 0, u[r] %= jr;
    for(t && (u.unshift(t), ++n), a = u.length; 0 == u[--a];)u.pop();
    return e1.d = u, e1.e = to(u, n), Ir ? Qr(e1, s, l) : e1;
}, Gr.precision = Gr.sd = function(e1) {
    var t, i = this;
    if (void 0 !== e1 && e1 !== !!e1 && 1 !== e1 && 0 !== e1) throw Error(Or + e1);
    return i.d ? (t = ro(i.d), e1 && i.e + 1 > t && (t = i.e + 1)) : t = NaN, t;
}, Gr.round = function() {
    var e1 = this, t = e1.constructor;
    return Qr(new t(e1), e1.e + 1, t.rounding);
}, Gr.sine = Gr.sin = function() {
    var e1, t, i = this, n = i.constructor;
    return i.isFinite() ? i.isZero() ? new n(i) : (e1 = n.precision, t = n.rounding, n.precision = e1 + Math.max(i.e, i.sd()) + 7, n.rounding = 1, i = function(e1, t) {
        var i, n = t.d.length;
        if (n < 3) return t.isZero() ? t : po(e1, 2, t, t);
        i = (i = 1.4 * Math.sqrt(n)) > 16 ? 16 : 0 | i, t = po(e1, 2, t = t.times(1 / fo(5, i)), t);
        for(var r, o = new e1(5), a = new e1(16), s = new e1(20); i--;)r = t.times(t), t = t.times(o.plus(r.times(a.times(r).minus(s))));
        return t;
    }(n, go(n, i)), n.precision = e1, n.rounding = t, Qr(Cr > 2 ? i.neg() : i, e1, t, !0)) : new n(NaN);
}, Gr.squareRoot = Gr.sqrt = function() {
    var e1, t, i, n, r, o, a = this, s = a.d, l = a.e, u = a.s, c = a.constructor;
    if (1 !== u || !s || !s[0]) return new c(!u || u < 0 && (!s || s[0]) ? NaN : s ? a : 1 / 0);
    for(Ir = !1, 0 == (u = Math.sqrt(+a)) || u == 1 / 0 ? (((t = Zr(s)).length + l) % 2 == 0 && (t += "0"), u = Math.sqrt(t), l = Br((l + 1) / 2) - (l < 0 || l % 2), n = new c(t = u == 1 / 0 ? "5e" + l : (t = u.toExponential()).slice(0, t.indexOf("e") + 1) + l)) : n = new c(u.toString()), i = (l = c.precision) + 3;;)if (n = (o = n).plus(Yr(a, o, i + 2, 1)).times(.5), Zr(o.d).slice(0, i) === (t = Zr(n.d)).slice(0, i)) {
        if ("9999" != (t = t.slice(i - 3, i + 1)) && (r || "4999" != t)) {
            +t && (+t.slice(1) || "5" != t.charAt(0)) || (Qr(n, l + 1, 1), e1 = !n.times(n).eq(a));
            break;
        }
        if (!r && (Qr(o, l + 1, 0), o.times(o).eq(a))) {
            n = o;
            break;
        }
        i += 4, r = 1;
    }
    return Ir = !0, Qr(n, l, c.rounding, e1);
}, Gr.tangent = Gr.tan = function() {
    var e1, t, i = this, n = i.constructor;
    return i.isFinite() ? i.isZero() ? new n(i) : (e1 = n.precision, t = n.rounding, n.precision = e1 + 10, n.rounding = 1, (i = i.sin()).s = 1, i = Yr(i, new n(1).minus(i.times(i)).sqrt(), e1 + 10, 0), n.precision = e1, n.rounding = t, Qr(2 == Cr || 4 == Cr ? i.neg() : i, e1, t, !0)) : new n(NaN);
}, Gr.times = Gr.mul = function(e1) {
    var t, i, n, r, o, a, s, l, u, c = this, d = c.constructor, h = c.d, m = (e1 = new d(e1)).d;
    if (e1.s *= c.s, !(h && h[0] && m && m[0])) return new d(!e1.s || h && !h[0] && !m || m && !m[0] && !h ? NaN : h && m ? 0 * e1.s : e1.s / 0);
    for(i = Br(c.e / 7) + Br(e1.e / 7), (l = h.length) < (u = m.length) && (o = h, h = m, m = o, a = l, l = u, u = a), o = [], n = a = l + u; n--;)o.push(0);
    for(n = u; --n >= 0;){
        for(t = 0, r = l + n; r > n;)s = o[r] + m[n] * h[r - n - 1] + t, o[r--] = s % jr | 0, t = s / jr | 0;
        o[r] = (o[r] + t) % jr | 0;
    }
    for(; !o[--a];)o.pop();
    return t ? ++i : o.shift(), e1.d = o, e1.e = to(o, i), Ir ? Qr(e1, d.precision, d.rounding) : e1;
}, Gr.toBinary = function(e1, t) {
    return yo(this, 2, e1, t);
}, Gr.toDecimalPlaces = Gr.toDP = function(e1, t) {
    var i = this, n = i.constructor;
    return i = new n(i), void 0 === e1 ? i : (Wr(e1, 0, 1e9), void 0 === t ? t = n.rounding : Wr(t, 0, 8), Qr(i, e1 + i.e + 1, t));
}, Gr.toExponential = function(e1, t) {
    var i, n = this, r = n.constructor;
    return void 0 === e1 ? i = eo(n, !0) : (Wr(e1, 0, 1e9), void 0 === t ? t = r.rounding : Wr(t, 0, 8), i = eo(n = Qr(new r(n), e1 + 1, t), !0, e1 + 1)), n.isNeg() && !n.isZero() ? "-" + i : i;
}, Gr.toFixed = function(e1, t) {
    var i, n, r = this, o = r.constructor;
    return void 0 === e1 ? i = eo(r) : (Wr(e1, 0, 1e9), void 0 === t ? t = o.rounding : Wr(t, 0, 8), i = eo(n = Qr(new o(r), e1 + r.e + 1, t), !1, e1 + n.e + 1)), r.isNeg() && !r.isZero() ? "-" + i : i;
}, Gr.toFraction = function(e1) {
    var t, i, n, r, o, a, s, l, u, c, d, h, m = this, p = m.d, f = m.constructor;
    if (!p) return new f(m);
    if (u = i = new f(1), n = l = new f(0), a = (o = (t = new f(n)).e = ro(p) - m.e - 1) % 7, t.d[0] = $r(10, a < 0 ? 7 + a : a), null == e1) e1 = o > 0 ? t : u;
    else {
        if (!(s = new f(e1)).isInt() || s.lt(u)) throw Error(Or + s);
        e1 = s.gt(t) ? o > 0 ? t : u : s;
    }
    for(Ir = !1, s = new f(Zr(p)), c = f.precision, f.precision = o = 7 * p.length * 2; d = Yr(s, t, 0, 1, 1), 1 != (r = i.plus(d.times(n))).cmp(e1);)i = n, n = r, r = u, u = l.plus(d.times(r)), l = r, r = t, t = s.minus(d.times(r)), s = r;
    return r = Yr(e1.minus(i), n, 0, 1, 1), l = l.plus(r.times(u)), i = i.plus(r.times(n)), l.s = u.s = m.s, h = Yr(u, n, o, 1).minus(m).abs().cmp(Yr(l, i, o, 1).minus(m).abs()) < 1 ? [
        u,
        n
    ] : [
        l,
        i
    ], f.precision = c, Ir = !0, h;
}, Gr.toHexadecimal = Gr.toHex = function(e1, t) {
    return yo(this, 16, e1, t);
}, Gr.toNearest = function(e1, t) {
    var i = this, n = i.constructor;
    if (i = new n(i), null == e1) {
        if (!i.d) return i;
        e1 = new n(1), t = n.rounding;
    } else {
        if (e1 = new n(e1), void 0 === t ? t = n.rounding : Wr(t, 0, 8), !i.d) return e1.s ? i : e1;
        if (!e1.d) return e1.s && (e1.s = i.s), e1;
    }
    return e1.d[0] ? (Ir = !1, i = Yr(i, e1, 0, t, 1).times(e1), Ir = !0, Qr(i)) : (e1.s = i.s, i = e1), i;
}, Gr.toNumber = function() {
    return +this;
}, Gr.toOctal = function(e1, t) {
    return yo(this, 8, e1, t);
}, Gr.toPower = Gr.pow = function(e1) {
    var t, i, n, r, o, a, s = this, l = s.constructor, u = +(e1 = new l(e1));
    if (!(s.d && e1.d && s.d[0] && e1.d[0])) return new l($r(+s, u));
    if ((s = new l(s)).eq(1)) return s;
    if (n = l.precision, o = l.rounding, e1.eq(1)) return Qr(s, n, o);
    if ((t = Br(e1.e / 7)) >= e1.d.length - 1 && (i = u < 0 ? -u : u) <= 9007199254740991) return r = ao(l, s, i, n), e1.s < 0 ? new l(1).div(r) : Qr(r, n, o);
    if ((a = s.s) < 0) {
        if (t < e1.d.length - 1) return new l(NaN);
        if (0 == (1 & e1.d[t]) && (a = 1), 0 == s.e && 1 == s.d[0] && 1 == s.d.length) return s.s = a, s;
    }
    return (t = 0 != (i = $r(+s, u)) && isFinite(i) ? new l(i + "").e : Br(u * (Math.log("0." + Zr(s.d)) / Math.LN10 + s.e + 1))) > l.maxE + 1 || t < l.minE - 1 ? new l(t > 0 ? a / 0 : 0) : (Ir = !1, l.rounding = s.s = 1, i = Math.min(12, (t + "").length), (r = uo(e1.times(co(s, n + i)), n)).d && Jr((r = Qr(r, n + 5, 1)).d, n, o) && (t = n + 10, +Zr((r = Qr(uo(e1.times(co(s, t + i)), t), t + 5, 1)).d).slice(n + 1, n + 15) + 1 == 1e14 && (r = Qr(r, n + 1, 0))), r.s = a, Ir = !0, l.rounding = o, Qr(r, n, o));
}, Gr.toPrecision = function(e1, t) {
    var i, n = this, r = n.constructor;
    return void 0 === e1 ? i = eo(n, n.e <= r.toExpNeg || n.e >= r.toExpPos) : (Wr(e1, 1, 1e9), void 0 === t ? t = r.rounding : Wr(t, 0, 8), i = eo(n = Qr(new r(n), e1, t), e1 <= n.e || n.e <= r.toExpNeg, e1)), n.isNeg() && !n.isZero() ? "-" + i : i;
}, Gr.toSignificantDigits = Gr.toSD = function(e1, t) {
    var i = this.constructor;
    return void 0 === e1 ? (e1 = i.precision, t = i.rounding) : (Wr(e1, 1, 1e9), void 0 === t ? t = i.rounding : Wr(t, 0, 8)), Qr(new i(this), e1, t);
}, Gr.toString = function() {
    var e1 = this, t = e1.constructor, i = eo(e1, e1.e <= t.toExpNeg || e1.e >= t.toExpPos);
    return e1.isNeg() && !e1.isZero() ? "-" + i : i;
}, Gr.truncated = Gr.trunc = function() {
    return Qr(new this.constructor(this), this.e + 1, 1);
}, Gr.valueOf = Gr.toJSON = function() {
    var e1 = this, t = e1.constructor, i = eo(e1, e1.e <= t.toExpNeg || e1.e >= t.toExpPos);
    return e1.isNeg() ? "-" + i : i;
};
var Yr = function() {
    function e1(e1, t, i) {
        var n, r = 0, o = e1.length;
        for(e1 = e1.slice(); o--;)n = e1[o] * t + r, e1[o] = n % i | 0, r = n / i | 0;
        return r && e1.unshift(r), e1;
    }
    function t(e1, t, i, n) {
        var r, o;
        if (i != n) o = i > n ? 1 : -1;
        else for(r = o = 0; r < i; r++)if (e1[r] != t[r]) {
            o = e1[r] > t[r] ? 1 : -1;
            break;
        }
        return o;
    }
    function i(e1, t, i, n) {
        for(var r = 0; i--;)e1[i] -= r, r = e1[i] < t[i] ? 1 : 0, e1[i] = r * n + e1[i] - t[i];
        for(; !e1[0] && e1.length > 1;)e1.shift();
    }
    return function(n, r, o, a, s, l) {
        var u, c, d, h, m, p, f, g, y, b, v, x, k, _, w, S, M, N, L, A, C = n.constructor, E = n.s == r.s ? 1 : -1, T = n.d, D = r.d;
        if (!(T && T[0] && D && D[0])) return new C(n.s && r.s && (T ? !D || T[0] != D[0] : D) ? T && 0 == T[0] || !D ? 0 * E : E / 0 : NaN);
        for(l ? (m = 1, c = n.e - r.e) : (l = jr, m = 7, c = Br(n.e / m) - Br(r.e / m)), L = D.length, M = T.length, b = (y = new C(E)).d = [], d = 0; D[d] == (T[d] || 0); d++);
        if (D[d] > (T[d] || 0) && c--, null == o ? (_ = o = C.precision, a = C.rounding) : _ = s ? o + (n.e - r.e) + 1 : o, _ < 0) b.push(1), p = !0;
        else {
            if (_ = _ / m + 2 | 0, d = 0, 1 == L) {
                for(h = 0, D = D[0], _++; (d < M || h) && _--; d++)w = h * l + (T[d] || 0), b[d] = w / D | 0, h = w % D | 0;
                p = h || d < M;
            } else {
                for((h = l / (D[0] + 1) | 0) > 1 && (D = e1(D, h, l), T = e1(T, h, l), L = D.length, M = T.length), S = L, x = (v = T.slice(0, L)).length; x < L;)v[x++] = 0;
                (A = D.slice()).unshift(0), N = D[0], D[1] >= l / 2 && ++N;
                do h = 0, (u = t(D, v, L, x)) < 0 ? (k = v[0], L != x && (k = k * l + (v[1] || 0)), (h = k / N | 0) > 1 ? (h >= l && (h = l - 1), 1 == (u = t(f = e1(D, h, l), v, g = f.length, x = v.length)) && (h--, i(f, L < g ? A : D, g, l))) : (0 == h && (u = h = 1), f = D.slice()), (g = f.length) < x && f.unshift(0), i(v, f, x, l), -1 == u && (u = t(D, v, L, x = v.length)) < 1 && (h++, i(v, L < x ? A : D, x, l)), x = v.length) : 0 === u && (h++, v = [
                    0
                ]), b[d++] = h, u && v[0] ? v[x++] = T[S] || 0 : (v = [
                    T[S]
                ], x = 1);
                while ((S++ < M || void 0 !== v[0]) && _--);
                p = void 0 !== v[0];
            }
            b[0] || b.shift();
        }
        if (1 == m) y.e = c, Ar = p;
        else {
            for(d = 1, h = b[0]; h >= 10; h /= 10)d++;
            y.e = d + c * m - 1, Qr(y, s ? o + y.e + 1 : o, a, p);
        }
        return y;
    };
}();
function Qr(e1, t, i, n) {
    var r, o, a, s, l, u, c, d, h, m = e1.constructor;
    e: if (null != t) {
        if (!(d = e1.d)) return e1;
        for(r = 1, s = d[0]; s >= 10; s /= 10)r++;
        if ((o = t - r) < 0) o += 7, a = t, l = (c = d[h = 0]) / $r(10, r - a - 1) % 10 | 0;
        else if ((h = Math.ceil((o + 1) / 7)) >= (s = d.length)) {
            if (!n) break e;
            for(; s++ <= h;)d.push(0);
            c = l = 0, r = 1, a = (o %= 7) - 7 + 1;
        } else {
            for(c = s = d[h], r = 1; s >= 10; s /= 10)r++;
            l = (a = (o %= 7) - 7 + r) < 0 ? 0 : c / $r(10, r - a - 1) % 10 | 0;
        }
        if (n = n || t < 0 || void 0 !== d[h + 1] || (a < 0 ? c : c % $r(10, r - a - 1)), u = i < 4 ? (l || n) && (0 == i || i == (e1.s < 0 ? 3 : 2)) : l > 5 || 5 == l && (4 == i || n || 6 == i && (o > 0 ? a > 0 ? c / $r(10, r - a) : 0 : d[h - 1]) % 10 & 1 || i == (e1.s < 0 ? 8 : 7)), t < 1 || !d[0]) return d.length = 0, u ? (t -= e1.e + 1, d[0] = $r(10, (7 - t % 7) % 7), e1.e = -t || 0) : d[0] = e1.e = 0, e1;
        if (0 == o ? (d.length = h, s = 1, h--) : (d.length = h + 1, s = $r(10, 7 - o), d[h] = a > 0 ? (c / $r(10, r - a) % $r(10, a) | 0) * s : 0), u) for(;;){
            if (0 == h) {
                for(o = 1, a = d[0]; a >= 10; a /= 10)o++;
                for(a = d[0] += s, s = 1; a >= 10; a /= 10)s++;
                o != s && (e1.e++, d[0] == jr && (d[0] = 1));
                break;
            }
            if (d[h] += s, d[h] != jr) break;
            d[h--] = 0, s = 1;
        }
        for(o = d.length; 0 === d[--o];)d.pop();
    }
    return Ir && (e1.e > m.maxE ? (e1.d = null, e1.e = NaN) : e1.e < m.minE && (e1.e = 0, e1.d = [
        0
    ])), e1;
}
function eo(e1, t, i) {
    if (!e1.isFinite()) return ho(e1);
    var n, r = e1.e, o = Zr(e1.d), a = o.length;
    return t ? (i && (n = i - a) > 0 ? o = o.charAt(0) + "." + o.slice(1) + oo(n) : a > 1 && (o = o.charAt(0) + "." + o.slice(1)), o = o + (e1.e < 0 ? "e" : "e+") + e1.e) : r < 0 ? (o = "0." + oo(-r - 1) + o, i && (n = i - a) > 0 && (o += oo(n))) : r >= a ? (o += oo(r + 1 - a), i && (n = i - r - 1) > 0 && (o = o + "." + oo(n))) : ((n = r + 1) < a && (o = o.slice(0, n) + "." + o.slice(n)), i && (n = i - a) > 0 && (r + 1 === a && (o += "."), o += oo(n))), o;
}
function to(e1, t) {
    var i = e1[0];
    for(t *= 7; i >= 10; i /= 10)t++;
    return t;
}
function io(e1, t, i) {
    if (t > Hr) throw Ir = !0, i && (e1.precision = i), Error("[DecimalError] Precision limit exceeded");
    return Qr(new e1(Dr), t, 1, !0);
}
function no(e1, t, i) {
    if (t > Ur) throw Error("[DecimalError] Precision limit exceeded");
    return Qr(new e1(zr), t, i, !0);
}
function ro(e1) {
    var t = e1.length - 1, i = 7 * t + 1;
    if (t = e1[t]) {
        for(; t % 10 == 0; t /= 10)i--;
        for(t = e1[0]; t >= 10; t /= 10)i++;
    }
    return i;
}
function oo(e1) {
    for(var t = ""; e1--;)t += "0";
    return t;
}
function ao(e1, t, i, n) {
    var r, o = new e1(1), a = Math.ceil(n / 7 + 4);
    for(Ir = !1;;){
        if (i % 2 && bo((o = o.times(t)).d, a) && (r = !0), 0 === (i = Br(i / 2))) {
            i = o.d.length - 1, r && 0 === o.d[i] && ++o.d[i];
            break;
        }
        bo((t = t.times(t)).d, a);
    }
    return Ir = !0, o;
}
function so(e1) {
    return 1 & e1.d[e1.d.length - 1];
}
function lo(e1, t, i) {
    for(var n, r = new e1(t[0]), o = 0; ++o < t.length;){
        if (!(n = new e1(t[o])).s) {
            r = n;
            break;
        }
        r[i](n) && (r = n);
    }
    return r;
}
function uo(e1, t) {
    var i, n, r, o, a, s, l, u = 0, c = 0, d = 0, h = e1.constructor, m = h.rounding, p = h.precision;
    if (!e1.d || !e1.d[0] || e1.e > 17) return new h(e1.d ? e1.d[0] ? e1.s < 0 ? 0 : 1 / 0 : 1 : e1.s ? e1.s < 0 ? 0 : e1 : NaN);
    for(null == t ? (Ir = !1, l = p) : l = t, s = new h(.03125); e1.e > -2;)e1 = e1.times(s), d += 5;
    for(l += n = Math.log($r(2, d)) / Math.LN10 * 2 + 5 | 0, i = o = a = new h(1), h.precision = l;;){
        if (o = Qr(o.times(e1), l, 1), i = i.times(++c), Zr((s = a.plus(Yr(o, i, l, 1))).d).slice(0, l) === Zr(a.d).slice(0, l)) {
            for(r = d; r--;)a = Qr(a.times(a), l, 1);
            if (null != t) return h.precision = p, a;
            if (!(u < 3 && Jr(a.d, l - n, m, u))) return Qr(a, h.precision = p, m, Ir = !0);
            h.precision = l += 10, i = o = s = new h(1), c = 0, u++;
        }
        a = s;
    }
}
function co(e1, t) {
    var i, n, r, o, a, s, l, u, c, d, h, m = 1, p = e1, f = p.d, g = p.constructor, y = g.rounding, b = g.precision;
    if (p.s < 0 || !f || !f[0] || !p.e && 1 == f[0] && 1 == f.length) return new g(f && !f[0] ? -1 / 0 : 1 != p.s ? NaN : f ? 0 : p);
    if (null == t ? (Ir = !1, c = b) : c = t, g.precision = c += 10, n = (i = Zr(f)).charAt(0), !(Math.abs(o = p.e) < 15e14)) return u = io(g, c + 2, b).times(o + ""), p = co(new g(n + "." + i.slice(1)), c - 10).plus(u), g.precision = b, null == t ? Qr(p, b, y, Ir = !0) : p;
    for(; n < 7 && 1 != n || 1 == n && i.charAt(1) > 3;)n = (i = Zr((p = p.times(e1)).d)).charAt(0), m++;
    for(o = p.e, n > 1 ? (p = new g("0." + i), o++) : p = new g(n + "." + i.slice(1)), d = p, l = a = p = Yr(p.minus(1), p.plus(1), c, 1), h = Qr(p.times(p), c, 1), r = 3;;){
        if (a = Qr(a.times(h), c, 1), Zr((u = l.plus(Yr(a, new g(r), c, 1))).d).slice(0, c) === Zr(l.d).slice(0, c)) {
            if (l = l.times(2), 0 !== o && (l = l.plus(io(g, c + 2, b).times(o + ""))), l = Yr(l, new g(m), c, 1), null != t) return g.precision = b, l;
            if (!Jr(l.d, c - 10, y, s)) return Qr(l, g.precision = b, y, Ir = !0);
            g.precision = c += 10, u = a = p = Yr(d.minus(1), d.plus(1), c, 1), h = Qr(p.times(p), c, 1), r = s = 1;
        }
        l = u, r += 2;
    }
}
function ho(e1) {
    return e1.s * e1.s / 0 + "";
}
function mo(e1, t) {
    var i, n, r;
    for((i = t.indexOf(".")) > -1 && (t = t.replace(".", "")), (n = t.search(/e/i)) > 0 ? (i < 0 && (i = n), i += +t.slice(n + 1), t = t.substring(0, n)) : i < 0 && (i = t.length), n = 0; 48 === t.charCodeAt(n); n++);
    for(r = t.length; 48 === t.charCodeAt(r - 1); --r);
    if (t = t.slice(n, r)) {
        if (r -= n, e1.e = i = i - n - 1, e1.d = [], n = (i + 1) % 7, i < 0 && (n += 7), n < r) {
            for(n && e1.d.push(+t.slice(0, n)), r -= 7; n < r;)e1.d.push(+t.slice(n, n += 7));
            n = 7 - (t = t.slice(n)).length;
        } else n -= r;
        for(; n--;)t += "0";
        e1.d.push(+t), Ir && (e1.e > e1.constructor.maxE ? (e1.d = null, e1.e = NaN) : e1.e < e1.constructor.minE && (e1.e = 0, e1.d = [
            0
        ]));
    } else e1.e = 0, e1.d = [
        0
    ];
    return e1;
}
function po(e1, t, i, n, r) {
    var o, a, s, l, u = e1.precision, c = Math.ceil(u / 7);
    for(Ir = !1, l = i.times(i), s = new e1(n);;){
        if (a = Yr(s.times(l), new e1(t++ * t++), u, 1), s = r ? n.plus(a) : n.minus(a), n = Yr(a.times(l), new e1(t++ * t++), u, 1), void 0 !== (a = s.plus(n)).d[c]) {
            for(o = c; a.d[o] === s.d[o] && o--;);
            if (-1 == o) break;
        }
        o = s, s = n, n = a, a = o;
    }
    return Ir = !0, a.d.length = c + 1, a;
}
function fo(e1, t) {
    for(var i = e1; --t;)i *= e1;
    return i;
}
function go(e1, t) {
    var i, n = t.s < 0, r = no(e1, e1.precision, 1), o = r.times(.5);
    if ((t = t.abs()).lte(o)) return Cr = n ? 4 : 1, t;
    if ((i = t.divToInt(r)).isZero()) Cr = n ? 3 : 2;
    else {
        if ((t = t.minus(i.times(r))).lte(o)) return Cr = so(i) ? n ? 2 : 3 : n ? 4 : 1, t;
        Cr = so(i) ? n ? 1 : 4 : n ? 3 : 2;
    }
    return t.minus(r).abs();
}
function yo(e1, t, i, n) {
    var r, o, a, s, l, u, c, d, h, m = e1.constructor, p = void 0 !== i;
    if (p ? (Wr(i, 1, 1e9), void 0 === n ? n = m.rounding : Wr(n, 0, 8)) : (i = m.precision, n = m.rounding), e1.isFinite()) {
        for(p ? (r = 2, 16 == t ? i = 4 * i - 3 : 8 == t && (i = 3 * i - 2)) : r = t, (a = (c = eo(e1)).indexOf(".")) >= 0 && (c = c.replace(".", ""), (h = new m(1)).e = c.length - a, h.d = Xr(eo(h), 10, r), h.e = h.d.length), o = l = (d = Xr(c, 10, r)).length; 0 == d[--l];)d.pop();
        if (d[0]) {
            if (a < 0 ? o-- : ((e1 = new m(e1)).d = d, e1.e = o, d = (e1 = Yr(e1, h, i, n, 0, r)).d, o = e1.e, u = Ar), a = d[i], s = r / 2, u = u || void 0 !== d[i + 1], u = n < 4 ? (void 0 !== a || u) && (0 === n || n === (e1.s < 0 ? 3 : 2)) : a > s || a === s && (4 === n || u || 6 === n && 1 & d[i - 1] || n === (e1.s < 0 ? 8 : 7)), d.length = i, u) for(; ++d[--i] > r - 1;)d[i] = 0, i || (++o, d.unshift(1));
            for(l = d.length; !d[l - 1]; --l);
            for(a = 0, c = ""; a < l; a++)c += Tr.charAt(d[a]);
            if (p) {
                if (l > 1) {
                    if (16 == t || 8 == t) {
                        for(a = 16 == t ? 4 : 3, --l; l % a; l++)c += "0";
                        for(l = (d = Xr(c, r, t)).length; !d[l - 1]; --l);
                        for(a = 1, c = "1."; a < l; a++)c += Tr.charAt(d[a]);
                    } else c = c.charAt(0) + "." + c.slice(1);
                }
                c = c + (o < 0 ? "p" : "p+") + o;
            } else if (o < 0) {
                for(; ++o;)c = "0" + c;
                c = "0." + c;
            } else if (++o > l) for(o -= l; o--;)c += "0";
            else o < l && (c = c.slice(0, o) + "." + c.slice(o));
        } else c = p ? "0p+0" : "0";
        c = (16 == t ? "0x" : 2 == t ? "0b" : 8 == t ? "0o" : "") + c;
    } else c = ho(e1);
    return e1.s < 0 ? "-" + c : c;
}
function bo(e1, t) {
    if (e1.length > t) return e1.length = t, !0;
}
function vo(e1) {
    return new this(e1).abs();
}
function xo(e1) {
    return new this(e1).acos();
}
function ko(e1) {
    return new this(e1).acosh();
}
function _o(e1, t) {
    return new this(e1).plus(t);
}
function wo(e1) {
    return new this(e1).asin();
}
function So(e1) {
    return new this(e1).asinh();
}
function Mo(e1) {
    return new this(e1).atan();
}
function No(e1) {
    return new this(e1).atanh();
}
function Lo(e1, t) {
    e1 = new this(e1), t = new this(t);
    var i, n = this.precision, r = this.rounding, o = n + 4;
    return e1.s && t.s ? e1.d || t.d ? !t.d || e1.isZero() ? (i = t.s < 0 ? no(this, n, r) : new this(0)).s = e1.s : !e1.d || t.isZero() ? (i = no(this, o, 1).times(.5)).s = e1.s : t.s < 0 ? (this.precision = o, this.rounding = 1, i = this.atan(Yr(e1, t, o, 1)), t = no(this, o, 1), this.precision = n, this.rounding = r, i = e1.s < 0 ? i.minus(t) : i.plus(t)) : i = this.atan(Yr(e1, t, o, 1)) : (i = no(this, o, 1).times(t.s > 0 ? .25 : .75)).s = e1.s : i = new this(NaN), i;
}
function Ao(e1) {
    return new this(e1).cbrt();
}
function Co(e1) {
    return Qr(e1 = new this(e1), e1.e + 1, 2);
}
function Eo(e1, t, i) {
    return new this(e1).clamp(t, i);
}
function To(e1) {
    if (!e1 || "object" != typeof e1) throw Error("[DecimalError] Object expected");
    var t, i, n, r = !0 === e1.defaults, o = [
        "precision",
        1,
        1e9,
        "rounding",
        0,
        8,
        "toExpNeg",
        -Er,
        0,
        "toExpPos",
        0,
        Er,
        "maxE",
        0,
        Er,
        "minE",
        -Er,
        0,
        "modulo",
        0,
        9
    ];
    for(t = 0; t < o.length; t += 3)if (i = o[t], r && (this[i] = qr[i]), void 0 !== (n = e1[i])) {
        if (!(Br(n) === n && n >= o[t + 1] && n <= o[t + 2])) throw Error(Or + i + ": " + n);
        this[i] = n;
    }
    if (i = "crypto", r && (this[i] = qr[i]), void 0 !== (n = e1[i])) {
        if (!0 !== n && !1 !== n && 0 !== n && 1 !== n) throw Error(Or + i + ": " + n);
        if (n) {
            if ("undefined" == typeof crypto || !crypto || !crypto.getRandomValues && !crypto.randomBytes) throw Error("[DecimalError] crypto unavailable");
            this[i] = !0;
        } else this[i] = !1;
    }
    return this;
}
function Do(e1) {
    return new this(e1).cos();
}
function zo(e1) {
    return new this(e1).cosh();
}
function qo(e1, t) {
    return new this(e1).div(t);
}
function Io(e1) {
    return new this(e1).exp();
}
function Oo(e1) {
    return Qr(e1 = new this(e1), e1.e + 1, 3);
}
function Fo() {
    var e1, t, i = new this(0);
    for(Ir = !1, e1 = 0; e1 < arguments.length;)if ((t = new this(arguments[e1++])).d) i.d && (i = i.plus(t.times(t)));
    else {
        if (t.s) return Ir = !0, new this(1 / 0);
        i = t;
    }
    return Ir = !0, i.sqrt();
}
function Bo(e1) {
    return e1 instanceof oa || e1 && e1.toStringTag === Fr || !1;
}
function $o(e1) {
    return new this(e1).ln();
}
function Po(e1, t) {
    return new this(e1).log(t);
}
function Ro(e1) {
    return new this(e1).log(2);
}
function Ko(e1) {
    return new this(e1).log(10);
}
function Vo() {
    return lo(this, arguments, "lt");
}
function jo() {
    return lo(this, arguments, "gt");
}
function Ho(e1, t) {
    return new this(e1).mod(t);
}
function Uo(e1, t) {
    return new this(e1).mul(t);
}
function Go(e1, t) {
    return new this(e1).pow(t);
}
function Zo(e1) {
    var t, i, n, r, o = 0, a = new this(1), s = [];
    if (void 0 === e1 ? e1 = this.precision : Wr(e1, 1, 1e9), n = Math.ceil(e1 / 7), this.crypto) {
        if (crypto.getRandomValues) for(t = crypto.getRandomValues(new Uint32Array(n)); o < n;)(r = t[o]) >= 429e7 ? t[o] = crypto.getRandomValues(new Uint32Array(1))[0] : s[o++] = r % 1e7;
        else {
            if (!crypto.randomBytes) throw Error("[DecimalError] crypto unavailable");
            for(t = crypto.randomBytes(n *= 4); o < n;)(r = t[o] + (t[o + 1] << 8) + (t[o + 2] << 16) + ((127 & t[o + 3]) << 24)) >= 214e7 ? crypto.randomBytes(4).copy(t, o) : (s.push(r % 1e7), o += 4);
            o = n / 4;
        }
    } else for(; o < n;)s[o++] = 1e7 * Math.random() | 0;
    for(e1 %= 7, (n = s[--o]) && e1 && (r = $r(10, 7 - e1), s[o] = (n / r | 0) * r); 0 === s[o]; o--)s.pop();
    if (o < 0) i = 0, s = [
        0
    ];
    else {
        for(i = -1; 0 === s[0]; i -= 7)s.shift();
        for(n = 1, r = s[0]; r >= 10; r /= 10)n++;
        n < 7 && (i -= 7 - n);
    }
    return a.e = i, a.d = s, a;
}
function Wo(e1) {
    return Qr(e1 = new this(e1), e1.e + 1, this.rounding);
}
function Jo(e1) {
    return (e1 = new this(e1)).d ? e1.d[0] ? e1.s : 0 * e1.s : e1.s || NaN;
}
function Xo(e1) {
    return new this(e1).sin();
}
function Yo(e1) {
    return new this(e1).sinh();
}
function Qo(e1) {
    return new this(e1).sqrt();
}
function ea(e1, t) {
    return new this(e1).sub(t);
}
function ta() {
    var e1 = 0, t = arguments, i = new this(t[e1]);
    for(Ir = !1; i.s && ++e1 < t.length;)i = i.plus(t[e1]);
    return Ir = !0, Qr(i, this.precision, this.rounding);
}
function ia(e1) {
    return new this(e1).tan();
}
function na(e1) {
    return new this(e1).tanh();
}
function ra(e1) {
    return Qr(e1 = new this(e1), e1.e + 1, 1);
}
Gr[Symbol.for("nodejs.util.inspect.custom")] = Gr.toString, Gr[Symbol.toStringTag] = "Decimal";
var oa = Gr.constructor = function e1(t) {
    var i, n, r;
    function o(e1) {
        var t, i, n, r = this;
        if (!(r instanceof o)) return new o(e1);
        if (r.constructor = o, Bo(e1)) return r.s = e1.s, void (Ir ? !e1.d || e1.e > o.maxE ? (r.e = NaN, r.d = null) : e1.e < o.minE ? (r.e = 0, r.d = [
            0
        ]) : (r.e = e1.e, r.d = e1.d.slice()) : (r.e = e1.e, r.d = e1.d ? e1.d.slice() : e1.d));
        if ("number" == (n = typeof e1)) {
            if (0 === e1) return r.s = 1 / e1 < 0 ? -1 : 1, r.e = 0, void (r.d = [
                0
            ]);
            if (e1 < 0 ? (e1 = -e1, r.s = -1) : r.s = 1, e1 === ~~e1 && e1 < 1e7) {
                for(t = 0, i = e1; i >= 10; i /= 10)t++;
                return void (Ir ? t > o.maxE ? (r.e = NaN, r.d = null) : t < o.minE ? (r.e = 0, r.d = [
                    0
                ]) : (r.e = t, r.d = [
                    e1
                ]) : (r.e = t, r.d = [
                    e1
                ]));
            }
            return 0 * e1 != 0 ? (e1 || (r.s = NaN), r.e = NaN, void (r.d = null)) : mo(r, e1.toString());
        }
        if ("string" !== n) throw Error(Or + e1);
        return 45 === (i = e1.charCodeAt(0)) ? (e1 = e1.slice(1), r.s = -1) : (43 === i && (e1 = e1.slice(1)), r.s = 1), Vr.test(e1) ? mo(r, e1) : function(e1, t) {
            var i, n, r, o, a, s, l, u, c;
            if (t.indexOf("_") > -1) {
                if (t = t.replace(/(\d)_(?=\d)/g, "$1"), Vr.test(t)) return mo(e1, t);
            } else if ("Infinity" === t || "NaN" === t) return +t || (e1.s = NaN), e1.e = NaN, e1.d = null, e1;
            if (Rr.test(t)) i = 16, t = t.toLowerCase();
            else if (Pr.test(t)) i = 2;
            else {
                if (!Kr.test(t)) throw Error(Or + t);
                i = 8;
            }
            for((o = t.search(/p/i)) > 0 ? (l = +t.slice(o + 1), t = t.substring(2, o)) : t = t.slice(2), a = (o = t.indexOf(".")) >= 0, n = e1.constructor, a && (o = (s = (t = t.replace(".", "")).length) - o, r = ao(n, new n(i), o, 2 * o)), o = c = (u = Xr(t, i, jr)).length - 1; 0 === u[o]; --o)u.pop();
            return o < 0 ? new n(0 * e1.s) : (e1.e = to(u, c), e1.d = u, Ir = !1, a && (e1 = Yr(e1, r, 4 * s)), l && (e1 = e1.times(Math.abs(l) < 54 ? $r(2, l) : oa.pow(2, l))), Ir = !0, e1);
        }(r, e1);
    }
    if (o.prototype = Gr, o.ROUND_UP = 0, o.ROUND_DOWN = 1, o.ROUND_CEIL = 2, o.ROUND_FLOOR = 3, o.ROUND_HALF_UP = 4, o.ROUND_HALF_DOWN = 5, o.ROUND_HALF_EVEN = 6, o.ROUND_HALF_CEIL = 7, o.ROUND_HALF_FLOOR = 8, o.EUCLID = 9, o.config = o.set = To, o.clone = e1, o.isDecimal = Bo, o.abs = vo, o.acos = xo, o.acosh = ko, o.add = _o, o.asin = wo, o.asinh = So, o.atan = Mo, o.atanh = No, o.atan2 = Lo, o.cbrt = Ao, o.ceil = Co, o.clamp = Eo, o.cos = Do, o.cosh = zo, o.div = qo, o.exp = Io, o.floor = Oo, o.hypot = Fo, o.ln = $o, o.log = Po, o.log10 = Ko, o.log2 = Ro, o.max = Vo, o.min = jo, o.mod = Ho, o.mul = Uo, o.pow = Go, o.random = Zo, o.round = Wo, o.sign = Jo, o.sin = Xo, o.sinh = Yo, o.sqrt = Qo, o.sub = ea, o.sum = ta, o.tan = ia, o.tanh = na, o.trunc = ra, void 0 === t && (t = {}), t && !0 !== t.defaults) for(r = [
        "precision",
        "rounding",
        "toExpNeg",
        "toExpPos",
        "maxE",
        "minE",
        "modulo",
        "crypto"
    ], i = 0; i < r.length;)t.hasOwnProperty(n = r[i++]) || (t[n] = this[n]);
    return o.config(t), o;
}(qr);
Dr = new oa(Dr), zr = new oa(zr);
var aa, sa = {
    exports: {}
};
aa = sa, function(e1) {
    var t = Math.cosh || function(e1) {
        return Math.abs(e1) < 1e-9 ? 1 - e1 : .5 * (Math.exp(e1) + Math.exp(-e1));
    }, i = Math.sinh || function(e1) {
        return Math.abs(e1) < 1e-9 ? e1 : .5 * (Math.exp(e1) - Math.exp(-e1));
    }, n = function() {
        throw SyntaxError("Invalid Param");
    };
    function r(e1, t) {
        var i = Math.abs(e1), n = Math.abs(t);
        return 0 === e1 ? Math.log(n) : 0 === t ? Math.log(i) : i < 3e3 && n < 3e3 ? .5 * Math.log(e1 * e1 + t * t) : .5 * Math.log((e1 /= 2) * e1 + (t /= 2) * t) + Math.LN2;
    }
    function o(e1, t) {
        if (!(this instanceof o)) return new o(e1, t);
        var i = function(e1, t) {
            var i = {
                re: 0,
                im: 0
            };
            if (null == e1) i.re = i.im = 0;
            else if (void 0 !== t) i.re = e1, i.im = t;
            else switch(typeof e1){
                case "object":
                    if ("im" in e1 && "re" in e1) i.re = e1.re, i.im = e1.im;
                    else if ("abs" in e1 && "arg" in e1) {
                        if (!Number.isFinite(e1.abs) && Number.isFinite(e1.arg)) return o.INFINITY;
                        i.re = e1.abs * Math.cos(e1.arg), i.im = e1.abs * Math.sin(e1.arg);
                    } else if ("r" in e1 && "phi" in e1) {
                        if (!Number.isFinite(e1.r) && Number.isFinite(e1.phi)) return o.INFINITY;
                        i.re = e1.r * Math.cos(e1.phi), i.im = e1.r * Math.sin(e1.phi);
                    } else 2 === e1.length ? (i.re = e1[0], i.im = e1[1]) : n();
                    break;
                case "string":
                    i.im = i.re = 0;
                    var r = e1.match(/\d+\.?\d*e[+-]?\d+|\d+\.?\d*|\.\d+|./g), a = 1, s = 0;
                    null === r && n();
                    for(var l = 0; l < r.length; l++){
                        var u = r[l];
                        " " === u || "	" === u || "\n" === u || ("+" === u ? a++ : "-" === u ? s++ : "i" === u || "I" === u ? (a + s === 0 && n(), " " === r[l + 1] || isNaN(r[l + 1]) ? i.im += parseFloat((s % 2 ? "-" : "") + "1") : (i.im += parseFloat((s % 2 ? "-" : "") + r[l + 1]), l++), a = s = 0) : ((a + s === 0 || isNaN(u)) && n(), "i" === r[l + 1] || "I" === r[l + 1] ? (i.im += parseFloat((s % 2 ? "-" : "") + u), l++) : i.re += parseFloat((s % 2 ? "-" : "") + u), a = s = 0));
                    }
                    a + s > 0 && n();
                    break;
                case "number":
                    i.im = 0, i.re = e1;
                    break;
                default:
                    n();
            }
            return isNaN(i.re) || i.im, i;
        }(e1, t);
        this.re = i.re, this.im = i.im;
    }
    o.prototype = {
        re: 0,
        im: 0,
        sign: function() {
            var e1 = this.abs();
            return new o(this.re / e1, this.im / e1);
        },
        add: function(e1, t) {
            var i = new o(e1, t);
            return this.isInfinite() && i.isInfinite() ? o.NAN : this.isInfinite() || i.isInfinite() ? o.INFINITY : new o(this.re + i.re, this.im + i.im);
        },
        sub: function(e1, t) {
            var i = new o(e1, t);
            return this.isInfinite() && i.isInfinite() ? o.NAN : this.isInfinite() || i.isInfinite() ? o.INFINITY : new o(this.re - i.re, this.im - i.im);
        },
        mul: function(e1, t) {
            var i = new o(e1, t);
            return this.isInfinite() && i.isZero() || this.isZero() && i.isInfinite() ? o.NAN : this.isInfinite() || i.isInfinite() ? o.INFINITY : 0 === i.im && 0 === this.im ? new o(this.re * i.re, 0) : new o(this.re * i.re - this.im * i.im, this.re * i.im + this.im * i.re);
        },
        div: function(e1, t) {
            var i = new o(e1, t);
            if (this.isZero() && i.isZero() || this.isInfinite() && i.isInfinite()) return o.NAN;
            if (this.isInfinite() || i.isZero()) return o.INFINITY;
            if (this.isZero() || i.isInfinite()) return o.ZERO;
            e1 = this.re, t = this.im;
            var n, r, a = i.re, s = i.im;
            return 0 === s ? new o(e1 / a, t / a) : Math.abs(a) < Math.abs(s) ? new o((e1 * (r = a / s) + t) / (n = a * r + s), (t * r - e1) / n) : new o((e1 + t * (r = s / a)) / (n = s * r + a), (t - e1 * r) / n);
        },
        pow: function(e1, t) {
            var i = new o(e1, t);
            if (e1 = this.re, t = this.im, i.isZero()) return o.ONE;
            if (0 === i.im) {
                if (0 === t && e1 > 0) return new o(Math.pow(e1, i.re), 0);
                if (0 === e1) switch((i.re % 4 + 4) % 4){
                    case 0:
                        return new o(Math.pow(t, i.re), 0);
                    case 1:
                        return new o(0, Math.pow(t, i.re));
                    case 2:
                        return new o(-Math.pow(t, i.re), 0);
                    case 3:
                        return new o(0, -Math.pow(t, i.re));
                }
            }
            if (0 === e1 && 0 === t && i.re > 0 && i.im >= 0) return o.ZERO;
            var n = Math.atan2(t, e1), a = r(e1, t);
            return e1 = Math.exp(i.re * a - i.im * n), t = i.im * a + i.re * n, new o(e1 * Math.cos(t), e1 * Math.sin(t));
        },
        sqrt: function() {
            var e1, t, i = this.re, n = this.im, r = this.abs();
            if (i >= 0) {
                if (0 === n) return new o(Math.sqrt(i), 0);
                e1 = .5 * Math.sqrt(2 * (r + i));
            } else e1 = Math.abs(n) / Math.sqrt(2 * (r - i));
            return t = i <= 0 ? .5 * Math.sqrt(2 * (r - i)) : Math.abs(n) / Math.sqrt(2 * (r + i)), new o(e1, n < 0 ? -t : t);
        },
        exp: function() {
            var e1 = Math.exp(this.re);
            return this.im, new o(e1 * Math.cos(this.im), e1 * Math.sin(this.im));
        },
        expm1: function() {
            var e1 = this.re, t = this.im;
            return new o(Math.expm1(e1) * Math.cos(t) + function(e1) {
                var t = Math.PI / 4;
                if (-t > e1 || e1 > t) return Math.cos(e1) - 1;
                var i = e1 * e1;
                return i * (i * (i * (i * (i * (i * (i * (i / 20922789888e3 - 1 / 87178291200) + 1 / 479001600) - 1 / 3628800) + 1 / 40320) - 1 / 720) + 1 / 24) - .5);
            }(t), Math.exp(e1) * Math.sin(t));
        },
        log: function() {
            var e1 = this.re, t = this.im;
            return new o(r(e1, t), Math.atan2(t, e1));
        },
        abs: function() {
            var e1, t, i, n;
            return e1 = this.re, t = this.im, i = Math.abs(e1), n = Math.abs(t), i < 3e3 && n < 3e3 ? Math.sqrt(i * i + n * n) : (i < n ? (i = n, n = e1 / t) : n = t / e1, i * Math.sqrt(1 + n * n));
        },
        arg: function() {
            return Math.atan2(this.im, this.re);
        },
        sin: function() {
            var e1 = this.re, n = this.im;
            return new o(Math.sin(e1) * t(n), Math.cos(e1) * i(n));
        },
        cos: function() {
            var e1 = this.re, n = this.im;
            return new o(Math.cos(e1) * t(n), -Math.sin(e1) * i(n));
        },
        tan: function() {
            var e1 = 2 * this.re, n = 2 * this.im, r = Math.cos(e1) + t(n);
            return new o(Math.sin(e1) / r, i(n) / r);
        },
        cot: function() {
            var e1 = 2 * this.re, n = 2 * this.im, r = Math.cos(e1) - t(n);
            return new o(-Math.sin(e1) / r, i(n) / r);
        },
        sec: function() {
            var e1 = this.re, n = this.im, r = .5 * t(2 * n) + .5 * Math.cos(2 * e1);
            return new o(Math.cos(e1) * t(n) / r, Math.sin(e1) * i(n) / r);
        },
        csc: function() {
            var e1 = this.re, n = this.im, r = .5 * t(2 * n) - .5 * Math.cos(2 * e1);
            return new o(Math.sin(e1) * t(n) / r, -Math.cos(e1) * i(n) / r);
        },
        asin: function() {
            var e1 = this.re, t = this.im, i = new o(t * t - e1 * e1 + 1, -2 * e1 * t).sqrt(), n = new o(i.re - t, i.im + e1).log();
            return new o(n.im, -n.re);
        },
        acos: function() {
            var e1 = this.re, t = this.im, i = new o(t * t - e1 * e1 + 1, -2 * e1 * t).sqrt(), n = new o(i.re - t, i.im + e1).log();
            return new o(Math.PI / 2 - n.im, n.re);
        },
        atan: function() {
            var e1 = this.re, t = this.im;
            if (0 === e1) {
                if (1 === t) return new o(0, 1 / 0);
                if (-1 === t) return new o(0, -1 / 0);
            }
            var i = e1 * e1 + (1 - t) * (1 - t), n = new o((1 - t * t - e1 * e1) / i, -2 * e1 / i).log();
            return new o(-0.5 * n.im, .5 * n.re);
        },
        acot: function() {
            var e1 = this.re, t = this.im;
            if (0 === t) return new o(Math.atan2(1, e1), 0);
            var i = e1 * e1 + t * t;
            return 0 !== i ? new o(e1 / i, -t / i).atan() : new o(0 !== e1 ? e1 / 0 : 0, 0 !== t ? -t / 0 : 0).atan();
        },
        asec: function() {
            var e1 = this.re, t = this.im;
            if (0 === e1 && 0 === t) return new o(0, 1 / 0);
            var i = e1 * e1 + t * t;
            return 0 !== i ? new o(e1 / i, -t / i).acos() : new o(0 !== e1 ? e1 / 0 : 0, 0 !== t ? -t / 0 : 0).acos();
        },
        acsc: function() {
            var e1 = this.re, t = this.im;
            if (0 === e1 && 0 === t) return new o(Math.PI / 2, 1 / 0);
            var i = e1 * e1 + t * t;
            return 0 !== i ? new o(e1 / i, -t / i).asin() : new o(0 !== e1 ? e1 / 0 : 0, 0 !== t ? -t / 0 : 0).asin();
        },
        sinh: function() {
            var e1 = this.re, n = this.im;
            return new o(i(e1) * Math.cos(n), t(e1) * Math.sin(n));
        },
        cosh: function() {
            var e1 = this.re, n = this.im;
            return new o(t(e1) * Math.cos(n), i(e1) * Math.sin(n));
        },
        tanh: function() {
            var e1 = 2 * this.re, n = 2 * this.im, r = t(e1) + Math.cos(n);
            return new o(i(e1) / r, Math.sin(n) / r);
        },
        coth: function() {
            var e1 = 2 * this.re, n = 2 * this.im, r = t(e1) - Math.cos(n);
            return new o(i(e1) / r, -Math.sin(n) / r);
        },
        csch: function() {
            var e1 = this.re, n = this.im, r = Math.cos(2 * n) - t(2 * e1);
            return new o(-2 * i(e1) * Math.cos(n) / r, 2 * t(e1) * Math.sin(n) / r);
        },
        sech: function() {
            var e1 = this.re, n = this.im, r = Math.cos(2 * n) + t(2 * e1);
            return new o(2 * t(e1) * Math.cos(n) / r, -2 * i(e1) * Math.sin(n) / r);
        },
        asinh: function() {
            var e1 = this.im;
            this.im = -this.re, this.re = e1;
            var t = this.asin();
            return this.re = -this.im, this.im = e1, e1 = t.re, t.re = -t.im, t.im = e1, t;
        },
        acosh: function() {
            var e1 = this.acos();
            if (e1.im <= 0) {
                var t = e1.re;
                e1.re = -e1.im, e1.im = t;
            } else t = e1.im, e1.im = -e1.re, e1.re = t;
            return e1;
        },
        atanh: function() {
            var e1 = this.re, t = this.im, i = e1 > 1 && 0 === t, n = 1 - e1, a = 1 + e1, s = n * n + t * t, l = 0 !== s ? new o((a * n - t * t) / s, (t * n + a * t) / s) : new o(-1 !== e1 ? e1 / 0 : 0, 0 !== t ? t / 0 : 0), u = l.re;
            return l.re = r(l.re, l.im) / 2, l.im = Math.atan2(l.im, u) / 2, i && (l.im = -l.im), l;
        },
        acoth: function() {
            var e1 = this.re, t = this.im;
            if (0 === e1 && 0 === t) return new o(0, Math.PI / 2);
            var i = e1 * e1 + t * t;
            return 0 !== i ? new o(e1 / i, -t / i).atanh() : new o(0 !== e1 ? e1 / 0 : 0, 0 !== t ? -t / 0 : 0).atanh();
        },
        acsch: function() {
            var e1 = this.re, t = this.im;
            if (0 === t) return new o(0 !== e1 ? Math.log(e1 + Math.sqrt(e1 * e1 + 1)) : 1 / 0, 0);
            var i = e1 * e1 + t * t;
            return 0 !== i ? new o(e1 / i, -t / i).asinh() : new o(0 !== e1 ? e1 / 0 : 0, 0 !== t ? -t / 0 : 0).asinh();
        },
        asech: function() {
            var e1 = this.re, t = this.im;
            if (this.isZero()) return o.INFINITY;
            var i = e1 * e1 + t * t;
            return 0 !== i ? new o(e1 / i, -t / i).acosh() : new o(0 !== e1 ? e1 / 0 : 0, 0 !== t ? -t / 0 : 0).acosh();
        },
        inverse: function() {
            if (this.isZero()) return o.INFINITY;
            if (this.isInfinite()) return o.ZERO;
            var e1 = this.re, t = this.im, i = e1 * e1 + t * t;
            return new o(e1 / i, -t / i);
        },
        conjugate: function() {
            return new o(this.re, -this.im);
        },
        neg: function() {
            return new o(-this.re, -this.im);
        },
        ceil: function(e1) {
            return e1 = Math.pow(10, e1 || 0), new o(Math.ceil(this.re * e1) / e1, Math.ceil(this.im * e1) / e1);
        },
        floor: function(e1) {
            return e1 = Math.pow(10, e1 || 0), new o(Math.floor(this.re * e1) / e1, Math.floor(this.im * e1) / e1);
        },
        round: function(e1) {
            return e1 = Math.pow(10, e1 || 0), new o(Math.round(this.re * e1) / e1, Math.round(this.im * e1) / e1);
        },
        equals: function(e1, t) {
            var i = new o(e1, t);
            return Math.abs(i.re - this.re) <= o.EPSILON && Math.abs(i.im - this.im) <= o.EPSILON;
        },
        clone: function() {
            return new o(this.re, this.im);
        },
        toString: function() {
            var e1 = this.re, t = this.im, i = "";
            return this.isNaN() ? "NaN" : this.isInfinite() ? "Infinity" : (Math.abs(e1) < o.EPSILON && (e1 = 0), Math.abs(t) < o.EPSILON && (t = 0), 0 === t ? i + e1 : (0 !== e1 ? (i += e1, i += " ", t < 0 ? (t = -t, i += "-") : i += "+", i += " ") : t < 0 && (t = -t, i += "-"), 1 !== t && (i += t), i + "i"));
        },
        toVector: function() {
            return [
                this.re,
                this.im
            ];
        },
        valueOf: function() {
            return 0 === this.im ? this.re : null;
        },
        isNaN: function() {
            return isNaN(this.re) || isNaN(this.im);
        },
        isZero: function() {
            return 0 === this.im && 0 === this.re;
        },
        isFinite: function() {
            return isFinite(this.re) && isFinite(this.im);
        },
        isInfinite: function() {
            return !(this.isNaN() || this.isFinite());
        }
    }, o.ZERO = new o(0, 0), o.ONE = new o(1, 0), o.I = new o(0, 1), o.PI = new o(Math.PI, 0), o.E = new o(Math.E, 0), o.INFINITY = new o(1 / 0, 1 / 0), o.NAN = new o(NaN, NaN), o.EPSILON = 1e-15, Object.defineProperty(o, "__esModule", {
        value: !0
    }), o.default = o, o.Complex = o, aa.exports = o;
}();
var la = function(e1) {
    return e1 && e1.__esModule && Object.prototype.hasOwnProperty.call(e1, "default") ? e1.default : e1;
}(sa.exports);
function ua(e1) {
    return 8205 === e1 || 65038 === e1 || 65039 === e1 || e1 >= 127995 && e1 <= 128e3 || e1 >= 129456 && e1 <= 129460 || e1 >= 917536 && e1 <= 917632;
}
function ca(e1) {
    return e1 >= 127462 && e1 <= 127487;
}
class da {
    end() {
        return this.pos >= this.s.length;
    }
    get() {
        return this.pos < this.s.length ? this.s[this.pos++] : "";
    }
    peek() {
        return this.s[this.pos];
    }
    match(e1) {
        let t;
        return t = "string" == typeof this.s ? e1.exec(this.s.slice(this.pos)) : e1.exec(this.s.slice(this.pos).join("")), (null == t ? void 0 : t[0]) ? (this.pos += t[0].length, t[0]) : null;
    }
    next() {
        if (this.end()) return null;
        if (!this.obeyspaces && this.match(/^[ \f\n\r\t\v\xA0\u2028\u2029]+/)) return "<space>";
        if (this.obeyspaces && this.match(/^[ \f\n\r\t\v\xA0\u2028\u2029]/)) return "<space>";
        const e1 = this.get();
        if ("\\" === e1) {
            if (!this.end()) {
                let e2 = this.match(/^[a-zA-Z*]+/);
                if (e2) this.match(/^[ \f\n\r\t\v\xA0\u2028\u2029]*/);
                else if (e2 = this.get(), " " === e2) return "<space>";
                return "\\" + e2;
            }
        } else {
            if ("{" === e1) return "<{>";
            if ("}" === e1) return "<}>";
            if ("^" === e1) {
                if ("^" === this.peek()) {
                    this.get();
                    const e3 = this.match(/^(\^(\^(\^(\^[0-9a-f])?[0-9a-f])?[0-9a-f])?[0-9a-f])?[0-9a-f][0-9a-f]/);
                    if (e3) return String.fromCodePoint(parseInt(e3.slice(e3.lastIndexOf("^") + 1), 16));
                }
                return e1;
            }
            if ("#" === e1) {
                if (!this.end()) {
                    let e4 = !1;
                    if (/[0-9?]/.test(this.peek()) && (e4 = !0, this.pos + 1 < this.s.length)) {
                        const t = this.s[this.pos + 1];
                        e4 = /[^0-9A-Za-z]/.test(t);
                    }
                    return e4 ? "#" + this.get() : "#";
                }
            } else if ("$" === e1) return "$" === this.peek() ? (this.get(), "<$$>") : "<$>";
        }
        return e1;
    }
    constructor(e1){
        this.obeyspaces = !1, this.s = function(e1) {
            if (/^[\u0020-\u00FF]*$/.test(e1)) return e1;
            const t = [], i = function(e1) {
                const t = [];
                for(let i = 0; i < e1.length; i++){
                    let n = e1.charCodeAt(i);
                    if (n >= 55296 && n <= 56319) {
                        const t1 = e1.charCodeAt(i + 1);
                        t1 >= 56320 && t1 <= 57343 && (n = 65536 + 1024 * (n - 55296) + (t1 - 56320), i++);
                    }
                    t.push(n);
                }
                return t;
            }(e1);
            let n = 0;
            for(; n < i.length;){
                const e2 = i[n++], r = i[n];
                if (8205 === r) {
                    const e3 = n - 1;
                    for(n += 2; 8205 === i[n];)n += 2;
                    t.push(String.fromCodePoint(...i.slice(e3, 2 * n - e3 + 1)));
                } else if (ua(r)) {
                    const e4 = n - 1;
                    for(; ua(i[n]);)n += 8205 === i[n] ? 2 : 1;
                    t.push(String.fromCodePoint(...i.slice(e4, 2 * n - e4 - 1)));
                } else ca(e2) ? (n += 1, t.push(String.fromCodePoint(...i.slice(n - 2, 2)))) : t.push(String.fromCodePoint(e2));
            }
            return t;
        }(e1), this.pos = 0;
    }
}
function ha(e1, t) {
    var i, n, r, o;
    let a = [], s = e1.next();
    if (s) {
        if ("\\relax" === s) ;
        else if ("\\noexpand" === s) s = e1.next(), s && a.push(s);
        else if ("\\obeyspaces" === s) e1.obeyspaces = !0;
        else if ("\\space" === s || "~" === s) a.push("<space>");
        else if ("\\bgroup" === s) a.push("<{>");
        else if ("\\egroup" === s) a.push("<}>");
        else if ("\\string" === s) s = e1.next(), s && ("\\" === s[0] ? Array.from(s).forEach((e1)=>a.push("\\" === e1 ? "\\backslash" : e1)) : "<{>" === s ? a.push("\\{") : "<space>" === s ? a.push("~") : "<}>" === s && a.push("\\}"));
        else if ("\\csname" === s) {
            for(; "<space>" === e1.peek();)e1.next();
            let r1 = "", o1 = !1, l = [];
            do 0 === l.length && (/^#[0-9?]$/.test(e1.peek()) ? (l = ma(null !== (n = null !== (i = null == t ? void 0 : t[e1.get().slice(1)]) && void 0 !== i ? i : null == t ? void 0 : t["?"]) && void 0 !== n ? n : "\\placeholder{}", t), s = l[0]) : (s = e1.next(), l = s ? [
                s
            ] : [])), o1 = 0 === l.length, o1 || "\\endcsname" !== s || (o1 = !0, l.shift()), o1 || (o1 = "<$>" === s || "<$$>" === s || "<{>" === s || "<}>" === s || !!s && s.length > 1 && "\\" === s[0]), o1 || (r1 += l.shift());
            while (!o1);
            r1 && a.push("\\" + r1), a = a.concat(l);
        } else if ("\\endcsname" === s) ;
        else if (s.length > 1 && "#" === s[0]) {
            const e2 = s.slice(1);
            a = a.concat(ma(null !== (o = null !== (r = null == t ? void 0 : t[e2]) && void 0 !== r ? r : null == t ? void 0 : t["?"]) && void 0 !== o ? o : "\\placeholder{}", t));
        } else a.push(s);
    }
    return a;
}
function ma(e1, t) {
    const i = e1.toString().split(/\r?\n/);
    let n = "", r = "";
    for (const e2 of i){
        n += r, r = " ";
        const t1 = e2.match(/((?:\\%)|[^%])*/);
        null !== t1 && (n += t1[0]);
    }
    const o = new da(n), a = [];
    do a.push(...ha(o, t));
    while (!o.end());
    return a;
}
function pa(e1) {
    let t = "", i = "";
    for (const n of e1)n && (/[a-zA-Z*]/.test(n[0]) && (i += t), t = /\\[a-zA-Z]+\*?$/.test(n) ? " " : "", i += n);
    return i;
}
function fa(e1) {
    let t = [];
    if (Array.isArray(e1)) for (const i of e1)Array.isArray(i) ? t = [
        ...t,
        ...i
    ] : t.push(i);
    else t = [
        e1
    ];
    return pa(t.map((e1)=>{
        var t;
        return null !== (t = ({
            "<space>": " ",
            "<$$>": "$$",
            "<$>": "$",
            "<{>": "{",
            "<}>": "}"
        })[e1]) && void 0 !== t ? t : e1;
    }));
}
function ga(e1) {
    return null !== e1 && "object" == typeof e1 && "num" in e1;
}
function ya(e1) {
    return null !== e1 && "object" == typeof e1 && "sym" in e1;
}
function ba(e1) {
    return null !== e1 && "object" == typeof e1 && "fn" in e1;
}
function va(e1) {
    return !/[\u0000-\u0020\u0022\u0060\ufffe\uffff]/.test(e1) && !/^[\u0021\u0022\u0024-\u0029\u002e\u003a\u003f\u0040\u005b\u005d\u005e\u007b\u007d\u007e\+\-[0-9]]/.test(e1);
}
function xa(e1) {
    return null == e1 ? null : "object" == typeof e1 && "str" in e1 ? e1.str : "string" != typeof e1 || e1.length < 2 || "'" !== e1[0] || "'" !== e1[e1.length - 1] ? null : e1.substring(1, e1.length - 1);
}
function ka(e1) {
    var t;
    if (null == e1 || null !== xa(e1)) return null;
    const i = _a(e1);
    return null !== i ? [
        i,
        ...(null !== (t = Sa(e1)) && void 0 !== t ? t : []).map((e1)=>ka(e1)).filter((e1)=>null !== e1)
    ] : e1;
}
function _a(e1) {
    return null == e1 ? null : Array.isArray(e1) ? e1[0] : ba(e1) ? e1.fn[0] : null;
}
function wa(e1) {
    const t = _a(e1);
    return "string" == typeof t ? t : "";
}
function Sa(e1) {
    return null == e1 ? null : Array.isArray(e1) ? e1.slice(1) : ba(e1) ? e1.fn.slice(1) : null;
}
function Ma(e1, t) {
    var i, n;
    return null == e1 ? null : Array.isArray(e1) ? null !== (i = e1[t]) && void 0 !== i ? i : null : ba(e1) && null !== (n = e1.fn[t]) && void 0 !== n ? n : null;
}
function Na(e1) {
    return Ma(e1, 1);
}
function La(e1) {
    return Ma(e1, 2);
}
function Aa(e1) {
    return null == e1 ? 0 : Array.isArray(e1) ? Math.max(0, e1.length - 1) : ba(e1) ? Math.max(0, e1.fn.length - 1) : 0;
}
function Ca(e1) {
    if (null == e1) return null;
    if ("string" == typeof e1) {
        if (/^[+\-\.0-9]/.test(e1)) return null;
        if (e1.length >= 2 && "'" === e1[0] && "'" === e1[e1.length - 1]) return null;
    }
    const t = ya(e1) ? e1.sym : e1;
    return "string" != typeof t ? null : t;
}
function Ea(e1) {
    var t;
    const i = _a(e1);
    if ("KeyValuePair" === i || "Tuple" === i || "Pair" === i) {
        const i1 = xa(Na(e1));
        return i1 ? [
            i1,
            null !== (t = La(e1)) && void 0 !== t ? t : "Nothing"
        ] : null;
    }
    return null;
}
function Ta(e1) {
    if (null === e1) return null;
    if ("object" == typeof e1 && "dict" in e1) return e1.dict;
    const t = Ea(e1);
    if (t) return {
        [t[0]]: t[1]
    };
    if ("Dictionary" === _a(e1)) {
        const t1 = {};
        for(let i = 1; i < Aa(e1); i++){
            const n = Ea(Ma(e1, i));
            n && (t1[n[0]] = n[1]);
        }
        return t1;
    }
    return null;
}
function Da(e1) {
    var t;
    if ("nan" === (e1 = e1.toLowerCase().replace(/[nd]$/g, "").replace(/[\u0009-\u000d\u0020\u00a0]/g, ""))) return NaN;
    if ("+infinity" === e1) return 1 / 0;
    if ("-infinity" === e1) return -1 / 0;
    if (/\([0-9]+\)/.test(e1)) {
        const [i, n, r, o] = null !== (t = e1.match(/(.+)\(([0-9]+)\)(.*)$/)) && void 0 !== t ? t : [];
        e1 = n + r.repeat(Math.ceil(16 / r.length)) + (null != o ? o : "");
    }
    return parseFloat(e1);
}
function za(e1) {
    return null == e1 ? null : "number" == typeof e1 ? e1 : ga(e1) ? Da(e1.num) : "string" == typeof e1 ? Da(e1) : null;
}
function qa(e1) {
    var t, i;
    if (null == e1) return null;
    if ("Half" === Ca(e1)) return [
        1,
        2
    ];
    const n = _a(e1);
    if (!n) return null;
    let r = null, o = null;
    if ("Negate" === n) {
        const t1 = qa(Na(e1));
        if (t1) return [
            -t1[0],
            t1[1]
        ];
    }
    if ("Rational" !== n && "Divide" !== n || (r = null !== (t = za(Na(e1))) && void 0 !== t ? t : NaN, o = null !== (i = za(La(e1))) && void 0 !== i ? i : NaN), "Power" === n) {
        const t2 = za(La(e1));
        1 === t2 ? (r = za(Na(e1)), o = 1) : -1 === t2 && (r = 1, o = za(Na(e1)));
    }
    return "Multiply" === n && "Power" === _a(La(e1)) && -1 === za(La(La(e1))) && (r = za(Na(e1)), o = za(Na(La(e1)))), null === r || null === o ? null : Number.isInteger(r) && Number.isInteger(o) ? [
        r,
        o
    ] : null;
}
function Ia(e1, t) {
    var i;
    const n = _a(e1);
    if (null !== n) return [
        Ia(n, t),
        ...(null !== (i = Sa(e1)) && void 0 !== i ? i : []).map((e1)=>Ia(e1, t))
    ];
    const r = Ta(e1);
    if (null !== r) {
        const e2 = Object.keys(r), i1 = {};
        for (const n1 of e2)i1[n1] = Ia(r[n1], t);
        return {
            dict: i1
        };
    }
    const o = Ca(e1);
    return o && t[o] ? t[o] : e1;
}
function Oa(e1, t) {
    let i = null;
    if (Array.isArray(e1) && (i = e1), ba(e1) && (i = e1.fn), null === i) return [];
    let n = 1;
    const r = [];
    for(; n < i.length;)r.push(t(i[n])), n += 1;
    return r;
}
function Fa(e1, t, i, n = "both") {
    var r, o, a, s, l, u;
    if ("non" === n) return [
        e1,
        t,
        i
    ];
    const c = _a(t), d = _a(i);
    return "left" === n ? c === e1 ? [
        e1,
        ...null !== (r = Sa(t)) && void 0 !== r ? r : [],
        i
    ] : [
        e1,
        t,
        i
    ] : "right" === n ? d === e1 ? [
        e1,
        t,
        ...null !== (o = Sa(i)) && void 0 !== o ? o : []
    ] : [
        e1,
        t,
        i
    ] : c === e1 && d === e1 ? [
        e1,
        ...null !== (a = Sa(t)) && void 0 !== a ? a : [],
        ...null !== (s = Sa(i)) && void 0 !== s ? s : []
    ] : c === e1 ? [
        e1,
        ...null !== (l = Sa(t)) && void 0 !== l ? l : [],
        i
    ] : d === e1 ? [
        e1,
        t,
        ...null !== (u = Sa(i)) && void 0 !== u ? u : []
    ] : [
        e1,
        t,
        i
    ];
}
function Ba(e1) {
    var t;
    let i = _a(e1);
    if (null === e1) return null;
    if ("Delimiter" === i) {
        if (null === (e1 = Ma(e1, 1))) return [];
        if ("Sequence" !== _a(e1)) return [
            e1
        ];
    }
    return i = _a(e1), "Sequence" === i ? null !== (t = Sa(e1)) && void 0 !== t ? t : [] : null;
}
function $a(e1) {
    return null !== e1 && "Sequence" === _a(e1) && 0 === Aa(e1);
}
function Pa(e1) {
    return null === e1 || $a(e1) ? [
        "Error",
        "'missing'"
    ] : e1;
}
function Ra(e1) {
    return "Square" === e1[0] ? Ra(e1.slice(1)) + 2 : e1.reduce((e1, t)=>e1 + Ka(t), 0);
}
function Ka(e1) {
    if (null === e1) return 0;
    if ("number" == typeof e1 || "string" == typeof e1) return 1;
    if (ga(e1) || ya(e1) || function(e1) {
        return null !== e1 && "object" == typeof e1 && "str" in e1;
    }(e1)) return 1;
    if (Array.isArray(e1)) return Ra(e1);
    if ("fn" in e1) return Ra(e1.fn);
    const t = Ta(e1);
    if (t) {
        const e2 = Object.keys(t);
        return 1 + e2.length + e2.reduce((e1, i)=>e1 + Ka(t[i]), 0);
    }
    return 0;
}
function Va(e1, t) {
    return t > 2 ? "solidus" : "radical";
}
function ja(e1, t) {
    if (t > 3) return "inline-solidus";
    if ("Divide" === _a(e1)) {
        const [t1, i] = [
            Ka(Na(e1)),
            Ka(La(e1))
        ];
        if (i <= 2 && t1 > 3) return "factor";
        if (t1 <= 2 && i > 3) return "reciprocal";
    }
    return "quotient";
}
function Ha(e1, t, i, n) {
    return null === i ? "\\sqrt{}" : (n = null != n ? n : 2, "solidus" === t ? e1.wrapShort(i) + "^{1\\/" + e1.serialize(n) + "}" : "quotient" === t ? e1.wrapShort(i) + "^{\\frac{1}{" + e1.serialize(n) + "}}" : 2 === za(n) ? "\\sqrt{" + e1.serialize(i) + "}" : "\\sqrt[" + e1.serialize(n) + "]{" + e1.serialize(i) + "}");
}
function Ua(e1, t) {
    if (null === t) return "";
    const i = Pa(Ma(t, 1)), n = Pa(Ma(t, 2)), r = ja(t, e1.level);
    if ("inline-solidus" === r || "nice-solidus" === r) {
        const t1 = e1.wrapShort(i), o = e1.wrapShort(n);
        return "inline-solidus" === r ? `${t1}\\/${o}` : `^{${t1}}\\!\\!/\\!_{${o}}`;
    }
    return "reciprocal" === r ? 1 === za(i) ? e1.wrap(n) + "^{-1}" : e1.wrap(i) + e1.wrap(n) + "^{-1}" : "factor" === r ? 1 === za(n) ? e1.wrap(i) : "\\frac{1}{" + e1.serialize(n) + "}" + e1.wrap(i) : `\\frac{${e1.serialize(i)}}{${e1.serialize(n)}}`;
}
function Ga(e1, t) {
    var i;
    const n = _a(t), r = Pa(Ma(t, 1));
    if ("Sqrt" === n) return Ha(e1, Va(0, e1.level - 1), r, 2);
    const o = Pa(Ma(t, 2));
    if ("Root" === n) return Ha(e1, Va(0, e1.level - 1), r, o);
    const a = null !== (i = za(o)) && void 0 !== i ? i : 1;
    if (-1 === a) return e1.serialize([
        "Divide",
        "1",
        r
    ]);
    if (a < 0) return e1.serialize([
        "Divide",
        "1",
        [
            "Power",
            r,
            -a
        ]
    ]);
    if ("Divide" === _a(o) || "Rational" === _a(o)) {
        if (1 === za(Ma(o, 1))) return Ha(e1, Va(0, e1.level), r, Ma(o, 2));
        if (2 === za(Ma(o, 2))) return `${e1.serialize([
            "Sqrt",
            r
        ])}^{${e1.serialize(Ma(o, 1))}}`;
    } else if ("Power" === _a(o) && -1 === za(Ma(o, 2))) return Ha(e1, Va(0, e1.level), r, Ma(o, 1));
    return e1.wrapShort(r) + "^{" + e1.serialize(o) + "}";
}
const Za = [
    {
        name: "CatalanConstant",
        serialize: "G"
    },
    {
        name: "GoldenRatio",
        serialize: "\\varphi"
    },
    {
        name: "EulerGamma",
        serialize: "\\gamma"
    },
    {
        name: "Degrees",
        trigger: [
            "\\degree"
        ],
        kind: "postfix",
        precedence: 880,
        parse: (e1, t)=>[
                "Degrees",
                t
            ],
        serialize: (e1, t)=>pa([
                e1.serialize(Ma(t, 1)),
                "\\degree"
            ])
    },
    {
        trigger: [
            "\\deg"
        ],
        kind: "postfix",
        precedence: 880,
        parse: (e1, t)=>[
                "Degrees",
                t
            ]
    },
    {
        trigger: [
            "^",
            "<{>",
            "\\circ",
            "<}>"
        ],
        kind: "postfix",
        parse: (e1, t)=>[
                "Degrees",
                t
            ]
    },
    {
        trigger: [
            "^",
            "\\circ"
        ],
        kind: "postfix",
        parse: (e1, t)=>[
                "Degrees",
                t
            ]
    },
    {
        trigger: [
            "\xb0"
        ],
        kind: "postfix",
        precedence: 880,
        parse: (e1, t)=>[
                "Degrees",
                t
            ]
    },
    {
        trigger: [
            "\\ang"
        ],
        parse: (e1)=>{
            const t = e1.matchRequiredLatexArgument();
            return null === t ? [
                "Degrees"
            ] : [
                "Degrees",
                t
            ];
        }
    },
    {
        trigger: [
            "\\infty"
        ],
        parse: {
            num: "+Infinity"
        }
    },
    {
        name: "ComplexInfinity",
        trigger: [
            "\\tilde",
            "\\infty"
        ],
        serialize: "\\tilde\\infty"
    },
    {
        trigger: [
            "\\tilde",
            "<{>",
            "\\infty",
            "<}>"
        ],
        parse: "ComplexInfinity"
    },
    {
        name: "Pi",
        trigger: [
            "\\pi"
        ]
    },
    {
        trigger: [
            "π"
        ],
        parse: "Pi"
    },
    {
        name: "ExponentialE",
        trigger: [
            "\\exponentialE"
        ],
        parse: "ExponentialE",
        serialize: "\\exponentialE"
    },
    {
        name: "ImaginaryUnit",
        trigger: [
            "\\imaginaryI"
        ]
    },
    {
        name: "Abs",
        kind: "matchfix",
        openDelimiter: "|",
        closeDelimiter: "|",
        parse: (e1, t)=>$a(t) ? null : [
                "Abs",
                t
            ]
    },
    {
        trigger: "abs",
        kind: "function",
        parse: (e1)=>{
            const t = e1.matchArguments("enclosure");
            return null === t ? "Abs" : [
                "Abs",
                ...t
            ];
        }
    },
    {
        name: "Add",
        trigger: [
            "+"
        ],
        kind: "infix",
        associativity: "both",
        precedence: 275,
        parse: (e1, t, i)=>{
            if (275 < t.minPrec) return null;
            const n = e1.matchExpression({
                ...t,
                minPrec: 275
            });
            return null === n ? null : Fa("Add", i, n);
        },
        serialize: function(e1, t) {
            var i, n, r, o;
            e1.level -= 1;
            const a = _a(t);
            let s = "", l = Ma(t, 1);
            if ("Negate" === a) s = "-" + e1.wrap(l, 276);
            else if ("Add" === a) {
                if (2 === Aa(t)) {
                    let r1, o1;
                    if (za(Ma(t, 1)) && qa(Ma(t, 2)) ? (r1 = Ma(t, 1), o1 = Ma(t, 2)) : za(Ma(t, 2)) && qa(Ma(t, 1)) && (r1 = Ma(t, 2), o1 = Ma(t, 1)), r1 && o1) {
                        const t1 = null !== (i = za(r1)) && void 0 !== i ? i : NaN, a1 = null !== (n = qa(o1)) && void 0 !== n ? n : [
                            NaN,
                            NaN
                        ];
                        if (isFinite(t1) && Number.isInteger(t1) && t1 >= 0 && t1 <= 1e3 && isFinite(a1[0]) && isFinite(a1[1]) && a1[0] > 0 && a1[0] <= 100 && a1[1] <= 100) return s = pa([
                            e1.serialize(r1),
                            e1.options.invisiblePlus,
                            e1.serialize(o1)
                        ]), e1.level += 1, s;
                    }
                }
                let a2 = null !== (r = za(l)) && void 0 !== r ? r : NaN;
                s = e1.serialize(l);
                const u = Aa(t) + 1;
                for(let i1 = 2; i1 < u; i1++)if (l = Ma(t, i1), a2 = null !== (o = za(l)) && void 0 !== o ? o : NaN, a2 < 0) s += e1.serialize(l);
                else if ("Negate" === _a(l)) s += e1.wrap(l, 275);
                else {
                    const t2 = e1.wrap(l, 275);
                    "-" === t2[0] || "+" === t2[0] ? s += t2 : s += "+" + t2;
                }
            } else if ("Subtract" === a) {
                s = e1.wrap(l, 275);
                const i2 = Ma(t, 2);
                if (null !== i2) {
                    const t3 = e1.wrap(i2, 275);
                    "-" === t3[0] ? s += "+" + t3.slice(1) : "+" === t3[0] ? s += "-" + t3.slice(1) : s = s + "-" + t3;
                }
            }
            return e1.level += 1, s;
        }
    },
    {
        kind: "prefix",
        trigger: [
            "+"
        ],
        precedence: 275,
        parse: (e1, t)=>275 < t.minPrec ? null : e1.matchExpression({
                ...t,
                minPrec: 400
            })
    },
    {
        name: "Ceil",
        kind: "matchfix",
        openDelimiter: "\\lceil",
        closeDelimiter: "\\rceil"
    },
    {
        trigger: "ceil",
        kind: "function",
        parse: (e1)=>{
            const t = e1.matchArguments("enclosure");
            return null === t ? "Ceil" : [
                "Ceil",
                ...t
            ];
        }
    },
    {
        name: "Complex",
        precedence: 274,
        serialize: (e1, t)=>{
            const i = za(Ma(t, 1)), n = za(Ma(t, 2));
            if (0 === n) return e1.serialize(Ma(t, 1));
            const r = 1 === n ? "\\imaginaryI" : -1 === n ? "-\\imaginaryI" : pa([
                e1.serialize(Ma(t, 2)),
                "\\imaginaryI"
            ]);
            return 0 === i ? r : pa(null !== n && n < 0 ? [
                e1.serialize(Ma(t, 1)),
                r
            ] : [
                e1.serialize(Ma(t, 1)),
                "+",
                r
            ]);
        }
    },
    {
        name: "Divide",
        trigger: "\\frac",
        precedence: 660,
        parse: function(e1) {
            var t, i;
            const n = Pa(e1.matchRequiredLatexArgument()), r = Pa(e1.matchRequiredLatexArgument());
            if ("PartialDerivative" === _a(n) && ("PartialDerivative" === _a(r) || "Multiply" === _a(r) && "PartialDerivative" === _a(Ma(r, 1)))) {
                const o = null !== (t = Ma(n, 3)) && void 0 !== t ? t : null;
                let a = Ma(n, 1);
                null === a && (a = Pa(e1.matchExpression()));
                let s = [];
                if ("Multiply" === _a(r)) {
                    for (const e2 of null !== (i = Sa(r)) && void 0 !== i ? i : [])if ("PartialDerivative" === _a(e2)) {
                        const t1 = Ma(e2, 2);
                        t1 && s.push(t1);
                    }
                } else {
                    const e3 = Ma(r, 2);
                    e3 && s.push(e3);
                }
                return s.length > 1 && (s = [
                    "List",
                    ...s
                ]), [
                    "PartialDerivative",
                    a,
                    ...s,
                    null === o ? 1 : o
                ];
            }
            return [
                "Divide",
                n,
                r
            ];
        },
        serialize: Ua
    },
    {
        kind: "infix",
        trigger: "\\over",
        precedence: 660,
        parse: "Divide"
    },
    {
        trigger: [
            "\\/"
        ],
        kind: "infix",
        associativity: "non",
        precedence: 660,
        parse: "Divide"
    },
    {
        trigger: [
            "/"
        ],
        kind: "infix",
        associativity: "non",
        precedence: 660,
        parse: "Divide"
    },
    {
        trigger: [
            "\\div"
        ],
        kind: "infix",
        associativity: "non",
        precedence: 660,
        parse: "Divide"
    },
    {
        name: "Exp",
        serialize: (e1, t)=>pa([
                "\\exponentialE^{",
                e1.serialize(Pa(Ma(t, 1))),
                "}"
            ])
    },
    {
        name: "Factorial",
        trigger: [
            "!"
        ],
        kind: "postfix",
        precedence: 810
    },
    {
        name: "Factorial2",
        trigger: [
            "!",
            "!"
        ],
        kind: "postfix",
        precedence: 810
    },
    {
        name: "Floor",
        kind: "matchfix",
        openDelimiter: "\\lfloor",
        closeDelimiter: "\\rfloor"
    },
    {
        trigger: "floor",
        kind: "function",
        parse: (e1)=>{
            const t = e1.matchArguments("enclosure");
            return null === t ? "Floor" : [
                "Floor",
                ...t
            ];
        }
    },
    {
        name: "Gcd",
        trigger: "gcd",
        kind: "function"
    },
    {
        name: "Half",
        serialize: "\\frac12"
    },
    {
        name: "Lg",
        trigger: [
            "\\lg"
        ],
        serialize: (e1, t)=>"\\log_{10}" + e1.wrapArguments(t),
        parse: (e1)=>{
            const t = e1.matchArguments("implicit");
            return null === t ? [
                "Lg"
            ] : [
                "Log",
                ...t,
                10
            ];
        }
    },
    {
        name: "Lb",
        trigger: "\\lb",
        parse: (e1)=>{
            const t = e1.matchArguments("implicit");
            return null === t ? [
                "Log"
            ] : [
                "Log",
                ...t,
                2
            ];
        }
    },
    {
        name: "Ln",
        trigger: [
            "\\ln"
        ],
        serialize: (e1, t)=>"\\ln" + e1.wrapArguments(t),
        parse: (e1)=>Xa("Ln", e1)
    },
    {
        name: "Log",
        trigger: [
            "\\log"
        ],
        parse: (e1)=>Xa("Log", e1),
        serialize: (e1, t)=>{
            const i = La(t);
            return i ? pa([
                "\\log_{",
                i.toString(),
                "}",
                e1.wrap(Na(t))
            ]) : "\\log" + e1.wrapArguments(t);
        }
    },
    {
        name: "Lcm",
        trigger: "lcm",
        kind: "function"
    },
    {
        name: "MinusPlus",
        trigger: [
            "\\mp"
        ],
        kind: "infix",
        associativity: "both",
        precedence: 270
    },
    {
        name: "Multiply",
        trigger: [
            "\\times"
        ],
        kind: "infix",
        associativity: "both",
        precedence: 390,
        serialize: function e1(t, i) {
            var n;
            if (null === i) return "";
            t.level -= 1;
            let r = "";
            const [o, a] = function(e1) {
                var t, i;
                if ("Multiply" !== _a(e1)) return [
                    [],
                    []
                ];
                const n = [], r = [], o = null !== (t = Sa(e1)) && void 0 !== t ? t : [];
                for (const e2 of o)if ("Power" === _a(e2)) {
                    const t1 = Ma(e2, 1), o1 = Ma(e2, 2);
                    if ("Negate" === _a(o1)) {
                        const e3 = Ma(o1, 1);
                        t1 && e3 && r.push([
                            "Power",
                            t1,
                            e3
                        ]);
                    } else {
                        const a = null !== (i = za(o1)) && void 0 !== i ? i : NaN;
                        -1 === a ? t1 && r.push(t1) : a < 0 ? t1 && r.push([
                            "Power",
                            t1,
                            -a
                        ]) : n.push(e2);
                    }
                } else if ("Rational" === _a(e2) && 2 === Aa(e2)) {
                    const t2 = Ma(e2, 1), i1 = Ma(e2, 2);
                    1 !== za(t2) && n.push(t2), 1 !== za(i1) && r.push(i1);
                } else {
                    const t3 = qa(e2);
                    null !== t3 ? (1 !== t3[0] && n.push(t3[0]), r.push(t3[1])) : n.push(e2);
                }
                return [
                    n,
                    r
                ];
            }(i);
            if (a.length > 0 && (r = 1 === a.length && 1 === a[0] ? 0 === o.length ? "1" : 1 === o.length ? t.serialize(o[0]) : e1(t, [
                "Multiply",
                ...o
            ]) : t.serialize([
                "Divide",
                1 === o.length ? o[0] : [
                    "Multiply",
                    ...o
                ],
                1 === a.length ? a[0] : [
                    "Multiply",
                    ...a
                ]
            ])), r) return t.level += 1, r;
            let s = !1, l = null;
            const u = Aa(i) + 1;
            let c = !1;
            for(let e2 = 1; e2 < u; e2++){
                if (l = Ma(i, e2), null === l) continue;
                let o1;
                if ("number" == typeof l || ga(l)) o1 = t.serialize(l), "-1" !== o1 || r ? ("-" === o1[0] && (o1 = o1.slice(1), s = !s), r = r ? pa([
                    r,
                    t.options.multiply,
                    o1
                ]) : o1) : (r = "", s = !s), c = !0;
                else {
                    if ("Power" === _a(l)) {
                        const e3 = qa(Ma(l, 2));
                        if (e3) {
                            const [i1, n1] = e3;
                            if (1 === i1 && null !== n1) {
                                r += Ha(t, Va(0, t.level), Ma(l, 1), n1), c = !1;
                                continue;
                            }
                        }
                    }
                    if ("Power" !== _a(l) || isNaN(null !== (n = za(Ma(l, 1))) && void 0 !== n ? n : NaN)) {
                        if ("Negate" === _a(l) && (l = Ma(l, 1), s = !s), o1 = t.wrap(l, 390), r) {
                            const e4 = _a(l);
                            r = !c || "Divide" !== e4 && "Rational" !== e4 ? t.options.invisibleMultiply ? pa([
                                r,
                                t.options.invisibleMultiply,
                                o1
                            ]) : pa([
                                r,
                                o1
                            ]) : pa([
                                r,
                                t.options.multiply,
                                o1
                            ]);
                        } else r = o1;
                        c = !1;
                    } else o1 = t.serialize(l), r = r ? pa([
                        r,
                        t.options.multiply,
                        o1
                    ]) : o1, c = !0;
                }
            }
            return t.level += 1, s ? "-" + r : r;
        }
    },
    {
        trigger: [
            "\\cdot"
        ],
        kind: "infix",
        associativity: "both",
        precedence: 390,
        parse: (e1, t, i)=>{
            if (391 < t.minPrec) return null;
            const n = e1.matchExpression({
                ...t,
                minPrec: 392
            });
            return null === n ? [
                "Multiply",
                i,
                [
                    "Error",
                    "'missing'"
                ]
            ] : Fa("Multiply", i, n);
        }
    },
    {
        trigger: [
            "*"
        ],
        kind: "infix",
        associativity: "both",
        precedence: 390,
        parse: (e1, t, i)=>{
            if (391 < t.minPrec) return null;
            const n = e1.matchExpression({
                ...t,
                minPrec: 392
            });
            return null === n ? [
                "Multiply",
                i,
                [
                    "Error",
                    "'missing'"
                ]
            ] : Fa("Multiply", i, n);
        }
    },
    {
        name: "Negate",
        trigger: [
            "-"
        ],
        kind: "prefix",
        parse: (e1, t)=>276 < t.minPrec ? null : [
                "Negate",
                Pa(e1.matchExpression({
                    ...t,
                    minPrec: 400
                }))
            ],
        precedence: 275
    },
    {
        kind: "matchfix",
        openDelimiter: "||",
        closeDelimiter: "||",
        parse: (e1, t)=>$a(t) ? null : [
                "Norm",
                t
            ]
    },
    {
        name: "Norm",
        kind: "matchfix",
        openDelimiter: [
            "\\left",
            "\\Vert"
        ],
        closeDelimiter: [
            "\\right",
            "\\Vert"
        ]
    },
    {
        name: "PlusMinus",
        trigger: [
            "\\pm"
        ],
        kind: "infix",
        associativity: "both",
        precedence: 270
    },
    {
        name: "Power",
        trigger: [
            "^"
        ],
        kind: "infix",
        serialize: Ga
    },
    {
        trigger: "\\prod",
        precedence: 265,
        name: "Product",
        parse: Wa("Product"),
        serialize: Ja("\\prod")
    },
    {
        name: "Rational",
        precedence: 660,
        serialize: (e1, t)=>t && 1 === Aa(t) ? "\\mathrm{Rational}" + e1.wrapArguments(t) : Ua(e1, t)
    },
    {
        name: "Root",
        serialize: Ga
    },
    {
        name: "Round",
        trigger: "round",
        kind: "function"
    },
    {
        name: "Square",
        precedence: 720,
        serialize: (e1, t)=>e1.wrapShort(Ma(t, 1)) + "^2"
    },
    {
        trigger: "\\sum",
        precedence: 265,
        name: "Sum",
        parse: Wa("Sum"),
        serialize: Ja("\\sum")
    },
    {
        name: "Sign",
        trigger: "sgn",
        kind: "function"
    },
    {
        name: "Sqrt",
        trigger: [
            "\\sqrt"
        ],
        parse: function(e1) {
            const t = e1.matchOptionalLatexArgument(), i = e1.matchRequiredLatexArgument();
            return null === i || $a(i) ? null !== t ? [
                "Root",
                [
                    "Error",
                    "'missing'"
                ],
                Pa(t)
            ] : [
                "Sqrt",
                [
                    "Error",
                    "'missing'"
                ]
            ] : null !== t ? [
                "Root",
                i,
                t
            ] : [
                "Sqrt",
                i
            ];
        },
        serialize: Ga
    },
    {
        name: "Subtract",
        trigger: [
            "-"
        ],
        kind: "infix",
        associativity: "both",
        precedence: 275,
        parse: (e1, t, i)=>276 < t.minPrec ? null : [
                "Subtract",
                i,
                Pa(e1.matchExpression({
                    ...t,
                    minPrec: 277
                }))
            ]
    }
];
function Wa(e1) {
    return (t)=>{
        var i, n;
        t.skipSpace();
        let r = null, o = null;
        for(; !(o && r || "_" !== t.peek && "^" !== t.peek);)t.match("_") ? o = t.matchRequiredLatexArgument() : t.match("^") && (r = t.matchRequiredLatexArgument()), t.skipSpace();
        ("Nothing" === o || $a(o)) && (o = null), ("Nothing" === r || $a(r)) && (r = null);
        let a = null, s = null;
        "Equal" === _a(o) ? (a = Ma(o, 1), s = Ma(o, 2)) : a = o;
        const l = Ca(a);
        l && (null === (i = t.computeEngine) || void 0 === i || i.pushScope({
            [l]: {
                domain: "Integer"
            }
        }));
        const u = t.matchExpression({
            minPrec: 266
        });
        return l && (null === (n = t.computeEngine) || void 0 === n || n.popScope()), u ? r ? [
            e1,
            u,
            [
                "Tuple",
                a ? [
                    "Hold",
                    a
                ] : "Nothing",
                null != s ? s : 1,
                r
            ]
        ] : s ? [
            e1,
            u,
            [
                "Tuple",
                a ? [
                    "Hold",
                    a
                ] : "Nothing",
                s
            ]
        ] : a ? [
            e1,
            u,
            [
                "Tuple",
                [
                    "Hold",
                    a
                ]
            ]
        ] : [
            e1,
            u
        ] : [
            e1
        ];
    };
}
function Ja(e1) {
    return (t, i)=>{
        if (!Ma(i, 1)) return e1;
        let n = Ma(i, 2);
        const r = _a(n);
        "Tuple" !== r && "Triple" !== r && "Pair" !== r && "Single" !== r && (n = null);
        let o = Ma(n, 1);
        o && "Hold" === _a(o) && (o = Ma(o, 1));
        const a = Ma(i, 1);
        if (!n) return Ma(i, 2) ? pa([
            e1,
            "_{",
            t.serialize(Ma(i, 2)),
            "}",
            t.serialize(a)
        ]) : pa([
            e1,
            "_n",
            t.serialize(a)
        ]);
        const s = Ma(n, 2);
        let l = [];
        o && "Nothing" !== Ca(o) && s ? l = [
            t.serialize(o),
            "=",
            t.serialize(s)
        ] : o && "Nothing" !== Ca(o) ? l = [
            t.serialize(o)
        ] : s && (l = [
            t.serialize(s)
        ]), l.length > 0 && (l = [
            "_{",
            ...l,
            "}"
        ]);
        let u = [];
        return Ma(n, 3) && (u = [
            "^{",
            t.serialize(Ma(n, 3)),
            "}"
        ]), pa([
            e1,
            ...u,
            ...l,
            t.serialize(a)
        ]);
    };
}
function Xa(e1, t) {
    var i;
    let n = null, r = null;
    t.match("_") && (n = null !== (i = t.matchStringArgument()) && void 0 !== i ? i : t.next(), r = Number.parseFloat(null != n ? n : "10"));
    const o = t.matchArguments("implicit");
    return null === o ? [
        e1
    ] : 10 === r ? [
        "Log",
        o[0]
    ] : 2 === r ? [
        "Lb",
        ...o
    ] : null === n ? [
        e1,
        ...o
    ] : [
        "Log",
        ...o,
        n
    ];
}
function Ya(e1, t, i, n, r) {
    if (t.minPrec >= n) return null;
    const o = [
        i
    ];
    let a = !1;
    for(; !a;){
        for(a = !0, e1.skipSpace(); e1.match(r);)o.push("Nothing"), e1.skipSpace();
        if (e1.atTerminator(t)) o.push("Nothing");
        else {
            const i1 = e1.matchExpression({
                ...t,
                minPrec: n
            });
            o.push(null != i1 ? i1 : "Nothing"), a = null === i1;
        }
        a || (e1.skipSpace(), a = !e1.match(r));
    }
    return o;
}
function Qa(e1 = "") {
    return (t, i)=>{
        var n;
        return (null !== (n = Sa(i)) && void 0 !== n ? n : []).map((e1)=>t.serialize(e1)).join(e1);
    };
}
const es = [
    {
        trigger: [
            "\\placeholder"
        ],
        parse: (e1)=>{
            if (e1.skipSpaceTokens(), e1.match("[")) for(; !e1.match("]") && !e1.atBoundary;)e1.next();
            if (e1.skipSpaceTokens(), e1.match("<{>")) for(; !e1.match("<}>") && !e1.atBoundary;)e1.next();
            return "Nothing";
        }
    },
    {
        name: "BaseForm",
        kind: "function",
        serialize: (e1, t)=>{
            var i, n;
            const r = null !== (i = za(Ma(t, 2))) && void 0 !== i ? i : NaN;
            if (isFinite(r) && r >= 2 && r <= 36) {
                const e2 = null !== (n = za(Ma(t, 1))) && void 0 !== n ? n : NaN;
                if (isFinite(e2) && Number.isInteger(e2)) {
                    let t1 = Number(e2).toString(r), i1 = 0;
                    if (2 === r || 10 === r ? i1 = 4 : 16 === r ? i1 = 2 : r > 16 && (i1 = 4), i1 > 0) {
                        const e3 = t1;
                        t1 = "";
                        for(let n1 = 0; n1 < e3.length; n1++)n1 > 0 && n1 % i1 == 0 && (t1 = "\\, " + t1), t1 = e3[e3.length - n1 - 1] + t1;
                    }
                    return `(\\text{${t1}}_{${r}}`;
                }
            }
            return "\\operatorname{BaseForm}(" + e1.serialize(Ma(t, 1)) + ", " + e1.serialize(Ma(t, 2)) + ")";
        }
    },
    {
        name: "Delimiter",
        serialize: (e1, t)=>{
            var i, n, r, o, a;
            const s = Aa(t);
            if (0 === s) return "";
            const l = e1.options.groupStyle(t, e1.level + 1), u = Ma(t, 1);
            if (1 === s) return e1.wrapString(e1.serialize(u), l);
            let c = "", d = "", h = "";
            if (s > 1) {
                const e2 = null !== (i = xa(Ma(t, 2))) && void 0 !== i ? i : "";
                d = null !== (n = e2[0]) && void 0 !== n ? n : "", h = null !== (r = e2[1]) && void 0 !== r ? r : "", c = null !== (o = e2[2]) && void 0 !== o ? o : "";
            }
            const m = "List" === _a(u) ? Qa(c)(e1, u) : e1.serialize(u);
            return e1.wrapString(m, l, null !== (a = xa(Ma(t, 2))) && void 0 !== a ? a : void 0), d && h ? `${d} ${m} ${h}` : e1.wrapString(m, l);
        }
    },
    {
        name: "Domain",
        serialize: (e1, t)=>"Error" === _a(t) ? e1.serialize(t) : `\\mathbf{${e1.serialize(Ma(t, 1))}}`
    },
    {
        name: "Error",
        serialize: (e1, t)=>{
            var i;
            if ("missing" === xa(Ma(t, 1))) return `\\error{${null !== (i = e1.options.missingSymbol) && void 0 !== i ? i : "\\placeholder{}"}}`;
            const n = function(e1, t) {
                var i;
                const n = Ma(t, 2);
                return n ? "Latex" === _a(n) ? `\\texttt{${is(null !== (i = xa(Ma(n, 1))) && void 0 !== i ? i : "")}}` : "Hold" === _a(n) ? e1.serialize(Ma(n, 1)) : e1.serialize(n) : "";
            }(e1, t) || "\\blacksquare", r = Ma(t, 1);
            return "incompatible-domain" === ("ErrorCode" === _a(r) ? xa(Ma(r, 1)) : xa(r)) ? `\\mathtip{\\error{${n}}}{\\in ${e1.serialize(Ma(r, 3))}\\notin ${e1.serialize(Ma(r, 2))}}` : `\\error{${n}}`;
        }
    },
    {
        name: "ErrorCode",
        serialize: (e1, t)=>{
            var i;
            const n = xa(Ma(t, 1));
            return "missing" === n ? null !== (i = e1.options.missingSymbol) && void 0 !== i ? i : "\\placeholder{}" : "unexpected-command" === n || "unexpected-operator" === n || "unexpected-token" === n || "invalid-symbol-name" === n || "unknown-environment" === n || "unexpected-base" === n || "incompatible-domain" === n || "invalid-domain-expression" === n ? "" : `\\texttip{\\error{\\blacksquare}}{\\mathtt{${n}}}`;
        }
    },
    {
        name: "FromLatex",
        serialize: (e1, t)=>`\\texttt{${is(xa(Ma(t, 1)))}}`
    },
    {
        name: "Latex",
        serialize: (e1, t)=>null === t ? "" : pa(Oa(t, (t)=>{
                var i;
                return null !== (i = xa(t)) && void 0 !== i ? i : e1.serialize(t);
            }))
    },
    {
        name: "LatexString",
        serialize: (e1, t)=>null === t ? "" : pa(Oa(t, (t)=>e1.serialize(t)))
    },
    {
        name: "LatexTokens",
        serialize: function(e1, t) {
            return null === t ? "" : pa(Oa(t, (t)=>{
                const i = xa(t);
                return null === i ? e1.serialize(t) : "<{>" === i ? "{" : "<}>" === i ? "}" : "<$>" === i ? "$" : "<$$>" === i ? "$$" : "<space>" === i ? " " : i;
            }));
        }
    },
    {
        name: "List",
        kind: "matchfix",
        openDelimiter: "[",
        closeDelimiter: "]",
        parse: (e1, t)=>{
            var i;
            return null === t ? [
                "List"
            ] : "Sequence" !== _a(t) && "List" !== _a(t) ? [
                "List",
                t
            ] : [
                "List",
                ...null !== (i = Sa(t)) && void 0 !== i ? i : []
            ];
        },
        serialize: (e1, t)=>pa([
                "\\lbrack",
                Qa(", ")(e1, t),
                "\\rbrack"
            ])
    },
    {
        kind: "matchfix",
        openDelimiter: "(",
        closeDelimiter: ")",
        parse: (e1, t)=>{
            var i;
            return null === t ? null : "Sequence" === _a(t) || "List" === _a(t) ? 0 === Aa(t) ? [
                "Delimiter"
            ] : [
                "Delimiter",
                [
                    "Sequence",
                    ...null !== (i = Sa(t)) && void 0 !== i ? i : []
                ]
            ] : [
                "Delimiter",
                t
            ];
        }
    },
    {
        trigger: [
            ","
        ],
        kind: "infix",
        precedence: 20,
        parse: (e1, t, i)=>{
            const n = Ya(e1, t, i, 20, ",");
            return null === n ? null : [
                "Sequence",
                ...n
            ];
        }
    },
    {
        name: "Sequence",
        serialize: Qa("")
    },
    {
        trigger: [
            ";"
        ],
        kind: "infix",
        precedence: 19,
        parse: (e1, t, i)=>{
            const n = Ya(e1, t, i, 19, ";");
            return null === n ? null : [
                "Sequence",
                ...n.map((e1)=>{
                    var t;
                    return "Sequence" === _a(e1) ? [
                        "List",
                        ...null !== (t = Sa(e1)) && void 0 !== t ? t : []
                    ] : e1;
                })
            ];
        }
    },
    {
        name: "String",
        trigger: [
            "\\text"
        ],
        parse: (e1)=>ts(e1),
        serialize: (e1, t)=>{
            const i = Sa(t);
            return null === i || 0 === i.length ? "\\text{}" : pa([
                "\\text{",
                i.map((t)=>e1.serialize(t)).join(""),
                "}"
            ]);
        }
    },
    {
        name: "Subscript",
        trigger: [
            "_"
        ],
        kind: "infix",
        serialize: (e1, t)=>2 === Aa(t) ? e1.serialize(Ma(t, 1)) + "_{" + e1.serialize(Ma(t, 2)) + "}" : "_{" + e1.serialize(Ma(t, 1)) + "}"
    },
    {
        name: "Superplus",
        trigger: [
            "^",
            "+"
        ],
        kind: "postfix"
    },
    {
        name: "Subplus",
        trigger: [
            "_",
            "+"
        ],
        kind: "postfix"
    },
    {
        name: "Superminus",
        trigger: [
            "^",
            "-"
        ],
        kind: "postfix"
    },
    {
        name: "Subminus",
        trigger: [
            "_",
            "-"
        ],
        kind: "postfix"
    },
    {
        trigger: [
            "^",
            "*"
        ],
        kind: "postfix",
        parse: (e1, t)=>[
                "Superstar",
                t
            ]
    },
    {
        name: "Superstar",
        trigger: [
            "^",
            "\\star"
        ],
        kind: "postfix"
    },
    {
        trigger: [
            "_",
            "*"
        ],
        kind: "postfix",
        parse: (e1, t)=>[
                "Substar",
                t
            ]
    },
    {
        name: "Substar",
        trigger: [
            "_",
            "\\star"
        ],
        kind: "postfix"
    },
    {
        name: "Superdagger",
        trigger: [
            "^",
            "\\dagger"
        ],
        kind: "postfix"
    },
    {
        trigger: [
            "^",
            "\\dag"
        ],
        kind: "postfix",
        parse: (e1, t)=>[
                "Superdagger",
                t
            ]
    },
    {
        name: "Prime",
        trigger: [
            "^",
            "\\prime"
        ],
        kind: "postfix"
    },
    {
        trigger: [
            "^",
            "\\doubleprime"
        ],
        kind: "postfix",
        parse: (e1, t)=>[
                "Prime",
                Pa(t),
                2
            ]
    },
    {
        name: "InverseFunction",
        serialize: (e1, t)=>e1.serialize(Ma(t, 1)) + "^{-1}"
    },
    {
        name: "Derivative",
        serialize: (e1, t)=>{
            var i;
            const n = null !== (i = za(Ma(t, 1))) && void 0 !== i ? i : NaN;
            if (!isFinite(n)) return "";
            const r = e1.serialize(Ma(t, 2));
            return 1 === n ? r + "^{\\prime}" : 2 === n ? r + "^{\\doubleprime}" : r + "^{(" + Number(n).toString() + ")}";
        }
    },
    {
        name: "Which",
        trigger: "cases",
        kind: "environment",
        parse: (e1)=>{
            var t;
            const i = e1.matchTabular("cases");
            if (!i) return [
                "Which"
            ];
            const n = [
                "Which"
            ];
            for (const e2 of i)if (1 === e2.length) n.push("True"), n.push(e2[0]);
            else if (2 === e2.length) {
                const i1 = xa(e2[1]);
                n.push(i1 ? "True" : null !== (t = ka(e2[1])) && void 0 !== t ? t : "True"), n.push(e2[0]);
            }
            return n;
        },
        serialize: (e1, t)=>{
            var i;
            if ("List" !== _a(Ma(t, 1))) return "";
            const n = null !== (i = Sa(Ma(t, 1))) && void 0 !== i ? i : [], r = [];
            let o = "";
            for (const t1 of n){
                if (("Tuple" === _a(t1) || "Pair" === _a(t1)) && (r.push(o), Ma(t1, 2))) {
                    r.push(e1.serialize(Ma(t1, 2)));
                    const i1 = Ma(t1, 1);
                    null !== i1 && r.push("&", e1.serialize(i1));
                }
                o = "\\\\";
            }
            return pa([
                "\\begin{cases}",
                ...r,
                "\\end{cases}"
            ]);
        }
    }
];
function ts(e1, t) {
    var i, n, r;
    if (!e1.match("<{>")) return "''";
    const o = [];
    let a, s = "", l = null;
    for(; !e1.atEnd && !e1.match("<}>");)if ("<{>" === e1.peek) o.push(ts(e1));
    else if (e1.match("\\textbf") && e1.match("<{>")) o.push(ts(e1, {
        "font-weight": "bold"
    }));
    else if (e1.match("\\color") && e1.match("<{>")) {
        const t1 = e1.matchColor();
        t1 && e1.match("<}>") && (null !== l && s ? o.push([
            "Style",
            s,
            {
                dict: l
            }
        ]) : s && o.push([
            "String",
            s
        ]), s = "", l = {
            color: t1
        });
    } else if (e1.match("<space>")) s += " ";
    else if (e1.match("<$>")) {
        const t2 = e1.index, n1 = null !== (i = e1.matchExpression()) && void 0 !== i ? i : [
            "Sequence"
        ];
        e1.skipSpace(), e1.match("<$>") ? o.push(n1) : (s += "$", e1.index = t2);
    } else if (e1.match("<$$>")) {
        const t3 = e1.index, i1 = null !== (n = e1.matchExpression()) && void 0 !== n ? n : [
            "Sequence"
        ];
        e1.skipSpace(), e1.match("<$$>") ? o.push(i1) : (s += "$$", e1.index = t3);
    } else s += null !== (r = e1.matchChar()) && void 0 !== r ? r : "";
    return null !== l && s ? o.push([
        "Style",
        `'${s}'`,
        {
            dict: l
        }
    ]) : s && o.push(`'${s}'`), a = 1 === o.length ? o[0] : o.every((e1)=>null !== xa(e1)) ? "'" + o.map((e1)=>xa(e1)).join() + "'" : [
        "String",
        ...o
    ], t ? [
        "Style",
        a,
        {
            dict: t
        }
    ] : a;
}
function is(e1) {
    return null === e1 ? "" : e1.replace(/[{}\[\]\\:\-\$%]/g, (e1)=>{
        var t;
        return null !== (t = ({
            "{": "\\lbrace ",
            "}": "\\rbrace ",
            "[": "\\lbrack ",
            "]": "\\rbrack ",
            ":": "\\colon ",
            "\\": "\\backslash "
        })[e1]) && void 0 !== t ? t : "\\" + e1;
    });
}
function ns(e1) {
    return (t)=>{
        const i = t.matchRequiredLatexArgument();
        return null === i ? [
            e1
        ] : [
            e1,
            i
        ];
    };
}
const rs = [
    {
        name: "Overscript",
        trigger: [
            "\\overset"
        ],
        kind: "infix",
        precedence: 700
    },
    {
        name: "Underscript",
        trigger: [
            "\\underset"
        ],
        kind: "infix",
        precedence: 700
    },
    {
        name: "Increment",
        trigger: [
            "+",
            "+"
        ],
        kind: "postfix",
        precedence: 880
    },
    {
        name: "Decrement",
        trigger: [
            "-",
            "-"
        ],
        kind: "postfix",
        precedence: 880
    },
    {
        name: "PreIncrement",
        trigger: [
            "+",
            "+"
        ],
        kind: "prefix",
        precedence: 880
    },
    {
        name: "PreDecrement",
        trigger: [
            "-",
            "-"
        ],
        kind: "prefix",
        precedence: 880
    },
    {
        name: "Ring",
        trigger: [
            "\\circ"
        ],
        kind: "infix",
        precedence: 265
    },
    {
        name: "Transpose",
        trigger: [
            "^",
            "T"
        ],
        kind: "infix"
    },
    {
        name: "ConjugateTranspose",
        trigger: [
            "^",
            "H"
        ],
        kind: "infix"
    },
    {
        name: "StringJoin",
        trigger: [
            "\\lt",
            "\\gt"
        ],
        kind: "infix",
        precedence: 780
    },
    {
        name: "Starstar",
        trigger: [
            "\\star",
            "\\star"
        ],
        kind: "infix",
        precedence: 780
    },
    {
        name: "PartialDerivative",
        trigger: [
            "\\partial"
        ],
        kind: "prefix",
        parse: (e1)=>{
            var t, i;
            let n = !1, r = "Nothing", o = "Nothing";
            for(; !n;)e1.skipSpace(), e1.match("_") ? o = e1.matchRequiredLatexArgument() : e1.match("^") ? r = e1.matchRequiredLatexArgument() : n = !0;
            const a = Ba(o);
            if (a && (o = [
                "List",
                ...a
            ]), null === o || null === r) return null;
            let s = null !== (t = e1.matchRequiredLatexArgument()) && void 0 !== t ? t : "Nothing";
            return "Nothing" === s || $a(s) || (s = [
                s,
                ...null !== (i = e1.matchArguments("enclosure")) && void 0 !== i ? i : [
                    "Nothing"
                ]
            ]), [
                "PartialDerivative",
                s,
                o,
                r
            ];
        },
        serialize: (e1, t)=>{
            var i;
            let n = "\\partial";
            const r = Ma(t, 1), o = Ma(t, 2), a = Ma(t, 3);
            return null !== o && "Nothing" !== o && ("List" === _a(o) ? n += "_{" + e1.serialize([
                "Sequence",
                ...null !== (i = Sa(o)) && void 0 !== i ? i : []
            ]) + "}" : n += "_{" + e1.serialize(o) + "}"), null !== a && "Nothing" !== a && (n += "^{" + e1.serialize(a) + "}"), null !== r && "Nothing" !== r && (n += e1.serialize(r)), n;
        },
        precedence: 740
    },
    {
        name: "OverBar",
        trigger: [
            "\\overline"
        ],
        parse: ns("OverBar")
    },
    {
        name: "UnderBar",
        trigger: [
            "\\underline"
        ],
        parse: ns("UnderBar")
    },
    {
        name: "OverVector",
        trigger: [
            "\\vec"
        ],
        parse: ns("OverVector")
    },
    {
        name: "OverTilde",
        trigger: [
            "\\tilde"
        ],
        parse: ns("OverTilde")
    },
    {
        name: "OverHat",
        trigger: [
            "\\hat"
        ],
        parse: ns("OverHat")
    },
    {
        name: "OverRightArrow",
        trigger: [
            "\\overrightarrow"
        ],
        parse: ns("OverRightArrow")
    },
    {
        name: "OverLeftArrow",
        trigger: [
            "\\overleftarrow"
        ],
        parse: ns("OverLeftArrow")
    },
    {
        name: "OverRightDoubleArrow",
        trigger: [
            "\\Overrightarrow"
        ],
        parse: ns("OverRightDoubleArrow")
    },
    {
        name: "OverLeftHarpoon",
        trigger: [
            "\\overleftharpoon"
        ],
        parse: ns("OverLeftHarpoon")
    },
    {
        name: "OverRightHarpoon",
        trigger: [
            "\\overrightharpoon"
        ],
        parse: ns("OverRightHarpoon")
    },
    {
        name: "OverLeftRightArrow",
        trigger: [
            "\\overleftrightarrow"
        ],
        parse: ns("OverLeftRightArrow")
    },
    {
        name: "OverBrace",
        trigger: [
            "\\overbrace"
        ],
        parse: ns("OverBrace")
    },
    {
        name: "OverLineSegment",
        trigger: [
            "\\overlinesegment"
        ],
        parse: ns("OverLineSegment")
    },
    {
        name: "OverGroup",
        trigger: [
            "\\overgroup"
        ],
        parse: ns("OverGroup")
    },
    {
        trigger: [
            "\\displaystyle"
        ],
        parse: ()=>[
                "Sequence"
            ]
    },
    {
        trigger: [
            "\\textstyle"
        ],
        parse: ()=>[
                "Sequence"
            ]
    },
    {
        trigger: [
            "\\scriptstyle"
        ],
        parse: ()=>[
                "Sequence"
            ]
    },
    {
        trigger: [
            "\\scriptscriptstyle"
        ],
        parse: ()=>[
                "Sequence"
            ]
    },
    {
        trigger: [
            "\\tiny"
        ],
        parse: ()=>[
                "Sequence"
            ]
    },
    {
        trigger: [
            "\\scriptsize"
        ],
        parse: ()=>[
                "Sequence"
            ]
    },
    {
        trigger: [
            "\\footnotesize"
        ],
        parse: ()=>[
                "Sequence"
            ]
    },
    {
        trigger: [
            "\\small"
        ],
        parse: ()=>[
                "Sequence"
            ]
    },
    {
        trigger: [
            "\\normalsize"
        ],
        parse: ()=>[
                "Sequence"
            ]
    },
    {
        trigger: [
            "\\large"
        ],
        parse: ()=>[
                "Sequence"
            ]
    },
    {
        trigger: [
            "\\Large"
        ],
        parse: ()=>[
                "Sequence"
            ]
    },
    {
        trigger: [
            "\\LARGE"
        ],
        parse: ()=>[
                "Sequence"
            ]
    },
    {
        trigger: [
            "\\huge"
        ],
        parse: ()=>[
                "Sequence"
            ]
    },
    {
        trigger: [
            "\\Huge"
        ],
        parse: ()=>[
                "Sequence"
            ]
    },
    {
        name: "Style",
        serialize: (e1, t)=>{
            let i = e1.serialize(Ma(t, 1));
            const n = Ta(Ma(t, 2));
            if (null === n) return i;
            "block" === xa(n.display) ? i = pa([
                "{\\displaystyle",
                i,
                "}"
            ]) : "inline" === xa(n.display) ? i = pa([
                "{\\textstyle",
                i,
                "}"
            ]) : "script" === xa(n.display) ? i = pa([
                "{\\scriptstyle",
                i,
                "}"
            ]) : "scriptscript" === xa(n.display) && (i = pa([
                "{\\scriptscriptstyle",
                i,
                "}"
            ]));
            const r = za(n.size);
            return null !== r && r >= 1 && r <= 10 && (i = pa([
                "{",
                {
                    1: "\\tiny",
                    2: "\\scriptsize",
                    3: "\\footnotesize",
                    4: "\\small",
                    5: "\\normalsize",
                    6: "\\large",
                    7: "\\Large",
                    8: "\\LARGE",
                    9: "\\huge",
                    10: "\\Huge"
                }[r],
                i,
                "}"
            ])), i;
        }
    },
    {
        trigger: [
            "\\!"
        ],
        parse: ()=>[
                "HorizontalSpacing",
                -3
            ]
    },
    {
        trigger: [
            "\\ "
        ],
        parse: ()=>[
                "HorizontalSpacing",
                6
            ]
    },
    {
        trigger: [
            "\\:"
        ],
        parse: ()=>[
                "HorizontalSpacing",
                4
            ]
    },
    {
        trigger: [
            "\\enskip"
        ],
        parse: ()=>[
                "HorizontalSpacing",
                9
            ]
    },
    {
        trigger: [
            "\\quad"
        ],
        parse: ()=>[
                "HorizontalSpacing",
                18
            ]
    },
    {
        trigger: [
            "\\qquad"
        ],
        parse: ()=>[
                "HorizontalSpacing",
                36
            ]
    },
    {
        trigger: [
            "\\,"
        ],
        parse: ()=>[
                "HorizontalSpacing",
                3
            ]
    },
    {
        trigger: [
            "\\;"
        ],
        parse: ()=>[
                "HorizontalSpacing",
                5
            ]
    },
    {
        trigger: [
            "\\enspace"
        ],
        parse: ()=>[
                "HorizontalSpacing",
                9
            ]
    },
    {
        name: "HorizontalSpacing",
        serialize: (e1, t)=>{
            var i;
            if (Ma(t, 2)) return e1.serialize(Ma(t, 1));
            const n = za(Ma(t, 1));
            return null === n ? "" : null !== (i = ({
                "-3": "\\!",
                6: "\\ ",
                3: "\\,",
                4: "\\:",
                5: "\\;",
                9: "\\enspace",
                18: "\\quad",
                36: "\\qquad"
            })[n]) && void 0 !== i ? i : "";
        }
    }
];
function os(e1) {
    return (t)=>{
        var i, n;
        let r = !1, o = 0, a = null;
        if (t.skipSpace(), t.match("^")) {
            t.skipSpace();
            const e2 = t.index;
            if (t.match("<{>")) {
                if (t.skipSpace(), t.match("-") && t.match("1") && (t.skipSpace(), t.match("<}>") && (r = !0)), !r) {
                    let e3 = !1;
                    for(; !e3;)t.skipSpace(), t.match("\\doubleprime") ? o += 2 : t.match("\\prime") || t.match("'") ? o += 1 : e3 = !0;
                    t.match("<}>") || (o = 0);
                }
                if (0 !== o || r || (t.index = e2, a = t.matchRequiredLatexArgument()), 0 === o) {
                    let e4 = !1;
                    for(; !e4;)t.skipSpace(), t.match("\\doubleprime") ? o += 2 : t.match("\\prime") || t.match("'") ? o += 1 : e4 = !0;
                }
            }
        }
        let s = null !== (n = null !== (i = ({
            "\\arcsin": "Arcsin",
            "\\arccos": "Arccos",
            "\\arctan": "Arctan",
            "\\arctg": "Arctan",
            "\\arcctg": "Arctan",
            "\\arcsec": "Arcsec",
            "\\arccsc": " Arccsc",
            "\\arsinh": "Arsinh",
            "\\arcosh": "Arcosh",
            "\\artanh": "Artanh",
            "\\arcsech": "Arcsech",
            "\\arccsch": "Arcsch",
            "\\ch": "Cosh",
            "\\cos": "Cos",
            "\\cosec": "Csc",
            "\\cosh": "Csch",
            "\\cot": "Cot",
            "\\cotg": "Cot",
            "\\coth": "Coth",
            "\\csc": "Csc",
            "\\ctg": "Cot",
            "\\cth": "Coth",
            "\\sec": "Sec",
            "\\sin": "Sin",
            "\\sinh": "Sinh",
            "\\sh": "Sinh",
            "\\tan": "Tan",
            "\\tanh": "Tanh",
            "\\tg": "Tan",
            "\\th": "Tanh"
        })[null != e1 ? e1 : ""]) && void 0 !== i ? i : e1) && void 0 !== n ? n : "";
        r && (s = [
            "InverseFunction",
            s
        ]), o >= 1 && (s = [
            "Derivative",
            o,
            s
        ]);
        const l = t.matchArguments("implicit");
        return null === l ? a ? [
            [
                "Power",
                [
                    s,
                    "_"
                ],
                a
            ]
        ] : s : a ? [
            "Power",
            [
                s,
                ...l
            ],
            a
        ] : [
            s,
            ...l
        ];
    };
}
const as = [
    {
        name: "Arcsin",
        trigger: [
            "\\arcsin"
        ],
        parse: os("Arcsin")
    },
    {
        name: "Arccos",
        trigger: [
            "\\arccos"
        ],
        parse: os("Arccos")
    },
    {
        name: "Arctan",
        trigger: [
            "\\arctan"
        ],
        parse: os("Arctan")
    },
    {
        trigger: [
            "\\arctg"
        ],
        parse: os("Arctan")
    },
    {
        name: "Arccot",
        trigger: [
            "\\arcctg"
        ],
        parse: os("Arccot")
    },
    {
        name: "Arcsec",
        trigger: "arcsec",
        parse: os("Arcsec")
    },
    {
        name: "Arccsc",
        trigger: [
            "\\arccsc"
        ],
        parse: os("Arccsc")
    },
    {
        name: "Arsinh",
        trigger: [
            "\\arsinh"
        ],
        parse: os("Arsinh")
    },
    {
        name: "Arcosh",
        trigger: [
            "\\arcosh"
        ],
        parse: os("Arcosh")
    },
    {
        name: "Artanh",
        trigger: [
            "\\artanh"
        ],
        parse: os("Artanh")
    },
    {
        name: "Arsech",
        trigger: [
            "\\arsech"
        ],
        parse: os("Arsech")
    },
    {
        name: "Arcsch",
        trigger: [
            "\\arcsch"
        ],
        parse: os("Arcsch")
    },
    {
        trigger: [
            "\\ch"
        ],
        parse: os("Cosh")
    },
    {
        name: "Cosec",
        trigger: [
            "\\cosec"
        ],
        parse: os("Cosec")
    },
    {
        name: "Cosh",
        trigger: [
            "\\cosh"
        ],
        parse: os("Cosh")
    },
    {
        name: "Cot",
        trigger: [
            "\\cot"
        ],
        parse: os("Cot")
    },
    {
        trigger: [
            "\\cotg"
        ],
        parse: os("Cot")
    },
    {
        name: "Coth",
        trigger: [
            "\\coth"
        ],
        parse: os("Coth")
    },
    {
        name: "Csc",
        trigger: [
            "\\csc"
        ],
        parse: os("Csc")
    },
    {
        trigger: [
            "\\ctg"
        ],
        parse: os("Cot")
    },
    {
        trigger: [
            "\\cth"
        ],
        parse: os("Cotanh")
    },
    {
        name: "Sec",
        trigger: [
            "\\sec"
        ],
        parse: os("Sec")
    },
    {
        name: "Sinh",
        trigger: [
            "\\sinh"
        ],
        parse: os("Sinh")
    },
    {
        trigger: [
            "\\sh"
        ],
        parse: os("Sinh")
    },
    {
        name: "Tan",
        trigger: [
            "\\tan"
        ],
        parse: os("Tan")
    },
    {
        trigger: [
            "\\tg"
        ],
        parse: os("Tan")
    },
    {
        name: "Tanh",
        trigger: [
            "\\tanh"
        ],
        parse: os("Tanh")
    },
    {
        trigger: [
            "\\th"
        ],
        parse: os("Tanh")
    },
    {
        name: "Cos",
        trigger: [
            "\\cos"
        ],
        parse: os("Cos")
    },
    {
        name: "Sin",
        trigger: [
            "\\sin"
        ],
        parse: os("Sin")
    }
], ss = [
    {
        name: "AlgebraicNumber",
        trigger: "\\bar\\Q"
    },
    {
        name: "ComplexNumber",
        trigger: [
            "\\C"
        ]
    },
    {
        trigger: "\\mathbb{C}",
        parse: "ComplexNumber"
    },
    {
        name: "ImaginaryNumber",
        trigger: [
            "\\imaginaryI\\R"
        ]
    },
    {
        name: "ExtendedComplexNumber",
        trigger: [
            "\\bar\\C"
        ]
    },
    {
        name: "EmptySet",
        trigger: [
            "\\emptyset"
        ]
    },
    {
        trigger: [
            "\\varnothing"
        ],
        parse: "EmptySet"
    },
    {
        name: "Integer",
        trigger: [
            "\\Z"
        ]
    },
    {
        trigger: "\\mathbb{Z}",
        parse: "Integer"
    },
    {
        name: "RationalNumber",
        trigger: [
            "\\Q"
        ]
    },
    {
        name: "RealNumber",
        trigger: [
            "\\R"
        ]
    },
    {
        trigger: "\\mathbb{R}",
        parse: "RealNumber"
    },
    {
        name: "ExtendedRealNumber",
        trigger: [
            "\\bar\\R"
        ]
    },
    {
        name: "TranscendentalNumber",
        trigger: "\\R-\\bar\\Q"
    },
    {
        trigger: "\\R\\backslash\\bar\\Q",
        parse: "TranscendentalNumber"
    },
    {
        name: "NegativeNumber",
        trigger: "\\R^-"
    },
    {
        trigger: "\\R^{-}",
        parse: "NegativeNumber"
    },
    {
        trigger: "\\R_-",
        parse: "NegativeNumber"
    },
    {
        trigger: "\\R_{-}",
        parse: "NegativeNumber"
    },
    {
        trigger: "\\R^{\\lt}",
        parse: "NegativeNumber"
    },
    {
        name: "PositiveNumber",
        trigger: "\\R^+"
    },
    {
        trigger: "\\R^{+}",
        parse: "PositiveNumber"
    },
    {
        trigger: "\\R_+",
        parse: "PositiveNumber"
    },
    {
        trigger: "\\R_{+}",
        parse: "PositiveNumber"
    },
    {
        trigger: "\\R^{\\gt}",
        parse: "PositiveNumber"
    },
    {
        name: "NonPositiveNumber",
        trigger: "\\R^{0-}"
    },
    {
        trigger: "\\R^{-0}",
        parse: "NonPositiveNumber"
    },
    {
        trigger: "\\R^{\\leq}",
        parse: "NonPositiveNumber"
    },
    {
        name: "NegativeInteger",
        trigger: "\\Z^-"
    },
    {
        trigger: "\\Z^-",
        parse: "NegativeInteger"
    },
    {
        trigger: "\\Z^{-}",
        parse: "NegativeInteger"
    },
    {
        trigger: "\\Z_-",
        parse: "NegativeInteger"
    },
    {
        trigger: "\\Z_{-}",
        parse: "NegativeInteger"
    },
    {
        trigger: "\\Z^{\\lt}",
        parse: "NegativeInteger"
    },
    {
        name: "PositiveInteger",
        trigger: "\\Z^+"
    },
    {
        trigger: "\\Z^{+}",
        parse: "PositiveInteger"
    },
    {
        trigger: "\\Z_+",
        parse: "PositiveInteger"
    },
    {
        trigger: "\\Z_{+}",
        parse: "PositiveInteger"
    },
    {
        trigger: "\\Z^{\\gt}",
        parse: "PositiveInteger"
    },
    {
        trigger: "\\Z^{\\gt0}",
        parse: "PositiveInteger"
    },
    {
        trigger: "\\N^+",
        parse: "PositiveInteger"
    },
    {
        trigger: "\\N^{+}",
        parse: "PositiveInteger"
    },
    {
        trigger: "\\N^*",
        parse: "PositiveInteger"
    },
    {
        trigger: "\\N^{*}",
        parse: "PositiveInteger"
    },
    {
        trigger: "\\N^\\star",
        parse: "PositiveInteger"
    },
    {
        trigger: "\\N^{\\star}",
        parse: "PositiveInteger"
    },
    {
        trigger: "\\N_1",
        parse: "PositiveInteger"
    },
    {
        trigger: "\\N_{1}",
        parse: "PositiveInteger"
    },
    {
        name: "NonNegativeInteger",
        trigger: [
            "\\N"
        ]
    },
    {
        trigger: "\\Z^{+0}",
        parse: "NonNegativeInteger"
    },
    {
        trigger: "\\Z^{\\geq}",
        parse: "NonNegativeInteger"
    },
    {
        trigger: "\\Z^{\\geq0}",
        parse: "NonNegativeInteger"
    },
    {
        trigger: "\\Z^{0+}",
        parse: "NonNegativeInteger"
    },
    {
        trigger: "\\mathbb{N}",
        parse: "NonNegativeInteger"
    },
    {
        trigger: "\\N_0",
        parse: "NonNegativeInteger"
    },
    {
        trigger: "\\N_{0}",
        parse: "NonNegativeInteger"
    },
    {
        name: "CartesianProduct",
        trigger: [
            "\\times"
        ],
        kind: "infix",
        associativity: "right",
        precedence: 390,
        parse: (e1, t, i)=>{
            if (390 < t.minPrec) return null;
            const n = e1.computeEngine;
            if (!n || !n.box(i).domain.isCompatible("Set")) return null;
            const r = e1.index, o = e1.matchExpression({
                ...t,
                minPrec: 390
            });
            return null === o || !0 !== n.box(i).domain.isCompatible("Set") ? (e1.index = r, null) : [
                "CartesianProduct",
                i,
                o
            ];
        }
    },
    {
        name: "Complement",
        trigger: [
            "^",
            "\\complement"
        ],
        kind: "infix"
    },
    {
        name: "Intersection",
        trigger: [
            "\\cap"
        ],
        kind: "infix",
        precedence: 350
    },
    {
        name: "Interval",
        serialize: ls
    },
    {
        name: "Multiple",
        serialize: ls
    },
    {
        name: "Union",
        trigger: [
            "\\cup"
        ],
        kind: "infix",
        precedence: 350
    },
    {
        name: "Range",
        serialize: ls
    },
    {
        name: "SetMinus",
        trigger: [
            "\\setminus"
        ],
        kind: "infix",
        precedence: 650
    },
    {
        name: "SymmetricDifference",
        trigger: [
            "\\triangle"
        ],
        kind: "infix",
        precedence: 260
    },
    {
        trigger: [
            "\\ni"
        ],
        kind: "infix",
        associativity: "right",
        precedence: 160,
        parse: (e1, t, i)=>{
            const n = e1.matchExpression(t);
            return null === n ? null : [
                "Element",
                n,
                i
            ];
        }
    },
    {
        name: "Element",
        trigger: [
            "\\in"
        ],
        kind: "infix",
        precedence: 240
    },
    {
        name: "NotElement",
        trigger: [
            "\\notin"
        ],
        kind: "infix",
        precedence: 240
    },
    {
        name: "NotSubset",
        trigger: [
            "\\nsubset"
        ],
        kind: "infix",
        associativity: "right",
        precedence: 240
    },
    {
        name: "NotSuperset",
        trigger: [
            "\\nsupset"
        ],
        kind: "infix",
        associativity: "right",
        precedence: 240
    },
    {
        name: "NotSubsetNotEqual",
        trigger: [
            "\\nsubseteq"
        ],
        kind: "infix",
        associativity: "right",
        precedence: 240
    },
    {
        name: "NotSupersetNotEqual",
        trigger: [
            "\\nsupseteq"
        ],
        kind: "infix",
        associativity: "right",
        precedence: 240
    },
    {
        name: "SquareSubset",
        trigger: [
            "\\sqsubset"
        ],
        kind: "infix",
        associativity: "right",
        precedence: 265
    },
    {
        name: "SquareSubsetEqual",
        trigger: [
            "\\sqsubseteq"
        ],
        kind: "infix",
        associativity: "right",
        precedence: 265
    },
    {
        name: "SquareSuperset",
        trigger: [
            "\\sqsupset"
        ],
        kind: "infix",
        associativity: "right",
        precedence: 265
    },
    {
        name: "SquareSupersetEqual",
        trigger: [
            "\\sqsupseteq"
        ],
        kind: "infix",
        associativity: "right",
        precedence: 265
    },
    {
        name: "Subset",
        trigger: [
            "\\subset"
        ],
        kind: "infix",
        associativity: "right",
        precedence: 240
    },
    {
        trigger: [
            "\\subsetneq"
        ],
        kind: "infix",
        associativity: "right",
        precedence: 240,
        parse: "Subset"
    },
    {
        trigger: [
            "\\varsubsetneqq"
        ],
        kind: "infix",
        associativity: "right",
        precedence: 240,
        parse: "Subset"
    },
    {
        name: "SubsetEqual",
        trigger: [
            "\\subseteq"
        ],
        kind: "infix",
        precedence: 240
    },
    {
        name: "Superset",
        trigger: [
            "\\supset"
        ],
        kind: "infix",
        associativity: "right",
        precedence: 240
    },
    {
        trigger: [
            "\\supsetneq"
        ],
        kind: "infix",
        associativity: "right",
        precedence: 240,
        parse: "Superset"
    },
    {
        trigger: [
            "\\varsupsetneq"
        ],
        kind: "infix",
        associativity: "right",
        precedence: 240,
        parse: "Superset"
    },
    {
        name: "SupersetEqual",
        trigger: [
            "\\supseteq"
        ],
        kind: "infix",
        associativity: "right",
        precedence: 240
    }
];
function ls(e1, t) {
    var i;
    if (null === t) return "";
    const n = _a(t);
    if (null === n) return "";
    if ("Set" === n) return 0 === Aa(t) ? "\\emptyset" : 2 === Aa(t) && "Condition" === _a(Ma(t, 2)) ? pa([
        "\\left\\lbrace",
        e1.serialize(Ma(t, 1)),
        "\\middle\\mid",
        e1.serialize(Ma(t, 2)),
        "\\right\\rbrace"
    ]) : pa([
        "\\left\\lbrace",
        ...(null !== (i = Sa(t)) && void 0 !== i ? i : []).map((t)=>e1.serialize(t) + " ,"),
        "\\right\\rbrace"
    ]);
    if ("Range" === n) return pa([
        "\\mathopen\\lbrack",
        e1.serialize(Ma(t, 1)),
        ", ",
        e1.serialize(Ma(t, 2)),
        "\\mathclose\\rbrack"
    ]);
    if ("Interval" === n) {
        let i1 = Ma(t, 1), n1 = Ma(t, 2), r = !1, o = !1;
        return "Open" === _a(i1) && (i1 = Ma(i1, 1), r = !0), "Open" === _a(n1) && (n1 = Ma(n1, 1), o = !0), pa([
            "\\mathopen" + (r ? "\\rbrack" : "\\lbrack"),
            e1.serialize(i1),
            ", ",
            e1.serialize(n1),
            "\\mathclose" + (o ? "\\lbrack" : "\\rbrack")
        ]);
    }
    return e1.numericSetStyle(t, e1.level), "";
}
function us(e1) {
    return (t)=>{
        var i;
        t.skipSpace();
        let n = null, r = null;
        for(; !(null !== r && null !== n || "_" !== t.peek && "^" !== t.peek);)t.match("_") ? r = t.matchRequiredLatexArgument() : t.match("^") && (n = t.matchRequiredLatexArgument()), t.skipSpace();
        ("Nothing" === r || $a(r)) && (r = null), ("Nothing" === n || $a(n)) && (n = null);
        let [o, a] = function(e1) {
            const t = e1.index;
            let i = !1, n = e1.matchExpression({
                minPrec: 266,
                condition: ()=>(e1.matchAll([
                        "\\mathrm",
                        "<{>",
                        "d",
                        "<}>"
                    ]) && (i = !0), i)
            });
            return i || (e1.index = t, n = e1.matchExpression({
                minPrec: 266,
                condition: ()=>(e1.match("d") && (i = !0), i)
            })), n && !i ? ds(n) : [
                n,
                i ? Ca(e1.matchSymbol()) : null
            ];
        }(t);
        if (o && !a && ("Add" === _a(o) || "Subtract" === _a(o))) {
            const s = [], l = [];
            for (const e2 of null !== (i = Sa(o)) && void 0 !== i ? i : [])if (a) l.push(e2);
            else {
                let t1;
                [t1, a] = ds(e2), s.push(null != t1 ? t1 : e2);
            }
            if (null !== a && l.length > 0) return [
                "Add",
                cs(t, e1, [
                    "Add",
                    ...s
                ], a, r, n),
                ...l
            ];
        }
        return cs(t, e1, o, a, r, n);
    };
}
function cs(e1, t, i, n, r, o) {
    if (i && null === o && null === r && !n) return [
        t,
        i
    ];
    if (null != i || (i = "Nothing"), e1.computeEngine) {
        const t1 = e1.computeEngine;
        n && t1.pushScope({
            [n]: {
                domain: "ExtendedRealNumber"
            }
        }), i = t1.box(i).json, n && t1.popScope();
    }
    const a = n ? [
        "Hold",
        n
    ] : null;
    return null !== o ? [
        t,
        i,
        [
            "Tuple",
            null != a ? a : "Nothing",
            null != r ? r : "Nothing",
            o
        ]
    ] : null !== r ? [
        t,
        i,
        [
            "Tuple",
            null != a ? a : "Nothing",
            r
        ]
    ] : a ? [
        t,
        i,
        a
    ] : [
        t,
        i
    ];
}
function ds(e1) {
    const t = _a(e1), i = Ma(e1, 1);
    if (!i) return [
        e1,
        null
    ];
    if ("Multiply" === t) {
        const t1 = Sa(e1);
        if (t1 && t1.length > 1) {
            if ("d" === Ca(t1[t1.length - 2])) return 2 === t1.length ? [
                null,
                Ca(t1[1])
            ] : 3 === t1.length ? [
                t1[0],
                Ca(t1[2])
            ] : [
                [
                    "Multiply",
                    ...t1.slice(0, -2)
                ],
                Ca(t1[t1.length - 1])
            ];
            const [e2, i1] = ds(t1[t1.length - 1]);
            if (e2) return [
                [
                    "Multiply",
                    ...t1.slice(0, -1),
                    e2
                ],
                i1
            ];
        }
    } else if ("Delimiter" === t) {
        const [t2, n] = ds(i);
        if (n) return t2 ? [
            [
                "Delimiter",
                t2,
                ...Sa(e1).slice(1)
            ],
            n
        ] : [
            null,
            n
        ];
    } else if ("Add" === t) {
        const t3 = Sa(e1);
        if (t3 && t3.length > 0) {
            const [e3, i2] = ds(t3[t3.length - 1]);
            if (i2) {
                if (e3) return [
                    [
                        "Add",
                        ...t3.slice(0, -1),
                        e3
                    ],
                    i2
                ];
                if (t3.length > 2) return [
                    [
                        "Add",
                        ...t3.slice(0, -1)
                    ],
                    i2
                ];
                if (t3.length > 2) return [
                    t3[0],
                    i2
                ];
            }
        }
    } else if ("Negate" === t) {
        const [e4, t4] = ds(i);
        if (t4) return [
            e4 ? [
                "Negate",
                e4
            ] : null,
            t4
        ];
    } else if ("Divide" === t) {
        const [t5, n1] = ds(i);
        if (n1) return [
            [
                "Divide",
                null != t5 ? t5 : 1,
                Ma(e1, 2)
            ],
            n1
        ];
    } else {
        const t6 = Sa(e1);
        if (1 === (null == t6 ? void 0 : t6.length)) {
            const [i3, n2] = ds(t6[0]);
            if (n2) return [
                [
                    _a(e1),
                    i3
                ],
                n2
            ];
        }
    }
    return [
        e1,
        null
    ];
}
function hs(e1) {
    return (t, i)=>{
        var n;
        if (!Ma(i, 1)) return e1;
        let r = Ma(i, 2);
        const o = _a(r);
        let a = null;
        "Tuple" !== o && "Triple" !== o && "Pair" !== o && "Single" !== o ? (a = Ca(r), r = null) : a = null !== (n = Ca(Ma(r, 1))) && void 0 !== n ? n : "x";
        let s = Ma(i, 1);
        if ("Lambda" === _a(s) && Ma(s, 1) && (s = Ia(Ma(s, 1), {
            _: null != a ? a : "x",
            _1: null != a ? a : "x"
        })), !r) return pa(a ? [
            e1,
            t.serialize(s),
            "\\mathrm{d}",
            a
        ] : [
            e1,
            t.serialize(s)
        ]);
        let l = r ? [
            t.serialize(Ma(r, 2))
        ] : [];
        l.length > 0 && (l = [
            "_{",
            ...l,
            "}"
        ]);
        let u = [];
        return Ma(r, 3) && (u = [
            "^{",
            t.serialize(Ma(r, 3)),
            "}"
        ]), pa([
            e1,
            ...u,
            ...l,
            t.serialize(s),
            ...a && "Nothing" !== Ca(a) ? [
                "\\,\\mathrm{d}",
                t.serialize(a)
            ] : []
        ]);
    };
}
const ms = [
    {
        name: "Integrate",
        trigger: [
            "\\int"
        ],
        parse: us("Integrate"),
        serialize: hs("\\int")
    },
    {
        trigger: [
            "\\iint"
        ],
        parse: us("Integrate")
    },
    {
        name: "CircularIntegrate",
        trigger: [
            "\\oint"
        ],
        parse: us("CircularIntegrate"),
        serialize: hs("\\oint")
    }
], ps = [
    [
        "Alpha",
        "\\alpha",
        945
    ],
    [
        "Beta",
        "\\beta",
        946
    ],
    [
        "Gamma",
        "\\gamma",
        947
    ],
    [
        "Delta",
        "\\delta",
        948
    ],
    [
        "Epsilon",
        "\\epsilon",
        949
    ],
    [
        "EpsilonSymbol",
        "\\varepsilon",
        1013
    ],
    [
        "Zeta",
        "\\zeta",
        950
    ],
    [
        "Eta",
        "\\eta",
        951
    ],
    [
        "Theta",
        "\\theta",
        952
    ],
    [
        "ThetaSymbol",
        "\\vartheta",
        977
    ],
    [
        "Iota",
        "\\iota",
        953
    ],
    [
        "Kappa",
        "\\kappa",
        954
    ],
    [
        "KappaSymbol",
        "\\varkappa",
        1008
    ],
    [
        "Lambda",
        "\\lambda",
        955
    ],
    [
        "Mu",
        "\\mu",
        956
    ],
    [
        "Nu",
        "\\nu",
        957
    ],
    [
        "Xi",
        "\\xi",
        958
    ],
    [
        "Omicron",
        "\\omicron",
        959
    ],
    [
        "PiSymbol",
        "\\varpi",
        982
    ],
    [
        "Rho",
        "\\rho",
        961
    ],
    [
        "RhoSymbol",
        "\\varrho",
        1009
    ],
    [
        "Sigma",
        "\\sigma",
        963
    ],
    [
        "FinalSigma",
        "\\varsigma",
        962
    ],
    [
        "Tau",
        "\\tau",
        964
    ],
    [
        "Phi",
        "\\phi",
        981
    ],
    [
        "PhiLetter",
        "\\varphi",
        966
    ],
    [
        "Upsilon",
        "\\upsilon",
        965
    ],
    [
        "Chi",
        "\\chi",
        967
    ],
    [
        "Psi",
        "\\psi",
        968
    ],
    [
        "Omega",
        "\\omega",
        969
    ],
    [
        "CapitalAlpha",
        "\\Alpha",
        913
    ],
    [
        "CapitalBeta",
        "\\Beta",
        914
    ],
    [
        "CapitalGamma",
        "\\Gamma",
        915
    ],
    [
        "CapitalDelta",
        "\\Delta",
        916
    ],
    [
        "CapitalEpsilon",
        "\\Epsilon",
        917
    ],
    [
        "CapitalZeta",
        "\\Zeta",
        918
    ],
    [
        "CapitalEta",
        "\\Eta",
        919
    ],
    [
        "CapitalTheta",
        "\\Theta",
        920
    ],
    [
        "CapitaIota",
        "\\Iota",
        921
    ],
    [
        "CapitalKappa",
        "\\Kappa",
        922
    ],
    [
        "CapitalLambda",
        "\\Lambda",
        923
    ],
    [
        "CapitalMu",
        "\\Mu",
        924
    ],
    [
        "CapitalNu",
        "\\Nu",
        925
    ],
    [
        "CapitalXi",
        "\\Xi",
        926
    ],
    [
        "CapitalOmicron",
        "\\Omicron",
        927
    ],
    [
        "CapitalPi",
        "\\Pi",
        928
    ],
    [
        "CapitalRho",
        "\\Rho",
        929
    ],
    [
        "CapitalSigma",
        "\\Sigma",
        931
    ],
    [
        "CapitalTau",
        "\\Tau",
        932
    ],
    [
        "CapitalPhi",
        "\\Phi",
        934
    ],
    [
        "CapitalUpsilon",
        "\\Upsilon",
        933
    ],
    [
        "CapitalChi",
        "\\Chi",
        935
    ],
    [
        "CapitalPsi",
        "\\Psi",
        936
    ],
    [
        "CapitalOmega",
        "\\Omega",
        937
    ],
    [
        "Digamma",
        "\\digamma",
        989
    ],
    [
        "Alef",
        "\\aleph",
        8501
    ],
    [
        "Bet",
        "\\beth",
        8502
    ],
    [
        "Gimel",
        "\\gimel",
        8503
    ],
    [
        "Dalet",
        "\\daleth",
        8504
    ],
    [
        "TurnedCapitalF",
        "\\Finv",
        8498
    ],
    [
        "TurnedCapitalG",
        "\\Game",
        8513
    ],
    [
        "Weierstrass",
        "\\wp",
        8472
    ],
    [
        "Eth",
        "\\eth",
        240
    ],
    [
        "InvertedOhm",
        "\\mho",
        8487
    ],
    [
        "BlackClubSuit",
        "\\clubsuit",
        9827
    ],
    [
        "WhiteHeartSuit",
        "\\heartsuit",
        9825
    ],
    [
        "BlackSpadeSuit",
        "\\spadesuit",
        9824
    ],
    [
        "WhiteDiamondSuit",
        "\\diamondsuit",
        9826
    ],
    [
        "Sharp",
        "\\sharp",
        9839
    ],
    [
        "Flat",
        "\\flat",
        9837
    ],
    [
        "Natural",
        "\\natural",
        9838
    ]
], fs = [
    ...ps.map(([e1, t, i])=>({
            name: e1,
            trigger: [
                t
            ],
            parse: e1
        })),
    ...ps.map(([e1, t, i])=>({
            trigger: [
                String.fromCodePoint(i)
            ],
            parse: e1
        }))
], gs = {
    "(": "(",
    ")": ")",
    "[": "\\lbrack",
    "]": "\\rbrack",
    "{": "\\lbrace",
    "}": "\\rbrace",
    "<": "\\langle",
    ">": "\\rangle",
    "|": "\\vert",
    "||": "\\Vert",
    "\\lceil": "\\lceil",
    "\\lfloor": "\\lfloor",
    "\\rceil": "\\rceil",
    "\\rfloor": "\\rfloor"
};
function ys(e1) {
    return Array.isArray(e1) ? e1.length : 1;
}
function bs(e1, t) {
    var i, n, r, o, a, s, l, u;
    if (!function(e1, t) {
        var i, n;
        const r = null !== (n = null !== (i = e1.name) && void 0 !== i ? i : e1.trigger) && void 0 !== n ? n : e1.openDelimiter;
        if (void 0 !== e1.serialize && !e1.name) return t({
            severity: "warning",
            message: [
                "invalid-dictionary-entry",
                r,
                "Unexpected serialize property without a name property"
            ]
        }), !1;
        if (wr(e1)) {
            if (e1.trigger) return t({
                severity: "warning",
                message: [
                    "invalid-dictionary-entry",
                    r,
                    `Unexpected 'trigger' "${e1.trigger}". 'matchfix' operators use a 'openDelimiter' and 'closeDelimiter' instead of a trigger. `
                ]
            }), !1;
            if (!e1.openDelimiter || !e1.closeDelimiter) return t({
                severity: "warning",
                message: [
                    "invalid-dictionary-entry",
                    r,
                    "Expected `openDelimiter` and a `closeDelimiter` for matchfix operator"
                ]
            }), !1;
            if (typeof e1.openDelimiter != typeof e1.closeDelimiter) return t({
                severity: "warning",
                message: [
                    "invalid-dictionary-entry",
                    r,
                    "Expected `openDelimiter` and `closeDelimiter` to both be strings or array of LatexToken"
                ]
            }), !1;
        }
        if (Sr(e1) || Nr(e1) || Mr(e1)) {
            if (Array.isArray(e1.trigger) && ("_" === e1.trigger[0] || "^" === e1.trigger[0]) || "string" == typeof e1.trigger && (e1.trigger.startsWith("^") || e1.trigger.startsWith("_"))) {
                if (void 0 !== e1.precedence || void 0 !== e1.associativity) return t({
                    severity: "warning",
                    message: [
                        "invalid-dictionary-entry",
                        r,
                        'Unexpected "precedence" or "associativity" for superscript/subscript operator'
                    ]
                }), !1;
            } else if (void 0 === e1.precedence) return t({
                severity: "warning",
                message: [
                    "invalid-dictionary-entry",
                    r,
                    `Expected a "precedence" for ${e1.kind} operator`
                ]
            }), !1;
        } else if (void 0 !== e1.associativity) return t({
            severity: "warning",
            message: [
                "invalid-dictionary-entry",
                r,
                'Unexpected "associativity" operator'
            ]
        }), !1;
        return wr(e1) || e1.trigger || e1.name ? void 0 !== e1.parse || void 0 !== e1.name || (t({
            severity: "warning",
            message: [
                "invalid-dictionary-entry",
                r,
                "Expected a 'parse' or 'name'"
            ]
        }), !1) : (t({
            severity: "warning",
            message: [
                "invalid-dictionary-entry",
                r,
                "Expected at least a 'trigger' or a 'name'"
            ]
        }), !1);
    }(e1, t)) return [
        null,
        null
    ];
    const c = {
        name: e1.name,
        kind: "kind" in e1 ? e1.kind : "symbol"
    };
    if ("matchfix" === c.kind && wr(e1)) {
        if (c.openDelimiter = e1.openDelimiter, c.closeDelimiter = e1.closeDelimiter, "function" == typeof e1.serialize) c.serialize = e1.serialize;
        else {
            const e2 = "string" == typeof c.openDelimiter ? gs[c.openDelimiter] : fa(c.openDelimiter), t1 = "string" == typeof c.closeDelimiter ? gs[c.closeDelimiter] : fa(c.closeDelimiter);
            c.serialize = (i, n)=>pa([
                    e2,
                    i.serialize(Ma(n, 1)),
                    t1
                ]);
        }
        if ("function" == typeof e1.parse) c.parse = e1.parse;
        else {
            const t2 = null !== (i = e1.parse) && void 0 !== i ? i : e1.name;
            c.parse = (e1, i)=>[
                    t2,
                    i
                ];
        }
        return [
            null,
            c
        ];
    }
    if ("environment" === c.kind && Lr(e1)) {
        const t3 = e1.trigger;
        return c.serialize = null !== (n = e1.serialize) && void 0 !== n ? n : (e1, i)=>`\\begin{${t3}}${e1.serialize(Ma(i, 1))}\\end{${t3}}`, c.parse = null !== (r = e1.parse) && void 0 !== r ? r : ()=>null, [
            t3,
            c
        ];
    }
    const d = "string" == typeof e1.trigger ? ma(e1.trigger, []) : e1.trigger, h = d ? fa(d) : "";
    if ("function" === c.kind && _r(e1)) return c.serialize = e1.serialize, h && !e1.serialize && (c.serialize = (e1, t)=>`\\mathrm{${h}}${e1.wrapArguments(t)}`), c.parse = e1.parse, !c.parse && e1.name && (c.parse = (t)=>{
        const i = t.matchArguments("enclosure");
        return null === i ? e1.name : [
            e1.name,
            ...i
        ];
    }), [
        h,
        c
    ];
    if (e1.trigger, "symbol" === c.kind && kr(e1) && (c.precedence = null !== (o = e1.precedence) && void 0 !== o ? o : 1e4), "infix" !== c.kind && "prefix" !== c.kind && "postfix" !== c.kind || !(Sr(e1) || Mr(e1) || Nr(e1)) || (!d || "^" !== d[0] && "_" !== d[0] ? c.precedence = null !== (a = e1.precedence) && void 0 !== a ? a : 1e4 : c.precedence = 720), "infix" === c.kind && Sr(e1)) {
        if (c.associativity = null !== (s = e1.associativity) && void 0 !== s ? s : "non", "function" == typeof e1.parse) c.parse = e1.parse;
        else if (!d || "^" !== d[0] && "_" !== d[0]) {
            const t4 = null !== (l = e1.parse) && void 0 !== l ? l : e1.name, i1 = c.precedence, n1 = c.associativity;
            c.parse = (e1, r, o)=>{
                if (i1 < r.minPrec) return null;
                const a = Pa(e1.matchExpression({
                    ...r,
                    minPrec: i1
                }));
                return "string" == typeof t4 ? Fa(t4, o, a, n1) : [
                    t4,
                    o,
                    a
                ];
            };
        } else {
            const t5 = null !== (u = e1.parse) && void 0 !== u ? u : e1.name;
            c.parse = (e1, i, n)=>[
                    t5,
                    Pa(Ma(n, 1)),
                    Pa(Ma(n, 2))
                ];
        }
    } else if ("function" == typeof e1.parse) c.parse = e1.parse;
    else if (void 0 !== e1.parse) c.parse = ()=>e1.parse;
    else if (void 0 === e1.parse && void 0 !== e1.name) {
        if ("postfix" === c.kind) c.parse = (t, i)=>i ? [
                e1.name,
                i
            ] : null;
        else if ("prefix" === c.kind) {
            const t6 = c.precedence, i2 = e1.name;
            c.parse = (e1, n)=>{
                if (t6 < n.minPrec) return null;
                const r = e1.matchExpression({
                    ...n,
                    minPrec: t6
                });
                return null === r ? null : [
                    i2,
                    r
                ];
            };
        }
    }
    return "function" == typeof e1.serialize || "string" == typeof e1.serialize ? c.serialize = e1.serialize : d && ("postfix" === c.kind ? c.serialize = "#1" + h : "prefix" === c.kind ? c.serialize = h + "#1" : "infix" === c.kind ? c.serialize = "#1" + h + "#2" : "symbol" === c.kind ? c.serialize = h : c.serialize = ""), [
        null != d ? d : null,
        c
    ];
}
const vs = {
    algebra: [
        {
            name: "To",
            trigger: [
                "\\to"
            ],
            kind: "infix",
            precedence: 270
        }
    ],
    arithmetic: Za,
    calculus: ms,
    core: es,
    logic: [
        {
            name: "True",
            trigger: [
                "\\mathrm",
                "<{>",
                "T",
                "r",
                "u",
                "e",
                "<}>"
            ],
            serialize: "\\mathrm{True}"
        },
        {
            name: "False",
            trigger: [
                "\\mathrm",
                "<{>",
                "F",
                "a",
                "l",
                "s",
                "e",
                "<}>"
            ],
            serialize: "\\mathrm{False}"
        },
        {
            name: "Maybe",
            trigger: [
                "\\mathrm",
                "<{>",
                "M",
                "a",
                "y",
                "b",
                "e",
                "<}>"
            ],
            serialize: "\\mathrm{Maybe}"
        }
    ],
    relop: [
        {
            trigger: [
                "!",
                "<"
            ],
            kind: "infix",
            associativity: "right",
            precedence: 246,
            parse: "NotLess"
        },
        {
            name: "NotLess",
            trigger: [
                "\\nless"
            ],
            kind: "infix",
            associativity: "right",
            precedence: 246
        },
        {
            trigger: [
                "<"
            ],
            kind: "infix",
            associativity: "right",
            precedence: 245,
            parse: "Less"
        },
        {
            name: "Less",
            trigger: [
                "\\lt"
            ],
            kind: "infix",
            associativity: "right",
            precedence: 245
        },
        {
            trigger: [
                "<",
                "="
            ],
            kind: "infix",
            associativity: "right",
            precedence: 241,
            parse: "LessEqual"
        },
        {
            name: "LessEqual",
            trigger: [
                "\\le"
            ],
            kind: "infix",
            associativity: "right",
            precedence: 241
        },
        {
            trigger: [
                "\\leq"
            ],
            kind: "infix",
            associativity: "right",
            precedence: 241,
            parse: "Equal"
        },
        {
            trigger: [
                "\\leqslant"
            ],
            kind: "infix",
            associativity: "right",
            precedence: 265,
            parse: "LessEqual"
        },
        {
            name: "LessNotEqual",
            trigger: [
                "\\lneqq"
            ],
            kind: "infix",
            associativity: "right",
            precedence: 260
        },
        {
            name: "NotLessNotEqual",
            trigger: [
                "\\nleqq"
            ],
            kind: "infix",
            associativity: "right",
            precedence: 260
        },
        {
            name: "LessOverEqual",
            trigger: [
                "\\leqq"
            ],
            kind: "infix",
            associativity: "right",
            precedence: 265
        },
        {
            name: "GreaterOverEqual",
            trigger: [
                "\\geqq"
            ],
            kind: "infix",
            associativity: "right",
            precedence: 265,
            parse: "GreaterEqual"
        },
        {
            name: "Equal",
            trigger: [
                "="
            ],
            kind: "infix",
            associativity: "right",
            precedence: 260
        },
        {
            trigger: [
                "*",
                "="
            ],
            kind: "infix",
            associativity: "right",
            precedence: 260,
            parse: "StarEqual"
        },
        {
            name: "StarEqual",
            trigger: [
                "\\star",
                "="
            ],
            kind: "infix",
            associativity: "right",
            precedence: 260
        },
        {
            name: "PlusEqual",
            trigger: [
                "+",
                "="
            ],
            kind: "infix",
            associativity: "right",
            precedence: 260
        },
        {
            name: "MinusEqual",
            trigger: [
                "-",
                "="
            ],
            kind: "infix",
            associativity: "right",
            precedence: 260
        },
        {
            name: "SlashEqual",
            trigger: [
                "/",
                "="
            ],
            kind: "infix",
            associativity: "right",
            precedence: 260
        },
        {
            name: "EqualEqual",
            trigger: [
                "=",
                "="
            ],
            kind: "infix",
            associativity: "right",
            precedence: 260
        },
        {
            name: "EqualEqualEqual",
            trigger: [
                "=",
                "=",
                "="
            ],
            kind: "infix",
            associativity: "right",
            precedence: 265
        },
        {
            name: "TildeFullEqual",
            trigger: [
                "\\cong"
            ],
            kind: "infix",
            associativity: "right",
            precedence: 260
        },
        {
            name: "NotTildeFullEqual",
            trigger: [
                "\\ncong"
            ],
            kind: "infix",
            associativity: "right",
            precedence: 260
        },
        {
            trigger: [
                ":",
                "="
            ],
            kind: "infix",
            associativity: "right",
            precedence: 260,
            parse: "Assign"
        },
        {
            name: "Assign",
            trigger: [
                "\\coloneq"
            ],
            kind: "infix",
            associativity: "right",
            precedence: 260
        },
        {
            name: "Approx",
            trigger: [
                "\\approx"
            ],
            kind: "infix",
            associativity: "right",
            precedence: 247
        },
        {
            name: "NotApprox",
            trigger: [
                "\\approx"
            ],
            kind: "infix",
            associativity: "right",
            precedence: 247
        },
        {
            name: "ApproxEqual",
            trigger: [
                "\\approxeq"
            ],
            kind: "infix",
            associativity: "right",
            precedence: 260
        },
        {
            name: "NotApproxEqual",
            trigger: [
                "!",
                "\\approxeq"
            ],
            kind: "infix",
            associativity: "right",
            precedence: 250
        },
        {
            name: "NotEqual",
            trigger: [
                "\\ne"
            ],
            kind: "infix",
            associativity: "right",
            precedence: 255
        },
        {
            name: "Unequal",
            trigger: [
                "!",
                "="
            ],
            kind: "infix",
            associativity: "right",
            precedence: 260
        },
        {
            name: "GreaterEqual",
            trigger: [
                "\\ge"
            ],
            kind: "infix",
            associativity: "right",
            precedence: 242
        },
        {
            trigger: [
                "\\geq"
            ],
            kind: "infix",
            associativity: "right",
            precedence: 242,
            parse: "GreaterEqual"
        },
        {
            trigger: [
                ">",
                "="
            ],
            kind: "infix",
            associativity: "right",
            precedence: 243,
            parse: "GreaterEqual"
        },
        {
            trigger: [
                "\\geqslant"
            ],
            kind: "infix",
            associativity: "right",
            precedence: 265,
            parse: "GreaterEqual"
        },
        {
            name: "GreaterNotEqual",
            trigger: [
                "\\gneqq"
            ],
            kind: "infix",
            associativity: "right",
            precedence: 260
        },
        {
            name: "NotGreaterNotEqual",
            trigger: [
                "\\ngeqq"
            ],
            kind: "infix",
            associativity: "right",
            precedence: 260
        },
        {
            trigger: [
                ">"
            ],
            kind: "infix",
            associativity: "right",
            precedence: 245,
            parse: "Greater"
        },
        {
            name: "Greater",
            trigger: [
                "\\gt"
            ],
            kind: "infix",
            associativity: "right",
            precedence: 245
        },
        {
            name: "NotGreater",
            trigger: [
                "\\ngtr"
            ],
            kind: "infix",
            associativity: "right",
            precedence: 244
        },
        {
            trigger: [
                "!",
                ">"
            ],
            kind: "infix",
            associativity: "right",
            precedence: 244,
            parse: "NotGreater"
        },
        {
            name: "RingEqual",
            trigger: [
                "\\circeq"
            ],
            kind: "infix",
            associativity: "right",
            precedence: 260
        },
        {
            name: "TriangleEqual",
            trigger: [
                "\\triangleq"
            ],
            kind: "infix",
            associativity: "right",
            precedence: 260
        },
        {
            name: "DotEqual",
            trigger: [
                "\\doteq"
            ],
            kind: "infix",
            associativity: "right",
            precedence: 265
        },
        {
            name: "DotEqualDot",
            trigger: [
                "\\doteqdot"
            ],
            kind: "infix",
            associativity: "right",
            precedence: 265
        },
        {
            name: "FallingDotEqual",
            trigger: [
                "\\fallingdotseq"
            ],
            kind: "infix",
            associativity: "right",
            precedence: 265
        },
        {
            name: "RisingDotEqual",
            trigger: [
                "\\fallingdotseq"
            ],
            kind: "infix",
            associativity: "right",
            precedence: 265
        },
        {
            name: "QuestionEqual",
            trigger: [
                "\\questeq"
            ],
            kind: "infix",
            associativity: "right",
            precedence: 260
        },
        {
            name: "Equivalent",
            trigger: [
                "\\equiv"
            ],
            kind: "infix",
            associativity: "right",
            precedence: 260
        },
        {
            trigger: [
                "\\iff"
            ],
            kind: "infix",
            parse: "Equivalent",
            associativity: "right",
            precedence: 260
        },
        {
            name: "MuchLess",
            trigger: [
                "\\ll"
            ],
            kind: "infix",
            associativity: "right",
            precedence: 260
        },
        {
            name: "MuchGreater",
            trigger: [
                "\\gg"
            ],
            kind: "infix",
            associativity: "right",
            precedence: 260
        },
        {
            name: "Precedes",
            trigger: [
                "\\prec"
            ],
            kind: "infix",
            associativity: "right",
            precedence: 260
        },
        {
            name: "Succeeds",
            trigger: [
                "\\succ"
            ],
            kind: "infix",
            associativity: "right",
            precedence: 260
        },
        {
            name: "PrecedesEqual",
            trigger: [
                "\\preccurlyeq"
            ],
            kind: "infix",
            associativity: "right",
            precedence: 260
        },
        {
            name: "SucceedsEqual",
            trigger: [
                "\\curlyeqprec"
            ],
            kind: "infix",
            associativity: "right",
            precedence: 260
        },
        {
            name: "NotPrecedes",
            trigger: [
                "\\nprec"
            ],
            kind: "infix",
            associativity: "right",
            precedence: 260
        },
        {
            name: "NotSucceeds",
            trigger: [
                "\\nsucc"
            ],
            kind: "infix",
            associativity: "right",
            precedence: 260
        },
        {
            name: "Between",
            trigger: [
                "\\between"
            ],
            kind: "infix",
            associativity: "right",
            precedence: 265
        }
    ],
    other: rs,
    physics: [
        {
            name: "mu-0",
            trigger: "\\mu_0"
        }
    ],
    sets: ss,
    symbols: fs,
    trigonometry: as
}, xs = {
    "(": [
        "\\lparen",
        "("
    ],
    ")": [
        "\\rparen",
        ")"
    ],
    "[": [
        "\\lbrack"
    ],
    "]": [
        "\\rbrack"
    ],
    "<": [
        "<",
        "\\langle"
    ],
    ">": [
        ">",
        "\\rangle"
    ],
    "{": [
        "\\{",
        "\\lbrace"
    ],
    "}": [
        "\\}",
        "\\rbrace"
    ],
    ":": [
        ":",
        "\\colon"
    ],
    "|": [
        "|",
        "\\|",
        "\\lvert",
        "\\rvert"
    ],
    "||": [
        "||",
        "\\Vert",
        "\\lVert",
        "\\rVert"
    ],
    "\\lfloor": [
        "\\lfloor"
    ],
    "\\rfloor": [
        "\\rfloor"
    ],
    "\\lceil": [
        "\\lceil"
    ],
    "\\rceil": [
        "\\rceil"
    ],
    "\\ulcorner": [
        "\\ulcorner"
    ],
    "\\urcorner": [
        "\\urcorner"
    ],
    "\\llcorner": [
        "\\llcorner"
    ],
    "\\lrcorner": [
        "\\lrcorner"
    ],
    "\\lgroup": [
        "\\lgroup"
    ],
    "\\rgroup": [
        "\\rgroup"
    ],
    "\\lmoustache": [
        "\\lmoustache"
    ],
    "\\rmoustache": [
        "\\rmoustache"
    ]
}, ks = {
    ":": [
        ":",
        "\\colon"
    ],
    "|": [
        "|",
        "\\|",
        "\\mid",
        "\\mvert"
    ]
}, _s = {
    "\\left": "\\right",
    "\\bigl": "\\bigr",
    "\\Bigl": "\\Bigr",
    "\\biggl": "\\biggr",
    "\\Biggl": "\\Biggr",
    "\\big": "\\big",
    "\\Big": "\\Big",
    "\\bigg": "\\bigg",
    "\\Bigg": "\\Bigg"
}, ws = [
    "\\middle",
    "\\bigm",
    "\\Bigm",
    "\\biggm",
    "\\Biggm",
    "\\big",
    "\\Big",
    "\\bigg",
    "\\Bigg"
], Ss = {
    "(": ")",
    "[": "]",
    "\\{": "\\}",
    "\\lbrace": "\\rbrace",
    "\\lparen": "\\rparen",
    "\\langle": "\\rangle",
    "\\lfloor": "\\rfloor",
    "\\lceil": "\\rceil",
    "\\vert": "\\vert",
    "\\lvert": "\\rvert",
    "\\Vert": "\\Vert",
    "\\lVert": "\\rVert",
    "\\lbrack": "\\rbrack",
    "\\ulcorner": "\\urcorner",
    "\\llcorner": "\\lrcorner",
    "\\lgroup": "\\rgroup",
    "\\lmoustache": "\\rmoustache"
}, Ms = {
    precision: 6,
    positiveInfinity: "\\infty",
    negativeInfinity: "-\\infty",
    notANumber: "\\operatorname{NaN}",
    decimalMarker: ".",
    groupSeparator: "\\,",
    exponentProduct: "\\cdot",
    beginExponentMarker: "10^{",
    endExponentMarker: "}",
    notation: "auto",
    truncationMarker: "\\ldots",
    beginRepeatingDigits: "\\overline{",
    endRepeatingDigits: "}",
    imaginaryUnit: "\\imaginaryI",
    avoidExponentsInRange: [
        -7,
        20
    ]
}, Ns = {
    applyInvisibleOperator: "auto",
    skipSpace: !0,
    parseArgumentsOfUnknownLatexCommands: !0,
    parseNumbers: !0,
    parseUnknownIdentifier: (e1, t)=>{
        var i;
        return void 0 !== (null === (i = t.computeEngine) || void 0 === i ? void 0 : i.lookupFunction(e1)) ? "function" : /^[a-zA-Z]/.test(e1) ? "symbol" : "unknown";
    },
    preserveLatex: !1
};
class Ls {
    updateOptions(e1) {
        for (const [t, i] of Object.entries(e1)){
            if (!(t in this.options)) throw Error(`Unexpected option "${t}"`);
            this.options[t] = i, "string" == typeof i && ("positiveInfinity" === t && (this._positiveInfinityTokens = ma(i, [])), "negativeInfinity" === t && (this._negativeInfinityTokens = ma(i, [])), "notANumber" === t && (this._notANumberTokens = ma(i, [])), "decimalMarker" === t && (this._decimalMarkerTokens = ma(i, [])), "groupSeparator" === t && (this._groupSeparatorTokens = ma(i, [])), "exponentProduct" === t && (this._exponentProductTokens = ma(i, [])), "beginExponentMarker" === t && (this._beginExponentMarkerTokens = ma(i, [])), "endExponentMarker" === t && (this._endExponentMarkerTokens = ma(i, [])), "truncationMarker" === t && (this._truncationMarkerTokens = ma(i, [])), "beginRepeatingDigits" === t && (this._beginRepeatingDigitsTokens = ma(i, [])), "endRepeatingDigits" === t && (this._endRepeatingDigitsTokens = ma(i, [])), "imaginaryNumber" === t && (this._imaginaryNumberTokens = ma(i, [])));
        }
    }
    get atEnd() {
        return this.index >= this._tokens.length;
    }
    get peek() {
        const e1 = this._tokens[this.index];
        if (e1 === this._lastPeek ? this._peekCounter += 1 : this._peekCounter = 0, this._peekCounter >= 1024) throw Error(`Infinite loop detected while parsing "${this.latex(0)}" at ${this._lastPeek} (index ${this.index})`);
        return this._lastPeek = e1, e1;
    }
    next() {
        return this._tokens[this.index++];
    }
    atTerminator(e1) {
        return !!this.atBoundary || !(!(null == e1 ? void 0 : e1.condition) || !e1.condition(this));
    }
    get atBoundary() {
        if (this.atEnd) return !0;
        const e1 = this.index;
        for (const t of this._boundaries)if (this.matchAll(t.tokens)) return this.index = e1, !0;
        return !1;
    }
    addBoundary(e1) {
        this._boundaries.push({
            index: this.index,
            tokens: e1
        });
    }
    removeBoundary() {
        this._boundaries.pop();
    }
    matchBoundary() {
        const e1 = this._boundaries[this._boundaries.length - 1], t = e1 && this.matchAll(e1.tokens);
        return t && this._boundaries.pop(), t;
    }
    boundaryError(e1) {
        const t = this._boundaries[this._boundaries.length - 1];
        return this._boundaries.pop(), this.error(e1, t.index);
    }
    latex(e1, t) {
        return fa(this._tokens.slice(e1, t));
    }
    latexAhead(e1) {
        return this.latex(this.index, this.index + e1);
    }
    latexBefore() {
        return this.latex(0, this.index);
    }
    latexAfter() {
        return this.latex(this.index);
    }
    lookAhead() {
        let e1 = Math.min(this._dictionary.lookahead, this._tokens.length - this.index);
        if (e1 < 0) return [];
        const t = Array(e1 + 1);
        for(; e1 > 0;)t[e1] = this.latexAhead(e1--);
        return t;
    }
    peekDefinitions(e1) {
        let t;
        if ("function" === e1) {
            const e2 = this.index;
            if (this.match("\\operatorname") || this.match("\\mathrm") || this.match("\\mathit")) {
                const t1 = this.matchStringArgument(), i = this.index - e2;
                return this.index = e2, null !== t1 && this._dictionary.function.has(t1) ? this._dictionary.function.get(t1).map((e1)=>[
                        e1,
                        i
                    ]) : null;
            }
            return null;
        }
        t = "operator" === e1 ? this.lookAhead().map((e1, t)=>{
            var i, n, r, o, a;
            return null !== (o = null !== (n = null === (i = this._dictionary.infix[t]) || void 0 === i ? void 0 : i.get(e1)) && void 0 !== n ? n : null === (r = this._dictionary.postfix[t]) || void 0 === r ? void 0 : r.get(e1)) && void 0 !== o ? o : null === (a = this._dictionary.prefix[t]) || void 0 === a ? void 0 : a.get(e1);
        }) : this.lookAhead().map((t, i)=>{
            var n;
            return null === (n = this._dictionary[e1][i]) || void 0 === n ? void 0 : n.get(t);
        });
        const i1 = [];
        for(let e3 = t.length; e3 > 0; e3--)if (void 0 !== t[e3]) for (const n of t[e3])i1.push([
            n,
            e3
        ]);
        return 0 === i1.length ? null : i1;
    }
    skipSpaceTokens() {
        for(; this.match("<space>"););
    }
    skipSpace() {
        if (!this.options.skipSpace) return !1;
        if (!this.atEnd && "<{>" === this.peek) {
            const e1 = this.index;
            for(this.next(); this.match("<space>"););
            if ("<}>" === this.next()) return this.skipSpace(), !0;
            this.index = e1;
        }
        let e2 = !1;
        for(; this.match("<space>");)e2 = !0;
        return e2 && this.skipSpace(), e2;
    }
    skipVisualSpace() {
        this.options.skipSpace && (this.skipSpace(), [
            "\\!",
            "\\,",
            "\\:",
            "\\;",
            "\\enskip",
            "\\enspace",
            "\\space",
            "\\quad",
            "\\qquad"
        ].includes(this.peek) && (this.next(), this.skipVisualSpace()), this.skipSpace());
    }
    matchChar() {
        var e1;
        const t = this.index;
        let i = 0;
        for(; this.match("^");)i += 1;
        if (i >= 2) {
            let e2 = "", t1 = 0;
            for(; t1 != i;){
                const i1 = this.matchAny([
                    "0",
                    "1",
                    "2",
                    "3",
                    "4",
                    "5",
                    "6",
                    "7",
                    "8",
                    "9",
                    "a",
                    "b",
                    "c",
                    "d",
                    "e",
                    "f"
                ]);
                if (!i1) break;
                e2 += i1, t1 += 1;
            }
            if (e2.length === i) return String.fromCodePoint(Number.parseInt(e2, 16));
        } else {
            if (this.match("\\char")) {
                let t2 = Math.floor(null !== (e1 = this.matchLatexNumber()) && void 0 !== e1 ? e1 : NaN);
                return (!Number.isFinite(t2) || t2 < 0 || t2 > 1114111) && (t2 = 10067), String.fromCodePoint(t2);
            }
            if (this.match("\\unicode")) {
                if (this.skipSpaceTokens(), "<{>" === this.peek) {
                    this.next();
                    const e3 = this.matchLatexNumber();
                    if (this.match("<}>") && null !== e3 && e3 >= 0 && e3 <= 1114111) return String.fromCodePoint(e3);
                } else {
                    const e4 = this.matchLatexNumber();
                    if (null !== e4 && e4 >= 0 && e4 <= 1114111) return String.fromCodePoint(e4);
                }
            }
        }
        return this.index = t, this.next();
    }
    matchColor(e1 = !1) {
        let t = "";
        for(; !this.atEnd && "}" !== this.peek;)t += this.next();
        return t;
    }
    matchLatexDimension() {
        return null;
    }
    match(e1) {
        return this._tokens[this.index] === e1 && (this.index++, !0);
    }
    matchAll(e1) {
        if ("string" == typeof e1 && (e1 = [
            e1
        ]), 0 === e1.length) return !1;
        let t = !0, i = 0;
        do t = this._tokens[this.index + i] === e1[i++];
        while (t && i < e1.length);
        return t && (this.index += i), t;
    }
    matchAny(e1) {
        return e1.includes(this._tokens[this.index]) ? this._tokens[this.index++] : "";
    }
    matchSequence(e1) {
        const t = [];
        for(; e1.includes(this._tokens[this.index]);)t.push(this._tokens[this.index++]);
        return t;
    }
    matchOptionalSign() {
        let e1 = !!this.matchAny([
            "-",
            "−"
        ]);
        for(; this.matchAny([
            "+",
            "﹢"
        ]) || this.skipSpace();)this.matchAny([
            "-",
            "−"
        ]) && (e1 = !e1);
        return e1 ? "-" : "+";
    }
    matchDecimalDigits(e1) {
        var t;
        null != e1 || (e1 = {}), null !== (t = e1.withGrouping) && void 0 !== t || (e1.withGrouping = !1);
        const i = [];
        let n = !1;
        for(; !n;){
            for(; /^[0-9]$/.test(this.peek);)i.push(this.next()), this.skipVisualSpace();
            if (n = !0, e1.withGrouping && this.options.groupSeparator) {
                const e2 = this.index;
                this.skipVisualSpace(), this.matchAll(this._groupSeparatorTokens) && (this.skipVisualSpace(), /^[0-9]$/.test(this.peek) ? n = !1 : this.index = e2);
            }
        }
        return i.join("");
    }
    matchSignedInteger(e1) {
        var t;
        null != e1 || (e1 = {}), null !== (t = e1.withGrouping) && void 0 !== t || (e1.withGrouping = !1);
        const i = this.index, n = this.matchOptionalSign(), r = this.matchDecimalDigits(e1);
        return r ? "-" === n ? "-" + r : r : (this.index = i, "");
    }
    matchExponent() {
        const e1 = this.index;
        if (this.matchAny([
            "e",
            "E"
        ])) {
            const e2 = this.matchSignedInteger({
                withGrouping: !1
            });
            if (e2) return "e" + e2;
        }
        if (this.index = e1, this.match("\\times") && (this.skipSpaceTokens(), this.match("1") && this.match("0") && this.match("^"))) {
            if (/^[0-9]$/.test(this.peek)) return "e" + this.next();
            if (this.match("<{>")) {
                this.skipSpaceTokens();
                const e3 = this.matchSignedInteger();
                if (this.skipSpaceTokens(), this.match("<}>") && e3) return "e" + e3;
            }
        }
        if (this.index = e1, this.skipSpaceTokens(), this.match("\\%")) return "e-2";
        if (this.index = e1, this.matchAll(this._exponentProductTokens) && (this.skipSpaceTokens(), this.matchAll(this._beginExponentMarkerTokens))) {
            this.skipSpaceTokens();
            const e4 = this.matchSignedInteger();
            if (this.skipSpaceTokens(), this.matchAll(this._endExponentMarkerTokens) && e4) return "e" + e4;
        }
        return this.index = e1, "";
    }
    matchRepeatingDecimal() {
        const e1 = this.index;
        let t = "";
        return this.match("(") ? (t = this.matchDecimalDigits(), t && this.match(")") ? "(" + t + ")" : (this.index = e1, "")) : (this.index = e1, this.matchAll([
            "\\left",
            "("
        ]) ? (t = this.matchDecimalDigits(), t && this.matchAll([
            "\\right",
            ")"
        ]) ? "(" + t + ")" : (this.index = e1, "")) : (this.index = e1, this.matchAll([
            "\\overline",
            "<{>"
        ]) ? (t = this.matchDecimalDigits(), t && this.match("<}>") ? "(" + t + ")" : (this.index = e1, "")) : (this.index = e1, this.matchAll(this._beginRepeatingDigitsTokens) ? (t = this.matchDecimalDigits(), t && this.matchAll(this._endRepeatingDigitsTokens) ? "(" + t + ")" : (this.index = e1, "")) : (this.index = e1, ""))));
    }
    matchNumber() {
        if (!this.options.parseNumbers) return "";
        const e1 = this.index;
        this.skipVisualSpace(), this.match("+");
        let t = "", i = !1;
        if (this.match(".") || this.matchAll(this._decimalMarkerTokens)) {
            const t1 = this.peek;
            if ("\\overline" !== t1 && t1 !== this._beginRepeatingDigitsTokens[0] && !/[0-9\(]/.test(t1)) return this.index = e1, "";
            i = !0;
        } else if (t = this.matchDecimalDigits({
            withGrouping: !0
        }), !t) return this.index = e1, "";
        let n = !0;
        if (i || !this.match(".") && !this.matchAll(this._decimalMarkerTokens) ? i ? t = "0." + this.matchDecimalDigits({
            withGrouping: !0
        }) : n = !1 : t += "." + this.matchDecimalDigits({
            withGrouping: !0
        }), n) {
            const e2 = this.matchRepeatingDecimal();
            e2 ? t += e2 : this.match("\\ldots") || this.matchAll(this._truncationMarkerTokens);
        }
        return this.skipVisualSpace(), t + this.matchExponent();
    }
    matchLatexNumber(e1 = !0) {
        var t, i;
        let n = !1, r = this.peek;
        for(; "<space>" === r || "+" === r || "-" === r;)"-" === r && (n = !n), this.next(), r = this.peek;
        let o = 10, a = [
            "0",
            "1",
            "2",
            "3",
            "4",
            "5",
            "6",
            "7",
            "8",
            "9"
        ];
        if (this.match("'")) o = 8, a = [
            "0",
            "1",
            "2",
            "3",
            "4",
            "5",
            "6",
            "7"
        ], e1 = !0;
        else if (this.match('"') || this.match("x")) o = 16, a = [
            "0",
            "1",
            "2",
            "3",
            "4",
            "5",
            "6",
            "7",
            "8",
            "9",
            "A",
            "B",
            "C",
            "D",
            "E",
            "F"
        ], e1 = !0;
        else if (this.match("`")) return r = this.next(), r ? r.startsWith("\\") && 2 === r.length ? (n ? -1 : 1) * (null !== (t = r.codePointAt(1)) && void 0 !== t ? t : 0) : (n ? -1 : 1) * (null !== (i = r.codePointAt(0)) && void 0 !== i ? i : 0) : null;
        let s = "";
        for(; a.includes(this.peek);)s += this.next();
        if (!e1 && this.match(".")) for(s += "."; a.includes(this.peek);)s += this.next();
        const l = e1 ? Number.parseInt(s, o) : Number.parseFloat(s);
        return Number.isNaN(l) ? null : n ? -l : l;
    }
    matchPrefixOperator(e1) {
        e1 || (e1 = {
            minPrec: 0
        }), e1.minPrec || (e1 = {
            ...e1,
            minPrec: 0
        });
        const t = this.peekDefinitions("prefix");
        if (null === t) return null;
        const i = this.index;
        for (const [n, r] of t){
            this.index = i + r;
            const t1 = n.parse(this, e1);
            if (t1) return t1;
        }
        return this.index = i, null;
    }
    matchInfixOperator(e1, t) {
        t || (t = {
            minPrec: 0
        }), t.minPrec || (t = {
            ...t,
            minPrec: 0
        });
        const i = this.peekDefinitions("infix");
        if (null === i) return null;
        const n = this.index;
        for (const [r, o] of i)if (r.precedence >= t.minPrec) {
            this.index = n + o;
            const i1 = r.parse(this, t, e1);
            if (i1) return i1;
        }
        return this.index = n, null;
    }
    matchArguments(e1) {
        var t, i, n, r;
        if (!e1) return null;
        const o = this.index, a = this.matchEnclosure();
        if ("enclosure" === e1 && "Delimiter" === _a(a)) return "Sequence" === Ma(a, 1) ? null !== (t = Sa(Ma(a, 1))) && void 0 !== t ? t : [] : [
            null !== (i = Ma(a, 1)) && void 0 !== i ? i : [
                "Sequence"
            ]
        ];
        if ("implicit" === e1) {
            if ("Delimiter" === _a(a)) return "Sequence" === _a(Ma(a, 1)) ? null !== (n = Ba(a)) && void 0 !== n ? n : [] : [
                null !== (r = Ma(a, 1)) && void 0 !== r ? r : [
                    "Sequence"
                ]
            ];
            if (null !== a) return [
                a
            ];
            const e2 = this.matchExpression({
                minPrec: 390
            });
            return null !== e2 ? [
                e2
            ] : null;
        }
        return this.index = o, null;
    }
    matchFunctionSuffix() {
        return null;
    }
    matchOpenDelimiter(e1, t) {
        var i;
        const n = this.index, r = _s[this.peek];
        r && this.next();
        const o = null !== (i = xs[e1]) && void 0 !== i ? i : [
            e1
        ], a = r ? [
            r
        ] : [];
        return o.includes("||") && this.matchAll([
            "|",
            "|"
        ]) ? (a.push("|"), a.push("|"), a) : o.includes(this.peek) ? (Ss[e1] === t ? a.push(Ss[this.peek]) : a.push(t), this.next(), a) : (this.index = n, null);
    }
    matchMiddleDelimiter(e1) {
        var t;
        const i = null !== (t = ks[e1]) && void 0 !== t ? t : [
            e1
        ];
        if (ws.includes(this.peek)) {
            const e2 = this.index;
            return this.next(), i.includes(this.peek) ? (this.next(), !0) : (this.index = e2, !1);
        }
        return !!i.include(this.peek) && (this.next(), !0);
    }
    matchEnclosureOpen() {
        const e1 = this._dictionary.matchfix;
        if (0 === e1.length) return null;
        const t = this.index;
        for (const i of e1){
            if (this.index = t, Array.isArray(i.openDelimiter)) {
                if (this.matchAll(i.openDelimiter)) return fa(i.closeDelimiter);
                continue;
            }
            const e2 = this.matchOpenDelimiter(i.openDelimiter, i.closeDelimiter);
            if (null !== e2) return fa(e2);
        }
        return this.index = t, null;
    }
    matchEnclosureClose() {
        const e1 = this._dictionary.matchfix;
        if (0 === e1.length) return null;
        const t = this.index;
        for (const i of e1){
            if (this.index = t, Array.isArray(i.closeDelimiter)) {
                if (this.matchAll(i.closeDelimiter)) return fa(i.openDelimiter);
                continue;
            }
            this.index = t;
            let e2 = this.peek;
            const n = Object.keys(_s).find((t)=>_s[t] === e2);
            n && this.next();
            let r = [];
            e2 = this.peek;
            const o = Object.keys(Ss).find((t)=>Ss[t] === e2);
            if (o && (r = [
                o
            ]), n && (r = [
                n,
                ...r
            ]), r.length > 0) return this.next(), fa(r);
        }
        return this.index = t, null;
    }
    matchEnclosure() {
        const e1 = this._dictionary.matchfix;
        if (0 === e1.length) return null;
        const t = this.index;
        for (const i of e1){
            if (this.index = t, Array.isArray(i.openDelimiter)) {
                if (!this.matchAll(i.openDelimiter)) continue;
                this.addBoundary(i.closeDelimiter);
                const e2 = this.matchExpression();
                if (this.skipSpace(), !this.matchBoundary()) {
                    this.removeBoundary();
                    continue;
                }
                const t1 = i.parse(this, null != e2 ? e2 : [
                    "Sequence"
                ]);
                if (null === t1) continue;
                return t1;
            }
            const e3 = this.matchOpenDelimiter(i.openDelimiter, i.closeDelimiter);
            if (null === e3) continue;
            if (this.matchAll(e3)) {
                const e4 = i.parse(this, [
                    "Sequence"
                ]);
                if (null === e4) continue;
                return e4;
            }
            this.addBoundary(e3);
            const n = this.index;
            let r = this.matchExpression();
            if (this.skipSpace(), !this.matchBoundary() && (this.removeBoundary(), this.index = n, r = this.matchExpression(), !this.matchAll(e3))) {
                if (!this.atEnd) continue;
                return this.index = t, null;
            }
            const o = i.parse(this, null != r ? r : [
                "Sequence"
            ]);
            if (null !== o) return o;
        }
        return this.index = t, null;
    }
    matchIdentifier() {
        if (this.match("\\operatorname") || this.match("\\mathit") || this.match("\\mathrm")) {
            const e1 = this.index, t = this.matchStringArgument();
            return null === t ? this.error("expected-string-argument", e1) : null !== t && va(t) ? t : this.error("invalid-symbol-name", e1);
        }
        return /^[a-zA-Z]$/.test(this.peek) ? this.next() : null;
    }
    matchFunction() {
        var e1, t;
        const i = this.index, n = this.peekDefinitions("function");
        if (n) for (const [e2, t1] of n){
            if (this.index = i + t1, "function" != typeof e2.parse) {
                const t2 = this.matchArguments("enclosure");
                return t2 ? [
                    e2.name,
                    ...t2
                ] : e2.name;
            }
            {
                const t3 = e2.parse(this);
                if (t3) return t3;
            }
        }
        this.index = i;
        const r = this.matchIdentifier();
        if (null === r) return this.index = i, null;
        if ("string" != typeof r) return r;
        if ("function" === (null === (t = (e1 = this.options).parseUnknownIdentifier) || void 0 === t ? void 0 : t.call(e1, r, this))) {
            const e3 = this.matchArguments("enclosure");
            return e3 ? [
                r,
                ...e3
            ] : r;
        }
        return this.index = i, null;
    }
    matchSymbol() {
        var e1, t;
        const i = this.index, n = this.peekDefinitions("symbol");
        if (n) for (const [e2, t1] of n){
            if (this.index = i + t1, "function" != typeof e2.parse) return e2.name;
            {
                const t2 = e2.parse(this);
                if (t2) return t2;
            }
        }
        this.index = i;
        const r = this.matchIdentifier();
        return null === r ? (this.index = i, null) : "string" != typeof r || r && "symbol" === (null === (t = (e1 = this.options).parseUnknownIdentifier) || void 0 === t ? void 0 : t.call(e1, r, this)) ? r : (this.index = i, null);
    }
    matchOptionalLatexArgument() {
        const e1 = this.index;
        if (this.skipSpaceTokens(), this.match("[")) {
            this.addBoundary([
                "]"
            ]);
            const e2 = this.matchExpression();
            return this.skipSpace(), this.matchBoundary() ? e2 : this.boundaryError("expected-closing-delimiter");
        }
        return this.index = e1, null;
    }
    matchRequiredLatexArgument(e1) {
        e1 || (e1 = [
            ...'!"#$%&(),/;:?@[]`|~'.split(""),
            "\\left",
            "\\bigl"
        ]);
        const t = this.index;
        if (this.skipSpaceTokens(), this.match("<{>")) {
            this.addBoundary([
                "<}>"
            ]);
            const e2 = this.matchExpression();
            return this.skipSpace(), this.matchBoundary() ? null != e2 ? e2 : [
                "Sequence"
            ] : this.boundaryError("expected-closing-delimiter");
        }
        return e1.includes(this.peek) ? (this.index = t, null) : /^[0-9]$/.test(this.peek) ? parseInt(this.next()) : /^[^\\#]$/.test(this.peek) ? this.next() : this.matchSymbol() || (this.index = t, null);
    }
    matchSupsub(e1) {
        var t, i, n;
        if (null === e1) return null;
        const r = this.index;
        this.skipSpace();
        const o = [], a = [];
        let s = r;
        for(; "_" === this.peek || "^" === this.peek;){
            if (this.match("_")) {
                if (s = this.index, this.match("_") || this.match("^")) a.push(this.error("syntax-error", s));
                else {
                    const e2 = null !== (t = this.matchRequiredLatexArgument()) && void 0 !== t ? t : this.matchStringArgument();
                    if (null === e2) return this.error("missing", r);
                    a.push(e2);
                }
            } else if (this.match("^")) {
                if (s = this.index, this.match("_") || this.match("^")) o.push(this.error("syntax-error", s));
                else {
                    const e3 = this.matchRequiredLatexArgument();
                    if (null === e3) return this.error("missing", r);
                    o.push(e3);
                }
            }
            s = this.index, this.skipSpace();
        }
        if (0 === o.length && 0 === a.length) return this.index = r, e1;
        let l = e1;
        if (a.length > 0) {
            const e4 = null === (i = this._dictionary.infix[1]) || void 0 === i ? void 0 : i.get("_");
            if (e4) {
                const t1 = [
                    "Subscript",
                    l,
                    1 === a.length ? a[0] : [
                        "List",
                        ...a
                    ]
                ];
                for (const i1 of e4)if (l = "function" == typeof i1.parse ? i1.parse(this, {
                    minPrec: 0
                }, t1) : t1, l) break;
            }
        }
        if (o.length > 0) {
            const e5 = null === (n = this._dictionary.infix[1]) || void 0 === n ? void 0 : n.get("^");
            if (e5) {
                const t2 = [
                    "Superscript",
                    l,
                    1 === o.length ? o[0] : [
                        "List",
                        ...o
                    ]
                ];
                for (const i2 of e5)if (l = "function" == typeof i2.parse ? i2.parse(this, {
                    minPrec: 0
                }, t2) : t2, l) break;
            }
        }
        return null === l && (this.index = r), l;
    }
    matchPostfix(e1) {
        if (null === e1) return null;
        const t = this.peekDefinitions("postfix");
        if (null === t) return null;
        const i = this.index;
        for (const [n, r] of t){
            this.index = i + r;
            const t1 = n.parse(this, e1);
            if (null !== t1) return t1;
        }
        return this.index = i, null;
    }
    matchString() {
        let e1 = "";
        for(; !this.atBoundary;){
            const t = this.peek;
            if ("<$>" === t || "<$$>" === t) return "";
            "<space>" === t ? (this.next(), e1 += " ") : (t[0], e1 += this.next());
        }
        return e1;
    }
    matchStringArgument() {
        const e1 = this.index;
        if (this.skipSpaceTokens(), this.match("<{>")) {
            for(this.addBoundary([
                "<}>"
            ]); this.match("<space>"););
            const e2 = this.matchString();
            if (this.matchBoundary()) return e2.trimEnd();
            this.removeBoundary();
        }
        return this.index = e1, null;
    }
    matchTabular() {
        var e1;
        const t = [];
        let i = [], n = null;
        for(; !this.atBoundary;)if (this.skipSpace(), this.match("&")) i.push(null != n ? n : "Nothing"), n = null;
        else if (this.match("\\\\") || this.match("\\cr")) this.skipSpace(), this.matchOptionalLatexArgument(), null !== n && i.push(n), t.push(i), i = [], n = null;
        else {
            const t1 = [];
            let i1 = this.peek;
            for(; "&" !== i1 && "\\\\" !== i1 && "\\cr" !== i1 && !this.atBoundary;)n = this.matchExpression({
                condition: (e1)=>{
                    const t = e1.peek;
                    return "&" === t || "\\\\" === t || "\\cr" === t;
                }
            }), n ? t1.push(n) : (t1.push([
                "Error",
                [
                    "'unexpected-token'",
                    i1
                ]
            ]), this.next()), this.skipSpace(), i1 = this.peek;
            n = t1.length > 1 ? [
                "Sequence",
                ...t1
            ] : null !== (e1 = t1[0]) && void 0 !== e1 ? e1 : "Nothing";
        }
        return null !== n && i.push(n), i.length > 0 && t.push(i), t;
    }
    matchEnvironment() {
        const e1 = this.index;
        if (!this.match("\\begin")) return null;
        const t = this.matchStringArgument();
        if (null === t) return this.error("expected-environment-name", e1);
        this.addBoundary([
            "\\end",
            "<{>",
            ...t.split(""),
            "<}>"
        ]);
        const i = this._dictionary.environment.get(t);
        if (!i) return this.matchTabular(), this.skipSpace(), this.matchBoundary() ? this.error([
            "unknown-environment",
            {
                str: t
            }
        ], e1) : this.boundaryError("unbalanced-environment");
        const n = i.parse(this, [], []);
        return this.skipSpace(), this.matchBoundary() ? null !== n ? this.decorate(n, e1) : (this.index = e1, null) : this.boundaryError("unbalanced-environment");
    }
    applyInvisibleOperator(e1, t) {
        var i;
        if (null === t || "Error" === _a(t) || "Nothing" === Ca(t) || $a(t) || this.atTerminator(e1) || null === this.options.applyInvisibleOperator) return null;
        if (null !== this.peekDefinitions("operator")) return null;
        const n = this.index, r = this.matchExpression({
            ...e1,
            minPrec: 390
        });
        if (null === r || "Nothing" === Ca(r) || $a(r)) return this.index = n, null;
        if ("Error" === _a(r)) return Fa("Sequence", t, r);
        if ("function" == typeof this.options.applyInvisibleOperator) return this.options.applyInvisibleOperator(this, t, r);
        const o = Ca(t);
        if (o && "function" === this.options.parseUnknownIdentifier(o, this)) {
            const e2 = Ba(r);
            return e2 ? [
                t,
                ...e2
            ] : o;
        }
        const a = za(t);
        if (null !== a && Number.isInteger(a)) {
            const e3 = _a(r);
            if ("Divide" === e3 || "Rational" === e3) {
                const [e4, i1] = [
                    za(Ma(r, 1)),
                    za(Ma(r, 2))
                ];
                if (null !== e4 && null !== i1 && e4 > 0 && e4 <= 1e3 && i1 > 1 && i1 <= 1e3 && Number.isInteger(e4) && Number.isInteger(i1)) return [
                    "Add",
                    t,
                    r
                ];
            }
        }
        if ("Delimiter" === _a(r)) {
            if ("Sequence" === _a(Ma(r, 1))) return [
                null != o ? o : t,
                ...null !== (i = Sa(Ma(r, 1))) && void 0 !== i ? i : []
            ];
            if (!Ma(r, 1) || "Nothing" === Ca(Ma(r, 1))) return Fa("Sequence", t, this.error("expected-expression", n));
        }
        return "Sequence" === _a(r) || "Sequence" === _a(t) || null !== xa(t) || null !== xa(r) || null !== Ta(t) || null !== Ta(r) ? Fa("Sequence", t, r) : Fa("Multiply", t, r);
    }
    matchUnexpectedLatexCommand() {
        var e1, t;
        const i = this.index;
        let n = this.peekDefinitions("operator");
        if (n) {
            if (n = this.peekDefinitions("postfix"), n) {
                const [e2, t1] = n[0];
                if (this.index += t1, "function" == typeof e2.parse) {
                    const t2 = e2.parse(this, this.error("missing", i));
                    if (t2) return t2;
                }
                return e2.name ? [
                    e2.name,
                    this.error("missing", i)
                ] : this.error("unexpected-operator", i);
            }
            if (n = this.peekDefinitions("prefix"), n) {
                const [t3, r] = n[0];
                if (this.index += r, "function" == typeof t3.parse) {
                    const e3 = t3.parse(this, {
                        minPrec: 0
                    });
                    if (e3) return e3;
                }
                return t3.name ? [
                    t3.name,
                    null !== (e1 = this.matchExpression()) && void 0 !== e1 ? e1 : this.error("missing", i)
                ] : this.error("unexpected-operator", i);
            }
            if (n = this.peekDefinitions("infix"), n) {
                const [e4, r1] = n[0];
                if (this.index += r1, "function" == typeof e4.parse) {
                    const t4 = e4.parse(this, {
                        minPrec: 0
                    }, this.error("missing", i));
                    if (t4) return t4;
                }
                return e4.name ? [
                    e4.name,
                    this.error("missing", i),
                    null !== (t = this.matchExpression()) && void 0 !== t ? t : this.error("missing", i)
                ] : this.error("unexpected-operator", i);
            }
        }
        const r2 = this.peek;
        if (!r2 || "\\" !== r2[0]) return null;
        if (this.next(), this.skipSpaceTokens(), "\\end" === r2) {
            const e5 = this.matchStringArgument();
            return null === e5 ? this.error("expected-environment-name", i) : this.error([
                "unbalanced-environment",
                {
                    str: e5
                }
            ], i);
        }
        for(; this.match("[");){
            let e6 = 0;
            for(; !this.atEnd && 0 === e6 && "]" !== this.peek;)"[" === this.peek && (e6 += 1), "]" === this.peek && (e6 -= 1), this.next();
            this.match("]");
        }
        const o = this.index;
        this.index = i;
        const a = this.matchEnclosureOpen();
        if (a) return this.error([
            "expected-close-delimiter",
            a
        ], o);
        const s = this.matchEnclosureClose();
        if (s) return this.error([
            "expected-open-delimiter",
            s
        ], i);
        for(this.index = o; this.match("<{>");){
            let e7 = 0;
            for(; !this.atEnd && 0 === e7 && "<}>" !== this.peek;)"<{>" === this.peek && (e7 += 1), "<}>" === this.peek && (e7 -= 1), this.next();
            this.match("<}>");
        }
        return this.error([
            "unexpected-command",
            {
                str: r2
            }
        ], i);
    }
    matchPrimary() {
        var e1;
        if (this.atBoundary) return null;
        let t = null;
        const i = this.index;
        if (this.match("<}>")) return this.error("unexpected-closing-delimiter", i);
        if (this.match("<{>")) {
            if (this.addBoundary([
                "<}>"
            ]), t = this.matchExpression(), null === t) return this.boundaryError("expected-expression");
            if (!this.matchBoundary()) return this.decorate([
                "Sequence",
                t,
                this.boundaryError("expected-closing-delimiter")
            ], i);
        }
        if (null === t) {
            const e2 = this.matchNumber();
            e2 && (t = {
                num: e2
            });
        }
        if (null === t && (t = this.matchEnclosure()), null === t && (t = this.matchEnvironment()), null === t && this.matchAll(this._positiveInfinityTokens) && (t = {
            num: "+Infinity"
        }), null === t && this.matchAll(this._negativeInfinityTokens) && (t = {
            num: "-Infinity"
        }), null === t && this.matchAll(this._notANumberTokens) && (t = {
            num: "NaN"
        }), null === t && (t = null !== (e1 = this.matchFunction()) && void 0 !== e1 ? e1 : this.matchSymbol()), null !== t) {
            t = this.decorate(t, i);
            let e3 = null, n = this.index;
            do {
                if (e3 = this.matchPostfix(t), t = null != e3 ? e3 : t, this.index === n && null !== e3) break;
                n = this.index;
            }while (null !== e3);
        }
        return null === t && (t = this.matchUnexpectedLatexCommand()), null !== t && (t = this.matchSupsub(t)), this.decorate(t, i);
    }
    matchExpression(e1) {
        const t = this.index;
        if (this.skipSpace(), this.atBoundary) return this.index = t, null;
        e1 || (e1 = {
            minPrec: 0
        }), void 0 === e1.minPrec && (e1.minPrec = 0);
        let i = this.matchPrefixOperator({
            ...e1,
            minPrec: 0
        });
        if (null === i && (i = this.matchPrimary(), "Sequence" === _a(i) && 0 === Aa(i) && (i = null)), i) {
            let t1 = !1;
            for(; !t1 && !this.atTerminator(e1);){
                this.skipSpace();
                let n = this.matchInfixOperator(i, e1);
                null === n && (n = this.applyInvisibleOperator(e1, i)), null !== n ? i = n : t1 = !0;
            }
        }
        return this.decorate(i, t);
    }
    decorate(e1, t) {
        if (null === e1) return null;
        if (!this.options.preserveLatex) return e1;
        const i = this.latex(t, this.index);
        return Array.isArray(e1) ? e1 = {
            latex: i,
            fn: e1
        } : "number" == typeof e1 ? e1 = {
            latex: i,
            num: Number(e1).toString()
        } : "string" == typeof e1 ? e1 = {
            latex: i,
            sym: e1
        } : "object" == typeof e1 && null !== e1 && (e1.latex = i), e1;
    }
    error(e1, t) {
        return "string" == typeof e1 ? [
            "Error",
            {
                str: e1
            },
            [
                "Latex",
                {
                    str: this.latex(t, this.index)
                }
            ]
        ] : [
            "Error",
            [
                "ErrorCode",
                {
                    str: e1[0]
                },
                ...e1.slice(1)
            ],
            [
                "Latex",
                {
                    str: this.latex(t, this.index)
                }
            ]
        ];
    }
    constructor(e1, t, i, n){
        this.index = 0, this._boundaries = [], this._lastPeek = "", this._peekCounter = 0, this._tokens = e1, this.options = {
            ...Ms,
            ...Ns,
            ...t
        }, this._dictionary = i, this.computeEngine = n, this._positiveInfinityTokens = ma(this.options.positiveInfinity, []), this._negativeInfinityTokens = ma(this.options.negativeInfinity, []), this._notANumberTokens = ma(this.options.notANumber, []), this._decimalMarkerTokens = ma(this.options.decimalMarker, []), this._groupSeparatorTokens = ma(this.options.groupSeparator, []), this._exponentProductTokens = ma(this.options.exponentProduct, []), this._beginExponentMarkerTokens = ma(this.options.beginExponentMarker, []), this._endExponentMarkerTokens = ma(this.options.endExponentMarker, []), this._truncationMarkerTokens = ma(this.options.truncationMarker, []), this._beginRepeatingDigitsTokens = ma(this.options.beginRepeatingDigits, []), this._endRepeatingDigitsTokens = ma(this.options.endRepeatingDigits, []), this._imaginaryNumberTokens = ma(this.options.imaginaryUnit, []);
    }
}
function As(e1, t) {
    const i = e1.length, n = e1;
    e1 = e1.slice(0, -1);
    for(let i1 = 0; i1 < e1.length - 16; i1++){
        const n1 = e1.substring(0, i1);
        for(let r = 0; r < 17; r++){
            const o = e1.substring(i1, i1 + r + 1), a = Math.floor((e1.length - n1.length) / o.length);
            if (a > 1 && (n1 + o.repeat(a + 1)).startsWith(e1)) return "0" === o ? n1.replace(/(\d{3})/g, "$1" + t.groupSeparator) : n1.replace(/(\d{3})/g, "$1" + t.groupSeparator) + t.beginRepeatingDigits + o + t.endRepeatingDigits;
        }
    }
    const r1 = i > t.precision - 1;
    return e1 = n, r1 && (e1 = e1.substring(0, t.precision - 1)), t.groupSeparator && (e1 = e1.replace(/(\d{3})/g, "$1" + t.groupSeparator)).endsWith(t.groupSeparator) && (e1 = e1.slice(0, -t.groupSeparator.length)), r1 ? e1 + t.truncationMarker : e1;
}
function Cs(e1, t) {
    var i;
    return e1 ? t.beginExponentMarker ? t.beginExponentMarker + e1 + (null !== (i = t.endExponentMarker) && void 0 !== i ? i : "") : "10^{" + e1 + "}" : "";
}
class Es {
    updateOptions(e1) {
        for (const t of Object.keys(this.options))t in e1 && (this.options[t] = e1[t]);
    }
    wrap(e1, t) {
        if (null === e1) return "";
        if (void 0 === t) return this.wrapString(this.serialize(e1), this.options.groupStyle(e1, this.level + 1));
        if ("number" == typeof e1 || ga(e1) || "string" == typeof e1 || ya(e1)) return this.serialize(e1);
        const i = _a(e1);
        if ("string" == typeof i && "Delimiter" !== i && "Subscript" !== i) {
            const n = this.dictionary.name.get(i);
            if (n && ("symbol" === n.kind || "prefix" === n.kind || "infix" === n.kind || "postfix" === n.kind) && n.precedence < t) return this.wrapString(this.serialize(e1), this.options.applyFunctionStyle(e1, this.level));
        }
        return this.serialize(e1);
    }
    wrapShort(e1) {
        if (null === e1) return "";
        const t = this.serialize(e1);
        return "Delimiter" === _a(e1) && 1 === Aa(e1) || "number" == typeof e1 || ga(e1) || /(^(.|\\[a-zA-Z*]+))$/.test(t) ? t : this.wrapString(t, this.options.groupStyle(e1, this.level + 1));
    }
    wrapString(e1, t, i) {
        var n, r;
        if ("none" === t) return e1;
        const o = null !== (n = null == i ? void 0 : i[0]) && void 0 !== n ? n : "(", a = null !== (r = null == i ? void 0 : i[1]) && void 0 !== r ? r : ")";
        return "." !== o && "." !== a || "paren" !== t || (t = "leftright"), "leftright" === t ? `${"." === o ? "" : "\\left(" + o}${e1}${"." === a ? "" : "\\right(" + a})` : "big" === t ? `${"." === o ? "" : "\\Bigl(" + o}${e1}${"." === a ? "" : "\\Bigr(" + a})` : o + e1 + a;
    }
    wrapArguments(e1) {
        var t;
        return this.wrapString((null !== (t = Sa(e1)) && void 0 !== t ? t : []).map((e1)=>this.serialize(e1)).join(", "), this.options.applyFunctionStyle(e1, this.level));
    }
    serializeSymbol(e1, t) {
        var i;
        return _a(e1) ? this.serializeFunction(e1, t) : "string" == typeof (null == t ? void 0 : t.serialize) ? t.serialize : "function" == typeof (null == t ? void 0 : t.serialize) ? t.serialize(this, e1) : null !== (i = zs(Ca(e1), "upright.")) && void 0 !== i ? i : "";
    }
    serializeFunction(e1, t) {
        var i, n;
        const r = _a(e1);
        if (!r) return this.serializeSymbol(e1, t);
        const o = null !== (i = Sa(e1)) && void 0 !== i ? i : [];
        if (t) return "function" == typeof t.serialize ? t.serialize(this, e1) : pa([
            null !== (n = t.serialize) && void 0 !== n ? n : r,
            this.wrapArguments(e1)
        ]);
        if ("string" == typeof r && r.length > 0 && "\\" === r[0]) return pa([
            r,
            ...o.map((e1)=>`{${this.serialize(e1)}}`)
        ]);
        if ("string" == typeof r) return zs(r, "upright.") + this.wrapArguments(e1);
        const a = this.options.applyFunctionStyle(e1, this.level);
        return "\\mathrm{Apply}" + this.wrapString(this.serialize(r) + ", " + this.serialize([
            "List",
            ...o
        ]), a);
    }
    serializeDictionary(e1) {
        return `\\left\\lbrack\\begin{array}{lll}${Object.keys(e1).map((t)=>`\\textbf{${t}} & \\rightarrow & ${this.serialize(e1[t])}`).join("\\\\")}\\end{array}\\right\\rbrack`;
    }
    serialize(e1) {
        if (null == e1) return "";
        this.level += 1;
        try {
            const t = (()=>{
                var t;
                const i = function(e1, t) {
                    var i, n, r;
                    if (null === e1) return "";
                    let o;
                    if ("number" == typeof e1 || "string" == typeof e1) o = e1;
                    else {
                        if ("object" != typeof e1 || !("num" in e1)) return "";
                        o = e1.num;
                    }
                    if ("number" == typeof o) return o === 1 / 0 ? t.positiveInfinity : o === -1 / 0 ? t.negativeInfinity : Number.isNaN(o) ? t.notANumber : "engineering" === t.notation ? function(e1, t) {
                        if (0 === e1) return "0";
                        const i = Math.abs(e1);
                        let n = Math.round(Math.log10(i));
                        n -= n % 3, i > Math.pow(10, t.avoidExponentsInRange[0]) && i < Math.pow(10, t.avoidExponentsInRange[1]) && (n = 0);
                        const r = i / Math.pow(10, n);
                        let o = "";
                        const a = r.toString().match(/^(.*)\.(.*)$/);
                        (null == a ? void 0 : a[1]) && a[2] && (o = a[1] + t.decimalMarker + a[2]), t.groupSeparator && (o = As(r.toExponential(), t));
                        let s = "";
                        return 0 !== n && (s = Cs(n.toString(), t)), (e1 < 0 ? "-" : "") + o + s;
                    }(o, t) : function(e1, t) {
                        var i;
                        let n, r = e1.match(/^(.*)[e|E]([-+]?[0-9]+)$/i);
                        (null == r ? void 0 : r[1]) && r[2] && (n = Cs(r[2], t));
                        let o = null !== (i = null == r ? void 0 : r[1]) && void 0 !== i ? i : e1, a = "";
                        return r = (n ? r[1] : e1).match(/^(.*)\.(.*)$/), (null == r ? void 0 : r[1]) && r[2] && (o = r[1], a = r[2]), t.groupSeparator && (o = o.replace(/\B(?=(\d{3})+(?!\d))/g, t.groupSeparator), a = As(a, t)), a && (a = t.decimalMarker + a), n ? "1" !== o || a ? o + a + t.exponentProduct + n : n : o + a;
                    }(o.toString(), t);
                    if (o = o.toLowerCase().replace(/[\u0009-\u000d\u0020\u00a0]/g, ""), "infinity" === o || "+infinity" === o) return t.positiveInfinity;
                    if ("-infinity" === o) return t.negativeInfinity;
                    if ("nan" === o) return t.notANumber;
                    if (!/^[-+\.]?[0-9]/.test(o)) return "";
                    if (o = o.replace(/[nd]$/, ""), /\([0-9]+\)/.test(o)) {
                        const [e2, n1, r1, a] = null !== (i = o.match(/(.+)\(([0-9]+)\)(.*)$/)) && void 0 !== i ? i : [];
                        o = n1 + r1.repeat(Math.ceil(t.precision / r1.length)) + a;
                    }
                    let a1 = "";
                    for("-" === o[0] ? (a1 = "-", o = o.substring(1)) : "+" === o[0] && (o = o.substring(1)); "0" === o[0];)o = o.substring(1);
                    if (0 === o.length) return a1 + "0";
                    "." === o[0] && (o = "0" + o);
                    let s = "";
                    if (o.indexOf(".") >= 0) {
                        const e3 = o.match(/(\d*)\.(\d*)([e|E]([-+]?[0-9]*))?/);
                        if (!e3) return "";
                        const i1 = e3[1], r2 = e3[2];
                        if (s = null !== (n = e3[4]) && void 0 !== n ? n : "", "0" === i1) {
                            let e4 = 0;
                            for(; "0" === r2[e4] && e4 < r2.length;)e4 += 1;
                            let i2 = "";
                            if (e4 <= 4) i2 = "0" + t.decimalMarker, i2 += r2.substring(0, e4), i2 += As(o.substring(i2.length), t);
                            else if (e4 + 1 >= t.precision) i2 = "0", a1 = "";
                            else {
                                i2 = o[e4];
                                const n2 = As(o.substring(e4 + 1), t);
                                n2 && (i2 += t.decimalMarker + n2);
                            }
                            "0" !== i2 && (!(o.length - 1 > t.precision) || t.endRepeatingDigits && i2.endsWith(t.endRepeatingDigits) || !t.truncationMarker || i2.endsWith(t.truncationMarker) || (i2 += t.truncationMarker), e4 > 4 && (i2 += t.exponentProduct + Cs("" + (1 - e4), t))), o = i2;
                        } else {
                            o = i1.replace(/\B(?=(\d{3})+(?!\d))/g, t.groupSeparator);
                            const e5 = As(r2, t);
                            e5 && (o += t.decimalMarker + e5);
                        }
                    } else if (o.length > t.precision) {
                        const e6 = o.length;
                        if (e6 > t.avoidExponentsInRange[1]) {
                            let i3 = o[0];
                            const n3 = As(o.substring(1), t);
                            n3 && (i3 += t.decimalMarker + n3, t.truncationMarker && !i3.endsWith(t.truncationMarker) && t.endRepeatingDigits && !i3.endsWith(t.endRepeatingDigits) && (i3 += t.truncationMarker)), "1" !== i3 ? i3 += t.exponentProduct : i3 = "", o = i3 + Cs("" + (e6 - 1), t);
                        }
                    } else {
                        const e7 = o.match(/([0-9]*)\.?([0-9]*)([e|E]([-+]?[0-9]+))?/);
                        e7 && (o = e7[1], e7[2] && (o += t.decimalMarker + e7[2]), s = null !== (r = e7[4]) && void 0 !== r ? r : ""), o = o.replace(/\B(?=(\d{3})+(?!\d))/g, t.groupSeparator);
                    }
                    const l = Cs(s, t);
                    return "1" === o && l ? a1 + l : (l && (o = o + t.exponentProduct + l), a1 + o);
                }(e1, this.options);
                if (i) return i;
                const n = xa(e1);
                if (null !== n) return `\\text{${n}}`;
                const r = Ca(e1);
                if (null !== r) {
                    const t1 = this.dictionary.name.get(r);
                    if ("symbol" === (null == t1 ? void 0 : t1.kind)) return this.serializeSymbol(e1, t1);
                    if ("function" === (null == t1 ? void 0 : t1.kind)) return this.serializeFunction(e1, t1);
                }
                const o = Ta(e1);
                if (null !== o) return this.serializeDictionary(o);
                const a = wa(e1);
                if (a) {
                    if ("\\" === a[0]) {
                        const i1 = null !== (t = Sa(e1)) && void 0 !== t ? t : [];
                        return 0 === i1.length ? a : a + "{" + i1.map((e1)=>this.serialize(e1)).filter((e1)=>!!e1).join("}{") + "}";
                    }
                    const i2 = this.dictionary.name.get(a);
                    if (i2) return "function" == typeof i2.serialize ? i2.serialize(this, e1) : "infix" === i2.kind || "postfix" === i2.kind || "prefix" === i2.kind ? function(e1, t, i) {
                        let n = "";
                        const r = Aa(t), o = wa(t);
                        if ("postfix" === i.kind) return 1 !== r && e1.onError([
                            {
                                severity: "warning",
                                message: [
                                    "postfix-operator-requires-one-operand",
                                    e1.serializeSymbol(o)
                                ]
                            }
                        ]), Ts(i.serialize, [
                            e1.wrap(Ma(t, 1), i.precedence)
                        ]);
                        if ("prefix" === i.kind) return 1 !== r && e1.onError([
                            {
                                severity: "warning",
                                message: [
                                    "prefix-operator-requires-one-operand",
                                    e1.serializeSymbol(o)
                                ]
                            }
                        ]), Ts(i.serialize, [
                            e1.wrap(Ma(t, 1), i.precedence + 1)
                        ]);
                        if ("infix" === i.kind) {
                            n = e1.wrap(Ma(t, 1), i.precedence);
                            for(let o1 = 2; o1 < r + 1; o1++){
                                const r1 = Ma(t, o1);
                                null !== r1 && (n = Ts(i.serialize, [
                                    n,
                                    e1.wrap(r1, i.precedence)
                                ]));
                            }
                        }
                        return n;
                    }(this, e1, i2) : "symbol" === i2.kind ? this.serializeSymbol(e1, i2) : "function" === i2.kind ? this.serializeFunction(e1, i2) : "";
                }
                if (Array.isArray(e1) || ba(e1) || null !== Ca(e1)) return this.serializeSymbol(e1);
                this.onError([
                    {
                        severity: "warning",
                        message: [
                            "syntax-error",
                            e1 ? JSON.stringify(e1) : "undefined"
                        ]
                    }
                ]);
            })();
            return this.level -= 1, null != t ? t : "";
        } catch (e2) {}
        return this.level -= 1, "";
    }
    applyFunctionStyle(e1, t) {
        return this.options.applyFunctionStyle(e1, t);
    }
    groupStyle(e1, t) {
        return this.options.groupStyle(e1, t);
    }
    rootStyle(e1, t) {
        return this.options.rootStyle(e1, t);
    }
    fractionStyle(e1, t) {
        return this.options.fractionStyle(e1, t);
    }
    logicStyle(e1, t) {
        return this.options.logicStyle(e1, t);
    }
    powerStyle(e1, t) {
        return this.options.powerStyle(e1, t);
    }
    numericSetStyle(e1, t) {
        return this.options.numericSetStyle(e1, t);
    }
    constructor(e1, t, i){
        this.level = -1, this.options = e1, e1.invisibleMultiply && (/#1/.test(e1.invisibleMultiply) && /#2/.test(e1.invisibleMultiply) || i([
            {
                severity: "warning",
                message: [
                    "expected-argument",
                    "invisibleMultiply"
                ]
            }
        ])), this.onError = i, this.dictionary = t;
    }
}
function Ts(e1, t) {
    var i;
    let n = e1;
    for(let e2 = 0; e2 < t.length; e2++){
        let r = null !== (i = t[e2]) && void 0 !== i ? i : "";
        if (/[a-zA-Z*]/.test(r[0])) {
            const t1 = n.match(RegExp("(.*)#" + Number(e2 + 1).toString()));
            t1 && /\\[a-zA-Z*]+/.test(t1[1]) && (r = " " + r);
        }
        n = n.replace("#" + Number(e2 + 1).toString(), r);
    }
    return n;
}
const Ds = [
    "alpha",
    "beta",
    "gamma",
    "Gamma",
    "delta",
    "Delta",
    "epsilon",
    "zeta",
    "eta",
    "theta",
    "Theta",
    "iota",
    "kappa",
    "lambda",
    "Lambda",
    "mu",
    "nu",
    "xi",
    "Xi",
    "pi",
    "Pi",
    "rho",
    "sigma",
    "Sigma",
    "tau",
    "upsilon",
    "phi",
    "Phi",
    "varphi",
    "chi",
    "psi",
    "Psi",
    "omega",
    "Omega",
    "aleph",
    "ast",
    "blacksquare",
    "bot",
    "bullet",
    "circ",
    "diamond",
    "times",
    "top",
    "square",
    "star"
];
function zs(e1, t = "italic.") {
    var i;
    if (null === e1) return null;
    const n = e1.match(/^(_+)(.*)/);
    if (n) return `\\text{${"\\_".repeat(n[1].length) + qs(n[2])}}`;
    let r;
    [r, e1] = function(e1) {
        const t = e1.match(/^([a-zA-Z-]+\.)(.*)/);
        return t ? [
            t[1],
            t[2]
        ] : [
            "",
            e1
        ];
    }(e1);
    const o = qs(e1);
    return 1 !== o.length || r ? (r || (r = t), (null !== (i = ({
        "upright.": "\\mathrm{_}",
        "italic.": "\\mathit{_}",
        "bold-italic.": "\\mathbf{\\mathit{_}}",
        "script.": "\\mathscr{_}",
        "calligraphic.": "\\mathcal{_}",
        "bold-script.": "\\mathbf{\\mathscr{_}}",
        "bold-calligraphic.": "\\mathbf{\\mathcal{_}}",
        "fraktur.": "\\mathfrak{_}",
        "gothic.": "\\mathfrak{_}",
        "bold-gothic.": "\\mathbf{\\mathfrak{_}}",
        "bold-fraktur.": "\\mathbf{\\mathfrak{_}}",
        "sans-serif.": "\\mathsf{_}",
        "bold-sans-serif.": "\\mathbf{\\mathsf{_}}",
        "italic-sans-serif.": "\\mathit{\\mathsf{_}}",
        "monospace.": "\\mathtt{_}",
        "blackboard.": "\\mathbb{_}",
        "double-struck.": "\\mathbb{_}"
    })[r]) && void 0 !== i ? i : "\\mathit{_}").replace("_", o)) : o;
}
function qs(e1) {
    const t = e1.indexOf("_");
    if (t > 0) {
        const i = e1.substring(0, t), n = e1.substring(t + 1);
        return n ? n.startsWith('"') && n.endsWith('"') ? `${qs(i)}_\\mathrm{${qs(n.substring(1, -1))}}` : `${qs(i)}_{${qs(n)}}` : zs(i) + "\\_";
    }
    const i1 = e1.match(/(.*?)(-?[0-9]+)$/);
    return i1 ? 0 === i1[1].length ? e1 : `${qs(i1[1])}_{${i1[2]}}` : Ds.includes(e1) ? "\\" + e1 : e1 = e1.replace(/[{}\[\]\\:\-\$%]/g, (e1)=>{
        var t;
        return null !== (t = ({
            "{": "\\lbrace ",
            "}": "\\rbrace ",
            "[": "\\lbrack ",
            "]": "\\rbrack ",
            ":": "\\colon ",
            "\\": "\\backslash ",
            "-": '\\unicode{"2013}'
        })[e1]) && void 0 !== t ? t : "\\" + e1;
    });
}
const Is = {
    invisibleMultiply: "",
    invisiblePlus: "",
    multiply: "\\times",
    missingSymbol: "\\blacksquare",
    applyFunctionStyle: function(e1, t) {
        return "paren";
    },
    groupStyle: function(e1, t) {
        return "paren";
    },
    rootStyle: Va,
    fractionStyle: ja,
    logicStyle: function(e1, t) {
        return "boolean";
    },
    powerStyle: function(e1, t) {
        return "solidus";
    },
    numericSetStyle: function(e1, t) {
        return "compact";
    }
};
class Os {
    updateOptions(e1) {
        for (const t of Object.keys(this.options))t in e1 && (this.options[t] = e1[t]);
        this.serializer.updateOptions(e1);
    }
    static getDictionary(e1 = "all") {
        if ("all" === e1) {
            const e2 = [];
            for (const t of Object.keys(vs))vs[t] && e2.push(...vs[t]);
            return e2;
        }
        return vs[e1] ? [
            ...vs[e1]
        ] : [];
    }
    parse(e1) {
        const t = new Ls(ma(e1, []), this.options, this.dictionary, this.computeEngine);
        let i = t.matchExpression();
        if (!t.atEnd) {
            const e2 = t.peekDefinitions("infix");
            if (e2) {
                const n = t.index, [r, o] = e2[0];
                t.index += o;
                const a = r.parse(t, {
                    minPrec: 0
                }, null != i ? i : t.error("missing", n));
                if (a) return a;
                if (r.name) return [
                    r.name,
                    null != i ? i : t.error("missing", n),
                    t.error("missing", n)
                ];
                t.index = n;
            }
            const n1 = t.index, r1 = t.matchEnclosureOpen();
            if (r1) {
                const e3 = t.error([
                    "expected-close-delimiter",
                    r1
                ], n1);
                return i ? [
                    "Sequence",
                    i,
                    e3
                ] : e3;
            }
            const o1 = t.matchEnclosureClose();
            if (o1) {
                const e4 = t.error([
                    "expected-open-delimiter",
                    o1
                ], n1);
                return i ? [
                    "Sequence",
                    i,
                    e4
                ] : e4;
            }
            const a1 = t.index, s = t.next();
            for(; !t.atEnd;)t.next();
            const l = t.error([
                s.length > 1 && s.startsWith("\\") ? "unexpected-command" : "unexpected-token",
                {
                    str: fa([
                        s
                    ])
                }
            ], a1);
            i = i ? [
                "Sequence",
                i,
                l
            ] : l;
        }
        return null != i || (i = [
            "Sequence"
        ]), this.options.preserveLatex && (Array.isArray(i) ? i = {
            latex: e1,
            fn: i
        } : "number" == typeof i ? i = {
            latex: e1,
            num: Number(i).toString()
        } : "string" == typeof i ? i = {
            latex: e1,
            sym: i
        } : "object" == typeof i && null !== i && (i.latex = e1)), null != i ? i : [
            "Sequence"
        ];
    }
    serialize(e1) {
        return this.serializer.serialize(e1);
    }
    get serializer() {
        return this._serializer || (this._serializer = new Es(this.options, this.dictionary, this.onError)), this._serializer;
    }
    constructor(e1){
        var t, i;
        this.onError = null !== (t = e1.onError) && void 0 !== t ? t : (e1)=>{
            if ("undefined" != typeof window) for (const t of e1);
        }, this.computeEngine = e1.computeEngine;
        const n = {
            ...e1
        };
        delete n.dictionary, delete n.onError, this.options = {
            ...Ms,
            ...Ns,
            ...Is,
            ...n
        }, this.dictionary = function(e1, t) {
            var i, n;
            const r = {
                lookahead: 1,
                name: new Map,
                function: new Map,
                symbol: [],
                infix: [],
                prefix: [],
                postfix: [],
                environment: new Map,
                matchfix: []
            };
            for (const o of e1){
                const [e2, a] = bs(o, t);
                if (null !== a) {
                    if (void 0 !== a.name && (r.name.has(a.name) && t({
                        severity: "warning",
                        message: [
                            "invalid-dictionary-entry",
                            a.name,
                            "Duplicate definition"
                        ]
                    }), r.name.set(a.name, a)), "matchfix" === a.kind) r.matchfix.push(a);
                    else if ("environment" === a.kind) {
                        const e3 = fa(null !== (i = o.trigger) && void 0 !== i ? i : "");
                        r.environment.has(e3) && t({
                            severity: "warning",
                            message: [
                                "invalid-dictionary-entry",
                                e3,
                                "Duplicate environment definition"
                            ]
                        }), r.environment.set(e3, a);
                    } else if (e2) {
                        const t1 = fa(null !== (n = o.trigger) && void 0 !== n ? n : ""), i1 = ys(e2);
                        if (r.lookahead = Math.max(r.lookahead, i1), "function" === a.kind) r.function.has(t1) ? r.function.set(t1, [
                            ...r.function.get(t1),
                            a
                        ]) : r.function.set(t1, [
                            a
                        ]);
                        else if ("symbol" === a.kind) {
                            void 0 === r.symbol[i1] && (r.symbol[i1] = new Map);
                            const e4 = r.symbol[i1];
                            e4.has(t1) ? e4.get(t1).push(a) : e4.set(t1, [
                                a
                            ]);
                        } else if ("prefix" === a.kind) {
                            void 0 === r.prefix[i1] && (r.prefix[i1] = new Map);
                            const e5 = r.prefix[i1];
                            e5.has(t1) ? e5.get(t1).push(a) : e5.set(t1, [
                                a
                            ]);
                        } else if ("infix" === a.kind) {
                            void 0 === r.infix[i1] && (r.infix[i1] = new Map);
                            const e6 = r.infix[i1];
                            e6.has(t1) ? e6.get(t1).push(a) : e6.set(t1, [
                                a
                            ]);
                        } else if ("postfix" === a.kind) {
                            void 0 === r.postfix[i1] && (r.postfix[i1] = new Map);
                            const e7 = r.postfix[i1];
                            e7.has(t1) ? e7.get(t1).push(a) : e7.set(t1, [
                                a
                            ]);
                        }
                    }
                }
            }
            return r;
        }(null !== (i = e1.dictionary) && void 0 !== i ? i : Os.getDictionary(), (e1)=>this.onError([
                e1
            ]));
    }
}
const Fs = Math.log10(Math.pow(2, 53)), Bs = new Set([
    2,
    3,
    5,
    7,
    11,
    13,
    17,
    19,
    23,
    29,
    31,
    37,
    41,
    43,
    47,
    53,
    59,
    61,
    67,
    71,
    73,
    79,
    83,
    89,
    97,
    101,
    103,
    107,
    109,
    113,
    127,
    131,
    137,
    139,
    149,
    151,
    157,
    163,
    167,
    173,
    179,
    181,
    191,
    193,
    197,
    199,
    211,
    223,
    227,
    229,
    233,
    239,
    241,
    251,
    257,
    263,
    269,
    271,
    277,
    281,
    283,
    293,
    307,
    311,
    313,
    317,
    331,
    337,
    347,
    349,
    353,
    359,
    367,
    373,
    379,
    383,
    389,
    397,
    401,
    409,
    419,
    421,
    431,
    433,
    439,
    443,
    449,
    457,
    461,
    463,
    467,
    479,
    487,
    491,
    499,
    503,
    509,
    521,
    523,
    541,
    547,
    557,
    563,
    569,
    571,
    577,
    587,
    593,
    599,
    601,
    607,
    613,
    617,
    619,
    631,
    641,
    643,
    647,
    653,
    659,
    661,
    673,
    677,
    683,
    691,
    701,
    709,
    719,
    727,
    733,
    739,
    743,
    751,
    757,
    761,
    769,
    773,
    787,
    797,
    809,
    811,
    821,
    823,
    827,
    829,
    839,
    853,
    857,
    859,
    863,
    877,
    881,
    883,
    887,
    907,
    911,
    919,
    929,
    937,
    941,
    947,
    953,
    967,
    971,
    977,
    983,
    991,
    997,
    1009,
    1013,
    1019,
    1021,
    1031,
    1033,
    1039,
    1049,
    1051,
    1061,
    1063,
    1069,
    1087,
    1091,
    1093,
    1097,
    1103,
    1109,
    1117,
    1123,
    1129,
    1151,
    1153,
    1163,
    1171,
    1181,
    1187,
    1193,
    1201,
    1213,
    1217,
    1223,
    1229,
    1231,
    1237,
    1249,
    1259,
    1277,
    1279,
    1283,
    1289,
    1291,
    1297,
    1301,
    1303,
    1307,
    1319,
    1321,
    1327,
    1361,
    1367,
    1373,
    1381,
    1399,
    1409,
    1423,
    1427,
    1429,
    1433,
    1439,
    1447,
    1451,
    1453,
    1459,
    1471,
    1481,
    1483,
    1487,
    1489,
    1493,
    1499,
    1511,
    1523,
    1531,
    1543,
    1549,
    1553,
    1559,
    1567,
    1571,
    1579,
    1583,
    1597,
    1601,
    1607,
    1609,
    1613,
    1619,
    1621,
    1627,
    1637,
    1657,
    1663,
    1667,
    1669,
    1693,
    1697,
    1699,
    1709,
    1721,
    1723,
    1733,
    1741,
    1747,
    1753,
    1759,
    1777,
    1783,
    1787,
    1789,
    1801,
    1811,
    1823,
    1831,
    1847,
    1861,
    1867,
    1871,
    1873,
    1877,
    1879,
    1889,
    1901,
    1907,
    1913,
    1931,
    1933,
    1949,
    1951,
    1973,
    1979,
    1987,
    1993,
    1997,
    1999,
    2003,
    2011,
    2017,
    2027,
    2029,
    2039,
    2053,
    2063,
    2069,
    2081,
    2083,
    2087,
    2089,
    2099,
    2111,
    2113,
    2129,
    2131,
    2137,
    2141,
    2143,
    2153,
    2161,
    2179,
    2203,
    2207,
    2213,
    2221,
    2237,
    2239,
    2243,
    2251,
    2267,
    2269,
    2273,
    2281,
    2287,
    2293,
    2297,
    2309,
    2311,
    2333,
    2339,
    2341,
    2347,
    2351,
    2357,
    2371,
    2377,
    2381,
    2383,
    2389,
    2393,
    2399,
    2411,
    2417,
    2423,
    2437,
    2441,
    2447,
    2459,
    2467,
    2473,
    2477,
    2503,
    2521,
    2531,
    2539,
    2543,
    2549,
    2551,
    2557,
    2579,
    2591,
    2593,
    2609,
    2617,
    2621,
    2633,
    2647,
    2657,
    2659,
    2663,
    2671,
    2677,
    2683,
    2687,
    2689,
    2693,
    2699,
    2707,
    2711,
    2713,
    2719,
    2729,
    2731,
    2741,
    2749,
    2753,
    2767,
    2777,
    2789,
    2791,
    2797,
    2801,
    2803,
    2819,
    2833,
    2837,
    2843,
    2851,
    2857,
    2861,
    2879,
    2887,
    2897,
    2903,
    2909,
    2917,
    2927,
    2939,
    2953,
    2957,
    2963,
    2969,
    2971,
    2999,
    3001,
    3011,
    3019,
    3023,
    3037,
    3041,
    3049,
    3061,
    3067,
    3079,
    3083,
    3089,
    3109,
    3119,
    3121,
    3137,
    3163,
    3167,
    3169,
    3181,
    3187,
    3191,
    3203,
    3209,
    3217,
    3221,
    3229,
    3251,
    3253,
    3257,
    3259,
    3271,
    3299,
    3301,
    3307,
    3313,
    3319,
    3323,
    3329,
    3331,
    3343,
    3347,
    3359,
    3361,
    3371,
    3373,
    3389,
    3391,
    3407,
    3413,
    3433,
    3449,
    3457,
    3461,
    3463,
    3467,
    3469,
    3491,
    3499,
    3511,
    3517,
    3527,
    3529,
    3533,
    3539,
    3541,
    3547,
    3557,
    3559,
    3571,
    3581,
    3583,
    3593,
    3607,
    3613,
    3617,
    3623,
    3631,
    3637,
    3643,
    3659,
    3671,
    3673,
    3677,
    3691,
    3697,
    3701,
    3709,
    3719,
    3727,
    3733,
    3739,
    3761,
    3767,
    3769,
    3779,
    3793,
    3797,
    3803,
    3821,
    3823,
    3833,
    3847,
    3851,
    3853,
    3863,
    3877,
    3881,
    3889,
    3907,
    3911,
    3917,
    3919,
    3923,
    3929,
    3931,
    3943,
    3947,
    3967,
    3989,
    4001,
    4003,
    4007,
    4013,
    4019,
    4021,
    4027,
    4049,
    4051,
    4057,
    4073,
    4079,
    4091,
    4093,
    4099,
    4111,
    4127,
    4129,
    4133,
    4139,
    4153,
    4157,
    4159,
    4177,
    4201,
    4211,
    4217,
    4219,
    4229,
    4231,
    4241,
    4243,
    4253,
    4259,
    4261,
    4271,
    4273,
    4283,
    4289,
    4297,
    4327,
    4337,
    4339,
    4349,
    4357,
    4363,
    4373,
    4391,
    4397,
    4409,
    4421,
    4423,
    4441,
    4447,
    4451,
    4457,
    4463,
    4481,
    4483,
    4493,
    4507,
    4513,
    4517,
    4519,
    4523,
    4547,
    4549,
    4561,
    4567,
    4583,
    4591,
    4597,
    4603,
    4621,
    4637,
    4639,
    4643,
    4649,
    4651,
    4657,
    4663,
    4673,
    4679,
    4691,
    4703,
    4721,
    4723,
    4729,
    4733,
    4751,
    4759,
    4783,
    4787,
    4789,
    4793,
    4799,
    4801,
    4813,
    4817,
    4831,
    4861,
    4871,
    4877,
    4889,
    4903,
    4909,
    4919,
    4931,
    4933,
    4937,
    4943,
    4951,
    4957,
    4967,
    4969,
    4973,
    4987,
    4993,
    4999,
    5003,
    5009,
    5011,
    5021,
    5023,
    5039,
    5051,
    5059,
    5077,
    5081,
    5087,
    5099,
    5101,
    5107,
    5113,
    5119,
    5147,
    5153,
    5167,
    5171,
    5179,
    5189,
    5197,
    5209,
    5227,
    5231,
    5233,
    5237,
    5261,
    5273,
    5279,
    5281,
    5297,
    5303,
    5309,
    5323,
    5333,
    5347,
    5351,
    5381,
    5387,
    5393,
    5399,
    5407,
    5413,
    5417,
    5419,
    5431,
    5437,
    5441,
    5443,
    5449,
    5471,
    5477,
    5479,
    5483,
    5501,
    5503,
    5507,
    5519,
    5521,
    5527,
    5531,
    5557,
    5563,
    5569,
    5573,
    5581,
    5591,
    5623,
    5639,
    5641,
    5647,
    5651,
    5653,
    5657,
    5659,
    5669,
    5683,
    5689,
    5693,
    5701,
    5711,
    5717,
    5737,
    5741,
    5743,
    5749,
    5779,
    5783,
    5791,
    5801,
    5807,
    5813,
    5821,
    5827,
    5839,
    5843,
    5849,
    5851,
    5857,
    5861,
    5867,
    5869,
    5879,
    5881,
    5897,
    5903,
    5923,
    5927,
    5939,
    5953,
    5981,
    5987,
    6007,
    6011,
    6029,
    6037,
    6043,
    6047,
    6053,
    6067,
    6073,
    6079,
    6089,
    6091,
    6101,
    6113,
    6121,
    6131,
    6133,
    6143,
    6151,
    6163,
    6173,
    6197,
    6199,
    6203,
    6211,
    6217,
    6221,
    6229,
    6247,
    6257,
    6263,
    6269,
    6271,
    6277,
    6287,
    6299,
    6301,
    6311,
    6317,
    6323,
    6329,
    6337,
    6343,
    6353,
    6359,
    6361,
    6367,
    6373,
    6379,
    6389,
    6397,
    6421,
    6427,
    6449,
    6451,
    6469,
    6473,
    6481,
    6491,
    6521,
    6529,
    6547,
    6551,
    6553,
    6563,
    6569,
    6571,
    6577,
    6581,
    6599,
    6607,
    6619,
    6637,
    6653,
    6659,
    6661,
    6673,
    6679,
    6689,
    6691,
    6701,
    6703,
    6709,
    6719,
    6733,
    6737,
    6761,
    6763,
    6779,
    6781,
    6791,
    6793,
    6803,
    6823,
    6827,
    6829,
    6833,
    6841,
    6857,
    6863,
    6869,
    6871,
    6883,
    6899,
    6907,
    6911,
    6917,
    6947,
    6949,
    6959,
    6961,
    6967,
    6971,
    6977,
    6983,
    6991,
    6997,
    7001,
    7013,
    7019,
    7027,
    7039,
    7043,
    7057,
    7069,
    7079,
    7103,
    7109,
    7121,
    7127,
    7129,
    7151,
    7159,
    7177,
    7187,
    7193,
    7207,
    7211,
    7213,
    7219,
    7229,
    7237,
    7243,
    7247,
    7253,
    7283,
    7297,
    7307,
    7309,
    7321,
    7331,
    7333,
    7349,
    7351,
    7369,
    7393,
    7411,
    7417,
    7433,
    7451,
    7457,
    7459,
    7477,
    7481,
    7487,
    7489,
    7499,
    7507,
    7517,
    7523,
    7529,
    7537,
    7541,
    7547,
    7549,
    7559,
    7561,
    7573,
    7577,
    7583,
    7589,
    7591,
    7603,
    7607,
    7621,
    7639,
    7643,
    7649,
    7669,
    7673,
    7681,
    7687,
    7691,
    7699,
    7703,
    7717,
    7723,
    7727,
    7741,
    7753,
    7757,
    7759,
    7789,
    7793,
    7817,
    7823,
    7829,
    7841,
    7853,
    7867,
    7873,
    7877,
    7879,
    7883,
    7901,
    7907,
    7919
]);
function $s(e1) {
    var t, i;
    if (e1 <= 3) return {
        [e1]: 1
    };
    const n = {};
    let r = 0;
    for(; e1 % 2 == 0;)r += 1, e1 /= 2;
    for(r > 0 && (n[2] = r), r = 0; e1 % 3 == 0;)r += 1, e1 /= 3;
    r > 0 && (n[3] = r);
    let o = !1;
    for(; !o;){
        if (1 === e1) return n;
        const r1 = Math.sqrt(e1);
        o = !0;
        for(let a = 6; a <= r1 + 6; a += 6){
            if (e1 % (a - 1) == 0) {
                n[a - 1] = (null !== (t = n[a - 1]) && void 0 !== t ? t : 0) + 1, e1 /= a - 1, o = !1;
                break;
            }
            if (e1 % (a + 1) == 0) {
                n[a + 1] = (null !== (i = n[a + 1]) && void 0 !== i ? i : 0) + 1, e1 /= a + 1, o = !1;
                break;
            }
        }
    }
    return n[e1] = 1, n;
}
function Ps(e1, t) {
    if (e1 >= Number.MAX_SAFE_INTEGER) return [
        1,
        e1
    ];
    const i = $s(e1);
    let n = 1, r = 1;
    for (const e2 of Object.keys(i)){
        const o = parseInt(e2);
        n *= Math.pow(o, Math.floor(i[e2] / t)), r *= Math.pow(o, i[e2] % t);
    }
    return [
        n,
        r
    ];
}
const Rs = [
    .9999999999998099,
    676.5203681218851,
    -1259.1392167224028,
    771.3234287776531,
    -176.6150291621406,
    12.507343278686905,
    -0.13857109526572012,
    9984369578019572e-21,
    1.5056327351493116e-7
], Ks = [
    .999999999999997,
    57.15623566586292,
    -59.59796035547549,
    14.13609797474174,
    -0.4919138160976202,
    3399464998481188e-20,
    4652362892704857e-20,
    -0.00009837447530487956,
    .0001580887032249125,
    -0.00021026444172410488,
    .0002174396181152126,
    -0.0001643181065367639,
    8441822398385274e-20,
    -0.0000261908384015814,
    3689918265953162e-21
];
function Vs(e1) {
    if (e1 < 0) return NaN;
    let t = Ks[0];
    for(let i = 14; i > 0; --i)t += Ks[i] / (e1 + i);
    const i1 = e1 + 4.7421875 + .5;
    return .9189385332046727 + (e1 + .5) * Math.log(i1) - i1 + Math.log(t) - Math.log(e1);
}
function js(e1) {
    if (e1 < .5) return Math.PI / (Math.sin(Math.PI * e1) * js(1 - e1));
    if (e1 > 100) return Math.exp(Vs(e1));
    e1 -= 1;
    let t = Rs[0];
    for(let i = 1; i < 9; i++)t += Rs[i] / (e1 + i);
    const i1 = e1 + 7 + .5;
    return 2.5066282746310002 * Math.pow(i1, e1 + .5) * Math.exp(-i1) * t;
}
function Hs(e1, t = 10) {
    let i = 0;
    for(let n = 0; n < e1.length; n++){
        const r = {
            " ": -1,
            "\xa0": -1,
            " ": -1,
            " ": -1,
            " ": -1,
            " ": -1,
            " ": -1,
            " ": -1,
            " ": -1,
            " ": -1,
            " ": -1,
            " ": -1,
            " ": -1,
            "​": -1,
            " ": -1,
            " ": -1,
            _: -1,
            ",": -1,
            0: 0,
            1: 1,
            2: 2,
            3: 3,
            4: 4,
            5: 5,
            6: 6,
            7: 7,
            8: 8,
            9: 9,
            a: 10,
            b: 11,
            c: 12,
            d: 13,
            e: 14,
            f: 15,
            g: 16,
            h: 17,
            i: 18,
            j: 19,
            k: 20,
            l: 21,
            m: 22,
            n: 23,
            o: 24,
            p: 25,
            q: 26,
            r: 27,
            s: 28,
            t: 29,
            u: 30,
            v: 31,
            w: 32,
            x: 33,
            y: 34,
            z: 35
        }[e1[n]];
        if (-1 !== r) {
            if (void 0 === r) return [
                i,
                e1.substring(n)
            ];
            if (r >= t) return [
                i,
                e1.substring(n)
            ];
            i = i * t + r;
        }
    }
    return [
        i,
        ""
    ];
}
function Us(e1) {
    const t = e1.numericValue;
    if (null === t) return null;
    if ("number" == typeof t) return t;
    if (t instanceof oa) return t.toNumber();
    if (Array.isArray(t)) {
        const [e2, i] = t;
        return "number" == typeof e2 && "number" == typeof i ? e2 / i : e2.div(i).toNumber();
    }
    return null;
}
function Gs(e1) {
    const t = e1.numericValue;
    if (null === t) return null;
    if (t instanceof oa) return t;
    if ("number" == typeof t) return e1.engine.bignum(t);
    if (Array.isArray(t)) {
        const [i, n] = t;
        return "number" == typeof i && "number" == typeof n ? e1.engine.bignum(i / n) : i.div(n);
    }
    return null;
}
function Zs(e1) {
    const t = e1.numericValue;
    if (null === t) return null;
    if ("number" == typeof t) return Number.isInteger(t) && t >= -1000000 && t <= 1e6 ? t : null;
    if (t instanceof oa) {
        if (t.isInteger()) {
            const e2 = t.toNumber();
            if (e2 >= -1000000 && e2 <= 1e6) return e2;
        }
        return null;
    }
    if (e1.isCanonical) return null;
    const i = t;
    if (Array.isArray(i)) {
        const [e3, t1] = i;
        let n;
        return n = "number" == typeof e3 && "number" == typeof t1 ? e3 / t1 : e3.div(t1).toNumber(), Number.isInteger(n) && n >= -1000000 && n <= 1e6 ? n : null;
    }
    return null;
}
function Ws(e1, t) {
    return "number" == typeof e1 && Math.abs(e1) <= t || e1 instanceof oa && e1.abs().lte(t) || e1 instanceof la && Math.abs(e1.re) <= t && Math.abs(e1.im) <= t ? 0 : e1;
}
function Js(e1) {
    return "string" == typeof e1 && e1.startsWith("$") && e1.endsWith("$");
}
function Xs(e1) {
    return "string" == typeof e1 && e1.startsWith("$") && e1.endsWith("$") ? e1.slice(1, -1) : null;
}
function Ys(e1) {
    if ("ImaginaryUnit" === e1.symbol) return 1;
    const t = e1.numericValue;
    if (null !== t && t instanceof la && 0 === t.re) return t.im;
    if ("Negate" === e1.head) {
        const t1 = Ys(e1.op1);
        return null === t1 ? null : -t1;
    }
    if ("Multiply" === e1.head && 2 === e1.nops) {
        if ("ImaginaryUnit" === e1.op1.symbol) return Us(e1.op2);
        if ("ImaginaryUnit" === e1.op2.symbol) return Us(e1.op1);
    }
    return 0;
}
function Qs(e1) {
    var t;
    if (e1.symbol) return (null === (t = e1.symbolDefinition) || void 0 === t ? void 0 : t.constant) ? [] : [
        e1.symbol
    ];
    if (!e1.ops && !e1.keys) return [];
    const i = [];
    if (e1.ops) for (const t1 of e1.ops)i.push(...Qs(t1));
    if (e1.keys) for (const t2 of e1.keys)i.push(...Qs(e1.getKey(t2)));
    return i;
}
function el(e1, t) {
    if (e1.symbol) return t.add(e1.symbol), t;
    if (!e1.ops && !e1.keys) return t;
    if (e1.ops) for (const i of e1.ops)el(i, t);
    if (e1.keys) for (const i1 of e1.keys)el(e1.getKey(i1), t);
    return t;
}
function tl(e1, t) {
    const i = t && e1.head !== t ? [] : [
        e1
    ];
    if (e1.ops) for (const n of e1.ops)i.push(...tl(n, t));
    else if (e1.keys) for (const n1 of e1.keys)i.push(...tl(e1.getKey(n1), t));
    return i;
}
function il(e1) {
    return "bignum" === e1.numericMode || "auto" === e1.numericMode;
}
function nl(e1) {
    return "auto" === e1.numericMode || "complex" === e1.numericMode;
}
function rl(e1) {
    let t = 0;
    for(let i = 0; i < e1.length; i++)t = Math.imul(31, t) + e1.charCodeAt(i) | 0;
    return Math.abs(t);
}
function ol(e1, t) {
    var i;
    if (null == t) return null;
    if ("number" == typeof t) return e1.bignum(t);
    if (ga(t)) {
        let n = t.num.toLowerCase().replace(/[nd]$/g, "").replace(/[\u0009-\u000d\u0020\u00a0]/g, "");
        if (/\([0-9]+\)/.test(n)) {
            const [t1, r, o, a] = null !== (i = n.match(/(.+)\(([0-9]+)\)(.*)$/)) && void 0 !== i ? i : [];
            n = r + o.repeat(Math.ceil(e1.precision / o.length)) + (null != a ? a : "");
        }
        return "nan" === n ? e1.bignum("NaN") : "infinity" === n || "+infinity" === n ? e1.bignum("+Infinity") : "-infinity" === n ? e1.bignum("-Infinity") : e1.bignum(n);
    }
    return null;
}
function al(e1, t) {
    var i;
    const n = new Set;
    for (const [r, o, a] of t){
        let t1;
        const s = Xs(null == a ? void 0 : a.condition);
        if (s) {
            const i1 = e1.pattern(s);
            t1 = (e1)=>{
                var t;
                return "True" === (null === (t = i1.subs(e1).value) || void 0 === t ? void 0 : t.symbol);
            };
        } else t1 = null == a ? void 0 : a.condition;
        n.add([
            e1.pattern(r),
            e1.pattern(o),
            null !== (i = null == a ? void 0 : a.priority) && void 0 !== i ? i : 0,
            t1
        ]);
    }
    return n;
}
function sl([e1, t, i, n], r, o, a) {
    const s = e1.match(r, {
        substitution: o,
        ...a
    });
    return null === s ? null : "function" != typeof n || n(s) ? t.subs(s, {
        canonical: !0
    }) : null;
}
function ll(e1, t, i) {
    var n, r;
    const o = null !== (n = null == i ? void 0 : i.iterationLimit) && void 0 !== n ? n : 1;
    let a = 0;
    const s = null !== (r = null == i ? void 0 : i.once) && void 0 !== r && r;
    let l = !1, u = !1;
    try {
        for(; !l && a < o;){
            l = !0;
            for (const n1 of t){
                const t1 = sl(n1, e1, {}, i);
                if (null !== t1 && t1 !== e1) {
                    if (s) return t1;
                    l = !1, u = !0, e1 = t1;
                }
            }
            a += 1;
        }
    } catch (e2) {}
    return u ? e1 : null;
}
function ul(e1, t) {
    var i;
    const n = [];
    for (const r of e1)r.ops && r.head === t ? n.push(...null !== (i = ul(r.ops, t)) && void 0 !== i ? i : r.ops) : n.push(r);
    return n.length === e1.length ? null : n;
}
function cl(e1) {
    const t = [];
    for (const i of e1)"Sequence" === i.head ? i.ops && t.push(...i.ops) : t.push(i);
    return t;
}
function dl(e1, t, i) {
    if (t.length === i) return t;
    const n = [
        ...t.slice(0, i)
    ];
    let r = Math.min(i, t.length);
    for(; r < i;)n.push(e1.error("missing")), r += 1;
    for(; r < t.length;)n.push(e1.error("unexpected-argument", t[r])), r += 1;
    return n;
}
function hl(e1, t, i) {
    if (!e1.strict) return t.map((t)=>e1.box(t));
    let n = [];
    if (void 0 === i) n = t.map((t)=>e1.box(t));
    else for(let r = 0; r <= Math.max(i - 1, t.length - 1); r++)r > i - 1 ? n.push(e1.error("unexpected-argument", t[r])) : n.push(void 0 !== t[r] ? e1.box(t[r]) : e1.error([
        "missing",
        "Number"
    ]));
    return cl(n).map((t)=>!t.isValid || t.isNumber ? t : e1.error([
            "incompatible-domain",
            "Number",
            t.domain
        ], t));
}
function ml(e1, t, i) {
    const n = e1.engine;
    if (!n.strict) return t;
    const r = t.map((e1)=>e1.domain), o = n.domain([
        "Function",
        ...r,
        null != i ? i : "Anything"
    ]);
    if (e1.isCompatible(o)) return null;
    const a = e1.domainArgs.slice(0, -1), s = Math.max(a.length, r.length);
    let l = [], u = [
        ...t
    ];
    for(let e2 = 0; e2 <= s - 1; e2++)[l, u] = fl(n, a[e2], l, u);
    for(; l.length > 0 && "Nothing" === l[l.length - 1].symbol;)l.pop();
    return l;
}
function pl(e1, t, i) {
    return void 0 === i ? e1.error("unexpected-argument", t) : void 0 === t ? e1.error([
        "missing",
        i
    ]) : t.isValid ? (null == t ? void 0 : t.domain.isCompatible(e1.domain(i))) ? t : e1.error([
        "incompatible-domain",
        i,
        t.domain
    ], t) : t;
}
function fl(e1, t, i, n) {
    let r = n.shift();
    if (void 0 === t) return [
        [
            ...i,
            e1.error("unexpected-argument", r)
        ],
        n
    ];
    if (!Array.isArray(t)) return r ? r.domain.isCompatible(e1.domain(t)) ? [
        [
            ...i,
            r
        ],
        n
    ] : [
        [
            ...i,
            e1.error([
                "incompatible-domain",
                t,
                r.domain
            ], r)
        ],
        n
    ] : [
        [
            ...i,
            e1.error([
                "missing",
                t
            ])
        ],
        n
    ];
    const o = t[0];
    if (void 0 === r) {
        let r1 = !1;
        if ("Union" === o) {
            for(let e2 = 1; e2 <= t.length - 1; e2++)if ("Nothing" === t[e2]) {
                r1 = !0;
                break;
            }
        } else "Maybe" === o && (r1 = !0);
        return r1 ? [
            [
                ...i,
                e1.symbol("Nothing")
            ],
            n
        ] : [
            [
                ...i,
                e1.error([
                    "missing",
                    t
                ])
            ],
            n
        ];
    }
    if ("Union" === o) {
        let o1 = !1;
        for(let i1 = 1; i1 <= t.length - 1; i1++)if (r.domain.isCompatible(e1.domain(t[i1]))) {
            o1 = !0;
            break;
        }
        return o1 ? [
            [
                ...i,
                r
            ],
            n
        ] : [
            [
                ...i,
                e1.error([
                    "incompatible-domain",
                    t,
                    r.domain
                ], r)
            ],
            n
        ];
    }
    if ("Sequence" === o) {
        const o2 = e1.domain(t[1]);
        if (!r || !r.domain.isCompatible(o2)) return [
            [
                ...i,
                e1.error([
                    "incompatible-domain",
                    o2,
                    r.domain
                ], r)
            ],
            n
        ];
        let a = !1;
        const s = [
            ...i,
            r
        ];
        for(; !a;)r = n.shift(), r ? r.domain.isCompatible(o2) ? s.push(r) : (n.unshift(r), a = !1) : a = !1;
        return [
            s,
            n
        ];
    }
    return "Maybe" === o ? void 0 === r || "Nothing" === r.symbol ? [
        [
            ...i,
            e1.symbol("Nothing")
        ],
        n
    ] : fl(e1, t[1], i, [
        r,
        ...n
    ]) : [
        [
            ...i,
            r
        ],
        n
    ];
}
const gl = [
    4,
    2,
    4,
    2,
    4,
    6,
    2,
    6
];
function yl(e1, t, i) {
    const n = function(e1, t) {
        var i;
        if (t.lt(Number.MAX_SAFE_INTEGER)) {
            const i1 = $s(t.toNumber()), n = new Map;
            for (const t1 of Object.keys(i1))n.set(e1.bignum(t1), i1[t1]);
            return n;
        }
        const n1 = new Map;
        let r = 0;
        for(; t.mod(2).isZero();)r += 1, t = t.div(2);
        for(r > 0 && n1.set("2", r), r = 0; t.mod(3).isZero();)r += 1, t = t.div(3);
        for(r > 0 && n1.set("3", r); t.mod(5).isZero();)r += 1, t = t.div(5);
        r > 0 && n1.set("5", r);
        let o = e1.bignum(7), a = o.toString(), s = 0;
        for(; o.mul(o).lt(t);)t.mod(o).isZero() ? (n1.set(a, (null !== (i = n1.get(a)) && void 0 !== i ? i : 0) + 1), t = t.div(o)) : (o = o.add(gl[s]), a = o.toString(), s = s < 7 ? s + 1 : 0);
        t.eq(1) || n1.set(t.toString(), 1);
        const l = new Map;
        for (const [t2, i2] of n1)l.set(e1.bignum(t2), i2);
        return l;
    }(e1, t);
    let r = e1.bignum(1), o = e1.bignum(1);
    for (const [t1, a] of n){
        const n1 = e1.bignum(a);
        r = r.mul(t1.pow(n1.div(i).floor())), o = o.mul(t1.pow(n1.mod(i)));
    }
    return [
        r,
        o
    ];
}
function bl(e1, t) {
    if (!t.isInteger() || t.isNegative()) return e1._BIGNUM_NAN;
    if (t.lessThan(10)) return e1.bignum([
        1,
        1,
        2,
        6,
        24,
        120,
        720,
        5040,
        40320,
        362880,
        3628800
    ][t.toNumber()]);
    if (t.gt(Number.MAX_SAFE_INTEGER)) {
        let i = e1._BIGNUM_ONE, n = e1._BIGNUM_TWO;
        for(; n.lessThan(t);)i = i.mul(n), n = n.add(1);
        return i;
    }
    if (t.modulo(2).eq(1)) return t.times(bl(e1, t.minus(1)));
    let i1 = t.toNumber(), n1 = t, r = t;
    for(; i1 > 2;)i1 -= 2, n1 = n1.add(i1), r = r.mul(n1);
    return r;
}
function vl(e1, t) {
    if (t.isNegative()) return e1._BIGNUM_NAN;
    const i = e1.cache("gamma-p-ln", ()=>[
            "0.99999999999999709182",
            "57.156235665862923517",
            "-59.597960355475491248",
            "14.136097974741747174",
            "-0.49191381609762019978",
            "0.33994649984811888699e-4",
            "0.46523628927048575665e-4",
            "-0.98374475304879564677e-4",
            "0.15808870322491248884e-3",
            "-0.21026444172410488319e-3",
            "0.2174396181152126432e-3",
            "-0.16431810653676389022e-3",
            "0.84418223983852743293e-4",
            "-0.2619083840158140867e-4",
            "0.36899182659531622704e-5"
        ].map((t)=>e1.bignum(t)));
    let n = i[0];
    for(let e2 = i.length - 1; e2 > 0; --e2)n = n.add(i[e2].div(t.add(e2)));
    const r = e1.cache("gamma-g-ln", ()=>e1.bignum(607).div(128)), o = t.add(r).add(e1._BIGNUM_HALF);
    return e1._BIGNUM_NEGATIVE_ONE.acos().mul(e1._BIGNUM_TWO).log().mul(e1._BIGNUM_HALF).add(o.log().mul(t.add(e1._BIGNUM_HALF)).minus(o).add(n.log()).minus(t.log()));
}
function xl(e1, t) {
    if (t.lessThan(e1._BIGNUM_HALF)) {
        const i = e1._BIGNUM_NEGATIVE_ONE.acos();
        return i.div(i.mul(t).sin().mul(xl(e1, e1._BIGNUM_ONE.sub(t))));
    }
    if (t.greaterThan(100)) return vl(e1, t).exp();
    t = t.sub(1);
    const i1 = e1.cache("lanczos-7-c", ()=>[
            "0.99999999999980993227684700473478",
            "676.520368121885098567009190444019",
            "-1259.13921672240287047156078755283",
            "771.3234287776530788486528258894",
            "-176.61502916214059906584551354",
            "12.507343278686904814458936853",
            "-0.13857109526572011689554707",
            "9.984369578019570859563e-6",
            "1.50563273514931155834e-7"
        ].map((t)=>e1.bignum(t)));
    let n = i1[0];
    for(let e2 = 1; e2 < 9; e2++)n = n.add(i1[e2].div(t.add(e2)));
    const r = t.add(7).add(e1._BIGNUM_HALF);
    return e1._BIGNUM_NEGATIVE_ONE.acos().times(e1._BIGNUM_TWO).sqrt().mul(n.mul(r.neg().exp()).mul(r.pow(t.add(e1._BIGNUM_HALF))));
}
function kl(e1) {
    return !e1.isFinite() || !(e1.d.length > 3 || 3 === e1.d.length && e1.d[0] >= 90) && e1.e < 308 && e1.e > -306;
}
function _l(e1) {
    return null !== e1 && Array.isArray(e1);
}
function wl(e1) {
    return null !== e1 && Array.isArray(e1) && "number" == typeof e1[0];
}
function Sl(e1) {
    return null !== e1 && Array.isArray(e1) && e1[0] instanceof oa;
}
function Ml(e1) {
    return 0 === e1[0] || e1[0] instanceof oa && e1[0].isZero();
}
function Nl(e1) {
    return e1[0] === e1[1] || "number" != typeof e1[0] && e1[0].eq(e1[1]);
}
function Ll(e1) {
    return "number" == typeof e1[0] ? e1[0] === -e1[1] : e1[0].eq(e1[1].neg());
}
function Al(e1) {
    return "number" == typeof e1[0] ? e1[0] : e1[0].toNumber();
}
function Cl(e1) {
    return "number" == typeof e1[1] ? e1[1] : e1[1].toNumber();
}
function El(e1) {
    return wl(e1) ? e1[0] < 0 : e1[0].isNeg();
}
function Tl(e1) {
    return wl(e1) ? [
        -e1[0],
        e1[1]
    ] : [
        e1[0].neg(),
        e1[1]
    ];
}
function Dl(e1) {
    return wl(e1) ? e1[0] < 0 ? [
        -e1[1],
        -e1[0]
    ] : [
        e1[1],
        e1[0]
    ] : e1[0].isNeg() ? [
        e1[1].neg(),
        e1[0].neg()
    ] : [
        e1[1],
        e1[0]
    ];
}
function zl(e1) {
    const t = e1.numericValue;
    if (null !== t) return Array.isArray(t) ? t : "number" == typeof t && Number.isInteger(t) ? [
        t,
        1
    ] : t instanceof oa && t.isInteger() ? [
        t,
        e1.engine._BIGNUM_ONE
    ] : void 0;
}
function ql(e1) {
    return wl(e1) ? e1 : [
        e1[0].toNumber(),
        e1[1].toNumber()
    ];
}
function Il(e1, t) {
    if (Array.isArray(t)) return Sl(t) ? [
        t[1].mul(e1[0]).add(t[0].mul(e1[1])),
        t[1].mul(e1[1])
    ] : Sl(e1) ? [
        e1[0].mul(t[1]).add(e1[1].mul(t[0])),
        e1[1].mul(t[1])
    ] : [
        t[1] * e1[0] + t[0] * e1[1],
        t[1] * e1[1]
    ];
    const i = t.numericValue;
    if (null !== i && "number" == typeof i) return wl(e1) ? [
        e1[0] + e1[1] * i,
        e1[1]
    ] : [
        e1[0].add(e1[1].mul(i)),
        e1[1]
    ];
    if (i instanceof oa) {
        if (wl(e1)) {
            const n = t.engine;
            return [
                n.bignum(i.mul(e1[1]).add(e1[0])),
                n.bignum(e1[1])
            ];
        }
        return [
            e1[0].add(e1[1].mul(i)),
            e1[1]
        ];
    }
    return Array.isArray(i) ? Sl(i) ? [
        i[1].mul(e1[0]).add(i[0].mul(e1[1])),
        i[1].mul(e1[1])
    ] : Sl(e1) ? [
        e1[0].mul(i[1]).add(e1[1].mul(i[0])),
        e1[1].mul(i[1])
    ] : [
        i[1] * e1[0] + i[0] * e1[1],
        i[1] * e1[1]
    ] : e1;
}
function Ol(e1, t) {
    if (Array.isArray(t)) return Sl(e1) ? [
        e1[0].mul(t[0]),
        e1[1].mul(t[1])
    ] : Sl(t) ? [
        t[0].mul(e1[0]),
        t[1].mul(e1[1])
    ] : [
        t[0] * e1[0],
        t[1] * e1[1]
    ];
    const i = t.numericValue;
    return null !== i && "number" == typeof i ? wl(e1) ? [
        e1[0] * i,
        e1[1]
    ] : [
        e1[0].mul(i),
        e1[1]
    ] : i instanceof oa ? wl(e1) ? [
        i.mul(e1[0]),
        t.engine.bignum(e1[1])
    ] : [
        i.mul(e1[0]),
        e1[1]
    ] : Array.isArray(i) ? Sl(i) ? [
        i[0].mul(e1[0]),
        i[1].mul(e1[1])
    ] : wl(e1) ? [
        e1[0] * i[0],
        e1[1] * i[1]
    ] : [
        e1[0].mul(i[0]),
        e1[1].mul(i[1])
    ] : e1;
}
function Fl(e1, t) {
    return t < 0 && (e1 = Dl(e1), t = -t), 0 === t ? [
        1,
        1
    ] : 1 === t ? e1 : wl(e1) ? [
        Math.pow(e1[0], t),
        Math.pow(e1[1], t)
    ] : [
        e1[0].pow(t),
        e1[1].pow(t)
    ];
}
function Bl(e1) {
    if (wl(e1)) {
        if (1 === e1[0] || 1 === e1[1]) return e1;
        e1[1] < 0 && (e1 = [
            -e1[0],
            -e1[1]
        ]);
        const t = function(e1, t) {
            if (0 === e1) return t;
            if (0 === t) return e1;
            if (e1 === t) return e1;
            if (!Number.isInteger(e1) || !Number.isInteger(t)) return NaN;
            for(; 0 !== t;)[e1, t] = [
                t,
                e1 % t
            ];
            return e1 < 0 ? -e1 : e1;
        }(e1[0], e1[1]);
        return t <= 1 ? e1 : [
            e1[0] / t,
            e1[1] / t
        ];
    }
    if (e1[0].equals(1) || e1[1].equals(1)) return e1;
    e1[1].isNegative() && (e1 = [
        e1[0].neg(),
        e1[1].neg()
    ]);
    const t1 = function(e1, t) {
        for(; !t.isZero();)[e1, t] = [
            t,
            e1.modulo(t)
        ];
        return e1.abs();
    }(e1[0], e1[1]);
    return t1.lessThanOrEqualTo(1) ? e1 : [
        e1[0].div(t1),
        e1[1].div(t1)
    ];
}
function $l(e1) {
    const t = e1.engine;
    if ("Multiply" === e1.head) {
        const i = [];
        let n = [
            1,
            1
        ];
        for (const t1 of e1.ops){
            const e2 = t1.numericValue;
            null === e2 || e2 instanceof la ? i.push(t1) : n = Ol(n, t1);
        }
        return n = Bl(n), Nl(n) ? [
            [
                1,
                1
            ],
            e1
        ] : 0 === i.length ? [
            n,
            t._ONE
        ] : 1 === i.length ? [
            n,
            i[0]
        ] : [
            n,
            t.mul(i)
        ];
    }
    if ("Divide" === e1.head) {
        let [i1, n1] = $l(e1.op1);
        const [r, o] = $l(e1.op2), a = Bl(Ol(i1, Dl(r)));
        return n1.isOne && o.isOne ? [
            a,
            t._ONE
        ] : o.isOne ? [
            a,
            n1
        ] : [
            a,
            t.fn("Divide", [
                n1,
                o
            ])
        ];
    }
    if ("Power" === e1.head) {
        if (null === e1.op2.numericValue) return [
            [
                1,
                1
            ],
            e1
        ];
        let [i2, n2] = $l(e1.op1);
        if (Nl(i2)) return [
            [
                1,
                1
            ],
            e1
        ];
        const r1 = e1.op2, o1 = Zs(r1);
        if (-1 === o1) return [
            Dl(i2),
            t.inverse(n2)
        ];
        if (null !== o1) return [
            Fl(i2, o1),
            t.power(n2, r1)
        ];
        if (null !== r1.numericValue && Array.isArray(r1.numericValue)) {
            const [o2, a1] = ql(r1.numericValue), [s, l] = ql(i2);
            if (s > 0 && 1 === Math.abs(o2)) {
                const [i3, u] = Ps(s, a1), [c, d] = Ps(l, a1);
                return 1 === i3 && 1 === c ? [
                    [
                        1,
                        1
                    ],
                    e1
                ] : [
                    1 === o2 ? [
                        i3,
                        c
                    ] : [
                        c,
                        i3
                    ],
                    t.power(t.mul([
                        t.number([
                            u,
                            d
                        ]),
                        n2
                    ]), r1)
                ];
            }
        }
        return [
            [
                1,
                1
            ],
            e1
        ];
    }
    if ("Negate" === e1.head) {
        const [t2, i4] = $l(e1.op1);
        return [
            Tl(t2),
            i4
        ];
    }
    const i5 = e1.numericValue;
    if (null !== i5) {
        if (i5 instanceof oa) {
            if (i5.isInteger() && kl(i5)) return [
                [
                    i5.toNumber(),
                    1
                ],
                t._ONE
            ];
            if (i5.isNegative()) return [
                [
                    -1,
                    1
                ],
                t.number(i5.neg())
            ];
        }
        if ("number" == typeof i5) {
            if (Number.isInteger(i5)) return [
                [
                    i5,
                    1
                ],
                t._ONE
            ];
            if (i5 < 0) return [
                [
                    -1,
                    1
                ],
                t.number(-i5)
            ];
        }
        if (Array.isArray(i5)) return [
            i5,
            t._ONE
        ];
        if (i5 instanceof la && i5.re < 0) return [
            [
                -1,
                1
            ],
            t.number(t.complex(-i5.re, -i5.im))
        ];
    }
    return [
        [
            1,
            1
        ],
        e1
    ];
}
function Pl(e1, t, i) {
    if (e1 === t) return 0;
    const n = e1.N(), r = t.N(), o = n.numericValue, a = r.numericValue;
    if (null === o || null === a) {
        const i1 = e1.sgn, n1 = t.sgn;
        if ("number" != typeof i1 || "number" != typeof n1) return;
        return 0 === i1 && 0 === n1 ? 0 : i1 < 0 && n1 > 0 ? -1 : i1 > 0 && n1 < 0 ? 1 : void 0;
    }
    if (null != i || (i = e1.engine.tolerance), o instanceof la && a instanceof la) return 0 === Ws(o.re - a.re, i) && 0 === Ws(o.im - a.im, i) ? 0 : void 0;
    if (o instanceof la || a instanceof la) return;
    const s = zl(r);
    if (!s) return;
    const l = Il(Tl(s), n), u = wl(l) ? Ws(l[0] / l[1], i) : Ws(l[0].div(l[1]), i);
    return 0 === u ? 0 : "number" == typeof u ? u > 0 ? 1 : -1 : u.isPos() ? 1 : -1;
}
function Rl(e1, t) {
    let i = e1.numericValue;
    return null === i ? null : ("number" == typeof i ? i = -i : i instanceof oa || i instanceof sa.exports.Complex ? i = i.neg() : Array.isArray(i) && (i = Tl(i)), e1.engine.number(i, {
        metadata: t
    }));
}
function Kl(e1, t) {
    var i, n;
    if ("Negate" === e1.head) return pl(e1.engine, null === (i = e1.op1) || void 0 === i ? void 0 : i.canonical, "Number");
    if (null !== (e1 = pl(e1.engine, e1.canonical, "Number")).numericValue) return Rl(e1, t);
    if ("Add" === e1.head) {
        let i1 = e1.ops.map((e1)=>Kl(e1));
        return i1 = null !== (n = ul(i1, "Add")) && void 0 !== n ? n : i1, e1.engine.add(i1, t);
    }
    return e1.engine._fn("Negate", [
        e1
    ], t);
}
function Vl(e1) {
    var t;
    if (null !== e1.numericValue) return Rl(e1);
    if ("Negate" === e1.head) return e1.op1;
    const i = e1.engine;
    if ("Add" === e1.head) {
        let n = e1.ops.map((e1)=>Vl(e1));
        return n = null !== (t = ul(n, "Add")) && void 0 !== t ? t : n, i.add(n);
    }
    return "Multiply" === e1.head ? function(e1, t) {
        let i = [], n = !1;
        for (const e2 of t)n || "Negate" !== e2.head ? i.push(e2) : (n = !0, i.push(e2.op1));
        if (n) return e1.mul(i);
        i = [];
        for (const e3 of t)n || null === e3.numericValue || !e3.isInteger ? i.push(e3) : (n = !0, i.push(Vl(e3)));
        if (n) return e1.mul(i);
        i = [];
        for (const e4 of t)n || null === e4.numericValue || !e4.isNumber ? i.push(e4) : (n = !0, i.push(Vl(e4)));
        return n ? e1.mul(i) : e1._fn("Negate", [
            e1._fn("Multiply", t)
        ]);
    }(i, e1.ops) : "Divide" === e1.head ? i.divide(Vl(e1.op1), e1.op2) : i._fn("Negate", [
        e1
    ]);
}
function jl(e1, t, i = "simplify") {
    return Vl(t);
}
function Hl(e1, t) {
    const i = e1.engine;
    return "Negate" === e1.head && "Negate" === t.head ? Hl(e1.op1, t.op1) : "Negate" === e1.head ? Kl(Hl(e1.op1, t)) : "Negate" === t.head ? Kl(Hl(e1, t.op1)) : (e1 = Gl(e1), t = Gl(t), "Add" === e1.head ? i.add(e1.ops.map((e1)=>Hl(e1, t))) : "Add" === t.head ? i.add(t.ops.map((t)=>Hl(e1, t))) : i.mul([
        e1,
        t
    ]));
}
function Ul(e1, t) {
    if (1 === t) return e1;
    const i = Hl(e1, e1);
    return 2 === t ? i : t % 2 == 0 ? Ul(i, t / 2) : Hl(Ul(i, Math.round(t / 2) - 1), e1);
}
function Gl(e1) {
    const t = (e1 = e1.simplify()).engine;
    if ("Add" === e1.head) return t.add(e1.ops.map((e1)=>Gl(e1))).simplify();
    if ("Negate" === e1.head) return Hl(t._NEGATIVE_ONE, e1.op1).simplify();
    if ("Subtract" === e1.head) return t.add([
        Gl(e1.op1),
        Hl(t._NEGATIVE_ONE, e1.op1)
    ]).simplify();
    if ("Divide" === e1.head) return t.divide(Gl(e1.op1), Gl(e1.op2)).simplify();
    if ("Multiply" === e1.head) return 2 === e1.nops ? Hl(e1.op1, e1.op2) : e1.ops.reduce((e1, t)=>Hl(e1, t), t._ONE).simplify();
    if ("Power" === e1.head) {
        const i = e1.op1.head;
        if ("Multiply" === i) return t.mul(e1.op1.ops.map((i)=>t.power(i, e1.op2))).simplify();
        if ("Negate" === i) {
            const i1 = Zs(e1.op2);
            if (null !== i1 && i1 > 0) return i1 % 2 == 0 ? t.power(e1.op1.op1, e1.op2).simplify() : t.negate(t.power(e1.op1.op1, e1.op2)).simplify();
        }
        if ("Add" === i) {
            const i2 = Zs(e1.op2);
            if (null !== i2) return i2 > 0 ? Ul(e1.op1, i2).simplify() : t.inverse(Ul(e1.op1, -i2)).simplify();
        }
    }
    return e1.simplify();
}
const Zl = [
    [
        [
            "Multiply",
            "_x",
            "_a"
        ],
        [
            "0"
        ]
    ],
    [
        [
            "Add",
            "_a",
            "_x"
        ],
        [
            "Negate",
            "_a"
        ]
    ],
    [
        [
            "Add",
            [
                "Negate",
                "_x"
            ],
            "_a"
        ],
        "_a"
    ],
    [
        [
            "Add",
            [
                "Multiply",
                "_x",
                "_a"
            ],
            "_b"
        ],
        [
            "Divide",
            [
                "Negate",
                "_b"
            ],
            "_a"
        ]
    ],
    [
        [
            "Add",
            [
                "Multiply",
                [
                    "Power",
                    "_x",
                    2
                ],
                "_a"
            ],
            [
                "Multiply",
                "_x",
                "_b"
            ],
            "_c"
        ],
        [
            "Divide",
            [
                "Add",
                [
                    "Negate",
                    "_b"
                ],
                [
                    "Sqrt",
                    [
                        "Subtract",
                        [
                            "Square",
                            "_b"
                        ],
                        [
                            "Multiply",
                            4,
                            "_a",
                            "_c"
                        ]
                    ]
                ]
            ],
            [
                "Multiply",
                2,
                "_a"
            ]
        ]
    ],
    [
        [
            "Add",
            [
                "Multiply",
                [
                    "Power",
                    "_x",
                    2
                ],
                "_a"
            ],
            [
                "Multiply",
                "_x",
                "_b"
            ],
            "_c"
        ],
        [
            "Divide",
            [
                "Subtract",
                [
                    "Negate",
                    "_b"
                ],
                [
                    "Sqrt",
                    [
                        "Subtract",
                        [
                            "Square",
                            "_b"
                        ],
                        [
                            "Multiply",
                            4,
                            "_a",
                            "_c"
                        ]
                    ]
                ]
            ],
            [
                "Multiply",
                2,
                "_a"
            ]
        ]
    ],
    [
        [
            "Add",
            [
                "Multiply",
                [
                    "Power",
                    "_x",
                    2
                ],
                "_a"
            ],
            [
                "Multiply",
                "_x",
                "_b"
            ]
        ],
        0
    ],
    [
        [
            "Add",
            [
                "Multiply",
                [
                    "Power",
                    "_x",
                    2
                ],
                "_a"
            ],
            [
                "Multiply",
                "_x",
                "_b"
            ]
        ],
        [
            "Divide",
            [
                "Negate",
                "_b"
            ],
            "_a"
        ]
    ],
    [
        [
            "Add",
            [
                "Multiply",
                [
                    "Power",
                    "_x",
                    2
                ],
                "_a"
            ],
            "_b"
        ],
        [
            "Sqrt",
            [
                "Divide",
                [
                    "Negate",
                    "_b"
                ],
                "_a"
            ]
        ]
    ],
    [
        [
            "Add",
            [
                "Multiply",
                [
                    "Power",
                    "_x",
                    2
                ],
                "_a"
            ],
            "_b"
        ],
        [
            "Negate",
            [
                "Sqrt",
                [
                    "Divide",
                    [
                        "Negate",
                        "_b"
                    ],
                    "_a"
                ]
            ]
        ]
    ]
];
function Wl(e1, t) {
    const i = e1.engine;
    "Equal" === e1.head && (e1 = i.add([
        e1.op1.canonical,
        i.negate(e1.op2.canonical)
    ]).simplify());
    const n = i.cache("univariate-roots-rules", ()=>al(i, Zl)), r = function(e1, t, i) {
        const n = [];
        for (const r of t){
            const t1 = sl(r, e1, i);
            null !== t1 && n.push(t1);
        }
        return n;
    }(Gl(e1).subs({
        [t]: "_x"
    }, {
        canonical: !1
    }), n, {
        _x: i.symbol("_x")
    });
    return r.map((e1)=>e1.canonical.evaluate());
}
function Jl(e1) {
    return "Element" === e1.head ? function(e1) {
        var t;
        const i = e1.engine, n = function(e1) {
            const t = e1.symbols;
            return 0 === t.length ? [] : t.filter((t)=>!Xl(e1.engine, t.symbol)).map((e1)=>e1.symbol);
        }(e1.op1);
        if (1 === n.length) {
            const t1 = i.domain(e1.op2.evaluate().json);
            return t1.isValid ? (t1.isCompatible("Function") ? i.defineFunction(n[0], {
                signature: {
                    domain: "Function"
                }
            }) : i.defineSymbol(n[0], {
                domain: t1
            }), "ok") : "not-a-predicate";
        }
        if (e1.op1.symbol && Xl(i, e1.op1.symbol)) {
            const n1 = i.domain(e1.op2.evaluate().json);
            if (!n1.isValid) return "not-a-predicate";
            const r = i.lookupSymbol(e1.op1.symbol);
            if (r) return r.domain && !n1.isCompatible(r.domain) ? "contradiction" : (r.domain = n1, "ok");
            const o = i.lookupFunction(e1.op1.symbol);
            return (null === (t = null == o ? void 0 : o.signature) || void 0 === t ? void 0 : t.domain) ? n1.isCompatible(o.signature.domain) ? n1.isCompatible(o.signature.domain, "bivariant") ? "tautology" : "not-a-predicate" : "contradiction" : "ok";
        }
        if (n.length > 0) return i.assumptions.set(e1, !0), "ok";
        const r1 = e1.evaluate();
        return "True" === r1.symbol ? "tautology" : "False" === r1.symbol ? "contradiction" : "not-a-predicate";
    }(e1) : "Equal" === e1.head ? function(e1) {
        const t = Yl(e1);
        if (0 === t.length) {
            const t1 = e1.evaluate();
            return "True" === t1.symbol ? "tautology" : "False" === t1.symbol ? "contradiction" : "not-a-predicate";
        }
        const i = e1.engine, n = e1.op1.symbol;
        if (n && !Ql(i, n) && !e1.op2.has(n)) {
            const t2 = e1.op2.evaluate();
            if (!t2.isValid) return "not-a-predicate";
            const r = i.lookupSymbol(n);
            return r ? r.domain && !t2.domain.isCompatible(r.domain) ? "contradiction" : (r.value = t2, "ok") : (i.defineSymbol(n, {
                value: t2
            }), "ok");
        }
        if (1 === t.length) {
            const n1 = t[0], r1 = Wl(e1, n1);
            0 === r1.length && i.assumptions.set(i.box([
                "Equal",
                i.add([
                    e1.op1.canonical,
                    i.negate(e1.op2.canonical)
                ]).simplify(),
                0
            ]), !0);
            const o = 1 === r1.length ? r1[0] : i.box([
                "List",
                ...r1
            ]), a = i.lookupSymbol(n1);
            return a ? a.domain && !r1.every((e1)=>o.domain.isCompatible(e1.domain)) ? "contradiction" : (a.value = o, "ok") : (i.defineSymbol(n1, {
                value: o
            }), "ok");
        }
        return i.assumptions.set(e1, !0), "ok";
    }(e1) : function(e1) {
        const t = e1.head;
        return "string" == typeof t && [
            "Less",
            "Greater",
            "LessEqual",
            "GreaterEqual"
        ].includes(t);
    }(e1) ? function(e1) {
        const t = e1.engine;
        if (e1.op1.symbol && !Xl(t, e1.op1.symbol)) return e1.op2.evaluate().isZero ? "Less" === e1.head ? t.defineSymbol(e1.op1.symbol, {
            domain: t.domain("NegativeNumber")
        }) : "LessEqual" === e1.head ? t.defineSymbol(e1.op1.symbol, {
            domain: t.domain("NonPositiveNumber")
        }) : "Greater" === e1.head ? t.defineSymbol(e1.op1.symbol, {
            domain: t.domain("PositiveNumber")
        }) : "GreaterEqual" === e1.head && t.defineSymbol(e1.op1.symbol, {
            domain: t.domain("NonNegativeNumber")
        }) : (t.defineSymbol(e1.op1.symbol, {
            domain: t.domain("ExtendedRealNumber")
        }), t.assumptions.set(e1, !0)), "ok";
        let i, n, r = "";
        if ("Less" === e1.head ? (i = e1.op1, n = e1.op2, r = "<") : "LessEqual" === e1.head ? (i = e1.op1, n = e1.op2, r = "<=") : "Greater" === e1.head ? (i = e1.op2, n = e1.op1, r = "<") : "GreaterEqual" === e1.head && (i = e1.op2, n = e1.op1, r = "<="), !r) return "internal-error";
        const o = t.add([
            i.canonical,
            t.negate(n.canonical)
        ]).simplify(), a = Yl(o), s = t.box([
            "<" === r ? "Less" : "LessEqual",
            o,
            0
        ]).evaluate();
        return 0 === a.length ? "True" === s.symbol ? "tautology" : "False" === s.symbol ? "contradiction" : "not-a-predicate" : (1 === a.length && t.defineSymbol(a[0], {
            domain: "ExtendedRealNumber"
        }), t.assumptions.set(s, !0), "ok");
    }(e1) : "not-a-predicate";
}
function Xl(e1, t) {
    var i;
    return void 0 !== (null !== (i = e1.lookupSymbol(t)) && void 0 !== i ? i : e1.lookupFunction(t));
}
function Yl(e1) {
    const t = e1.symbols;
    return 0 === t.length ? [] : t.filter((t)=>!Ql(e1.engine, t.symbol)).map((e1)=>e1.symbol);
}
function Ql(e1, t) {
    var i;
    return !e1.lookupFunction(t) && void 0 !== (null === (i = e1.lookupSymbol(t)) || void 0 === i ? void 0 : i.value);
}
class eu {
    valueOf() {
        var e1, t, i;
        return "True" === this.symbol || "False" !== this.symbol && (null !== (i = null !== (t = null !== (e1 = Us(this)) && void 0 !== e1 ? e1 : this.string) && void 0 !== t ? t : this.symbol) && void 0 !== i ? i : JSON.stringify(this.json));
    }
    toString() {
        if (this.symbol) return this.symbol;
        if (this.string) return this.string;
        const e1 = this.numericValue;
        if (null !== e1) {
            if ("number" == typeof e1) return e1.toString();
            if (wl(e1)) return `${e1[0].toString()}/${e1[1].toString()}`;
            if (Sl(e1)) return `${e1[0].toString()}/${e1[1].toString()}`;
            if (e1 instanceof sa.exports.Complex) {
                const t = 1 === e1.im ? "" : -1 === e1.im ? "-" : e1.im.toString();
                return 0 === e1.re ? t + "i" : e1.im < 0 ? `${e1.re.toString()}${t}i` : `${e1.re.toString()}+${t}i`;
            }
        }
        return JSON.stringify(this.json);
    }
    [Symbol.toPrimitive](e1) {
        if ("number" === e1) {
            const e2 = this.valueOf();
            return "number" == typeof e2 ? e2 : null;
        }
        return this.toString();
    }
    toJSON() {
        return this.json;
    }
    get scope() {
        return null;
    }
    is(e1) {
        return null != e1 && this.isSame(this.engine.box(e1));
    }
    get latex() {
        var e1;
        return null !== (e1 = this._latex) && void 0 !== e1 ? e1 : this.engine.serialize(this);
    }
    set latex(e1) {
        this._latex = e1;
    }
    get symbol() {
        return null;
    }
    get isNothing() {
        return !1;
    }
    get string() {
        return null;
    }
    getSubexpressions(e1) {
        return tl(this, e1);
    }
    get subexpressions() {
        return this.getSubexpressions("");
    }
    get symbols() {
        return [
            ...el(this, new Set)
        ].map((e1)=>this.engine.symbol(e1, {
                canonical: !1
            }));
    }
    get errors() {
        return this.getSubexpressions("Error");
    }
    get ops() {
        return null;
    }
    get nops() {
        return 0;
    }
    get op1() {
        return this.engine.symbol("Nothing");
    }
    get op2() {
        return this.engine.symbol("Nothing");
    }
    get op3() {
        return this.engine.symbol("Nothing");
    }
    get isValid() {
        return !0;
    }
    get isPure() {
        return !1;
    }
    get isExact() {
        return !0;
    }
    get isFree() {
        return !1;
    }
    get isConstant() {
        return !1;
    }
    get canonical() {
        return this;
    }
    apply(e1, t) {
        return this;
    }
    subs(e1, t) {
        return (null == t ? void 0 : t.canonical) ? this.canonical : this;
    }
    solve(e1) {
        return null;
    }
    replace(e1) {
        return null;
    }
    has(e1) {
        return !1;
    }
    get isNaN() {}
    get isZero() {}
    get isNotZero() {}
    get isOne() {}
    get isNegativeOne() {}
    get isInfinity() {}
    get isFinite() {}
    get isEven() {}
    get isOdd() {}
    get isPrime() {}
    get isComposite() {}
    get numericValue() {
        return null;
    }
    get sgn() {
        return null;
    }
    isLess(e1) {}
    isLessEqual(e1) {}
    isGreater(e1) {}
    isGreaterEqual(e1) {}
    get isPositive() {}
    get isNonNegative() {}
    get isNegative() {}
    get isNonPositive() {}
    isCompatible(e1, t) {
        return !1;
    }
    get description() {}
    get url() {}
    get wikidata() {
        return this._wikidata;
    }
    set wikidata(e1) {
        this._wikidata = e1;
    }
    get complexity() {}
    get basedDefinition() {}
    get symbolDefinition() {}
    get functionDefinition() {}
    bind(e1) {}
    unbind() {}
    get keys() {
        return null;
    }
    get keysCount() {
        return 0;
    }
    getKey(e1) {}
    hasKey(e1) {
        return !1;
    }
    get value() {}
    set value(e1) {
        throw Error(`Can't change the value of \\(${this.latex}\\)`);
    }
    get domain() {
        return this.engine.domain("Void");
    }
    set domain(e1) {
        throw Error(`Can't change the domain of \\(${this.latex}\\)`);
    }
    get explicitDomain() {
        return this.domain;
    }
    get isNumber() {}
    get isInteger() {}
    get isRational() {}
    get isAlgebraic() {
        return !1;
    }
    get isReal() {}
    get isExtendedReal() {}
    get isComplex() {}
    get isImaginary() {}
    get isExtendedComplex() {}
    simplify(e1) {
        return this;
    }
    evaluate(e1) {
        return this.simplify(e1);
    }
    N(e1) {
        return this.evaluate();
    }
    constructor(e1, t){
        this.engine = e1, void 0 !== (null == t ? void 0 : t.latex) && (this._latex = t.latex), void 0 !== (null == t ? void 0 : t.wikidata) && (this._wikidata = t.wikidata);
    }
}
function tu(e1) {
    if ("Power" === e1.head && null !== e1.op2.numericValue) {
        const t = Zs(e1.op2);
        return null !== t && t > 0 ? t : 1;
    }
    if ("Multiply" === e1.head) {
        let t1 = 1;
        for (const i of e1.ops){
            const e2 = tu(i);
            e2 > 1 && (t1 += e2);
        }
        return t1;
    }
    return 1;
}
function iu(e1) {
    if ("Power" === e1.head && null !== e1.op2.numericValue) {
        const t = Zs(e1.op2);
        return null !== t && t > 0 ? t : 1;
    }
    if ("Multiply" === e1.head) {
        let t1 = 1;
        for (const i of e1.ops)t1 = Math.max(t1, tu(i));
        return t1;
    }
    return 1;
}
function nu(e1) {
    return e1.symbol ? e1.symbol : e1.ops ? e1.ops.map((e1)=>nu(e1)).filter((e1)=>e1.length > 0).join('"') : "";
}
function ru(e1, t) {
    return t.sort((e1, t)=>{
        const i = nu(e1), n = nu(t);
        if (i < n) return -1;
        if (i > n) return 1;
        const r = tu(e1), o = tu(t);
        if (r !== o) return o - r;
        const a = iu(e1), s = iu(t);
        return a !== s ? a - s : ou(e1, t);
    });
}
function ou(e1, t) {
    var i, n, r, o, a, s, l, u;
    const c = Us(e1);
    if (null !== c) {
        const e2 = Us(t);
        return null !== e2 ? c - e2 : -1;
    }
    if (e1.numericValue instanceof la) return t.numericValue instanceof la ? e1.numericValue.re === t.numericValue.re ? Math.abs(e1.numericValue.im) === Math.abs(t.numericValue.im) ? e1.numericValue.im - t.numericValue.im : Math.abs(e1.numericValue.im) - Math.abs(t.numericValue.im) : e1.numericValue.re - t.numericValue.re : null !== t.numericValue ? 1 : -1;
    if (e1.symbol) return t.symbol ? e1.symbol === t.symbol ? 0 : e1.symbol > t.symbol ? 1 : -1 : null !== t.numericValue ? 1 : -1;
    if (e1.ops) {
        if (t.ops) {
            const a1 = null !== (n = null === (i = e1.functionDefinition) || void 0 === i ? void 0 : i.complexity) && void 0 !== n ? n : 1e5, s1 = null !== (o = null === (r = t.functionDefinition) || void 0 === r ? void 0 : r.complexity) && void 0 !== o ? o : 1e5;
            return a1 === s1 ? "string" == typeof e1.head && "string" == typeof t.head ? e1.head === t.head ? au(e1) - au(t) : e1.head < t.head ? 1 : -1 : au(e1) - au(t) : a1 - s1;
        }
        return null !== t.numericValue || t.symbol ? 1 : -1;
    }
    if (e1.string) return t.string ? e1.string.length !== t.string.length ? t.string.length - e1.string.length : t.string < e1.string ? -1 : e1.string > t.string ? 1 : 0 : t.keys ? -1 : 1;
    if (e1.keys && t.keys) {
        if (e1.keysCount !== t.keysCount) return t.keysCount - e1.keysCount;
        let i1 = 0, n1 = 0;
        for (const e3 of t.keys)i1 += null !== (a = t.getKey(e3).complexity) && void 0 !== a ? a : 1e5;
        for (const t1 of e1.keys)n1 += null !== (s = e1.getKey(t1).complexity) && void 0 !== s ? s : 1e5;
        return n1 - i1;
    }
    return (null !== (l = e1.complexity) && void 0 !== l ? l : 1e5) - (null !== (u = t.complexity) && void 0 !== u ? u : 1e5);
}
function au(e1) {
    return null !== e1.keys ? 1 + e1.keysCount : e1.ops ? ("string" == typeof e1.head ? 1 : au(e1.head)) + [
        ...e1.ops
    ].reduce((e1, t)=>e1 + au(t), 0) : 1;
}
class su {
    get isEmpty() {
        return this._isCanonical ? 0 === this._terms.length && !1 === this._hasInfinity && !1 === this._hasZero && 1 === this._sign && Nl(this._rational) && 1 === this._complex.re && 0 === this._complex.im && this._bignum.eq(this.engine._BIGNUM_ONE) && 1 === this._number : 0 === this._terms.length;
    }
    addTerm(e1) {
        if (this._isCanonical) {
            if (e1.isNothing) return;
            if (null !== e1.numericValue) {
                if (e1.isOne) return;
                if (e1.isZero) return void (this._hasZero = !0);
                if (e1.isNegativeOne) return void (this._sign *= -1);
                if (e1.isInfinity) return this._hasInfinity = !0, void (e1.isNegative && (this._sign *= -1));
                let t = e1.numericValue;
                if ("number" == typeof t) return t < 0 && (this._sign *= -1, t = -t), void (Number.isInteger(t) ? this._rational = Ol(this._rational, [
                    t,
                    1
                ]) : il(this.engine) ? this._bignum = this._bignum.mul(t) : this._number *= t);
                if (t instanceof oa) return t.isNegative() && (this._sign *= -1, t = t.neg()), void (t.isInteger() ? this._rational = Ol(this._rational, [
                    t,
                    this.engine._BIGNUM_ONE
                ]) : il(this.engine) ? this._bignum = this._bignum.mul(t) : this._number *= t.toNumber());
                if (t instanceof la) return void (this._complex = this._complex.mul(t));
                if (_l(t)) return this._rational = Ol(this._rational, t), void (El(this._rational) && (this._sign *= -1, this._rational = Tl(this._rational)));
            }
        }
        let t1 = e1;
        if (this._isCanonical) {
            let i;
            [i, t1] = $l(e1), this._rational = Ol(this._rational, i), El(this._rational) && (this._sign *= -1, this._rational = Tl(this._rational));
        }
        if (null !== t1.numericValue && t1.isOne) return;
        let i1 = [
            1,
            1
        ];
        if ("Power" === t1.head) {
            const e2 = zl(t1.op2);
            e2 && (i1 = e2, t1 = t1.op1);
        }
        let n = !1;
        for (const e3 of this._terms)if (e3.term.isSame(t1)) {
            e3.exponent = Il(e3.exponent, i1), n = !0;
            break;
        }
        n || this._terms.push({
            term: t1,
            exponent: i1
        });
    }
    unitTerms(e1) {
        const t = this.engine;
        if ("numeric" === e1) {
            if (!nl(t) && 0 !== this._complex.im) return null;
            if (il(t)) {
                let e2 = t._BIGNUM_ONE;
                if (Nl(this._rational) || (e2 = Sl(this._rational) ? this._rational[0].div(this._rational[1]) : t.bignum(this._rational[0]).div(this._rational[1])), e2 = e2.mul(this._bignum).mul(this._sign * this._number), 0 !== this._complex.im) {
                    const i = this._complex.mul(e2.toNumber());
                    return i.equals(1) ? [] : [
                        {
                            exponent: [
                                1,
                                1
                            ],
                            terms: [
                                t.number(i)
                            ]
                        }
                    ];
                }
                return e2 = e2.mul(this._complex.re), e2.equals(1) ? [] : [
                    {
                        exponent: [
                            1,
                            1
                        ],
                        terms: [
                            t.number(e2)
                        ]
                    }
                ];
            }
            let e3 = 1;
            if (Nl(this._rational) || (e3 = Sl(this._rational) ? this._rational[0].toNumber() / this._rational[1].toNumber() : this._rational[0] / this._rational[1]), e3 *= this._sign * this._number * this._bignum.toNumber(), 0 !== this._complex.im) {
                const i1 = this._complex.mul(e3);
                return i1.equals(1) ? [] : [
                    {
                        exponent: [
                            1,
                            1
                        ],
                        terms: [
                            t.number(i1)
                        ]
                    }
                ];
            }
            return e3 *= this._complex.re, 1 === e3 ? [] : [
                {
                    exponent: [
                        1,
                        1
                    ],
                    terms: [
                        t.number(e3)
                    ]
                }
            ];
        }
        const i2 = [], n = [];
        this._hasInfinity && n.push(t._POSITIVE_INFINITY), this._rational = Bl(this._rational), 1 === this._complex.re && 0 === this._complex.im || (0 === this._complex.im && (this._number *= Math.abs(this._complex.re)), this._complex.re < 0 ? this._rational = Tl(this._rational) : n.push(t.number(this._complex)));
        let r = this._sign * this._number, o = this._bignum;
        return Nl(this._rational) || ("rational" === e1 ? (1 !== Al(this._rational) && (Sl(this._rational) ? o = o.mul(this._rational[0]) : r *= this._rational[0]), 1 !== Cl(this._rational) && i2.push({
            exponent: [
                -1,
                1
            ],
            terms: [
                t.number(this._rational[1])
            ]
        })) : -1 === r ? (n.push(t.number(Tl(this._rational))), r = 1) : n.push(t.number(this._rational))), o.equals(t._BIGNUM_ONE) ? 1 !== r && n.push(t.number(r)) : n.push(t.number(o.mul(r))), n.length > 0 && i2.push({
            exponent: [
                1,
                1
            ],
            terms: n
        }), i2;
    }
    groupedByDegrees(e1) {
        var t;
        null != e1 || (e1 = {}), "mode" in e1 || (e1.mode = "expression");
        const i = this.engine;
        if ("numeric" === e1.mode) {
            if (0 !== this._complex.im && !nl(i)) return null;
            if (this._hasInfinity) return [
                {
                    exponent: [
                        1,
                        1
                    ],
                    terms: [
                        i._POSITIVE_INFINITY
                    ]
                }
            ];
        }
        const n = this.unitTerms(null !== (t = e1.mode) && void 0 !== t ? t : "expression");
        if (null === n) return null;
        for (const e2 of this._terms){
            const t1 = Bl(e2.exponent);
            if (0 === t1[0]) continue;
            let i1 = !1;
            for (const r of n)if (t1[0] === r.exponent[0] && t1[1] === r.exponent[1]) {
                r.terms.push(e2.term), i1 = !0;
                break;
            }
            i1 || n.push({
                exponent: t1,
                terms: [
                    e2.term
                ]
            });
        }
        return n;
    }
    asExpression(e1 = "evaluate") {
        var t;
        const i = this.engine;
        if (this._hasInfinity) {
            if (this._hasZero) return i._NAN;
            if (0 === this._terms.length) return Al(this._rational) > 0 ? i._POSITIVE_INFINITY : i._NEGATIVE_INFINITY;
        }
        if (this._hasZero) return i._ZERO;
        const n = this.groupedByDegrees({
            mode: "N" === e1 ? "numeric" : "expression"
        });
        if (null === n) return i._NAN;
        let r = cu(i, n);
        return r = null !== (t = ul(r, "Multiply")) && void 0 !== t ? t : r, 0 === r.length ? i._ONE : 1 === r.length ? r[0] : this.engine._fn("Multiply", r);
    }
    asNumeratorDenominator() {
        var e1, t;
        const i = this.groupedByDegrees({
            mode: "rational"
        });
        if (null === i) return [
            this.engine._NAN,
            this.engine._NAN
        ];
        const n = [], r = [];
        for (const e2 of i)"number" == typeof e2.exponent[0] && e2.exponent[0] >= 0 || "number" != typeof e2.exponent[0] && e2.exponent[0].isPositive() ? n.push(e2) : r.push({
            exponent: Tl(e2.exponent),
            terms: e2.terms
        });
        const o = this.engine;
        let a = cu(o, n);
        a = null !== (e1 = ul(a, "Multiply")) && void 0 !== e1 ? e1 : a;
        let s = o._ONE;
        1 === a.length ? s = a[0] : a.length > 0 && (s = o._fn("Multiply", a));
        let l = cu(o, r);
        l = null !== (t = ul(l, "Multiply")) && void 0 !== t ? t : l;
        let u = o._ONE;
        return 1 === l.length ? u = l[0] : l.length > 0 && (u = o._fn("Multiply", l)), [
            s,
            u
        ];
    }
    asRationalExpression() {
        const [e1, t] = this.asNumeratorDenominator();
        if (null !== t.numericValue) {
            if (t.isOne) return e1;
            if (t.isNegativeOne) return this.engine.negate(e1);
        }
        return this.engine._fn("Divide", [
            e1,
            t
        ]);
    }
    constructor(e1, t, i){
        if (this._terms = [], this._hasInfinity = !1, this._hasZero = !1, this._isCanonical = !0, null != i || (i = {}), "canonical" in i || (i.canonical = !0), this._isCanonical = i.canonical, this.engine = e1, this._sign = 1, this._rational = il(e1) ? [
            e1._BIGNUM_ONE,
            e1._BIGNUM_ONE
        ] : [
            1,
            1
        ], this._complex = la.ONE, this._bignum = e1._BIGNUM_ONE, this._number = 1, t) for (const e2 of t)this.addTerm(e2);
    }
}
function lu(e1) {
    if (Nl(e1)) return 0;
    const [t, i] = [
        Al(e1),
        Cl(e1)
    ];
    return t > 0 && Number.isInteger(t / i) ? 1 : t > 0 ? 2 : Number.isInteger(t / i) ? 3 : 4;
}
function uu(e1, t) {
    const i = lu(e1.exponent), n = lu(t.exponent);
    return i !== n ? i - n : Sl(e1.exponent) && Sl(t.exponent) ? e1.exponent[0].div(e1.exponent[1]).sub(t.exponent[0].div(t.exponent[1])).toNumber() : Sl(e1.exponent) && wl(t.exponent) ? e1.exponent[0].div(e1.exponent[1]).sub(t.exponent[0] / t.exponent[1]).toNumber() : wl(e1.exponent) && Sl(t.exponent) ? t.exponent[0].div(t.exponent[1]).add(-e1.exponent[0] / e1.exponent[1]).toNumber() : e1.exponent[0] / e1.exponent[1] - t.exponent[0] / t.exponent[1];
}
function cu(e1, t) {
    var i;
    const n = (t = t.sort(uu)).map((t)=>{
        var i;
        const n = null !== (i = ul(t.terms, "Multiply")) && void 0 !== i ? i : t.terms, r = n.length <= 1 ? n[0] : e1._fn("Multiply", n.sort(ou));
        return Nl(t.exponent) ? r : e1.power(r, t.exponent);
    });
    return null !== (i = ul(n, "Multiply")) && void 0 !== i ? i : n;
}
function du(e1, t, i, n) {
    if (null !== t.numericValue) {
        if (_l(t.numericValue)) return Al(t.numericValue) < 0 ? hu(e1, "Subtract", [
            i,
            e1.number(Tl(t.numericValue))
        ], n) : null;
        const r = Zs(t);
        if (null !== r && r < 0) return hu(e1, "Subtract", [
            i,
            e1.number(-r)
        ], n);
    }
    return "Negate" === t.head ? hu(e1, "Subtract", [
        i,
        t.op1
    ], n) : null;
}
function hu(e1, t, i, n) {
    var r;
    const o = e1.jsonSerializationOptions.exclude;
    if (("Rational" === t || "Divide" === t) && 2 === i.length && 1 === Zs(i[0]) && 2 === Zs(i[1]) && !o.includes("Half")) return mu(e1, "Half", {
        ...n,
        wikidata: "Q39373172"
    });
    if (1 === i.length) {
        const n1 = i[0].numericValue;
        if ("Negate" === t && null !== n1) {
            if ("number" == typeof n1) return pu(e1, -n1);
            if (n1 instanceof oa) return pu(e1, n1.neg());
            if (n1 instanceof sa.exports.Complex) return pu(e1, n1.neg());
            if (_l(n1)) return pu(e1, Tl(n1));
        }
    }
    if ("string" == typeof t && o.includes(t)) {
        if ("Rational" === t && 2 === i.length) return hu(e1, "Divide", i, n);
        if ("Complex" === t && 2 === i.length) return hu(e1, "Add", [
            i[0],
            e1._fn("Multiply", [
                i[1],
                e1.symbol("ImaginaryUnit")
            ])
        ], n);
        if ("Sqrt" === t && 1 === i.length) return hu(e1, "Power", [
            i[0],
            o.includes("Half") ? e1.number([
                1,
                2
            ]) : e1._HALF
        ], n);
        if ("Root" === t && 2 === i.length && null !== i[1].numericValue) {
            const t1 = Zs(i[1]);
            if (2 === t1) return hu(e1, "Sqrt", [
                i[0]
            ]);
            if (null !== t1) return t1 < 0 ? hu(e1, "Divide", [
                e1._ONE,
                e1._fn("Power", [
                    i[0],
                    e1.number([
                        1,
                        -t1
                    ])
                ])
            ], n) : hu(e1, "Power", [
                i[0],
                e1.number([
                    1,
                    -t1
                ])
            ], n);
        }
        if ("Square" === t && 1 === i.length) return hu(e1, "Power", [
            i[0],
            e1.number(2)
        ], n);
        if ("Exp" === t && 1 === i.length) return hu(e1, "Power", [
            e1.symbol("ExponentialE"),
            i[0]
        ], n);
        if ("Subtract" === t && 2 === i.length) return hu(e1, "Add", [
            i[0],
            e1._fn("Negate", [
                i[1]
            ])
        ], n);
        if ("Subtract" === t && 1 === i.length) return hu(e1, "Negate", i, n);
    }
    if ("Add" === t && 2 === i.length && !o.includes("Subtract")) {
        if (null !== i[1].numericValue) {
            const t2 = Zs(i[1]);
            if (null !== t2 && t2 < 0) return hu(e1, "Subtract", [
                i[0],
                e1.number(-t2)
            ], n);
        }
        if ("Negate" === i[1].head) return hu(e1, "Subtract", [
            i[0],
            i[1].op1
        ], n);
    }
    if ("Tuple" === t) {
        if (1 === i.length && !o.includes("Single")) return hu(e1, "Single", i, n);
        if (2 === i.length && !o.includes("Pair")) return hu(e1, "Pair", i, n);
        if (3 === i.length && !o.includes("Triple")) return hu(e1, "Triple", i, n);
    }
    const a = [
        "string" == typeof t ? t : t.json,
        ...i.map((e1)=>e1.json)
    ], s = {
        ...null != n ? n : {}
    };
    return e1.jsonSerializationOptions.metadata.includes("latex") ? s.latex = null !== (r = s.latex) && void 0 !== r ? r : e1.serialize({
        fn: a
    }) : s.latex = "", e1.jsonSerializationOptions.metadata.includes("wikidata") || (s.wikidata = ""), s.latex || s.wikidata || !e1.jsonSerializationOptions.shorthands.includes("function") ? s.latex && s.wikidata ? {
        fn: a,
        latex: s.latex,
        wikidata: s.wikidata
    } : s.latex ? {
        fn: a,
        latex: s.latex
    } : s.wikidata ? {
        fn: a,
        wikidata: s.wikidata
    } : {
        fn: a
    } : a;
}
function mu(e1, t, i) {
    var n, r;
    if ("Half" === t && e1.jsonSerializationOptions.exclude.includes("Half")) return pu(e1, [
        1,
        2
    ], i);
    if (i = {
        ...i
    }, e1.jsonSerializationOptions.metadata.includes("latex") ? (i.latex = null !== (n = i.latex) && void 0 !== n ? n : e1.serialize({
        sym: t
    }), void 0 !== i.latex && (i.latex = i.latex)) : i.latex = void 0, e1.jsonSerializationOptions.metadata.includes("wikidata")) {
        if (void 0 === i.wikidata) {
            const n1 = null === (r = e1.lookupSymbol(t)) || void 0 === r ? void 0 : r.wikidata;
            void 0 !== n1 && (i.wikidata = n1);
        }
    } else i.wikidata = void 0;
    return void 0 === i.latex && void 0 === i.wikidata && e1.jsonSerializationOptions.shorthands.includes("symbol") ? t : void 0 !== i.latex && void 0 !== i.wikidata ? {
        sym: t,
        latex: i.latex,
        wikidata: i.wikidata
    } : void 0 !== i.latex ? {
        sym: t,
        latex: i.latex
    } : void 0 !== i.wikidata ? {
        sym: t,
        wikidata: i.wikidata
    } : {
        sym: t
    };
}
function pu(e1, t, i) {
    var n, r, o;
    i = {
        ...i
    }, e1.jsonSerializationOptions.metadata.includes("latex") || (i.latex = void 0);
    const a = void 0 === i.latex && void 0 === i.wikidata && !e1.jsonSerializationOptions.metadata.includes("latex") && e1.jsonSerializationOptions.shorthands.includes("number");
    let s = "";
    if (t instanceof oa) {
        if (t.isNaN()) s = "NaN";
        else if (t.isFinite()) {
            if (a && kl(t)) return t.toNumber();
            if (t.isInteger() && t.e < t.precision() + 4) s = t.toFixed(0);
            else {
                const i1 = e1.jsonSerializationOptions.precision;
                if (s = fu(e1, "max" === i1 ? t.toString() : t.toPrecision("auto" === i1 ? e1.precision : i1)), a) {
                    const e2 = t.toNumber();
                    if (e2.toString() === s) return e2;
                }
            }
        } else s = t.isPositive() ? "+Infinity" : "-Infinity";
        return e1.jsonSerializationOptions.metadata.includes("latex") && (i.latex = null !== (n = i.latex) && void 0 !== n ? n : e1.serialize({
            num: s
        })), void 0 !== i.latex ? {
            num: s,
            latex: i.latex
        } : a ? s : {
            num: s
        };
    }
    if (t instanceof sa.exports.Complex) return t.isInfinite() ? mu(e1, "ComplexInfinity", i) : t.isNaN() ? (s = "NaN", e1.jsonSerializationOptions.metadata.includes("latex") && (i.latex = null !== (r = i.latex) && void 0 !== r ? r : e1.serialize({
        num: s
    })), void 0 !== i.latex ? {
        num: s,
        latex: i.latex
    } : {
        num: s
    }) : hu(e1, "Complex", [
        e1.number(t.re),
        e1.number(t.im)
    ], {
        ...i,
        wikidata: "Q11567"
    });
    if (_l(t)) return a && e1.jsonSerializationOptions.shorthands.includes("function") && wl(t) ? [
        "Rational",
        t[0],
        t[1]
    ] : hu(e1, "Rational", [
        e1.number(t[0]),
        e1.number(t[1])
    ], {
        ...i
    });
    if (Number.isNaN(t)) s = "NaN";
    else if (Number.isFinite(t)) {
        if (a) return t;
        s = fu(e1, t.toString());
    } else s = t > 0 ? "+Infinity" : "-Infinity";
    return e1.jsonSerializationOptions.metadata.includes("latex") && (i.latex = null !== (o = i.latex) && void 0 !== o ? o : e1.serialize({
        num: s
    })), void 0 !== i.latex ? {
        num: s,
        latex: i.latex
    } : {
        num: s
    };
}
function fu(e1, t) {
    var i;
    if (!e1.jsonSerializationOptions.repeatingDecimals) return t;
    let [n, r, o, a] = null !== (i = t.match(/^(.*)\.([0-9]+)([e|E][-+]?[0-9]+)?$/)) && void 0 !== i ? i : [];
    if (!o) return t.toLowerCase();
    const s = o[o.length - 1];
    o = o.slice(0, -1);
    let l = "";
    for(let e2 = 0; e2 < o.length - 16; e2++){
        l = o.substring(0, e2);
        for(let i1 = 0; i1 <= 16; i1++){
            const n1 = o.substring(e2, e2 + i1 + 1), u = Math.floor((o.length - l.length) / n1.length);
            if (u > 1 && (l + n1.repeat(u + 1)).startsWith(o)) return "0" === n1 ? "0" === s ? r + "." + l + (null != a ? a : "") : t : r + "." + l + "(" + n1 + ")" + (null != a ? a : "");
        }
    }
    for(o += s; o.endsWith("0");)o = o.slice(0, -1);
    return a ? `${r}.${o}${a.toLowerCase()}` : `${r}.${o}`;
}
class gu extends eu {
    unbind() {
        for (const [e1, t] of this._value)t.unbind();
    }
    get hash() {
        let e1 = rl("Dictionary");
        for (const [t, i] of this._value)e1 ^= rl(t) ^ i.hash;
        return e1;
    }
    get complexity() {
        return 97;
    }
    get head() {
        return "Dictionary";
    }
    get isPure() {
        return !1;
    }
    getKey(e1) {
        return this._value.get(e1);
    }
    hasKey(e1) {
        return this._value.has(e1);
    }
    get keys() {
        return this._value.keys();
    }
    get keysCount() {
        return this._value.size;
    }
    has(e1) {
        for (const [t, i] of this._value)if (i.has(e1)) return !0;
        return !1;
    }
    get domain() {
        const e1 = [
            "Dictionary"
        ];
        for (const [t, i] of this._value)e1.push([
            "Tuple",
            t,
            i.domain
        ]);
        return this.engine.domain(e1);
    }
    get json() {
        if (this.engine.jsonSerializationOptions.shorthands.includes("dictionary")) {
            const e1 = {};
            for (const t of this._value.keys())e1[t] = this._value.get(t).json;
            return {
                dict: e1
            };
        }
        const e2 = [];
        for (const t1 of this._value.keys())e2.push(this.engine._fn("KeyValuePair", [
            this.engine.string(t1),
            this._value.get(t1)
        ]));
        return hu(this.engine, "Dictionary", e2, {
            latex: this._latex
        });
    }
    isSame(e1) {
        if (this === e1) return !0;
        if (!(e1 instanceof gu)) return !1;
        if (this._value.size !== e1._value.size) return !1;
        for (const [t, i] of this._value){
            const n = e1.getKey(t);
            if (!n || !i.isSame(n)) return !1;
        }
        return !0;
    }
    match(e1, t) {
        if (!(e1 instanceof gu)) return null;
        if (this._value.size !== e1._value.size) return null;
        let i = {};
        for (const [t1, n] of this._value){
            const r = e1.getKey(t1);
            if (!r) return null;
            const o = n.match(r);
            if (null === o) return null;
            i = {
                ...i,
                ...o
            };
        }
        return i;
    }
    isEqual(e1) {
        if (this === e1) return !0;
        if (!(e1 instanceof gu)) return !1;
        if (!e1.keys || this._value.size !== e1._value.size) return !1;
        for (const [t, i] of this._value){
            const n = e1.getKey(t);
            if (!n || !i.isEqual(n)) return !1;
        }
        return !0;
    }
    apply(e1, t) {
        const i = {};
        for (const t1 of this.keys)i[t1] = this.engine.box(e1(this.getKey(t1)));
        return t ? this.engine.fn(t, [
            {
                dict: i
            }
        ]) : new gu(this.engine, i);
    }
    evaluate(e1) {
        return this.apply((t)=>{
            var i;
            return null !== (i = t.evaluate(e1)) && void 0 !== i ? i : t;
        });
    }
    get isCanonical() {
        return this._isCanonical;
    }
    set isCanonical(e1) {
        this._isCanonical = e1;
    }
    get canonical() {
        if (this.isCanonical) return this;
        const e1 = this.apply((e1)=>e1.canonical);
        return e1.isCanonical = !0, e1;
    }
    simplify(e1) {
        var t;
        return null === (t = null == e1 ? void 0 : e1.recursive) || void 0 === t || t ? this.apply((t)=>{
            var i;
            return null !== (i = t.simplify(e1)) && void 0 !== i ? i : t;
        }) : this;
    }
    N(e1) {
        return this.apply((t)=>t.N(e1));
    }
    replace(e1, t) {
        let i = 0;
        const n = {};
        for (const r of this.keys){
            const o = this.getKey(r), a = o.replace(e1, t);
            null !== a && (i += 1), n[r] = null != a ? a : o;
        }
        return 0 === i ? null : new gu(this.engine, n);
    }
    subs(e1, t) {
        const i = {};
        for (const n of this.keys)i[n] = this.getKey(n).subs(e1, t);
        return new gu(this.engine, i, t);
    }
    constructor(e1, t, i){
        var n;
        null != i || (i = {}), super(e1, i.metadata), this._value = new Map;
        const r = null === (n = i.canonical) || void 0 === n || n;
        for (const i1 of Object.keys(t))this._value.set(i1, e1.box(t[i1], {
            canonical: r
        }));
        e1._register(this);
    }
}
const yu = [];
function bu(e1, t) {
    if (null == t) return e1;
    if (e1 === t) return e1;
    const i = e1.engine, n = i.box(t);
    return i.costFunction(n) <= 1.7 * i.costFunction(e1) ? n : e1;
}
class vu extends eu {
    get hash() {
        if (void 0 !== this._hash) return this._hash;
        let e1 = 0;
        for (const t of this._ops)e1 = e1 << 1 ^ t.hash | 0;
        return e1 = "string" == typeof this._head ? e1 ^ rl(this._head) | 0 : e1 ^ this._head.hash | 0, this._hash = e1, e1;
    }
    get isCanonical() {
        return this._canonical === this;
    }
    set isCanonical(e1) {
        this._canonical = e1 ? this : void 0;
    }
    get isPure() {
        var e1;
        if (void 0 !== this._isPure) return this._isPure;
        if (!this.isCanonical) return this._isPure = !1, !1;
        let t;
        return void 0 !== (null === (e1 = this.functionDefinition) || void 0 === e1 ? void 0 : e1.pure) && (t = this.functionDefinition.pure), !1 !== t && (t = this._ops.every((e1)=>e1.isPure)), this._isPure = t, t;
    }
    get json() {
        return this.isValid && this._canonical === this ? function(e1, t, i, n) {
            var r, o, a;
            const s = e1.jsonSerializationOptions.exclude;
            if ("Add" === t && 2 === i.length && !s.includes("Subtract")) {
                const t1 = null !== (r = du(e1, i[0], i[1], n)) && void 0 !== r ? r : du(e1, i[1], i[0], n);
                if (t1) return t1;
            }
            if ("Divide" === t && 2 === i.length && s.includes("Divide")) return hu(e1, "Multiply", [
                i[0],
                e1._fn("Power", [
                    i[1],
                    e1._NEGATIVE_ONE
                ])
            ], n);
            if ("Multiply" === t && !s.includes("Negate") && -1 === Us(i[0])) return hu(e1, "Negate", [
                e1._fn("Multiply", i.slice(1))
            ], n);
            if ("Multiply" === t && !s.includes("Divide")) {
                const t2 = new su(e1, i, {
                    canonical: !1
                }).asRationalExpression();
                if ("Divide" === t2.head) return hu(e1, t2.head, t2.ops, n);
            }
            if ("Power" === t) {
                if (!s.includes("Exp") && "ExponentialE" === (null === (o = i[0]) || void 0 === o ? void 0 : o.symbol)) return hu(e1, "Exp", [
                    i[1]
                ], n);
                if (null !== (null === (a = i[1]) || void 0 === a ? void 0 : a.numericValue)) {
                    const t3 = Zs(i[1]);
                    if (2 === t3 && !s.includes("Square")) return hu(e1, "Square", [
                        i[0]
                    ], n);
                    if (null !== t3 && t3 < 0 && !s.includes("Divide")) return hu(e1, "Divide", [
                        e1._ONE,
                        -1 === t3 ? i[0] : e1.power(i[0], -t3)
                    ], n);
                    const r1 = i[1].numericValue;
                    if (!s.includes("Sqrt") && .5 === r1) return hu(e1, "Sqrt", [
                        i[0]
                    ], n);
                    if (!s.includes("Sqrt") && -0.5 === r1) return hu(e1, "Divide", [
                        e1._ONE,
                        e1._fn("Sqrt", [
                            i[0]
                        ])
                    ], n);
                    if (_l(r1)) {
                        const t4 = Al(r1), o1 = Cl(r1);
                        if (1 === t4) {
                            if (!s.includes("Sqrt") && 2 === o1) return hu(e1, "Sqrt", [
                                i[0]
                            ], n);
                            if (!s.includes("Root")) return hu(e1, "Root", [
                                i[0],
                                e1.number(r1[1])
                            ], n);
                        }
                        if (-1 === t4) {
                            if (!s.includes("Sqrt") && 2 === o1) return hu(e1, "Divide", [
                                e1._ONE,
                                e1._fn("Sqrt", [
                                    i[0]
                                ])
                            ], n);
                            if (!s.includes("Root")) return hu(e1, "Divide", [
                                e1._ONE,
                                e1._fn("Root", [
                                    i[0],
                                    e1.number(r1[1])
                                ])
                            ], n);
                        }
                    }
                }
            }
            return hu(e1, t, i, n);
        }(this.engine, this._head, this._ops, {
            latex: this._latex,
            wikidata: this._wikidata
        }) : hu(this.engine, this._head, this._ops, {
            latex: this._latex,
            wikidata: this._wikidata
        });
    }
    get scope() {
        return this._scope;
    }
    get head() {
        return this._head;
    }
    get ops() {
        return this._ops;
    }
    get nops() {
        return this._ops.length;
    }
    get op1() {
        var e1;
        return null !== (e1 = this._ops[0]) && void 0 !== e1 ? e1 : this.engine.symbol("Nothing");
    }
    get op2() {
        var e1;
        return null !== (e1 = this._ops[1]) && void 0 !== e1 ? e1 : this.engine.symbol("Nothing");
    }
    get op3() {
        var e1;
        return null !== (e1 = this._ops[2]) && void 0 !== e1 ? e1 : this.engine.symbol("Nothing");
    }
    get isValid() {
        return "Error" !== this._head && !("string" != typeof this._head && !this._head.isValid) && this._ops.every((e1)=>e1.isValid);
    }
    get canonical() {
        return this._canonical || (this._canonical = this.isValid ? xu(this.engine, this._head, this._ops) : this), this._canonical;
    }
    *map(e1) {
        let t = 0;
        for(; t < this._ops.length;)yield e1(this._ops[t++]);
    }
    subs(e1, t) {
        null != t || (t = {}), "canonical" in t || (t.canonical = !0);
        const i = this._ops.map((i)=>i.subs(e1, t));
        return t.canonical && i.every((e1)=>e1.isValid) ? xu(this.engine, this._head, i) : new vu(this.engine, this._head, i, {
            canonical: !1
        });
    }
    replace(e1, t) {
        return ll(this, e1, t);
    }
    has(e1) {
        if ("string" == typeof this._head) {
            if ("string" == typeof e1) {
                if (this._head === e1) return !0;
            } else if (e1.includes(this._head)) return !0;
        }
        for (const t of this._ops)if (t.has(e1)) return !0;
        return !1;
    }
    isSame(e1) {
        if (this === e1) return !0;
        if (!(e1 instanceof vu)) return !1;
        if (this.nops !== e1.nops) return !1;
        if ("string" == typeof this.head) {
            if (this.head !== e1.head) return !1;
        } else {
            if ("string" == typeof e1.head) return !1;
            if (!e1.head || !this.head.isSame(e1.head)) return !1;
        }
        const t = this._ops, i = e1._ops;
        for(let e2 = 0; e2 < t.length; e2++)if (!t[e2].isSame(i[e2])) return !1;
        return !0;
    }
    match(e1, t) {
        if (!(e1 instanceof vu)) return null;
        let i = {};
        if ("string" == typeof this.head) {
            if (this.head !== e1.head) return null;
        } else {
            if ("string" == typeof e1.head) return null;
            {
                if (!e1.head) return null;
                const n = this.head.match(e1.head, t);
                if (null === n) return null;
                i = {
                    ...i,
                    ...n
                };
            }
        }
        const n1 = this._ops, r = e1._ops;
        for(let e2 = 0; e2 < n1.length; e2++){
            const o = n1[e2].match(r[e2], t);
            if (null === o) return null;
            i = {
                ...i,
                ...o
            };
        }
        return i;
    }
    unbind() {
        this._value = void 0, this._numericValue = void 0;
    }
    get wikidata() {
        var e1, t, i;
        if (this.isCanonical) return null !== (i = null !== (e1 = this._wikidata) && void 0 !== e1 ? e1 : null === (t = this.functionDefinition) || void 0 === t ? void 0 : t.wikidata) && void 0 !== i ? i : void 0;
    }
    get description() {
        if (!this.isCanonical) return;
        const e1 = this.functionDefinition;
        return e1 ? e1.description ? "string" == typeof e1.description ? [
            e1.description
        ] : e1.description : void 0 : [];
    }
    get url() {
        var e1, t;
        return this.isCanonical ? null !== (t = null === (e1 = this.functionDefinition) || void 0 === e1 ? void 0 : e1.url) && void 0 !== t ? t : void 0 : "";
    }
    get complexity() {
        var e1, t;
        if (this.isCanonical) return null !== (t = null === (e1 = this.functionDefinition) || void 0 === e1 ? void 0 : e1.complexity) && void 0 !== t ? t : 1e5;
    }
    get functionDefinition() {
        if (this.isCanonical) return null !== this._def ? this._def : void 0;
    }
    bind(e1) {}
    get value() {
        if (this.isCanonical && this.isPure) return this._value || (this._value = this.evaluate()), this._value;
    }
    isEqual(e1) {
        const t = Pl(this, e1);
        return 0 === t || void 0 === t && this.isSame(e1);
    }
    isLess(e1) {
        const t = Pl(this, e1);
        if (void 0 !== t) return t < 0;
    }
    isLessEqual(e1) {
        const t = Pl(this, e1);
        if (void 0 !== t) return t <= 0;
    }
    isGreater(e1) {
        const t = Pl(this, e1);
        if (void 0 !== t) return t > 0;
    }
    isGreaterEqual(e1) {
        const t = Pl(this, e1);
        if (void 0 !== t) return t >= 0;
    }
    get isZero() {
        const e1 = this.sgn;
        return null !== e1 && ("number" == typeof e1 ? 0 === e1 : void 0);
    }
    get isNotZero() {
        const e1 = this.sgn;
        return null !== e1 && ("number" == typeof e1 ? 0 !== e1 : void 0);
    }
    get isOne() {
        return this.isEqual(this.engine._ONE);
    }
    get isNegativeOne() {
        return this.isEqual(this.engine._NEGATIVE_ONE);
    }
    get isPositive() {
        const e1 = this.sgn;
        return null !== e1 && ("number" == typeof e1 ? e1 > 0 : void 0);
    }
    get isNonPositive() {
        const e1 = this.sgn;
        return null !== e1 && ("number" == typeof e1 ? e1 <= 0 : void 0);
    }
    get isNegative() {
        const e1 = this.sgn;
        return null !== e1 && ("number" == typeof e1 ? e1 < 0 : void 0);
    }
    get isNonNegative() {
        const e1 = this.sgn;
        return null !== e1 && ("number" == typeof e1 ? e1 >= 0 : void 0);
    }
    get isNumber() {
        return this.domain.isCompatible("Number");
    }
    get isInteger() {
        return this.domain.isCompatible("Integer");
    }
    get isRational() {
        return this.domain.isCompatible("RationalNumber");
    }
    get isAlgebraic() {
        return this.domain.isCompatible("AlgebraicNumber");
    }
    get isReal() {
        return this.domain.isCompatible("RealNumber");
    }
    get isExtendedReal() {
        return this.domain.isCompatible("ExtendedRealNumber");
    }
    get isComplex() {
        return this.domain.isCompatible("ComplexNumber");
    }
    get isImaginary() {
        return this.domain.isCompatible("ImaginaryNumber");
    }
    get sgn() {
        var e1, t, i, n, r, o, a, s;
        if (!this.isCanonical) return;
        const l = this.head;
        if ("Negate" === l) {
            const t1 = null === (e1 = this._ops[0]) || void 0 === e1 ? void 0 : e1.sgn;
            if (void 0 === t1) return;
            return null === t1 ? null : 0 === t1 ? 0 : t1 > 0 ? -1 : 1;
        }
        if ("Multiply" === l) {
            const e2 = this._ops.reduce((e1, t)=>{
                var i;
                return e1 * (null !== (i = t.sgn) && void 0 !== i ? i : NaN);
            }, 1);
            return isNaN(e2) ? null : e2 > 0 ? 1 : e2 < 0 ? -1 : 0;
        }
        if ("Add" === l) {
            let e3 = 0, t2 = 0, i1 = 0;
            const n1 = this._ops.length;
            for (const n2 of this._ops){
                const r1 = n2.sgn;
                if (null == r1) break;
                0 === r1 && (i1 += 1), r1 > 0 && (e3 += 1), r1 < 0 && (t2 += 1);
            }
            return i1 === n1 ? 0 : e3 === n1 ? 1 : t2 === n1 ? -1 : null;
        }
        if ("Divide" === l) {
            const e4 = null === (t = this._ops[0]) || void 0 === t ? void 0 : t.sgn, n3 = null === (i = this._ops[1]) || void 0 === i ? void 0 : i.sgn;
            return null === e4 || null === n3 || void 0 === e4 || void 0 === n3 ? null : 0 === e4 ? 0 : e4 > 0 && n3 > 0 || e4 < 0 && n3 < 0 ? 1 : -1;
        }
        if ("Square" === l) return (null === (n = this._ops[0]) || void 0 === n ? void 0 : n.isImaginary) ? -1 : (null === (r = this._ops[0]) || void 0 === r ? void 0 : r.isZero) ? 0 : 1;
        if ("Abs" === l) return (null === (o = this._ops[0]) || void 0 === o ? void 0 : o.isZero) ? 0 : 1;
        if ("Sqrt" === l) return (null === (a = this._ops[0]) || void 0 === a ? void 0 : a.isZero) ? 0 : (null === (s = this._ops[0]) || void 0 === s ? void 0 : s.isImaginary) ? null : 1;
        const u = Us(this.N());
        return null !== u ? 0 === u ? 0 : u < 0 ? -1 : 1 : void 0;
    }
    get domain() {
        return this._codomain;
    }
    simplify(e1) {
        var t, i, n, r;
        if (!this.isValid) return this;
        if (!this.isCanonical) return this.canonical.simplify(e1);
        const o = this.functionDefinition, a = _u(this._ops, null !== (t = null == o ? void 0 : o.hold) && void 0 !== t ? t : "none", (null == o ? void 0 : o.associative) ? o.name : "", (t)=>t.simplify(e1));
        if ("string" != typeof this._head) {
            const t1 = ku(this._head, a);
            return "string" != typeof t1.head ? t1 : t1.simplify(e1);
        }
        let s;
        if (o) {
            if (o.inert) s = null !== (n = null === (i = a[0]) || void 0 === i ? void 0 : i.canonical) && void 0 !== n ? n : this;
            else {
                const e2 = o.signature;
                (null == e2 ? void 0 : e2.simplify) && (s = e2.simplify(this.engine, a));
            }
        }
        s || (s = this.engine.fn(this._head, a));
        const l = null !== (r = null == e1 ? void 0 : e1.rules) && void 0 !== r ? r : this.engine.cache("standard-simplification-rules", ()=>al(this.engine, yu), (e1)=>{
            for (const [t, i, n, r] of e1)t.unbind(), i.unbind();
            return e1;
        });
        let u = 0, c = !1;
        do {
            const e3 = s.replace(l);
            null !== e3 ? (s = bu(e3, s), s === e3 && (c = !0)) : c = !0, u += 1;
        }while (!c && u < this.engine.iterationLimit);
        return s;
    }
    evaluate(e1) {
        var t, i, n;
        if (!this.isValid) return this;
        if (!this.isCanonical) return this.canonical.evaluate(e1);
        const r = this.functionDefinition, o = _u(this._ops, null !== (t = null == r ? void 0 : r.hold) && void 0 !== t ? t : "none", (null == r ? void 0 : r.associative) ? r.name : "", (t)=>t.evaluate(e1));
        if ("string" != typeof this._head) {
            const t1 = ku(this._head, o);
            return "string" != typeof t1.head ? t1 : t1.evaluate(e1);
        }
        if (!r) return this.engine.fn(this._head, o);
        if (r.inert) return null !== (i = o[0]) && void 0 !== i ? i : this;
        const a = r.signature;
        return a && a.evaluate ? "function" != typeof a.evaluate ? ku(a.evaluate, o) : null !== (n = a.evaluate(this.engine, o)) && void 0 !== n ? n : this.engine.fn(this._head, o) : this.engine.fn(this._head, o);
    }
    N(e1) {
        var t, i, n, r, o;
        if (this._numericValue) return this._numericValue;
        if (this.engine.strict && !this.isValid) return this;
        if (!this.isCanonical) return this.canonical.N(e1);
        const a = this.functionDefinition, s = _u(this._ops, null !== (t = null == a ? void 0 : a.hold) && void 0 !== t ? t : "none", (null == a ? void 0 : a.associative) ? a.name : "", (t)=>t.N(e1));
        if ("string" != typeof this._head) {
            const t1 = ku(this._head, s);
            return "string" != typeof t1.head ? t1 : t1.N(e1);
        }
        if (!a) return this.engine.fn(this._head, s);
        if (a.inert) return null !== (i = s[0]) && void 0 !== i ? i : this;
        let l = null !== (o = null === (r = null === (n = a.signature) || void 0 === n ? void 0 : n.N) || void 0 === r ? void 0 : r.call(n, this.engine, s)) && void 0 !== o ? o : this.engine.fn(this._head, s).evaluate();
        const u = l.numericValue;
        return null !== u && (!nl(this.engine) && u instanceof la ? l = this.engine._NAN : !il(this.engine) && u instanceof oa && (l = this.engine.number(u.toNumber()))), this.isPure && (this._numericValue = l), l;
    }
    solve(e1) {
        return 1 !== e1.length ? null : Wl(this.simplify(), e1[0]);
    }
    constructor(e1, t, i, n){
        var r, o, a, s, l;
        if (null != n || (n = {}), null !== (r = n.canonical) && void 0 !== r || (n.canonical = !1), super(e1, n.metadata), this._scope = e1.context, this._head = t, this._ops = i, this._def = null !== (o = n.def) && void 0 !== o ? o : null, n.canonical && (this._def || (this._def = e1.lookupFunction(t, e1.context)), this._canonical = this), this._codomain = null, n.canonical) {
            if ("string" != typeof this._head) this._codomain = this._head.domain.codomain;
            else if (this._def) {
                const t1 = this._def.signature;
                "function" == typeof t1.codomain ? this._codomain = null !== (a = t1.codomain(e1, this._ops)) && void 0 !== a ? a : null : this._codomain = null !== (s = t1.codomain) && void 0 !== s ? s : null;
            }
            this._codomain || (this._codomain = null !== (l = e1.defaultDomain) && void 0 !== l ? l : e1.domain("Void"));
        } else this._codomain = e1.domain("Anything");
        e1._register(this);
    }
}
function xu(e1, t, i, n) {
    var r, o, a;
    if ("string" != typeof t && (t = null !== (r = t.evaluate().symbol) && void 0 !== r ? r : t), "string" == typeof t) {
        const r1 = function(e1, t, i, n) {
            var r;
            let o = [];
            if ("Add" === t || "Multiply" === t) o = hl(e1, i);
            else if ("Negate" === t || "Square" === t || "Sqrt" === t) o = hl(e1, i, 1);
            else {
                if ("Divide" !== t && "Power" !== t) return null;
                o = hl(e1, i, 2);
            }
            if (!o.every((e1)=>e1.isValid)) return new vu(e1, t, o, {
                metadata: n,
                canonical: !1
            });
            if ("Add" === t) return e1.add(o, n);
            if ("Negate" === t) return e1.negate(null !== (r = o[0]) && void 0 !== r ? r : e1.error("missing"), n);
            if ("Multiply" === t) return e1.mul(o, n);
            if ("Divide" === t) return e1.divide(o[0], o[1], n);
            if ("Power" === t) return e1.power(o[0], o[1], n);
            if ("Square" === t) return e1.power(o[0], e1.number(2), n);
            if ("Sqrt" === t) {
                const t1 = o[0].canonical;
                return _l(t1.numericValue) ? new vu(e1, "Sqrt", [
                    t1
                ], {
                    metadata: n,
                    canonical: !0
                }) : e1.power(t1, e1.number([
                    1,
                    2
                ]), n);
            }
            return "Pair" === t ? e1.pair(o[0], o[1], n) : "Tuple" === t ? e1.tuple(o, n) : null;
        }(e1, t, i, n);
        if (r1) return r1;
    } else if (!t.isValid) return new vu(e1, t, i.map((t)=>e1.box(t, {
            canonical: !1
        })), {
        metadata: n,
        canonical: !1
    });
    const s = e1.lookupFunction(t, e1.context);
    if ("string" != typeof t || !s) return new vu(e1, t, cl(i.map((t)=>e1.box(t))), {
        metadata: n,
        canonical: !0
    });
    let l = [];
    for(let t1 = 0; t1 < i.length; t1++)if (wu(s.hold, i.length - 1, t1)) l.push(e1.box(i[t1]));
    else {
        const n1 = e1.box(i[t1], {
            canonical: !1
        });
        "ReleaseHold" === n1.head ? l.push(n1.op1.canonical) : l.push(n1);
    }
    const u = s.signature;
    if (u.canonical) return u.canonical(e1, l) || new vu(e1, t, l, {
        metadata: n,
        canonical: !1
    });
    if (l = cl(l), s.associative && (l = null !== (o = ul(l, t)) && void 0 !== o ? o : l), !l.every((e1)=>e1.isValid)) return new vu(e1, t, l, {
        metadata: n,
        canonical: !1
    });
    if (l = null !== (a = ml(u.domain, l)) && void 0 !== a ? a : l, !l.every((e1)=>e1.isValid)) return new vu(e1, t, l, {
        metadata: n,
        canonical: !1
    });
    if (1 === l.length && l[0].head === t) {
        if (s.involution) return l[0].op1;
        s.idempotent && (l = l[0].ops);
    }
    return l.length > 1 && !0 === s.commutative && (l = l.sort(ou)), new vu(e1, t, l, {
        metadata: n,
        def: s,
        canonical: !0
    });
}
function ku(e1, t) {
    var i;
    if ("Lambda" !== e1.head) return e1.engine._fn(e1.evaluate(), t);
    const n = {
        __: e1.engine.tuple(t),
        "_#": e1.engine.number(t.length)
    };
    let r = 1;
    for (const e2 of t)n["_" + r++] = e2;
    n._ = n._1;
    const o = this.context;
    this.context = null !== (i = e1.scope) && void 0 !== i ? i : null;
    const a = e1.subs(n).evaluate();
    return this.context = o, a;
}
function _u(e1, t, i, n) {
    var r, o;
    if (0 === e1.length) return [];
    i && (e1 = null !== (r = ul(e1, i)) && void 0 !== r ? r : e1);
    const a = [];
    for(let i1 = 0; i1 < e1.length; i1++)if ("Hold" === e1[i1].head) a.push(e1[i1]);
    else {
        let r1;
        if ("ReleaseHold" === e1[i1].head ? r1 = e1[i1].op1 : wu(t, e1.length - 1, i1) ? r1 = e1[i1] : a.push(e1[i1]), r1) {
            const e2 = n(r1);
            null !== e2 && a.push(e2);
        }
    }
    return i && null !== (o = ul(a, i)) && void 0 !== o ? o : a;
}
function wu(e1, t, i) {
    return "all" !== e1 && ("none" === e1 || ("first" === e1 ? 0 !== i : "rest" === e1 ? 0 === i : "last" === e1 ? i !== t : "most" === e1 && i === t));
}
function Su(e1) {
    if (!Number.isInteger(e1) || !Number.isFinite(e1) || Number.isNaN(e1) || e1 <= 1) return !1;
    if (e1 <= 7919) return Bs.has(e1);
    for (const t of Bs)if (e1 % t == 0) return !1;
    return e1 >= 0x3ffffffffffe5 ? !!function(e1, t) {
        let i = 0, n = e1 - 1;
        for(; n % 2 == 0;)n /= 2, ++i;
        e: do {
            let t1 = Math.pow(2 + Math.floor(Math.random() * (e1 - 3)), n) % e1;
            if (1 !== t1 && t1 !== e1 - 1) {
                for(let n1 = i - 1; n1--;){
                    if (t1 = t1 * t1 % e1, 1 === t1) return !1;
                    if (t1 === e1 - 1) continue e;
                }
                return !1;
            }
        }while (--t);
        return !0;
    }(e1, 30) && void 0 : e1 === function(e1) {
        if (1 === e1) return 1;
        if (e1 % 2 == 0) return 2;
        if (e1 % 3 == 0) return 3;
        if (e1 % 5 == 0) return 5;
        const t = Math.floor(Math.sqrt(e1));
        let i = 7;
        for(; i <= t;){
            if (e1 % i == 0) return i;
            if (e1 % (i + 4) == 0) return i + 4;
            if (e1 % (i + 6) == 0) return i + 6;
            if (e1 % (i + 10) == 0) return i + 10;
            if (e1 % (i + 12) == 0) return i + 12;
            if (e1 % (i + 16) == 0) return i + 16;
            if (e1 % (i + 22) == 0) return i + 22;
            if (e1 % (i + 24) == 0) return i + 24;
            i += 30;
        }
        return e1;
    }(e1);
}
class Mu extends eu {
    get hash() {
        if (void 0 !== this._hash) return this._hash;
        let e1 = 0;
        return e1 = "number" == typeof this._value ? rl(this._value.toString()) : this._value instanceof sa.exports.Complex ? rl(this._value.re.toString() + " +i " + this._value.im.toString()) : this._value instanceof oa ? rl(this._value.toString()) : rl(this._value[0].toString() + " / " + this._value[1].toString()), this._hash = e1, e1;
    }
    get head() {
        return "Number";
    }
    get isPure() {
        return !0;
    }
    get isExact() {
        return "number" == typeof this._value ? Number.isInteger(this._value) : this._value instanceof oa ? this._value.isInteger() : this._value instanceof sa.exports.Complex ? Number.isInteger(this._value.re) && Number.isInteger(this._value.im) : _l(this._value);
    }
    get isCanonical() {
        return this._isCanonical;
    }
    set isCanonical(e1) {
        this._isCanonical = e1;
    }
    get complexity() {
        return 1;
    }
    get value() {
        return this;
    }
    get numericValue() {
        return this._value;
    }
    get domain() {
        return void 0 === this._domain && (this._domain = this.engine.domain(function(e1) {
            return "number" != typeof e1 || isNaN(e1) ? e1 instanceof oa ? e1.isNaN() ? "Number" : e1.isFinite() ? e1.isInteger() ? e1.isPositive() ? "PositiveInteger" : e1.isNegative() ? "NegativeInteger" : "Integer" : e1.isPositive() ? "PositiveNumber" : e1.isNegative() ? "NegativeNumber" : "RealNumber" : "ExtendedRealNumber" : e1 instanceof sa.exports.Complex ? 0 === e1.re ? "ImaginaryNumber" : "ComplexNumber" : Array.isArray(e1) ? "RationalNumber" : "Number" : isFinite(e1) ? Number.isInteger(e1) ? e1 > 0 ? "PositiveInteger" : e1 < 0 ? "NegativeInteger" : "Integer" : e1 > 0 ? "PositiveNumber" : e1 < 0 ? "NegativeNumber" : "RealNumber" : "ExtendedRealNumber";
        }(this._value))), this._domain;
    }
    get json() {
        return pu(this.engine, this._value, {
            latex: this._latex
        });
    }
    get sgn() {
        if (this.isZero) return 0;
        if (this._value instanceof sa.exports.Complex) return null;
        if ("number" == typeof this._value) return this._value < 0 ? -1 : this._value > 0 ? 1 : null;
        if (this._value instanceof oa) return this._value.isNegative() ? -1 : this._value.isPositive() ? 1 : null;
        if (Array.isArray(this._value)) {
            const [e1, t] = this._value;
            return 0 === e1 && 0 !== t ? 0 : e1 < 0 ? -1 : e1 > 0 ? 1 : null;
        }
        return null;
    }
    isSame(e1) {
        if (this === e1) return !0;
        if (!(e1 instanceof Mu)) return !1;
        if (Array.isArray(this._value)) {
            if (!Array.isArray(e1._value)) return !1;
            const [t, i] = e1._value;
            return this._value[0] === t && this._value[1] === i;
        }
        return this._value instanceof oa ? e1._value instanceof oa && this._value.eq(e1._value) : this._value instanceof sa.exports.Complex ? e1._value instanceof sa.exports.Complex && this._value.equals(e1._value) : "number" == typeof this._value && "number" == typeof e1._value && this._value === e1._value;
    }
    isEqual(e1) {
        if (this === e1) return !0;
        const t = e1.N();
        return t instanceof Mu && 0 === Pl(this.N(), t);
    }
    match(e1, t) {
        var i;
        return this.isEqualWithTolerance(e1, null !== (i = null == t ? void 0 : t.numericTolerance) && void 0 !== i ? i : 0) ? {} : null;
    }
    isEqualWithTolerance(e1, t) {
        return e1 instanceof Mu && 0 === Pl(this, e1, t);
    }
    isLess(e1) {
        const t = Pl(this, e1);
        if (void 0 !== t) return t < 0;
    }
    isLessEqual(e1) {
        const t = Pl(this, e1);
        if (void 0 !== t) return t <= 0;
    }
    isGreater(e1) {
        return e1.isLessEqual(this);
    }
    isGreaterEqual(e1) {
        return e1.isLess(this);
    }
    get isPositive() {
        const e1 = this.sgn;
        if (null != e1) return e1 > 0;
    }
    get isNonNegative() {
        const e1 = this.sgn;
        if (null != e1) return e1 >= 0;
    }
    get isNegative() {
        const e1 = this.sgn;
        if (null != e1) return e1 < 0;
    }
    get isNonPositive() {
        const e1 = this.sgn;
        if (null != e1) return e1 <= 0;
    }
    get isZero() {
        return 0 === this._value || (this._value instanceof oa || this._value instanceof sa.exports.Complex) && this._value.isZero();
    }
    get isNotZero() {
        return "number" == typeof this._value && 0 !== this._value || (this._value instanceof oa ? !this._value.isZero() : !(this._value instanceof sa.exports.Complex && this._value.isZero()));
    }
    get isOne() {
        return "number" == typeof this._value ? 1 === this._value : this._value instanceof oa ? this._value.equals(this.engine._BIGNUM_ONE) : this._value instanceof sa.exports.Complex ? 0 === this._value.im && 1 === this._value.re : Nl(this._value);
    }
    get isNegativeOne() {
        return "number" == typeof this._value ? -1 === this._value : this._value instanceof oa ? this._value.equals(this.engine._BIGNUM_NEGATIVE_ONE) : Array.isArray(this._value) ? Ll(this._value) : this._value.equals(-1);
    }
    get isOdd() {
        return !(!this.isOne && !this.isNegativeOne) || !this.isZero && !!this.isInteger && ("number" == typeof this._value ? this._value % 2 != 0 : this._value instanceof oa ? !this._value.mod(2).isZero() : void 0);
    }
    get isEven() {
        return !this.isOne && !this.isNegativeOne && (!!this.isZero || !!this.isInteger && ("number" == typeof this._value ? this._value % 2 == 0 : this._value instanceof oa ? this._value.mod(2).isZero() : void 0));
    }
    get isPrime() {
        return !(!this.isInteger || !this.isFinite || this.isNonPositive || this.isOne || this.isZero) && ("number" == typeof this._value ? Su(this._value) : this._value instanceof oa ? Su(this._value.toNumber()) : void 0);
    }
    get isComposite() {
        return !(!this.isInteger || !this.isFinite || this.isNonPositive || this.isOne || this.isZero) && ("number" == typeof this._value ? !Su(this._value) : this._value instanceof oa ? !Su(this._value.toNumber()) : void 0);
    }
    get isInfinity() {
        return "number" == typeof this._value ? !Number.isFinite(this._value) && !Number.isNaN(this._value) : (this._value instanceof oa || this._value instanceof sa.exports.Complex) && !this._value.isFinite() && !this._value.isNaN();
    }
    get isNaN() {
        return "number" == typeof this._value ? Number.isNaN(this._value) : (this._value instanceof oa && this._value.isNaN(), this._value instanceof sa.exports.Complex && this._value.isNaN(), !1);
    }
    get isFinite() {
        return !this.isInfinity && !this.isNaN;
    }
    get isNumber() {
        return !0;
    }
    get isInteger() {
        return "number" == typeof this._value ? Number.isInteger(this._value) : this._value instanceof oa && this._value.isInteger();
    }
    get isRational() {
        return !!Array.isArray(this._value) || this.isInteger;
    }
    get isAlgebraic() {
        if (this.isRational) return !0;
    }
    get isReal() {
        return !(!this.isFinite || this._value instanceof sa.exports.Complex && 0 !== this.engine.chop(this._value.im));
    }
    get isExtendedReal() {
        return this.isInfinity || this.isReal;
    }
    get isComplex() {
        return !this.isNaN;
    }
    get isImaginary() {
        return this._value instanceof sa.exports.Complex;
    }
    get isExtendedComplex() {
        return this.isInfinity || !this.isNaN;
    }
    get canonical() {
        return this._isCanonical ? this : this.engine.number(Nu(this.engine, this._value));
    }
    simplify(e1) {
        return this.canonical;
    }
    N(e1) {
        if (!Array.isArray(this._value)) return this;
        const t = this.engine, [i, n] = this._value;
        return "number" != typeof i || "number" != typeof n || il(t) ? t.number(t.bignum(i).div(n)) : t.number(i / n);
    }
    constructor(e1, t, i){
        var n;
        if (super(e1, null == i ? void 0 : i.metadata), "number" == typeof t) return this._value = t, void (this._isCanonical = !0);
        _l(t) ? null === (n = null == i ? void 0 : i.canonical) || void 0 === n || n ? (this._value = Nu(e1, t), this._isCanonical = !0) : (this._value = t, this._isCanonical = !1) : (this._value = Nu(e1, t), this._isCanonical = !0);
    }
}
function Nu(e1, t) {
    if (t instanceof oa && kl(t)) return t.toNumber();
    if (!_l(t)) return t;
    let [i, n] = t;
    if (i instanceof oa && n instanceof oa) {
        if (!kl(i) || !kl(n)) return i.isNaN() || n.isNaN() ? NaN : ([i, n] = Bl([
            i,
            n
        ]), n.isNegative() && ([i, n] = [
            i.neg(),
            n.neg()
        ]), n.eq(e1._BIGNUM_ONE) ? i : n.isZero() ? i.isZero() || !i.isFinite() ? NaN : i.isNegative() ? -1 / 0 : 1 / 0 : [
            i,
            n
        ]);
        [i, n] = [
            i.toNumber(),
            n.toNumber()
        ];
    }
    return Number.isNaN(i) || Number.isNaN(n) ? NaN : ([i, n] = Bl([
        i,
        n
    ]), n < 0 && ([i, n] = [
        -i,
        -n
    ]), 1 === n ? i : 0 === n ? 0 !== i && Number.isFinite(i) ? i < 0 ? -1 / 0 : 1 / 0 : NaN : 0 === i ? i : [
        i,
        n
    ]);
}
class Lu extends eu {
    get hash() {
        return rl("String" + this._string);
    }
    get json() {
        var e1, t;
        return e1 = this.engine, t = this._string, e1.jsonSerializationOptions.shorthands.includes("string") ? `'${t}'` : {
            str: t
        };
    }
    get head() {
        return "String";
    }
    get isPure() {
        return !0;
    }
    get isCanonical() {
        return !0;
    }
    set isCanonical(e1) {}
    get domain() {
        return this.engine.domain("String");
    }
    get complexity() {
        return 19;
    }
    get string() {
        return this._string;
    }
    isEqual(e1) {
        return e1.string === this._string;
    }
    isSame(e1) {
        return e1.string === this._string;
    }
    match(e1, t) {
        return e1 instanceof Lu && this._string === e1._string ? {} : null;
    }
    constructor(e1, t, i){
        super(e1, i), this._string = t.normalize(), e1._register(this);
    }
}
function Au(e1, t, i) {
    var n;
    if ("number" == typeof t || t instanceof oa) return new Mu(e1, t, i);
    if (null != i || (i = {}), "canonical" in i || (i.canonical = !0), _l(t)) {
        if (2 !== t.length) throw Error("Array argument to `boxNumber()` should be two integers or two bignums");
        const [n1, r] = t;
        if (n1 instanceof oa && r instanceof oa) {
            if (!n1.isInteger() || !r.isInteger()) throw Error("Array argument to `boxNumber()` should be two integers");
            return n1.eq(r) ? r.isZero() ? e1._NAN : e1._ONE : r.eq(1) ? e1.number(n1, i) : r.eq(-1) ? e1.number(n1.negated(), i) : n1.eq(1) && r.eq(2) ? e1._HALF : new Mu(e1, [
                n1,
                r
            ], i);
        }
        if ("number" != typeof n1 || "number" != typeof r) throw Error("Array argument to `boxNumber()` should be two integers or two bignums");
        if (!Number.isInteger(n1) || !Number.isInteger(r)) throw Error("Array argument to `boxNumber()` should be two integers");
        return r === n1 ? 0 === r ? e1._NAN : e1._ONE : 1 === r ? e1.number(n1, i) : -1 === r ? e1.number(-n1, i) : 1 === n1 && 2 === r ? e1._HALF : new Mu(e1, [
            n1,
            r
        ], i);
    }
    if (t instanceof sa.exports.Complex) return t.isNaN() ? e1._NAN : t.isZero() ? e1._ZERO : t.isInfinite() ? e1._COMPLEX_INFINITY : 0 === e1.chop(t.im) ? e1.number(t.re, i) : new Mu(e1, t, i);
    let r1 = "";
    if ("string" == typeof t) r1 = t;
    else if ("object" == typeof t && "num" in t) {
        if ("number" == typeof t.num) return e1.number(t.num, i);
        if ("string" != typeof t.num) throw Error("MathJSON `num` property should be a string of digits");
        r1 = t.num;
    }
    if (r1) {
        if (r1 = r1.toLowerCase(), /[0-9][nd]$/.test(r1) && (r1 = r1.slice(0, -1)), r1 = r1.replace(/[\u0009-\u000d\u0020\u00a0]/g, ""), "nan" === r1) return e1._NAN;
        if ("infinity" === r1 || "+infinity" === r1) return e1._POSITIVE_INFINITY;
        if ("-infinity" === r1) return e1._NEGATIVE_INFINITY;
        if ("0" === r1) return e1._ZERO;
        if ("1" === r1) return e1._ONE;
        if ("-1" === r1) return e1._NEGATIVE_ONE;
        if (/\([0-9]+\)/.test(r1)) {
            const [t1, i1, o, a] = null !== (n = r1.match(/(.+)\(([0-9]+)\)(.+)?$/)) && void 0 !== n ? n : [];
            r1 = i1 + o.repeat(Math.ceil(e1.precision / o.length)) + (null != a ? a : "");
        }
        return Au(e1, e1.bignum(r1), i);
    }
    return null;
}
function Cu(e1, t, i) {
    if (null === t) return e1.error("missing");
    if ("object" == typeof t && t instanceof eu) return t;
    if ("string" == typeof (t = Pa(t))) return Tu(e1, t, i);
    if (Array.isArray(t)) {
        const n = t.map((t)=>Cu(e1, t, i));
        return new vu(e1, n[0], n.slice(1));
    }
    if ("object" == typeof t) {
        if ("dict" in t) return new gu(e1, t.dict);
        if ("fn" in t) return Cu(e1, t.fn, i);
        if ("str" in t) return new Lu(e1, t.str);
        if ("sym" in t) return Tu(e1, t.sym, i);
        if ("num" in t) return Tu(e1, t.num, i);
    }
    return Tu(e1, t, i);
}
function Eu(e1, t, i, n) {
    var r;
    if ("Hold" === t) return new vu(e1, "Hold", [
        Cu(e1, i[0], n)
    ], {
        ...n,
        canonical: !0
    });
    if ("Error" === t || "ErrorCode" === t) return e1._fn(t, i.map((t)=>e1.box(t, {
            canonical: !1
        })), n.metadata);
    if ("Domain" === t) return e1.domain(i[0], n.metadata);
    if ("Number" === t && 1 === i.length) return Tu(e1, i[0], n);
    if ("String" === t) return 0 === i.length ? new Lu(e1, "", n.metadata) : new Lu(e1, i.map((e1)=>{
        var t;
        return null !== (t = Du(e1)) && void 0 !== t ? t : "";
    }).join(""), n.metadata);
    if ("Symbol" === t && i.length > 0) return e1.symbol(i.map((e1)=>{
        var t;
        return null !== (t = Du(e1)) && void 0 !== t ? t : "";
    }).join(""), n);
    if (("Divide" === t || "Rational" === t) && 2 === i.length) {
        if (i[0] instanceof eu && i[1] instanceof eu) {
            const [t1, r1] = [
                Gs(i[0]),
                Gs(i[1])
            ];
            if ((null == t1 ? void 0 : t1.isInteger()) && (null == r1 ? void 0 : r1.isInteger())) return e1.number([
                t1,
                r1
            ], n);
        } else {
            const [t2, r2] = [
                ol(e1, i[0]),
                ol(e1, i[1])
            ];
            if ((null == t2 ? void 0 : t2.isInteger()) && (null == r2 ? void 0 : r2.isInteger())) return e1.number([
                t2,
                r2
            ], n);
        }
        t = "Divide";
    }
    if ("Complex" === t) {
        if (1 === i.length) {
            const t3 = Tu(e1, i[0], n), r3 = Us(t3);
            return null !== r3 && 0 !== r3 ? e1.number(e1.complex(0, r3), n) : e1.mul([
                t3,
                e1._I
            ]);
        }
        if (2 === i.length) {
            const t4 = Tu(e1, i[0], n), r4 = Tu(e1, i[1], n), o = Us(t4), a = Us(r4);
            return null !== a && null !== o ? 0 === a && 0 === o ? e1._ZERO : null !== a && 0 !== a ? e1.number(e1.complex(o, a), n) : t4 : e1.add([
                t4,
                e1.mul([
                    r4,
                    e1._I
                ])
            ], n.metadata);
        }
    }
    if ("Negate" === t && 1 === i.length) {
        const t5 = i[0];
        if ("number" == typeof t5) return e1.number(-t5, n);
        if (t5 instanceof oa) return e1.number(t5.neg(), n);
        const r5 = e1.box(t5, n).numericValue;
        if (null !== r5) {
            if ("number" == typeof r5) return e1.number(-r5, n);
            if (r5 instanceof oa) return e1.number(r5.neg(), n);
            if (r5 instanceof sa.exports.Complex) return e1.number(r5.neg());
            if (_l(r5)) return e1.number(Tl(r5));
        }
    }
    if ("Dictionary" === t) {
        const t6 = {};
        for (const n1 of i){
            const i1 = e1.box(n1), o1 = i1.head;
            if ("KeyValuePair" === o1 || "Pair" === o1 || "Tuple" === o1 && 2 === i1.nops) {
                const e2 = i1.op1;
                if (e2.isValid && !e2.isNothing) {
                    const n2 = i1.op2;
                    let o2 = null !== (r = e2.symbol) && void 0 !== r ? r : e2.string;
                    if (!o2 && (null !== e2.numericValue || e2.string)) {
                        const t7 = "number" == typeof e2.numericValue ? e2.numericValue : Zs(e2);
                        t7 && Number.isFinite(t7) && Number.isInteger(t7) && (o2 = t7.toString());
                    }
                    o2 && (t6[o2] = n2);
                }
            }
        }
        return new gu(e1, t6, n);
    }
    return n.canonical ? xu(e1, t, i, n.metadata) : new vu(e1, t, i.map((t)=>Tu(e1, t, {
            canonical: !1
        })), n);
}
function Tu(e1, t, i) {
    if (null == t) return e1._fn("Sequence", []);
    if (null != i || (i = {}), "canonical" in i || (i.canonical = !0), t instanceof eu) return i.canonical ? t.canonical : t;
    if (Array.isArray(t)) {
        if (wl(t)) return Number.isInteger(t[0]) && Number.isInteger(t[1]) ? e1.number(t) : Eu(e1, "Divide", t, i);
        if (Sl(t)) return t[0].isInteger() && t[1].isInteger() ? e1.number(t) : Eu(e1, "Divide", t, i);
        if ("string" == typeof t[0]) return Eu(e1, t[0], t.slice(1), i);
        const n = t.slice(1).map((t)=>Tu(e1, t, i)), r = ku(Tu(e1, t[0], i), n);
        return r.symbol ? new vu(e1, r.symbol, n) : r;
    }
    if ("number" == typeof t || t instanceof sa.exports.Complex || t instanceof oa) return e1.number(t);
    if ("string" == typeof t) return t.startsWith("'") && t.endsWith("'") ? new Lu(e1, t.slice(1, -1)) : /^[+-]?[0-9]/.test(t) ? e1.number(t) : e1.symbol(t, i);
    if ("object" == typeof t) {
        const n1 = {
            latex: t.latex,
            wikidata: t.wikidata
        };
        if ("dict" in t) return new gu(e1, t.dict, {
            canonical: !0,
            metadata: n1
        });
        if ("fn" in t) return "string" == typeof t.fn[0] ? Eu(e1, t.fn[0], t.fn.slice(1), i) : new vu(e1, Tu(e1, t.fn[0], i), t.fn.slice(1).map((t)=>Tu(e1, t, i)), {
            metadata: n1
        });
        if ("str" in t) return new Lu(e1, t.str, n1);
        if ("sym" in t) return e1.symbol(t.sym, i);
        if ("num" in t) return e1.number(t, i);
    }
    return e1.symbol("Undefined");
}
function Du(e1) {
    var t, i;
    if ("string" == typeof e1) return e1;
    if (e1 instanceof eu) return null !== (i = null !== (t = e1.string) && void 0 !== t ? t : e1.symbol) && void 0 !== i ? i : e1.toString();
    if ("object" == typeof e1) {
        if ("str" in e1) return e1.str;
        if ("fn" in e1 && "String" === e1.fn[0] && "string" == typeof e1.fn[1]) return e1.fn[1];
    }
    return Array.isArray(e1) && "String" === e1[0] && "string" == typeof e1[1] ? e1[1] : null;
}
class zu {
    get isEmpty() {
        return this._isCanonical ? 0 === this._terms.length && Ml(this._rational) && 0 === this._imaginary && 0 === this._number && this._bignum.isZero() && 0 === this._negInfinityCount && 0 === this._posInfinityCount : 0 === this._terms.length;
    }
    addTerm(e1, t) {
        if (this._isCanonical) {
            if (e1.isNothing) return;
            if (null !== e1.numericValue) {
                if (e1.isInfinity) return void (e1.isPositive ? this._posInfinityCount += 1 : this._negInfinityCount += 1);
                const i = zl(e1);
                if (i) return void (this._rational = Il(this._rational, void 0 === t ? i : Ol(i, t)));
                const n = e1.numericValue;
                if (null !== n && "number" == typeof n) return void (il(this.engine) ? this._bignum = this._bignum.add(n) : this._number += n);
                if (null !== n && n instanceof oa) return void (this._bignum = this._bignum.add(n));
                if (null !== n && n instanceof la) {
                    let i1 = n.re, r = n.im;
                    if (Number.isInteger(i1) ? (this._rational = Il(this._rational, Ol([
                        i1,
                        1
                    ], null != t ? t : [
                        1,
                        1
                    ])), i1 = 0) : (il(this.engine) ? this._bignum = this._bignum.add(i1) : this._number += i1, i1 = 0), Number.isInteger(r) && (void 0 === t ? this._imaginary += r : wl(t) ? this._imaginary += r * t[0] / t[1] : this._imaginary += t[0].mul(r).div(t[1]).toNumber(), r = 0), 0 === i1 && 0 === r) return;
                    e1 = this.engine.number(this.engine.complex(i1, r));
                }
            }
        }
        let i2;
        if ([i2, e1] = $l(e1), Ml(i2)) return;
        if (void 0 !== t && (i2 = Ol(i2, t)), "Negate" === e1.head) return void this.addTerm(e1.op1, Tl(i2));
        if ("Add" === e1.head) {
            for (const t1 of e1.ops)this.addTerm(t1, i2);
            return;
        }
        let n1 = !1;
        if (null === e1.numericValue) {
            if (this._terms.length > 500) {
                const t2 = e1.hash;
                for(let r1 = 0; r1 < this._terms.length; r1++)if (null === this._terms[r1].term.numericValue && t2 === this._terms[r1].term.hash && e1.isSame(this._terms[r1].term)) {
                    this._terms[r1].coef = Il(this._terms[r1].coef, i2), n1 = !0;
                    break;
                }
            } else for(let t3 = 0; t3 < this._terms.length; t3++)if (null === this._terms[t3].term.numericValue && e1.isSame(this._terms[t3].term)) {
                this._terms[t3].coef = Il(this._terms[t3].coef, i2), n1 = !0;
                break;
            }
        }
        n1 || this._terms.push({
            term: e1,
            coef: i2
        });
    }
    terms(e1) {
        var t;
        const i = this.engine;
        if (this._posInfinityCount > 0 && this._negInfinityCount > 0) return [
            i._NAN
        ];
        if (this._posInfinityCount > 0) return [
            i._POSITIVE_INFINITY
        ];
        if (this._negInfinityCount > 0) return [
            i._NEGATIVE_INFINITY
        ];
        if (0 !== this._imaginary && !nl(i)) return [
            i._NAN
        ];
        const n = [];
        for (const { coef: e2 , term: t1  } of this._terms)Ml(e2) || (Nl(e2) ? n.push(t1) : Ll(e2) ? n.push(i.negate(t1)) : 1 === Cl(e2) ? n.push(i.mul([
            i.number(e2[0]),
            t1
        ])) : 1 === Al(e2) ? n.push(i.divide(t1, i.number(e2[1]))) : n.push(i.mul([
            i.number(e2),
            t1
        ])));
        if ("numeric" === e1) {
            if (il(this.engine)) {
                let e3 = this._bignum.add(this._number);
                Ml(this._rational) || (e3 = e3.add(i.bignum(this._rational[0]).div(this._rational[1]))), 0 !== this._imaginary ? n.push(i.number(i.complex(e3.toNumber(), this._imaginary))) : 0 !== i.chop(e3) && n.push(i.number(e3));
            } else {
                let e4 = this._bignum.toNumber() + this._number;
                Ml(this._rational) || (e4 += Al(this._rational) / Cl(this._rational)), 0 !== this._imaginary ? n.push(i.number(i.complex(e4, this._imaginary))) : 0 !== i.chop(e4) && n.push(i.number(e4));
            }
        } else {
            if (Ml(this._rational) || n.push(i.number(this._rational)), 0 !== this._imaginary) {
                if (!nl(i)) return [
                    i._NAN
                ];
                n.push(i.number(i.complex(0, this._imaginary)));
            }
            if (il(this.engine)) {
                const e5 = this._bignum.add(this._number);
                0 !== i.chop(e5) && n.push(i.number(e5));
            } else 0 !== i.chop(this._bignum) && n.push(i.number(this._bignum)), 0 !== i.chop(this._number) && n.push(i.number(this._number));
        }
        return null !== (t = ul(n, "Add")) && void 0 !== t ? t : n;
    }
    asExpression(e1) {
        const t = this.engine, i = this.terms(e1);
        return 0 === i.length ? t._ZERO : 1 === i.length ? i[0] : t._fn("Add", ru(0, i));
    }
    constructor(e1, t, i){
        if (this._imaginary = 0, this._posInfinityCount = 0, this._negInfinityCount = 0, this._terms = [], this._isCanonical = !0, null != i || (i = {}), "canonical" in i || (i.canonical = !0), this._isCanonical = i.canonical, this.engine = e1, this._rational = il(e1) ? [
            e1._BIGNUM_ZERO,
            e1._BIGNUM_ONE
        ] : [
            0,
            1
        ], this._bignum = e1._BIGNUM_ZERO, this._number = 0, t) for (const e2 of t)this.addTerm(e2);
    }
}
const qu = [
    "Error",
    "Dictionary",
    "Function",
    "List",
    "Tuple",
    "Intersection",
    "Union",
    "Maybe",
    "Sequence",
    "Interval",
    "Range",
    "Head",
    "Symbol",
    "Value"
], Iu = {
    NumericFunction: [
        "Function",
        [
            "Sequence",
            "Number"
        ],
        "Number"
    ],
    RealFunction: [
        "Function",
        [
            "Sequence",
            "ExtendedRealNumber"
        ],
        "ExtendedRealNumber"
    ],
    TrigonometricFunction: [
        "Function",
        "Number",
        "Number"
    ],
    LogicOperator: [
        "Function",
        "MaybeBoolean",
        [
            "Maybe",
            "MaybeBoolean"
        ],
        "MaybeBoolean"
    ],
    Predicate: [
        "Function",
        [
            "Sequence",
            "Anything"
        ],
        "MaybeBoolean"
    ],
    RelationalOperator: [
        "Function",
        "Anything",
        "Anything",
        "MaybeBoolean"
    ]
}, Ou = {
    Anything: [],
    Value: "Anything",
    Domain: "Anything",
    DomainExpression: "Domain",
    Void: "Nothing",
    Nothing: [
        "DomainExpression",
        "Boolean",
        "String",
        "Symbol",
        "Tuple",
        "List",
        "Dictionary",
        "InfiniteSet",
        "FiniteSet",
        "ImaginaryNumber",
        "TranscendentalNumber",
        "PositiveInteger",
        "NegativeInteger",
        "NonPositiveInteger",
        "NonNegativeInteger",
        "PositiveNumber",
        "NegativeNumber",
        "NonPositiveNumber",
        "NonNegativeNumber",
        "Scalar",
        "TrigonometricFunction",
        "LogicOperator",
        "RelationalOperator"
    ],
    MaybeBoolean: "Value",
    Boolean: "MaybeBoolean",
    String: "Boolean",
    Symbol: "Boolean",
    Collection: "Value",
    List: "Collection",
    Dictionary: "Collection",
    Sequence: "Collection",
    Tuple: "Sequence",
    Set: "Collection",
    InfiniteSet: "Set",
    FiniteSet: "Set",
    Function: "Anything",
    Predicate: "Function",
    LogicOperator: "Predicate",
    RelationalOperator: "Predicate",
    NumericFunction: "Function",
    RealFunction: "NumericFunction",
    TrigonometricFunction: "RealFunction",
    Number: "Value",
    ExtendedComplexNumber: "Number",
    ComplexNumber: "ExtendedComplexNumber",
    ImaginaryNumber: "ComplexNumber",
    ExtendedRealNumber: "ExtendedComplexNumber",
    RealNumber: [
        "ComplexNumber",
        "ExtendedRealNumber"
    ],
    PositiveNumber: "NonNegativeNumber",
    NonNegativeNumber: "RealNumber",
    NonPositiveNumber: "NegativeNumber",
    NegativeNumber: "RealNumber",
    TranscendentalNumber: "RealNumber",
    AlgebraicNumber: "RealNumber",
    RationalNumber: "AlgebraicNumber",
    Integer: "RationalNumber",
    PositiveInteger: "NonNegativeInteger",
    NonNegativeInteger: "Integer",
    NonPositiveInteger: "NegativeInteger",
    NegativeInteger: "Integer",
    Tensor: "Value",
    Matrix: "Tensor",
    Scalar: [
        "Row",
        "Column"
    ],
    Row: "Vector",
    Column: "Vector",
    Vector: "Matrix"
};
let Fu;
function Bu(e1) {
    return !!e1 && void 0 !== Ou[e1];
}
function $u(e1) {
    if (Fu || (Fu = {}, $u("Void")), Fu[e1]) return Array.from(Fu[e1]);
    let t = [];
    if ("string" != typeof e1 || !Ou[e1]) {
        if (!Array.isArray(e1)) throw Error("Unknown domain literal " + e1);
        if (!qu.includes(e1[0])) throw Error("Unknown domain constructor " + e1[0]);
        return "Function" === e1[0] || "Head" === e1[0] ? $u("Function") : "Symbol" === e1[0] ? $u("Symbol") : "Tuple" === e1[0] ? $u("Tuple") : "List" === e1[0] ? $u("List") : "Dictionary" === e1[0] ? $u("Dictionary") : "Range" === e1[0] ? $u("Integer") : "Interval" === e1[0] ? $u("RealNumberExtended") : "Maybe" === e1[0] || "Sequence" === e1[0] ? $u(e1[1]) : ("Literal" === e1[0] || "Union" === e1[0] || e1[0], [
            "Anything"
        ]);
    }
    if ("string" == typeof Ou[e1]) t = [
        Ou[e1],
        ...$u(Ou[e1])
    ];
    else if (Array.isArray(Ou[e1])) for (const i of Ou[e1])t.push(i), t.push(...$u(i));
    return Fu[e1] = new Set(t), t;
}
class Pu extends eu {
    get isCanonical() {
        return !0;
    }
    get canonical() {
        return this;
    }
    get isValid() {
        return "Error" !== this.ctor;
    }
    get json() {
        const e1 = Ju(this.engine, this._value);
        return "Error" === _a(e1) ? e1 : [
            "Domain",
            e1
        ];
    }
    get literal() {
        return "string" == typeof this._value ? this._value : null;
    }
    get ctor() {
        return "string" == typeof this._value ? null : this._value[0];
    }
    get domainArgs() {
        return "string" == typeof this._value ? null : this._value.slice(1);
    }
    get domainArg1() {
        return "string" == typeof this._value ? null : this._value[1];
    }
    get codomain() {
        return "string" == typeof this._value ? null : this.engine.domain(this._value[this._value.length - 1]);
    }
    get hash() {
        return void 0 === this._hash && (this._hash = rl(Xu(this._value))), this._hash;
    }
    isEqual(e1) {
        return Yu(this._value, e1);
    }
    isSame(e1) {
        return Yu(this._value, e1);
    }
    is(e1) {
        return Yu(this._value, e1);
    }
    isCompatible(e1, t = "covariant") {
        const i = this._value, n = e1 instanceof Pu ? e1._value : e1, r = Array.isArray(n) ? n[0] : null;
        if (r) {
            const e2 = n[1];
            if ("Covariant" === r) return Uu(i, e2);
            if ("Contravariant" === r) return Uu(e2, i);
            if ("Invariant" === r) return !Uu(e2, i) && !Uu(i, e2);
            if ("Bivariant" === r) return Uu(i, e2) && Uu(e2, i);
        }
        return "covariant" === t ? Uu(i, n) : "contravariant" === t ? Uu(n, i) : "bivariant" === t ? Uu(n, i) && Uu(i, n) : !Uu(n, i) && !Uu(i, n);
    }
    match(e1, t) {
        return e1 instanceof Pu && this.isSame(e1) ? {} : null;
    }
    get head() {
        return "Domain";
    }
    get domain() {
        return this.engine.domain("Domain");
    }
    get isNothing() {
        return "Nothing" === this._value;
    }
    get isFunction() {
        return "Function" === this.ctor || "Function" === this._value;
    }
    get isNumeric() {
        return this.isCompatible(this.engine.domain("Number"));
    }
    get isRelationalOperator() {
        return "RelationalOperator" === this._value || "Function" === this.ctor && 2 === this.domainArgs.length && !!this.codomain.isCompatible("MaybeBoolean");
    }
    constructor(e1, t, i){
        super(e1, i), this._value = Ku(e1, t);
    }
}
function Ru(e1, t, i) {
    if (t instanceof Pu) return t;
    if (t instanceof eu && (t = t.json), "string" == typeof t) {
        const n = Iu[t];
        if (n) return Ru(e1, n);
        if (!Bu(t)) throw Error("Expected a domain literal, got " + t);
        return new Pu(e1, t, i);
    }
    if (!Array.isArray(t) || 0 === t.length) throw Error("Expected a valid domain");
    const n1 = t[0];
    if (!qu.includes(n1)) throw Error("Expected domain constructor, got " + n1);
    return new Pu(e1, t, i);
}
function Ku(e1, t) {
    if ("string" == typeof t) {
        if (!Bu(t)) throw Error("Unknown domain literal");
        return t;
    }
    if (t instanceof Pu) return t._value;
    const i = t[0];
    if ("Range" === i) {
        if (1 === t.length) return "Integer";
        let i1 = 1, n = 1 / 0;
        2 === t.length ? n = t[1] : 3 === t.length && (i1 = t[1], n = t[2]);
        const r = Vu(e1, i1), o = Vu(e1, n);
        if (null === r || null === o) throw Error(`Invalid range [${r}, ${o}] `);
        return o < r && ([i1, n] = [
            n,
            i1
        ]), r === -1 / 0 && o === 1 / 0 ? "Integer" : 1 === r && o === 1 / 0 ? "PositiveInteger" : 0 === r && o === 1 / 0 ? "NonNegativeInteger" : r === -1 / 0 && -1 === o ? "NegativeInteger" : r === -1 / 0 && 0 === o ? "NonPositiveInteger" : [
            "Range",
            e1.number(r),
            e1.number(o)
        ];
    }
    if ("Interval" === i) {
        if (3 !== t.length) throw Error("Invalid range " + t);
        let [i2, n1] = ju(e1, t[1]), [r1, o1] = ju(e1, t[2]);
        if (null === n1 || null === o1) throw Error("Invalid range " + t);
        return o1 < n1 && ([n1, o1] = [
            o1,
            n1
        ], [i2, r1] = [
            r1,
            i2
        ]), 0 === n1 && o1 === 1 / 0 ? i2 ? "PositiveNumber" : "NonNegativeNumber" : n1 === -1 / 0 && 0 === o1 ? r1 ? "NegativeNumber" : "NonPositiveNumber" : [
            "Interval",
            i2 ? [
                "Open",
                e1.number(n1)
            ] : e1.number(n1),
            r1 ? [
                "Open",
                e1.number(o1)
            ] : e1.number(o1)
        ];
    }
    if ("Function" === i) return [
        "Function",
        ...t.slice(1).map((t)=>Ku(e1, t))
    ];
    if ("Dictionary" === i) return [
        "Dictionary",
        Ku(e1, t[1])
    ];
    if ("List" === i) return [
        "List",
        Ku(e1, t[1])
    ];
    if ("Tuple" === i) return [
        "Tuple",
        ...t.slice(1).map((t)=>Ku(e1, t))
    ];
    if ("Union" === i) return [
        "Union",
        ...t.slice(1).map((t)=>Ku(e1, t))
    ];
    if ("Intersection" === i) return [
        "Intersection",
        ...t.slice(1).map((t)=>Ku(e1, t))
    ];
    if ("Covariant" === i || "Contravariant" === i || "Invariant" === i) return [
        i,
        Ku(e1, t[1])
    ];
    if ("Maybe" === i) return [
        "Maybe",
        Ku(e1, t[1])
    ];
    if ("Sequence" === i) return [
        "Sequence",
        Ku(e1, t[1])
    ];
    if ("Head" === i) return [
        "Head",
        t[1]
    ];
    if ("Symbol" === i) return [
        "Symbol",
        t[1]
    ];
    if ("Value" === i) return [
        "Value",
        e1.box(t[1])
    ];
    if ("Error" === i) return [
        "Error",
        ...t.slice(1).map((t)=>e1.box(t))
    ];
    throw Error("Unexpected domain constructor " + i);
}
function Vu(e1, t) {
    if ("number" == typeof t) return t;
    const i = e1.box(t).evaluate();
    return i.isInfinity ? i.isPositive ? 1 / 0 : -1 / 0 : Zs(i);
}
function ju(e1, t) {
    return Array.isArray(t) && "Open" === t[0] ? [
        !0,
        Vu(e1, t[1])
    ] : [
        !1,
        Vu(e1, t)
    ];
}
function Hu(e1) {
    if (e1 instanceof Pu) return !0;
    if (e1 instanceof eu && (e1 = e1.json), "string" == typeof e1) return Bu(e1);
    if (Array.isArray(e1)) {
        if (e1.length <= 1) return !1;
        const t = e1[0];
        return !("string" != typeof t || !qu.includes(t)) && ("List" === t ? 2 === e1.length && Hu(e1[1]) : "Tuple" === t || "Function" === t || "Maybe" === t || "Sequence" === t || "Intersection" === t || "Union" === t ? e1.slice(1, -1).every((e1)=>Hu(e1)) : e1.every((e1)=>null !== e1));
    }
    return !1;
}
function Uu(e1, t) {
    const [i, n] = Gu([
        e1
    ], t);
    return !(!i || 0 !== n.length);
}
function Gu(e1, t) {
    let i = e1.shift();
    const n = "string" == typeof t ? t : null;
    if ("Anything" === n) return [
        !0,
        e1
    ];
    const r = "string" == typeof i ? i : null;
    if (r && n) return r === n ? [
        !0,
        e1
    ] : [
        $u(r).includes(n),
        e1
    ];
    if (n) {
        const t1 = i[0];
        return "Function" === t1 ? [
            "Function" === n,
            e1
        ] : "Dictionary" === t1 ? [
            "Dictionary" === n,
            e1
        ] : "List" === t1 ? [
            "List" === n,
            e1
        ] : "Tuple" === t1 ? [
            "Tuple" === n,
            e1
        ] : "Interval" === t1 ? [
            Uu("ExtendedRealNumber", n),
            e1
        ] : "Range" === t1 ? [
            Uu("Integer", n),
            e1
        ] : [
            !0,
            e1
        ];
    }
    const o = t[0];
    if ("Function" === o) {
        if ("Function" === r) return [
            !0,
            e1
        ];
        if (r) return [
            !1,
            e1
        ];
        if ("Function" !== i[0]) return [
            !1,
            e1
        ];
        if (1 === i.length && 1 === t.length) return [
            !0,
            e1
        ];
        if (!Uu(i[i.length - 1], t[t.length - 1])) return [
            !1,
            e1
        ];
        const n1 = i.slice(1, -1);
        let o1 = t.slice(1, -1);
        for(let t2 = 0; t2 <= n1.length - 1; t2++){
            if (0 === o1.length) return "Maybe" !== (Array.isArray(n1[t2]) ? n1[t2][0] : null) ? [
                !1,
                e1
            ] : [
                !0,
                e1
            ];
            {
                let i1 = !1;
                if ([i1, o1] = Gu(o1, n1[t2]), !i1) return [
                    !1,
                    e1
                ];
            }
        }
        return [
            0 === o1.length,
            e1
        ];
    }
    if ("Intersection" === o) return [
        t.slice(1, -1).every((e1)=>Uu(i, e1)),
        e1
    ];
    if ("Union" === o) return [
        t.slice(1, -1).some((e1)=>Uu(i, e1)),
        e1
    ];
    if ("Maybe" === o) return "Nothing" === r ? [
        !0,
        e1
    ] : Gu([
        i,
        ...e1
    ], t[1]);
    if ("Sequence" === o) {
        const n2 = t[1];
        if (!Uu(i, n2)) return [
            !1,
            e1
        ];
        i = e1.shift();
        let r1 = !0;
        for(; e1.length > 0 && r1;)[r1, e1] = Gu(e1, n2), i = e1.shift();
        return [
            !0,
            e1
        ];
    }
    if ("Tuple" === o) {
        if (!Array.isArray(i) || "Tuple" !== i[0]) return [
            !1,
            e1
        ];
        if (i.length > t.length) return [
            !1,
            e1
        ];
        for(let n3 = 1; n3 <= t.length - 1; n3++)if (!i[n3] || !Uu(i[n3], t[n3])) return [
            !1,
            e1
        ];
        return [
            !0,
            e1
        ];
    }
    if ("Range" === o) {
        if (!Array.isArray(i) || "Range" !== i[0]) return [
            !1,
            e1
        ];
        const n4 = Us(i[1]), r2 = Us(i[2]), o2 = Us(t[1]), a = Us(t[2]);
        return [
            null !== n4 && null !== r2 && null !== o2 && null !== a && n4 >= o2 && r2 <= a,
            e1
        ];
    }
    if ("Interval" === o) {
        if (!Array.isArray(i) || "Interval" !== i[0]) return [
            !1,
            e1
        ];
        const n5 = Us(i[1]), r3 = Us(i[2]), o3 = Us(t[1]), a1 = Us(t[2]);
        return [
            null !== n5 && null !== r3 && null !== o3 && null !== a1 && n5 >= o3 && r3 <= a1,
            e1
        ];
    }
    return [
        !1,
        e1
    ];
}
function Zu(e1, t) {
    const i = Wu(e1), n = Wu(t), r = [
        i,
        ...$u(i)
    ], o = [
        n,
        ...$u(n)
    ];
    for(; !o.includes(r[0]);)r.shift();
    return e1.engine.domain(r[0]);
}
function Wu(e1) {
    let t = e1.literal;
    return t || (t = e1.ctor, "Maybe" === t ? "Anything" : "Interval" === t ? "RealNumber" : "Range" === t ? "Integer" : "Head" === t ? "Function" : "Union" === t || "Intersection" === t ? "Anything" : t);
}
function Ju(e1, t) {
    if (t instanceof eu) return t.json;
    if ("string" == typeof t) return t;
    if ("Error" === t[0]) return t[2] ? [
        "Error",
        Ju(e1, t[1]),
        Ju(e1, t[2])
    ] : [
        "Error",
        Ju(e1, t[1])
    ];
    const i = [
        mu(e1, t[0])
    ];
    if (t.length > 1) for(let n = 1; n <= t.length - 1; n++)i.push(Ju(e1, t[n]));
    return i;
}
function Xu(e1) {
    if ("string" == typeof e1) return "domain:" + e1;
    let t = "domain:" + this.ctor;
    for (const e2 of this.domainArgs)t += ":" + Xu(e2);
    return t;
}
function Yu(e1, t) {
    if ("string" == typeof t) return this._value === t;
    if (t instanceof Pu) return Yu(e1, t._value);
    if ("string" == typeof e1) return e1 === t;
    if (!Array.isArray(t)) return !1;
    if (e1[0] !== t[0]) return !1;
    if (t.length !== e1.length) return !1;
    for(let i = 1; i <= e1.length - 1; i++)if (e1[i] instanceof eu) {
        if (!(t[i] instanceof eu)) return !1;
        if (!t[i].isEqual(t[i])) return !1;
    } else if ("string" == typeof e1[i]) {
        if ("string" != typeof t[i]) return !1;
        if (e1[i] !== t[i]) return !1;
    } else if (!Yu(e1[i], t[i])) return !1;
    return !0;
}
function Qu(e1, t) {
    var i;
    if (0 === (t = (t = null !== (i = ul(cl(t.map((e1)=>e1.canonical)), "Add")) && void 0 !== i ? i : t).filter((e1)=>null === e1.numericValue || !e1.isZero)).length) return e1.number(0);
    if (1 === t.length) return t[0];
    if (2 === t.length) {
        let i1 = 0, n = 0;
        if (n = Us(t[0]), null !== n && 0 !== n ? i1 = Ys(t[1]) : (i1 = Ys(t[0]), 0 !== i1 && null !== t[1].numericValue && (n = Us(t[1]))), null !== n && null !== i1 && 0 !== i1) return e1.number(e1.complex(n, i1));
    }
    return t.length > 1 && (t = ru(0, t)), e1._fn("Add", t);
}
function ec(e1, t, i = "evaluate") {
    if ("N" === i && "machine" === e1.numericMode) {
        const i1 = function(e1) {
            let t = 0;
            for (const i of e1){
                const e2 = i.numericValue;
                if ("number" != typeof e2) return null;
                t += e2;
            }
            return t;
        }(t = t.map((e1)=>e1.N()));
        if (null !== i1) return e1.number(i1);
    }
    for (const n of t){
        if (n.isImaginary && n.isInfinity) return e1.symbol("ComplexInfinity");
        if (n.isNaN || "Undefined" === n.symbol) return e1._NAN;
        n.isExact || (i = "N");
    }
    return t = "N" === i ? t.map((e1)=>e1.N()) : t.map((e1)=>e1.evaluate()), new zu(e1, t).asExpression("N" === i ? "numeric" : "expression");
}
function tc(e1, t, i, n) {
    var r, o, a, s;
    const l = t;
    let u = 1, c = 1e6, d = "Nothing";
    if ("Tuple" !== i.head && "Triple" !== i.head && "Pair" !== i.head && "Single" !== i.head || (d = null !== (r = "Hold" === i.op1.head ? i.op1.op1.symbol : i.op1.symbol) && void 0 !== r ? r : "Nothing", u = null !== (o = Zs(i.op2)) && void 0 !== o ? o : 1, c = null !== (a = Zs(i.op3)) && void 0 !== a ? a : 1e6), u >= c || c - u >= 200) return;
    const h = e1.context;
    if (e1.context = null !== (s = l.scope) && void 0 !== s ? s : e1.context, "simplify" === n) {
        const t1 = [];
        if (l.scope) for(let i1 = u; i1 <= c; i1++)e1.set({
            [d]: i1
        }), t1.push(l.simplify());
        else for(let e2 = u; e2 <= c; e2++)t1.push(l.simplify());
        return e1.context = h, e1.add(t1).simplify();
    }
    if ("evaluate" === n) {
        const t2 = [];
        if (l.scope) for(let i2 = u; i2 <= c; i2++)e1.set({
            [d]: i2
        }), t2.push(l.evaluate());
        else for(let e3 = u; e3 <= c; e3++)t2.push(l.evaluate());
        return e1.context = h, e1.add(t2).evaluate();
    }
    let m = il(e1) ? [
        e1._BIGNUM_ZERO,
        e1._BIGNUM_ONE
    ] : [
        0,
        1
    ];
    if (l.scope) for(let t3 = u; t3 <= c; t3++){
        e1.set({
            [d]: t3
        });
        const i3 = l.N();
        if (null === i3.numericValue) return void (e1.context = h);
        m = Il(m, i3);
    }
    else for(let e4 = u; e4 <= c; e4++){
        const e5 = l.N();
        if (null === e5.numericValue) return;
        m = Il(m, e5);
    }
    return e1.context = h, wl(m) ? e1.number(m[0] / m[1]) : e1.number(m[0].div(m[1]));
}
function ic(e1) {
    if ("Negate" === e1.head) return [
        -1,
        e1.op1
    ];
    const t = e1.numericValue;
    if (null === t) return [
        1,
        e1
    ];
    const i = e1.engine;
    return "number" == typeof t && t < 0 ? [
        -1,
        i.number(-t)
    ] : t instanceof oa && t.isNegative() ? [
        -1,
        i.number(t.neg())
    ] : t instanceof la && t.re < 0 ? [
        -1,
        i.number(i.complex(-t.re, -t.im))
    ] : wl(t) && t[0] < 0 ? [
        -1,
        i.number([
            -t[0],
            t[1]
        ])
    ] : Sl(t) && t[0].isNegative() ? [
        -1,
        i.number([
            t[0].neg(),
            t[1]
        ])
    ] : [
        1,
        e1
    ];
}
function nc(e1, t, i, n) {
    if (null !== e1.numericValue) return e1.engine.number(function(e1, t, i, n) {
        var r;
        const o = e1.numericValue;
        return "number" == typeof o ? il(e1.engine) && i ? e1.engine.chop(i(e1.engine.bignum(o))) : e1.engine.chop(t(o)) : o instanceof oa ? e1.engine.chop(null !== (r = null == i ? void 0 : i(o)) && void 0 !== r ? r : t(o.toNumber())) : wl(o) ? il(e1.engine) && i ? e1.engine.chop(i(e1.engine.bignum(o[0]).div(o[1]))) : e1.engine.chop(t(o[0] / o[1])) : Sl(o) ? i ? e1.engine.chop(i(o[0].div(o[1]))) : e1.engine.chop(t(o[0].toNumber() / o[1].toNumber())) : o instanceof la && n && nl(e1.engine) ? e1.engine.chop(n(o)) : NaN;
    }(e1, t, i, n));
}
function rc(e1, t, i, n, r) {
    if (null !== e1.numericValue && null !== t.numericValue) return e1.engine.number(function(e1, t, i, n, r) {
        var o, a, s;
        const l = e1.engine;
        let u = e1.numericValue;
        wl(u) && (u = u[0] / u[1]);
        let c, d, h = t.numericValue;
        return wl(h) && (h = h[0] / h[1]), il(l) || "number" != typeof u || "number" != typeof h ? (u instanceof oa ? c = u : Sl(u) ? c = u[0].div(u[1]) : null !== u && "number" == typeof u && (c = l.bignum(u)), h instanceof oa ? d = h : Sl(h) ? d = h[0].div(h[1]) : null !== h && "number" == typeof h && (d = l.bignum(h)), c && d ? null !== (o = null == n ? void 0 : n(c, d)) && void 0 !== o ? o : i(c.toNumber(), d.toNumber()) : (u instanceof la || h instanceof la) && r && nl(l) ? r(l.complex(null !== (a = null != u ? u : null == c ? void 0 : c.toNumber()) && void 0 !== a ? a : NaN), l.complex(null !== (s = null != h ? h : null == d ? void 0 : d.toNumber()) && void 0 !== s ? s : NaN)) : NaN) : i(u, h);
    }(e1, t, i, n, r));
}
function oc(e1, t, i, n) {
    if (t = pl(e1, null == t ? void 0 : t.canonical, "Number"), "ComplexInfinity" === (i = pl(e1, null == i ? void 0 : i.canonical, "Number")).symbol) return e1._NAN;
    if (null !== i.numericValue) {
        if (i.isZero) return e1._ONE;
        if (null !== t.numericValue) {
            const r = Us(t);
            if (1 === r) return e1._ONE;
            if (0 === r) {
                if (i.isPositive) return e1._ZERO;
                if (i.isNegative) return e1._COMPLEX_INFINITY;
            }
            if (i.isOne) return t;
            if (i.isNegativeOne) {
                if (1 === r) return e1._ONE;
                if (-1 === r) return e1._NEGATIVE_ONE;
                if (t.isInfinity) return e1._ZERO;
                const i1 = t.numericValue;
                return "number" == typeof i1 && Number.isInteger(i1) ? e1.number([
                    1,
                    i1
                ], {
                    metadata: n
                }) : i1 instanceof oa && i1.isInteger() ? e1.number([
                    e1._BIGNUM_ONE,
                    i1
                ], {
                    metadata: n
                }) : _l(i1) ? e1.number(Dl(i1), {
                    metadata: n
                }) : e1._fn("Power", [
                    t,
                    e1._NEGATIVE_ONE
                ], n);
            }
            const o = Us(i);
            if (.5 === o || -0.5 === o) {
                const i2 = Zs(t);
                if (null !== i2 && i2 > 0) {
                    const [t1, n1] = Ps(i2, 2);
                    if (1 === n1 && 1 === t1) return e1._ONE;
                    if (1 !== t1) return 1 === n1 ? e1.number(o >= 0 ? t1 : [
                        1,
                        t1
                    ]) : e1.mul([
                        e1.number(t1),
                        e1.power(e1.number(n1), e1._HALF)
                    ]);
                }
                return o > 0 ? e1._fn("Power", [
                    t,
                    e1._HALF
                ], n) : e1._fn("Power", [
                    t,
                    e1.number([
                        -1,
                        2
                    ])
                ], n);
            }
            if (t.isInfinity) {
                if (i.numericValue instanceof la) {
                    const t2 = i.numericValue.re;
                    if (0 === t2) return e1._NAN;
                    if (t2 < 0) return e1._ZERO;
                    if (t2 > 0) return e1._COMPLEX_INFINITY;
                }
                if (t.isNegative) {
                    if (i.isInfinity) return e1._NAN;
                } else if (t.isPositive) {
                    if (i.isNegativeOne) return e1._ZERO;
                    if (i.isInfinity) return i.isNegative ? e1._ZERO : e1._POSITIVE_INFINITY;
                }
            }
            if (i.isInfinity && (t.isOne || t.isNegativeOne)) return e1._NAN;
            const a = zl(t);
            if (a) {
                const t3 = Zs(i);
                if (null !== t3 && -1 === t3) return e1.number(Dl(a));
            }
        }
    }
    if ("Power" === t.head && t.op1.isReal) {
        const n2 = Zs(i);
        if (null !== n2) {
            const i3 = Zs(t.op2);
            if (null !== i3) return e1.power(t.op1, e1.number(n2 * i3));
        }
        if (t.op1.isNonNegative) {
            const n3 = zl(i);
            if (n3) {
                const i4 = zl(t.op2);
                if (i4) return e1.power(t.op1, e1.number(Ol(n3, i4)));
            }
        }
    }
    return "Multiply" === t.head && null !== Zs(i) ? e1._fn("Multiply", t.ops.map((t)=>e1.power(t, i))) : null;
}
function ac(e1, t) {
    const i = t.numericValue;
    if ("number" == typeof i) return e1.number(i * i);
    if (i instanceof oa) return e1.number(i.pow(2));
    if (i instanceof la) return e1.number(i.pow(2));
    if (wl(i)) return e1.number([
        i[1] * i[1],
        i[0] * i[0]
    ]);
    if (Sl(i)) return e1.number([
        i[1].pow(2),
        i[0].pow(2)
    ]);
    if ("Multiply" === t.head) return e1._fn("Multiply", t.ops.map((t)=>ac(e1, t)));
    if ("Power" === t.head) {
        const i1 = Zs(t.op2);
        return null !== i1 ? e1.power(t.op1, e1.number(2 * i1)) : e1.power(t.op1, e1.mul([
            e1.number(2),
            t.op2
        ]));
    }
    return e1.power(t, e1.number(2));
}
function sc(e1, t, i) {
    var n, r, o, a;
    if (null === t.numericValue || null === i.numericValue) return;
    if (t.numericValue instanceof la) return i.numericValue instanceof la ? e1.number(t.numericValue.pow(i.numericValue)) : e1.number(t.numericValue.pow(null !== (n = Us(i)) && void 0 !== n ? n : NaN));
    if (i.numericValue instanceof la) {
        const n1 = null !== (r = Us(t)) && void 0 !== r ? r : null;
        return null !== n1 ? e1.number(e1.complex(n1).pow(i.numericValue)) : void 0;
    }
    const s = function(e1) {
        if ("number" == typeof e1.numericValue) {
            const t = 1 / e1.numericValue;
            return Number.isInteger(t) ? t : null;
        }
        if (e1.numericValue instanceof oa) {
            const t1 = e1.engine._BIGNUM_ONE.div(e1.numericValue);
            return t1.isInt() ? t1.toNumber() : null;
        }
        if (!_l(e1.numericValue)) return null;
        const [t2, i] = [
            Al(e1.numericValue),
            Cl(e1.numericValue)
        ];
        return 1 !== t2 && -1 !== t2 ? null : t2 * i;
    }(i);
    if (il(e1) || t.numericValue instanceof oa || i.numericValue instanceof oa) {
        const n2 = Gs(t), r1 = Gs(i);
        if (!n2 || !r1) return;
        if (2 === s) return n2.isNeg() ? nl(e1) ? e1.mul([
            e1._I,
            e1.number(n2.neg().sqrt())
        ]) : e1._NAN : e1.number(n2.sqrt());
        if (!r1.isInteger() && n2.isNeg()) {
            if (!nl(e1)) return e1._NAN;
            const t1 = e1.complex(n2.toNumber()), i1 = e1.complex(r1.toNumber());
            return e1.number(t1.pow(i1));
        }
        return e1.number(n2.pow(r1));
    }
    const l = null !== (o = Us(i)) && void 0 !== o ? o : NaN, u = null !== (a = Us(t)) && void 0 !== a ? a : NaN;
    if (2 === s) return u < 0 ? nl(e1) ? e1.mul([
        e1._I,
        e1.number(Math.sqrt(-u))
    ]) : e1._NAN : e1.number(Math.sqrt(u));
    if (!Number.isInteger(l) && u < 0) {
        if (!nl(e1)) return e1._NAN;
        const t2 = e1.complex(u), i2 = e1.complex(l);
        return e1.number(t2.pow(i2));
    }
    return e1.number(Math.pow(u, l));
}
function lc(e1, t, i, n) {
    var r, o;
    if ("Multiply" === t.head) {
        let a = il(e1) ? [
            e1._BIGNUM_ONE,
            e1._BIGNUM_ONE
        ] : [
            1,
            1
        ];
        const s = [];
        for (const e2 of t.ops){
            const t1 = zl(e2);
            t1 ? a = Ol(a, t1) : s.push(e2);
        }
        if (!Nl(a)) return e1.mul([
            null !== (r = uc(e1, e1.number(a), n)) && void 0 !== r ? r : e1._ONE,
            e1.power(null !== (o = lc(e1, e1.mul(s), i, n)) && void 0 !== o ? o : e1.mul(s), i)
        ]);
    }
    if ("Power" === t.head) {
        if (-1 === Zs(t.op2) && -1 === Zs(i)) return t.op1;
        const r1 = zl(t.op2), o1 = zl(i);
        if (r1 && o1) {
            const i1 = Ol(r1, o1);
            return Ml(i1) ? e1._ONE : Nl(i1) ? t.op1 : e1.power(t.op1, i1);
        }
        if ("N" === n) {
            const n1 = Us(t.op2), r2 = Us(i);
            if (null !== n1 && null !== r2) {
                const i2 = n1 * r2;
                return 0 === i2 ? e1._ONE : 1 === i2 ? t.op1 : e1.power(t.op1, i2);
            }
        }
    }
    if ("N" !== n && null !== t.numericValue && t.isInteger) {
        if (Zs(i)) return sc(e1, t, i);
        const n2 = zl(i);
        if (n2) {
            const [r3, o2] = [
                Al(n2),
                Cl(n2)
            ];
            if (!(1 !== r3 && -1 !== r3 || 2 !== o2 && 3 !== o2)) {
                if (il(e1) || t.numericValue instanceof oa) {
                    const n3 = Gs(t);
                    if (o2 % 2 == 0 && n3.isNeg() && !nl(e1)) return e1._NAN;
                    const a1 = n3.isNegative() ? o2 % 2 == 0 ? e1._I : e1._NEGATIVE_ONE : e1._ONE, [s1, l] = yl(e1, n3.abs(), o2);
                    if (l.eq(1) && s1.eq(1)) return a1;
                    if (!s1.eq(1)) return l.eq(1) ? e1.mul([
                        a1,
                        e1.number(r3 >= 0 ? s1 : [
                            e1.bignum(1),
                            s1
                        ])
                    ]) : e1.mul([
                        a1,
                        e1.number(s1),
                        e1.power(e1.number(l), i)
                    ]);
                } else if ("number" == typeof t.numericValue) {
                    if (t.numericValue < 0 && o2 % 2 == 0 && !nl(e1)) return e1._NAN;
                    const [n4, a2] = Ps(Math.abs(t.numericValue), o2), s2 = t.numericValue < 0 ? o2 % 2 == 0 ? e1._I : e1._NEGATIVE_ONE : e1._ONE;
                    if (1 === a2 && 1 === n4) return s2;
                    if (1 !== n4) return 1 === a2 ? e1.mul([
                        s2,
                        e1.number(r3 >= 0 ? n4 : [
                            1,
                            n4
                        ])
                    ]) : e1.mul([
                        s2,
                        e1.number(n4),
                        e1.power(e1.number(a2), i)
                    ]);
                }
            }
            return t.isNegative ? nl ? e1.mul([
                e1._I,
                e1.fn("Sqrt", [
                    e1.negate(t)
                ])
            ]) : e1._NAN : void 0;
        }
    }
    if ("simplify" !== n && null !== t.numericValue && null !== i.numericValue) return sc(e1, t, i);
}
function uc(e1, t, i) {
    if (t.isOne) return e1._ONE;
    if (t.isZero) return e1._ZERO;
    if (t.isNegativeOne) return nl(e1) ? e1._I : e1._NAN;
    if (t.isNegative && !nl(e1)) return e1._NAN;
    const n = zl(t);
    if ("N" === i || "evaluate" === i && !n) return nc(t, (t)=>t < 0 ? e1.complex(t).sqrt() : Math.sqrt(t), (t)=>t.isNeg() ? e1.complex(t.toNumber()).sqrt() : t.sqrt(), (e1)=>e1.sqrt());
    const r = Zs(t);
    if (null !== r) {
        const [t1, i1] = Ps(Math.abs(r), 2);
        return r < 0 ? (1 === i1 && e1.mul([
            e1.number(e1.complex(0, t1))
        ]), e1.mul([
            e1.number(e1.complex(0, t1)),
            e1.sqrt(e1.number(i1))
        ])) : 1 === i1 ? e1.number(t1) : e1.mul([
            e1.number(t1),
            e1.sqrt(e1.number(i1))
        ]);
    }
    if (n) {
        if (wl(n) && !il(e1)) {
            const [t2, i2] = n;
            if (Math.abs(t2) < Number.MAX_SAFE_INTEGER && i2 < Number.MAX_SAFE_INTEGER) {
                const [n1, r1] = Ps(Math.abs(t2), 2), [o, a] = Ps(i2, 2);
                return t2 < 0 ? e1.mul([
                    e1.number([
                        n1,
                        o
                    ]),
                    e1.sqrt(e1.number([
                        r1,
                        a
                    ])),
                    e1._I
                ]) : e1.mul([
                    e1.number([
                        n1,
                        o
                    ]),
                    e1.sqrt(e1.number([
                        r1,
                        a
                    ]))
                ]);
            }
        }
        if (Sl(n) || il(e1)) {
            const t3 = e1.bignum(n[0]), [i3, r2] = yl(e1, t3.abs(), 2), [o1, a1] = yl(e1, e1.bignum(n[1]), 2);
            return t3.isNeg() ? e1.mul([
                e1.number([
                    i3,
                    o1
                ]),
                e1.sqrt(e1.number([
                    r2,
                    a1
                ])),
                e1._I
            ]) : e1.mul([
                e1.number([
                    i3,
                    o1
                ]),
                e1.sqrt(e1.number([
                    r2,
                    a1
                ]))
            ]);
        }
    }
}
function cc(e1, t) {
    var i;
    if (0 === (t = null !== (i = ul(cl(t).map((e1)=>e1.canonical), "Multiply")) && void 0 !== i ? i : t).length) return e1.number(1);
    if (1 === t.length) return t[0];
    if (2 === t.length) return hc(t[0], t[1]);
    const n = new su(e1);
    for (const i1 of t){
        if (i1.isNaN || "Undefined" === i1.symbol) return e1._NAN;
        n.addTerm(i1);
    }
    return n.asExpression();
}
function dc(e1, t, i = "evaluate") {
    if ("N" === i && "machine" === e1.numericMode) {
        const i1 = function(e1) {
            let t = 1;
            for (const i of e1){
                if ("number" != typeof i.numericValue) return null;
                t *= i.numericValue;
            }
            return t;
        }(t = t.map((e1)=>e1.N()));
        if (null !== i1) return e1.number(i1);
    }
    for (const n of t){
        if (n.isNaN || "Undefined" === n.symbol) return e1._NAN;
        n.isExact || (i = "N");
    }
    return t = "N" === i ? t.map((e1)=>e1.N()) : t.map((e1)=>e1.evaluate()), new su(e1, t).asExpression(i);
}
function hc(e1, t, i) {
    var n;
    const r = e1.engine;
    if (null !== e1.numericValue && null !== t.numericValue && e1.isInteger && t.isInteger) return null !== (n = rc(e1, t, (e1, t)=>e1 * t, (e1, t)=>e1.mul(t))) && void 0 !== n ? n : r._NAN;
    if (e1.isNaN || t.isNaN || "Undefined" === e1.symbol || "Undefined" === t.symbol) return r._NAN;
    if (e1.isNothing) return t;
    if (t.isNothing) return e1;
    if (null !== e1.numericValue) {
        if (e1.isOne) return t;
        if (e1.isNegativeOne) return Kl(t);
    }
    if (null !== t.numericValue) {
        if (t.isOne) return e1;
        if (t.isNegativeOne) return Kl(e1);
    }
    let o = 1, [a, s] = null !== e1.numericValue ? [
        e1,
        t
    ] : [
        t,
        e1
    ];
    if ("Negate" === a.head && (a = a.op1, o = -o), null !== s.numericValue) {
        const e2 = zl(s);
        if (e2) {
            if (Nl(e2)) return a;
            if (Ml(e2)) return r._ZERO;
            if ("Add" === a.head) return o < 0 && (s = Kl(s)), r.add(a.ops.map((e1)=>hc(s, e1)), i);
            const t1 = zl(a);
            if (t1) {
                const n1 = Ol(e2, t1);
                return r.number(o < 0 ? Tl(n1) : n1, {
                    metadata: i
                });
            }
            return o < 0 ? r._fn("Multiply", [
                Kl(s),
                a
            ], i) : r._fn("Multiply", [
                s,
                a
            ], i);
        }
    }
    if (s.hash === a.hash && s.isSame(a)) return ac(r, s);
    const l = new su(r, [
        s,
        a
    ]);
    return o > 0 ? l.asExpression() : Kl(l.asExpression(), i);
}
function mc(e1, t, i, n) {
    var r, o;
    if ("Lambda" !== t.head) return;
    const a = t.op1;
    let s = 1, l = 1e6;
    if ("Tuple" !== i.head && "Triple" !== i.head && "Pair" !== i.head && "Single" !== i.head || (s = null !== (r = Zs(i.op2)) && void 0 !== r ? r : 1, l = null !== (o = Zs(i.op3)) && void 0 !== o ? o : 1e6), s >= l || l - s >= 200) return;
    if ("evaluate" === n || "simplify" === n) {
        const t1 = [];
        for(let i1 = s; i1 <= l; i1++){
            const n1 = e1.number(i1);
            t1.push(a.subs({
                _1: n1,
                _: n1
            }));
        }
        const i2 = e1.mul(t1);
        return "simplify" === n ? i2.simplify() : i2.evaluate();
    }
    let u = il(e1) ? [
        e1._BIGNUM_ONE,
        e1._BIGNUM_ONE
    ] : [
        1,
        1
    ];
    for(let t2 = s; t2 <= l; t2++){
        const i3 = e1.number(t2), n2 = a.subs({
            _1: i3,
            _: i3
        }).N();
        if (null === n2.numericValue) return;
        u = Ol(u, n2);
    }
    return wl(u) ? e1.number(u[0] / u[1]) : e1.number(u[0].div(u[1]));
}
function pc(e1, t, i) {
    if (t = pl(e1, t, "Number"), i = pl(e1, i, "Number"), !t.isValid || !i.isValid) return e1._fn("Divide", [
        t,
        i
    ]);
    if (null !== t.numericValue && null !== i.numericValue) {
        if (i.isOne) return t;
        if (i.isNegativeOne) return Kl(t);
        if (t.isOne) return e1.inverse(i);
        if (t.isNegativeOne) return Kl(e1.inverse(i));
        const n = zl(t), r = zl(i);
        if (n && r && !Ml(r)) return e1.number(Ol(n, Dl(r)));
    }
    if (!("Divide" !== t.head && "Rational" !== t.head || "Divide" !== i.head && "Rational" !== i.head)) return pc(e1, e1.mul([
        t.op1,
        i.op2
    ]), e1.mul([
        t.op2,
        i.op1
    ]));
    const n1 = t.numericValue;
    if (null !== n1) {
        if (wl(n1)) {
            const [t1, r1] = n1;
            return pc(e1, e1.mul([
                e1.number(t1),
                i
            ]), e1.number(r1));
        }
        if (Sl(n1)) {
            const [t2, r2] = n1;
            return pc(e1, e1.mul([
                e1.number(t2),
                i
            ]), e1.number(r2));
        }
    }
    const r3 = i.numericValue;
    if (null !== r3) {
        if (wl(r3)) {
            const [i1, n2] = r3;
            return pc(e1, e1.mul([
                t,
                e1.number(n2)
            ]), e1.number(i1));
        }
        if (Sl(r3)) {
            const [i2, n3] = r3;
            return pc(e1, e1.mul([
                t,
                e1.number(n3)
            ]), e1.number(i2));
        }
    }
    if ("Divide" === t.head || "Rational" === t.head) return pc(e1, e1.mul([
        t.op1,
        i
    ]), t.op2);
    if ("Divide" === i.head || "Rational" === i.head) return pc(e1, e1.mul([
        t,
        i.op2
    ]), i.op1);
    let [o, a] = ic(t), [s, l] = ic(i);
    if (a = a.canonical, l = l.canonical, null !== l.numericValue && l.isOne) return o * s < 0 ? Kl(a) : a;
    if (l = e1.inverse(l), null !== a.numericValue) {
        if (a.isOne) return l;
        if (a.isNegativeOne) return Kl(l);
    }
    return o * s > 0 ? e1.mul([
        a,
        l
    ]) : Kl(e1.mul([
        a,
        l
    ]));
}
function fc(e1, t, i) {
    if (null !== t.numericValue && null !== i.numericValue) {
        const n = zl(t), r = zl(i);
        if (n && r && !Ml(r)) return e1.number(Ol(n, Dl(r)));
    }
}
const gc = [
    {
        Abs: {
            wikidata: "Q3317982",
            threadable: !0,
            idempotent: !0,
            complexity: 1200,
            signature: {
                domain: [
                    "Function",
                    "Number",
                    "NonNegativeNumber"
                ],
                simplify: (e1, t)=>yc(e1, t[0], "simplify"),
                evaluate: (e1, t)=>yc(e1, t[0], "evaluate"),
                N: (e1, t)=>yc(e1, t[0], "N")
            }
        },
        Add: {
            wikidata: "Q32043",
            associative: !0,
            commutative: !0,
            threadable: !0,
            idempotent: !0,
            complexity: 1300,
            hold: "all",
            signature: {
                domain: "NumericFunction",
                codomain: (e1, t)=>(function(e1, t) {
                        let i = null;
                        for (const e2 of t){
                            if (!e2.isNumeric) return null;
                            i = i ? Zu(i, e2) : e2;
                        }
                        return i;
                    })(0, t.map((e1)=>e1.domain)),
                canonical: (e1, t)=>Qu(e1, t),
                simplify: (e1, t)=>(function(e1, t) {
                        const i = new zu(e1);
                        for (let n of t){
                            if (n = n.simplify(), n.isImaginary && n.isInfinity) return e1.symbol("ComplexInfinity");
                            if (n.isNaN || "Undefined" === n.symbol) return e1._NAN;
                            n.isZero || i.addTerm(n);
                        }
                        return i.asExpression("expression");
                    })(e1, t),
                evaluate: (e1, t)=>ec(e1, t),
                N: (e1, t)=>ec(e1, t, "N")
            }
        },
        Ceil: {
            description: "Rounds a number up to the next largest integer",
            complexity: 1250,
            signature: {
                domain: [
                    "Function",
                    "Number",
                    "Integer"
                ],
                evaluate: (e1, t)=>nc(t[0], Math.ceil, (e1)=>e1.ceil(), (e1)=>e1.ceil(0))
            }
        },
        Chop: {
            associative: !0,
            threadable: !0,
            idempotent: !0,
            complexity: 1200,
            signature: {
                domain: [
                    "Function",
                    "Number",
                    "Number"
                ],
                evaluate: (e1, t)=>nc(t[0], (t)=>e1.chop(t), (t)=>e1.chop(t), (t)=>e1.chop(t))
            }
        },
        Complex: {
            wikidata: "Q11567",
            complexity: 500
        },
        Divide: {
            wikidata: "Q1226939",
            complexity: 2500,
            signature: {
                domain: [
                    "Function",
                    "Number",
                    "Number",
                    "Number"
                ],
                canonical: (e1, t)=>pc(e1, t[0], t[1]),
                simplify: (e1, t)=>fc(e1, t[0], t[1])
            }
        },
        Exp: {
            wikidata: "Q168698",
            threadable: !0,
            complexity: 3500,
            signature: {
                domain: [
                    "Function",
                    "Number",
                    "Number"
                ],
                canonical: (e1, t)=>e1.power(e1.symbol("ExponentialE"), pl(e1, t[0], "Number"))
            }
        },
        Erf: {
            description: "Complementary Error Function",
            complexity: 7500
        },
        Erfc: {
            description: "Complementary Error Function",
            complexity: 7500
        },
        Factorial: {
            description: "The factorial function",
            wikidata: "Q120976",
            complexity: 9e3,
            signature: {
                domain: [
                    "Function",
                    "Number",
                    "Number"
                ],
                evaluate: (e1, t)=>{
                    const i = Zs(t[0]);
                    if (null !== i && i >= 0) return il(e1) ? e1.number(bl(e1, e1.bignum(i))) : e1.number(function(e1) {
                        if (!Number.isInteger(e1) || e1 < 0) return NaN;
                        let t = 1;
                        for(let i = 2; i <= e1; i++)t *= i;
                        return t;
                    }(i));
                    const n = t[0].numericValue;
                    if (null !== n && n instanceof la) return e1.number(n.add(1));
                    const r = Us(t[0]);
                    return null !== r ? e1.number(js(1 + r)) : void 0;
                }
            }
        },
        Floor: {
            wikidata: "Q56860783",
            complexity: 1250,
            signature: {
                domain: [
                    "Function",
                    "Number",
                    "ExtendedRealNumber"
                ],
                evaluate: (e1, t)=>nc(t[0], Math.floor, (e1)=>e1.floor(), (e1)=>e1.floor(0))
            }
        },
        Gamma: {
            wikidata: "Q190573",
            complexity: 8e3,
            signature: {
                domain: [
                    "Function",
                    "Number",
                    "Number",
                    "Number"
                ],
                N: (e1, t)=>nc(t[0], (e1)=>js(e1), (t)=>xl(e1, t), (e1)=>e1)
            }
        },
        LogGamma: {
            complexity: 8e3,
            signature: {
                domain: [
                    "Function",
                    "Number",
                    "Number",
                    "Number"
                ],
                N: (e1, t)=>nc(t[0], (e1)=>Vs(e1), (t)=>vl(e1, t), (e1)=>e1)
            }
        },
        Ln: {
            description: "Natural Logarithm",
            wikidata: "Q204037",
            complexity: 4e3,
            signature: {
                domain: [
                    "Function",
                    "Number",
                    "Number"
                ],
                N: (e1, t)=>nc(t[0], (t)=>t >= 0 ? Math.log(t) : e1.complex(t).log(), (t)=>t.isNeg() ? e1.complex(t.toNumber()).log() : t.ln(), (e1)=>e1.log())
            }
        },
        Log: {
            description: "Log(z, b = 10) = Logarithm of base b",
            wikidata: "Q11197",
            complexity: 4100,
            signature: {
                domain: [
                    "Function",
                    "Number",
                    [
                        "Maybe",
                        "Number"
                    ],
                    "Number"
                ],
                canonical: (e1, t)=>{
                    if (1 === (t = cl(t)).length) return e1._fn("Log", [
                        pl(e1, t[0].canonical, "Number")
                    ]);
                    if (2 === t.length) {
                        const i = pl(e1, t[1].canonical, "Number");
                        return 10 === i.numericValue ? e1._fn("Log", [
                            pl(e1, t[0].canonical, "Number")
                        ]) : e1._fn("Log", [
                            pl(e1, t[0].canonical, "Number"),
                            i
                        ]);
                    }
                    return e1._fn("Log", dl(e1, t, 2));
                },
                N: (e1, t)=>void 0 === t[1] ? nc(t[0], (t)=>t >= 0 ? Math.log10(t) : e1.complex(t).log().div(Math.LN10), (t)=>t.isNeg() ? e1.complex(t.toNumber()).log().div(Math.LN10) : oa.log10(t), (e1)=>e1.log().div(Math.LN10)) : rc(t[0], t[1], (e1, t)=>Math.log(e1) / Math.log(t), (e1, t)=>e1.log(t), (e1, t)=>e1.log().div("number" == typeof t ? Math.log(t) : t.log()))
            }
        },
        Lb: {
            description: "Base-2 Logarithm",
            wikidata: "Q581168",
            complexity: 4100,
            signature: {
                domain: [
                    "Function",
                    "Number",
                    "Number"
                ],
                N: (e1, t)=>nc(t[0], (t)=>t >= 0 ? Math.log2(t) : e1.complex(t).log().div(Math.LN2), (t)=>t.isNeg() ? oa.log10(t) : e1.complex(t.toNumber()).log().div(Math.LN2), (e1)=>e1.log().div(Math.LN2))
            }
        },
        Lg: {
            description: "Base-10 Logarithm",
            wikidata: "Q966582",
            complexity: 4100,
            signature: {
                domain: [
                    "Function",
                    "Number",
                    "Number"
                ],
                N: (e1, t)=>nc(t[0], (t)=>t >= 0 ? Math.log10(t) : e1.complex(t).log().div(Math.LN10), (t)=>t.isNeg() ? e1.complex(t.toNumber()).log().div(Math.LN10) : oa.log10(t), (e1)=>e1.log().div(Math.LN10))
            }
        },
        Max: {
            description: "Maximum of two or more numbers",
            complexity: 1200,
            signature: {
                domain: [
                    "Function",
                    [
                        "Sequence",
                        "Number"
                    ],
                    "Number"
                ],
                simplify: (e1, t)=>0 === t.length ? e1._NEGATIVE_INFINITY : 1 === t.length ? t[0] : e1.box([
                        "Max",
                        ...t
                    ]),
                evaluate: (e1, t)=>{
                    if (0 === t.length) return e1._NEGATIVE_INFINITY;
                    let i;
                    const n = [];
                    for (const e2 of t)e2.isNumber && void 0 !== e2.numericValue ? i && !e2.isGreater(i) || (i = e2) : n.push(e2);
                    return n.length > 0 ? e1.box(i ? [
                        "Max",
                        i,
                        ...n
                    ] : [
                        "Max",
                        ...n
                    ]) : null != i ? i : e1._NAN;
                }
            }
        },
        Min: {
            description: "Minimum of two or more numbers",
            complexity: 1200,
            signature: {
                domain: [
                    "Function",
                    [
                        "Sequence",
                        "Number"
                    ],
                    "Number"
                ],
                simplify: (e1, t)=>0 === t.length ? e1._NEGATIVE_INFINITY : 1 === t.length ? t[0] : e1.box([
                        "Min",
                        ...t
                    ]),
                evaluate: (e1, t)=>{
                    if (0 === t.length) return e1._NEGATIVE_INFINITY;
                    let i;
                    const n = [];
                    for (const e2 of t)e2.isNumber && void 0 !== e2.numericValue ? i && !e2.isLess(i) || (i = e2) : n.push(e2);
                    return n.length > 0 ? e1.box(i ? [
                        "Min",
                        i,
                        ...n
                    ] : [
                        "Min",
                        ...n
                    ]) : null != i ? i : e1._NAN;
                }
            }
        },
        Multiply: {
            wikidata: "Q40276",
            associative: !0,
            commutative: !0,
            idempotent: !0,
            complexity: 2100,
            hold: "all",
            signature: {
                domain: "NumericFunction",
                canonical: (e1, t)=>cc(e1, t),
                simplify: (e1, t)=>(function(e1, t) {
                        const i = new su(e1);
                        for (let n of t){
                            if (n = n.simplify(), n.isNaN || "Undefined" === n.symbol) return e1._NAN;
                            i.addTerm(n);
                        }
                        return i.asExpression();
                    })(e1, t),
                evaluate: (e1, t)=>dc(e1, t),
                N: (e1, t)=>dc(e1, t, "N")
            }
        },
        Negate: {
            description: "Additive Inverse",
            wikidata: "Q715358",
            complexity: 2e3,
            signature: {
                domain: [
                    "Function",
                    "Number",
                    "Number"
                ],
                codomain: (e1, t)=>{
                    const i = t[0].domain;
                    if (!i.literal) return i;
                    const n = {
                        PositiveNumber: "NegativeNumber",
                        NonNegativeNumber: "NonPositiveNumber",
                        NonPositiveNumber: "NonNegativeNumber",
                        NegativeNumber: "PositiveNumber",
                        PositiveInteger: "NegativeInteger",
                        NonNegativeInteger: "NonPositiveInteger",
                        NonPositiveInteger: "NonNegativeInteger",
                        NegativeInteger: "PositiveInteger"
                    }[i.literal];
                    return n ? e1.domain(n) : i;
                },
                canonical: (e1, t)=>Kl(t[0]),
                simplify: (e1, t)=>jl(0, t[0], "simplify"),
                evaluate: (e1, t)=>jl(0, t[0], "evaluate"),
                N: (e1, t)=>jl(0, t[0], "N"),
                sgn: (e1, t)=>{
                    const i = t[0].sgn;
                    if (null != i) return 0 === i ? 0 : i > 0 ? -1 : i < 0 ? 1 : void 0;
                }
            }
        },
        Power: {
            wikidata: "Q33456",
            commutative: !1,
            complexity: 3500,
            signature: {
                domain: [
                    "Function",
                    "Number",
                    "Number",
                    "Number"
                ],
                canonical: (e1, t)=>{
                    var i;
                    return null !== (i = oc(e1, t[0], t[1])) && void 0 !== i ? i : e1._fn("Power", t);
                },
                simplify: (e1, t)=>lc(e1, t[0], t[1], "simplify"),
                evaluate: (e1, t)=>lc(e1, t[0], t[1], "evaluate"),
                N: (e1, t)=>"machine" === e1.numericMode && "number" == typeof t[0].numericValue && "number" == typeof t[1].numericValue ? e1.number(Math.pow(t[0].numericValue, t[1].numericValue)) : lc(e1, t[0], t[1], "N")
            }
        },
        Product: {
            wikidata: "Q901718",
            complexity: 1e3,
            hold: "first",
            signature: {
                domain: [
                    "Function",
                    "Anything",
                    "Tuple",
                    "Number"
                ],
                canonical: (e1, t)=>(function(e1, t, i) {
                        var n, r, o, a, s, l, u, c;
                        null != t || (t = e1.error([
                            "missing",
                            "Function"
                        ]));
                        let d = null, h = null, m = null;
                        return i && "Tuple" !== i.head && "Triple" !== i.head && "Pair" !== i.head && "Single" !== i.head ? d = i : i && (d = null !== (r = null === (n = i.ops) || void 0 === n ? void 0 : n[0]) && void 0 !== r ? r : null, h = null !== (s = null === (a = null === (o = i.ops) || void 0 === o ? void 0 : o[1]) || void 0 === a ? void 0 : a.canonical) && void 0 !== s ? s : null, m = null !== (c = null === (u = null === (l = i.ops) || void 0 === l ? void 0 : l[2]) || void 0 === u ? void 0 : u.canonical) && void 0 !== c ? c : null), d && "Hold" === d.head && (d = d.op1), d && "ReleaseHold" === d.head && (d = d.op1.evaluate()), null != d || (d = e1.symbol("Nothing")), d = d.symbol ? e1.hold(d) : e1.error([
                            "incompatible-domain",
                            "Symbol",
                            d.domain
                        ]), h && (h = pl(e1, h, "ExtendedRealNumber")), m && (h = pl(e1, m, "ExtendedRealNumber")), i = h && m ? e1.tuple([
                            d,
                            h,
                            m
                        ]) : m ? e1.tuple([
                            d,
                            null != h ? h : e1._NEGATIVE_INFINITY,
                            m
                        ]) : h ? e1.tuple([
                            d,
                            h
                        ]) : d, e1._fn("Product", [
                            t,
                            i
                        ]);
                    })(e1, t[0], t[1]),
                simplify: (e1, t)=>mc(e1, t[0], t[1], "simplify"),
                evaluate: (e1, t)=>mc(e1, t[0], t[1], "evaluate"),
                N: (e1, t)=>mc(e1, t[0], t[1], "N")
            }
        },
        Rational: {
            complexity: 2400,
            signature: {
                domain: [
                    "Function",
                    "Number",
                    [
                        "Maybe",
                        "Number"
                    ],
                    "RationalNumber"
                ],
                canonical: (e1, t)=>{
                    var i;
                    return 0 === (t = cl(t)).length ? e1._fn("Rational", [
                        e1.error([
                            "missing",
                            "Number"
                        ])
                    ]) : 1 === t.length ? e1._fn("Rational", [
                        pl(e1, t[0].canonical, "ExtendedRealNumber")
                    ]) : 2 === (t = null !== (i = ml(e1.domain([
                        "Function",
                        "Integer",
                        "Integer",
                        "RationalNumber"
                    ]), t)) && void 0 !== i ? i : t).length && t[0].isValid && t[1].isValid ? pc(e1, t[0], t[1]) : e1._fn("Rational", t);
                },
                simplify: (e1, t)=>{
                    if (2 === t.length) return fc(e1, t[0], t[1]);
                },
                evaluate: (e1, t)=>{
                    if (2 === t.length) {
                        const [i, n] = [
                            Zs(t[0]),
                            Zs(t[1])
                        ];
                        return null !== i && null !== n ? e1.number([
                            i,
                            n
                        ]) : void 0;
                    }
                    const i1 = Us(t[0].N());
                    if (null !== i1) return e1.number(function(e1) {
                        if (!Number.isFinite(e1)) return e1;
                        if (0 == e1 % 1) return e1;
                        let t = Math.floor(e1), i = 1, n = 0, r = t, o = 1;
                        for(; e1 - t > 1e-15 * o * o;){
                            t = Math.floor(e1 = 1 / (e1 - t));
                            const a = i;
                            i = r;
                            const s = n;
                            n = o, r = a + t * i, o = s + t * n;
                        }
                        return [
                            r,
                            o
                        ];
                    }(i1));
                },
                N: (e1, t)=>1 === t.length ? t[0] : rc(t[0], t[1], (e1, t)=>e1 / t, (e1, t)=>e1.div(t), (e1, t)=>e1.div(t))
            }
        },
        Root: {
            complexity: 3200,
            signature: {
                domain: [
                    "Function",
                    "Number",
                    "Number",
                    "Number"
                ],
                canonical: (e1, t)=>{
                    var i, n, r;
                    if ((t = cl(t)).length > 2) return e1._fn("Root", dl(e1, t, 2));
                    const [o, a] = [
                        pl(e1, null === (i = t[0]) || void 0 === i ? void 0 : i.canonical, "Number"),
                        pl(e1, null === (n = t[1]) || void 0 === n ? void 0 : n.canonical, "Number")
                    ];
                    return a.isValid && o.isValid ? null !== (r = oc(e1, o, e1.inverse(a))) && void 0 !== r ? r : e1._fn("Power", [
                        o,
                        e1.inverse(a)
                    ]) : e1._fn("Root", [
                        o,
                        a
                    ]);
                }
            }
        },
        Round: {
            complexity: 1250,
            signature: {
                domain: [
                    "Function",
                    "Number",
                    "Number"
                ],
                evaluate: (e1, t)=>nc(t[0], Math.round, (e1)=>e1.round(), (e1)=>e1.round(0))
            }
        },
        Sign: {
            complexity: 1200,
            signature: {
                domain: [
                    "Function",
                    "Number",
                    [
                        "Range",
                        -1,
                        1
                    ]
                ],
                simplify: (e1, t)=>{
                    const i = t[0].sgn;
                    return 0 === i ? e1._ZERO : 1 === i ? e1._ONE : -1 === i ? e1._NEGATIVE_ONE : void 0;
                },
                evaluate: (e1, t)=>{
                    const i = t[0].sgn;
                    return 0 === i ? e1._ZERO : 1 === i ? e1._ONE : -1 === i ? e1._NEGATIVE_ONE : void 0;
                },
                N: (e1, t)=>{
                    const i = t[0].sgn;
                    return 0 === i ? e1._ZERO : 1 === i ? e1._ONE : -1 === i ? e1._NEGATIVE_ONE : void 0;
                }
            }
        },
        SignGamma: {
            description: "The sign of the gamma function: -1 or +1",
            complexity: 7900
        },
        Sqrt: {
            description: "Square Root",
            wikidata: "Q134237",
            complexity: 3e3,
            signature: {
                domain: [
                    "Function",
                    "Number",
                    "Number"
                ],
                canonical: (e1, t)=>{
                    var i;
                    return null !== (i = oc(e1, t[0], e1._HALF)) && void 0 !== i ? i : e1._fn("Power", [
                        t[0],
                        e1._HALF
                    ]);
                },
                simplify: (e1, t)=>uc(e1, t[0], "simplify"),
                evaluate: (e1, t)=>uc(e1, t[0], "evaluate"),
                N: (e1, t)=>uc(e1, t[0], "N")
            }
        },
        Square: {
            wikidata: "Q3075175",
            complexity: 3100,
            signature: {
                domain: [
                    "Function",
                    "Number",
                    "Number"
                ],
                canonical: (e1, t)=>{
                    var i;
                    return null !== (i = oc(e1, t[0], e1.number(2))) && void 0 !== i ? i : e1._fn("Power", [
                        t[0],
                        e1.number(2)
                    ]);
                }
            }
        },
        Subtract: {
            wikidata: "Q40754",
            complexity: 1350,
            signature: {
                domain: [
                    "Function",
                    "Number",
                    [
                        "Maybe",
                        "Number"
                    ],
                    "Number"
                ],
                canonical: (e1, t)=>1 === (t = cl(t.map((e1)=>e1.canonical))).length ? Kl(t[0]) : 2 !== (t = dl(e1, t, 2)).length ? e1._fn("Subtract", t) : t.every((e1)=>e1.isValid) ? Qu(e1, [
                        t[0],
                        Kl(t[1])
                    ]) : e1._fn("Subtract", t)
            }
        },
        Sum: {
            wikidata: "Q218005",
            complexity: 1e3,
            hold: "all",
            signature: {
                domain: [
                    "Function",
                    "Anything",
                    "Tuple",
                    "Number"
                ],
                canonical: (e1, t)=>(function(e1, t, i) {
                        var n, r, o, a, s, l, u, c, d;
                        null != t || (t = e1.error([
                            "missing",
                            "Function"
                        ]));
                        let h = null, m = null, p = null;
                        i && "Tuple" !== i.head && "Triple" !== i.head && "Pair" !== i.head && "Single" !== i.head ? h = i : i && (h = null !== (r = null === (n = i.ops) || void 0 === n ? void 0 : n[0]) && void 0 !== r ? r : null, m = null !== (s = null === (a = null === (o = i.ops) || void 0 === o ? void 0 : o[1]) || void 0 === a ? void 0 : a.canonical) && void 0 !== s ? s : null, p = null !== (c = null === (u = null === (l = i.ops) || void 0 === l ? void 0 : l[2]) || void 0 === u ? void 0 : u.canonical) && void 0 !== c ? c : null), "Hold" === (null == h ? void 0 : h.head) && (h = h.op1), "ReleaseHold" === (null == h ? void 0 : h.head) && (h = null === (d = h.op1) || void 0 === d ? void 0 : d.evaluate()), null != h || (h = e1.symbol("Nothing")), h.symbol || (h = e1.error([
                            "incompatible-domain",
                            "Symbol",
                            h.domain
                        ])), h.symbol && e1.pushScope({
                            [h.symbol]: {
                                domain: "Integer"
                            }
                        });
                        const f = t.canonical;
                        return h.symbol && (e1.popScope(), h = h = e1.hold(h)), i = m && p ? e1.tuple([
                            h,
                            m,
                            p
                        ]) : p ? e1.tuple([
                            h,
                            null != m ? m : e1._NEGATIVE_INFINITY,
                            p
                        ]) : m ? e1.tuple([
                            h,
                            m
                        ]) : h, e1._fn("Sum", [
                            f,
                            i
                        ]);
                    })(e1, t[0], t[1]),
                simplify: (e1, t)=>tc(e1, t[0], t[1], "simplify"),
                evaluate: (e1, t)=>tc(e1, t[0], t[1], "evaluate"),
                N: (e1, t)=>tc(e1, t[0], t[1], "N")
            }
        }
    },
    {
        e: {
            domain: "TranscendentalNumber",
            constant: !0,
            holdUntil: "never",
            value: "ExponentialE"
        },
        i: {
            domain: "ImaginaryNumber",
            constant: !0,
            holdUntil: "never",
            flags: {
                imaginary: !0
            },
            value: "ImaginaryUnit"
        },
        MachineEpsilon: {
            domain: "RealNumber",
            holdUntil: "N",
            constant: !0,
            flags: {
                real: !0
            },
            value: {
                num: Number.EPSILON.toString()
            }
        },
        Half: {
            constant: !0,
            holdUntil: "never",
            value: [
                "Rational",
                1,
                2
            ]
        },
        ImaginaryUnit: {
            domain: "ImaginaryNumber",
            constant: !0,
            holdUntil: "evaluate",
            wikidata: "Q193796",
            flags: {
                imaginary: !0
            },
            value: [
                "Complex",
                0,
                1
            ]
        },
        ExponentialE: {
            domain: "TranscendentalNumber",
            flags: {
                algebraic: !1,
                real: !0
            },
            wikidata: "Q82435",
            constant: !0,
            holdUntil: "N",
            value: (e1)=>il(e1) ? e1._BIGNUM_ONE.exp() : Math.exp(1)
        },
        GoldenRatio: {
            domain: "AlgebraicNumber",
            wikidata: "Q41690",
            constant: !0,
            flags: {
                algebraic: !0
            },
            holdUntil: "simplify",
            value: [
                "Divide",
                [
                    "Add",
                    1,
                    [
                        "Sqrt",
                        5
                    ]
                ],
                2
            ]
        },
        CatalanConstant: {
            domain: "RealNumber",
            flags: {
                algebraic: void 0
            },
            wikidata: "Q855282",
            constant: !0,
            holdUntil: "N",
            value: {
                num: "0.91596559417721901505460351493238411077414937428167\n                  21342664981196217630197762547694793565129261151062\n                  48574422619196199579035898803325859059431594737481\n                  15840699533202877331946051903872747816408786590902\n                  47064841521630002287276409423882599577415088163974\n                  70252482011560707644883807873370489900864775113225\n                  99713434074854075532307685653357680958352602193823\n                  23950800720680355761048235733942319149829836189977\n                  06903640418086217941101917532743149978233976105512\n                  24779530324875371878665828082360570225594194818097\n                  53509711315712615804242723636439850017382875977976\n                  53068370092980873887495610893659771940968726844441\n                  66804621624339864838916280448281506273022742073884\n                  31172218272190472255870531908685735423498539498309\n                  91911596738846450861515249962423704374517773723517\n                  75440708538464401321748392999947572446199754961975\n                  87064007474870701490937678873045869979860644874974\n                  64387206238513712392736304998503539223928787979063\n                  36440323547845358519277777872709060830319943013323\n                  16712476158709792455479119092126201854803963934243\n                  "
            }
        },
        EulerGamma: {
            domain: "RealNumber",
            flags: {
                algebraic: void 0
            },
            wikidata: "Q273023",
            holdUntil: "N",
            constant: !0,
            value: {
                num: "0.57721566490153286060651209008240243104215933593992359880576723488486772677766\n          467093694706329174674951463144724980708248096050401448654283622417399764492353\n          625350033374293733773767394279259525824709491600873520394816567085323315177661\n          152862119950150798479374508570574002992135478614669402960432542151905877553526\n          733139925401296742051375413954911168510280798423487758720503843109399736137255\n          306088933126760017247953783675927135157722610273492913940798430103417771778088\n          154957066107501016191663340152278935867965497252036212879226555953669628176388\n          792726801324310104765059637039473949576389065729679296010090151251959509222435\n          014093498712282479497471956469763185066761290638110518241974448678363808617494\n          551698927923018773910729457815543160050021828440960537724342032854783670151773\n          943987003023703395183286900015581939880427074115422278197165230110735658339673"
            }
        }
    },
    {
        PreIncrement: {
            signature: {
                domain: [
                    "Function",
                    "Number",
                    "Number"
                ]
            }
        },
        PreDecrement: {
            signature: {
                domain: [
                    "Function",
                    "Number",
                    "Number"
                ]
            }
        }
    }
];
function yc(e1, t, i) {
    if ("simplify" !== i) {
        const n = t.numericValue;
        if (null !== n) {
            if ("number" == typeof n) return e1.number(Math.abs(n));
            if (n instanceof oa) return e1.number(n.abs());
            if (n instanceof la) return e1.number(n.abs());
            if (wl(n)) return e1.number("N" === i ? Math.abs(n[0] / n[1]) : [
                Math.abs(n[0]),
                n[1]
            ]);
            if (Sl(n)) {
                const [t1, r] = n;
                return e1.number("N" === i ? t1.div(r).abs() : [
                    t1.abs(),
                    r
                ]);
            }
        }
    }
    return t.isNonNegative ? t : t.isNegative ? e1.negate(t) : void 0;
}
const bc = [
    {
        Integrate: {
            wikidata: "Q80091",
            hold: "all",
            signature: {
                domain: [
                    "Function",
                    "Anything",
                    [
                        "Union",
                        "Nothing",
                        "Tuple",
                        "Symbol"
                    ],
                    "Number"
                ],
                canonical: (e1, t)=>{
                    var i, n, r, o, a, s, l, u, c;
                    const d = null !== (i = t[0]) && void 0 !== i ? i : e1.error([
                        "missing",
                        "Function"
                    ]);
                    let h = t[1], m = null, p = null, f = null;
                    return h && "Tuple" !== h.head && "Triple" !== h.head && "Pair" !== h.head && "Single" !== h.head ? m = h : h && (m = null !== (r = null === (n = h.ops) || void 0 === n ? void 0 : n[0]) && void 0 !== r ? r : null, p = null !== (s = null === (a = null === (o = h.ops) || void 0 === o ? void 0 : o[1]) || void 0 === a ? void 0 : a.canonical) && void 0 !== s ? s : null, f = null !== (c = null === (u = null === (l = h.ops) || void 0 === l ? void 0 : l[2]) || void 0 === u ? void 0 : u.canonical) && void 0 !== c ? c : null), m && "Hold" === m.head && (m = m.op1), m && "ReleaseHold" === m.head && (m = m.op1.evaluate()), null != m || (m = e1.symbol("Nothing")), m.symbol || (m = e1.error([
                        "incompatible-domain",
                        "Symbol",
                        m.domain
                    ])), p && (p = pl(e1, p, "Number")), f && (f = pl(e1, f, "Number")), h = p && f ? e1.tuple([
                        m,
                        p,
                        f
                    ]) : f ? e1.tuple([
                        m,
                        e1._NEGATIVE_INFINITY,
                        f
                    ]) : p ? e1.tuple([
                        m,
                        p
                    ]) : m, e1._fn("Integrate", [
                        d,
                        h
                    ]);
                }
            }
        }
    }
], vc = [
    {
        Nothing: {
            domain: "Nothing"
        }
    },
    {
        List: {
            complexity: 8200,
            signature: {
                domain: [
                    "Function",
                    [
                        "Maybe",
                        [
                            "Sequence",
                            "Anything"
                        ]
                    ],
                    "List"
                ]
            }
        },
        KeyValuePair: {
            description: "A key/value pair",
            complexity: 8200,
            signature: {
                domain: [
                    "Function",
                    "String",
                    "Anything",
                    [
                        "Tuple",
                        "String",
                        "Anything"
                    ]
                ],
                codomain: (e1, t)=>e1.domain([
                        "Tuple",
                        "String",
                        t[1].domain
                    ]),
                canonical: (e1, t)=>{
                    var i, n;
                    const r = pl(e1, null === (i = t[0]) || void 0 === i ? void 0 : i.canonical, "String"), o = pl(e1, null === (n = t[1]) || void 0 === n ? void 0 : n.canonical, "Value");
                    return e1.tuple([
                        r,
                        o
                    ]);
                }
            }
        },
        Single: {
            description: "A tuple with a single element",
            complexity: 8200,
            signature: {
                domain: [
                    "Function",
                    "Anything",
                    [
                        "Tuple",
                        "Anything"
                    ]
                ],
                codomain: (e1, t)=>e1.domain([
                        "Tuple",
                        t[0].domain
                    ]),
                canonical: (e1, t)=>e1.tuple(dl(e1, t.map((e1)=>e1.canonical), 1))
            }
        },
        Pair: {
            description: "A tuple of two elements",
            complexity: 8200,
            signature: {
                domain: [
                    "Function",
                    "Anything",
                    "Anything",
                    [
                        "Tuple",
                        "Anything",
                        "Anything"
                    ]
                ],
                codomain: (e1, t)=>e1.domain([
                        "Tuple",
                        t[0].domain,
                        t[1].domain
                    ]),
                canonical: (e1, t)=>e1.tuple(dl(e1, t.map((e1)=>e1.canonical), 2))
            }
        },
        Triple: {
            description: "A tuple of three elements",
            complexity: 8200,
            signature: {
                domain: [
                    "Function",
                    "Anything",
                    "Anything",
                    "Anything",
                    [
                        "Tuple",
                        "Anything",
                        "Anything",
                        "Anything"
                    ]
                ],
                codomain: (e1, t)=>e1.domain([
                        "Tuple",
                        t[0].domain,
                        t[1].domain,
                        t[2].domain
                    ]),
                canonical: (e1, t)=>e1.tuple(dl(e1, t.map((e1)=>e1.canonical), 3))
            }
        },
        Tuple: {
            description: "A fixed number of heterogeneous elements",
            complexity: 8200,
            signature: {
                domain: [
                    "Function",
                    [
                        "Sequence",
                        "Anything"
                    ],
                    [
                        "Tuple",
                        [
                            "Sequence",
                            "Anything"
                        ]
                    ]
                ],
                canonical: (e1, t)=>e1.tuple(t.map((e1)=>e1.canonical)),
                codomain: (e1, t)=>e1.domain([
                        "Tuple",
                        ...t.map((e1)=>e1.domain)
                    ])
            }
        }
    },
    {
        BaseForm: {
            description: "`BaseForm(expr, base=10)`",
            complexity: 9e3,
            inert: !0,
            signature: {
                domain: [
                    "Function",
                    "Value",
                    [
                        "Maybe",
                        "Integer"
                    ],
                    "Value"
                ],
                codomain: (e1, t)=>t[0].domain
            }
        },
        Delimiter: {
            complexity: 9e3,
            hold: "first",
            signature: {
                domain: [
                    "Function",
                    "Anything",
                    [
                        "Maybe",
                        "String"
                    ],
                    [
                        "Maybe",
                        "String"
                    ],
                    "Anything"
                ],
                codomain: (e1, t)=>t[0].domain,
                canonical: (e1, t)=>{
                    var i, n;
                    return null !== (n = null === (i = t[0]) || void 0 === i ? void 0 : i.canonical) && void 0 !== n ? n : e1.box([
                        "Sequence"
                    ]);
                }
            }
        },
        Error: {
            complexity: 500,
            signature: {
                domain: [
                    "Function",
                    "Anything",
                    [
                        "Maybe",
                        "Anything"
                    ],
                    "Void"
                ],
                canonical: (e1, t)=>e1._fn("Error", t)
            }
        },
        ErrorCode: {
            complexity: 500,
            hold: "all",
            signature: {
                domain: [
                    "Function",
                    "String",
                    [
                        "Maybe",
                        [
                            "Sequence",
                            "Anything"
                        ]
                    ],
                    "Anything"
                ],
                canonical: (e1, t)=>{
                    var i, n;
                    const r = pl(e1, t[0], "String").string;
                    return "incompatible-domain" === r ? e1._fn("ErrorCode", [
                        e1.string(r),
                        e1.domain(null !== (i = t[1]) && void 0 !== i ? i : "Anything"),
                        e1.domain(null !== (n = t[2]) && void 0 !== n ? n : "Anything")
                    ]) : e1._fn("ErrorCode", t);
                }
            }
        },
        Hold: {
            hold: "all",
            signature: {
                domain: "Function",
                codomain: (e1, t)=>t[0].symbol ? e1.domain("Symbol") : e1.domain("Anything"),
                canonical: (e1, t)=>1 !== t.length ? e1._fn("Hold", dl(e1, t, 1)) : e1._fn("Hold", [
                        pl(e1, t[0], "Anything")
                    ])
            }
        },
        HorizontalSpacing: {
            signature: {
                domain: "Function",
                canonical: (e1, t)=>2 === t.length ? t[0].canonical : e1.box([
                        "Sequence"
                    ])
            }
        },
        Style: {
            complexity: 9e3,
            inert: !0,
            signature: {
                domain: [
                    "Function",
                    "Anything",
                    [
                        "Maybe",
                        "Dictionary"
                    ],
                    "Anything"
                ]
            }
        }
    },
    {
        Apply: {
            signature: {
                domain: "Function",
                evaluate: (e1, t)=>ku(t[0], t.slice(1))
            }
        },
        About: {
            signature: {
                domain: "Function"
            }
        },
        Block: {
            signature: {
                domain: "Function"
            }
        },
        Domain: {
            signature: {
                domain: [
                    "Function",
                    "Anything",
                    "Domain"
                ],
                canonical: (e1, t)=>e1.domain(dl(e1, t.map((e1)=>e1.canonical), 1)[0])
            }
        },
        Evaluate: {
            hold: "all",
            signature: {
                domain: [
                    "Function",
                    "Anything",
                    "Anything"
                ],
                codomain: (e1, t)=>t[0].domain,
                canonical: (e1, t)=>e1._fn("Evaluate", dl(e1, t.map((e1)=>e1.canonical), 1)),
                evaluate: (e1, t)=>t[0].evaluate()
            }
        },
        Head: {
            signature: {
                domain: "Function",
                evaluate: (e1, t)=>{
                    var i;
                    const n = t[0];
                    return "string" == typeof (null == n ? void 0 : n.head) ? e1.symbol(n.head) : null !== (i = null == n ? void 0 : n.head) && void 0 !== i ? i : e1.symbol("Nothing");
                }
            }
        },
        Html: {
            signature: {
                domain: [
                    "Function",
                    "Value",
                    "String"
                ],
                evaluate: (e1, t)=>(t.length, e1.string(""))
            }
        },
        Lambda: {
            wikidata: "Q567612",
            hold: "all",
            signature: {
                domain: [
                    "Function",
                    "Anything",
                    "Function"
                ],
                codomain: (e1, t)=>t[0].domain,
                canonical: (e1, t)=>e1._fn("Lambda", dl(e1, t, 1))
            }
        },
        Signatures: {
            signature: {
                domain: [
                    "Function",
                    "Symbol",
                    [
                        "Maybe",
                        [
                            "List",
                            "Domain"
                        ]
                    ]
                ],
                canonical: (e1, t)=>(t = dl(e1, t, 1))[0].symbol ? e1._fn("Signatures", t) : e1._fn("Signatures", [
                        e1.error([
                            "incompatible-domain",
                            "Symbol",
                            t[0].domain
                        ], t[0])
                    ]),
                evaluate: (e1, t)=>{
                    const i = t[0].symbol;
                    if (!i) return e1.symbol("Nothing");
                    const n = e1.lookupFunction(i);
                    return n ? e1.fn("List", [
                        n.signature.domain
                    ]) : e1.symbol("Nothing");
                }
            }
        },
        Subscript: {
            hold: "last",
            signature: {
                domain: [
                    "Function",
                    "Anything",
                    "Anything",
                    "Anything"
                ],
                codomain: (e1, t)=>(t[0].isFunction, t[0].domain),
                canonical: (e1, t)=>{
                    var i, n, r, o;
                    const a = t[0], s = t[1];
                    if (a.string) {
                        const t1 = Zs(s);
                        if (null !== t1 && t1 > 1 && t1 <= 36) {
                            const [i1, n1] = Hs(a.string, t1);
                            return n1 ? e1.error([
                                "unexpected-digit",
                                n1[0]
                            ], [
                                "Latex",
                                e1.string(a.string)
                            ]) : e1.number(i1);
                        }
                    }
                    if (a.symbol) {
                        if (null === (i = a.symbolDefinition) || void 0 === i ? void 0 : i.at) return e1._fn("At", [
                            a,
                            s.canonical
                        ]);
                        const t2 = null !== (r = null !== (n = s.string) && void 0 !== n ? n : s.symbol) && void 0 !== r ? r : null === (o = Zs(s)) || void 0 === o ? void 0 : o.toString();
                        if (t2) return e1.symbol(a.symbol + "_" + t2);
                    }
                    return "Sequence" === s.head && e1._fn("Subscript", [
                        a,
                        e1._fn("List", s.ops)
                    ]), e1._fn("Subscript", t);
                }
            }
        },
        Symbol: {
            complexity: 500,
            description: "Construct a new symbol with a name formed by concatenating the arguments",
            threadable: !0,
            hold: "all",
            signature: {
                domain: [
                    "Function",
                    [
                        "Sequence",
                        "Anything"
                    ],
                    "Anything"
                ],
                canonical: (e1, t)=>{
                    if (0 === t.length) return e1.symbol("Nothing");
                    const i = t.map((e1)=>{
                        var t, i, n, r;
                        return null !== (r = null !== (i = null !== (t = e1.symbol) && void 0 !== t ? t : e1.string) && void 0 !== i ? i : null === (n = Zs(e1)) || void 0 === n ? void 0 : n.toString()) && void 0 !== r ? r : "";
                    }).join("");
                    return i.length > 0 ? e1.symbol(i) : e1.symbol("Nothing");
                }
            }
        },
        Tail: {
            signature: {
                domain: [
                    "Function",
                    "Value",
                    [
                        "List",
                        "Value"
                    ]
                ],
                evaluate: (e1, t)=>{
                    var i;
                    return t[0] ? e1._fn("List", null !== (i = t[0].ops) && void 0 !== i ? i : []) : e1._fn("List", []);
                }
            }
        },
        Timing: {
            description: "`Timing(expr)` evaluates `expr` and return a `Pair` of the number of second elapsed for the evaluation, and the value of the evaluation",
            signature: {
                domain: [
                    "Function",
                    "Value",
                    [
                        "Maybe",
                        "Integer"
                    ],
                    [
                        "Tuple",
                        "Value",
                        "Number"
                    ]
                ],
                evaluate: (e1, t)=>{
                    var i;
                    if ("Nothing" === t[1].symbol) {
                        const i1 = globalThis.performance.now(), n = t[0].evaluate(), r = 1e3 * (globalThis.performance.now() - i1);
                        return e1.pair(e1.number(r), n);
                    }
                    let n1, r1 = Math.max(3, Math.round(null !== (i = Zs(t[1])) && void 0 !== i ? i : 3)), o = [];
                    for(; r1 > 0;){
                        const e2 = globalThis.performance.now();
                        n1 = t[0].evaluate(), o.push(1e3 * (globalThis.performance.now() - e2)), r1 -= 1;
                    }
                    const a = Math.max(...o), s = Math.min(...o);
                    o = o.filter((e1)=>e1 > s && e1 < a);
                    const l = o.reduce((e1, t)=>e1 + t, 0);
                    return 0 === l ? e1.pair(e1.number(a), n1) : e1.pair(e1.number(l / o.length), n1);
                }
            }
        }
    },
    {
        FromDigits: {
            description: "`FromDigits(s, base=10)`       return an integer representation of the string `s` in base `base`.",
            signature: {
                domain: [
                    "Function",
                    "String",
                    [
                        "Maybe",
                        [
                            "Range",
                            1,
                            36
                        ]
                    ],
                    "Integer"
                ],
                evaluate: (e1, t)=>{
                    const i = t[0];
                    if (!i.string) return e1.error([
                        "incompatible-domain",
                        "String",
                        i.domain
                    ], i);
                    const n = t[1];
                    if (n.isNothing) return e1.number(Number.parseInt(i.string, 10));
                    if (null === n.numericValue) return e1.error([
                        "unexpected-base",
                        n.latex
                    ], n);
                    const r = Us(n);
                    if (!Number.isInteger(r) || r < 2 || r > 36) return e1.error([
                        "unexpected-base",
                        r
                    ], n);
                    const [o, a] = Hs(i.string, r);
                    return a ? e1.error([
                        "unexpected-digit",
                        a[0]
                    ], {
                        str: a
                    }) : e1.number(o);
                }
            }
        },
        IntegerString: {
            description: "`IntegerString(n, base=10)`       return a string representation of the integer `n` in base `base`.",
            signature: {
                domain: [
                    "Function",
                    "Integer",
                    [
                        "Maybe",
                        "Integer"
                    ],
                    "String"
                ],
                evaluate: (e1, t)=>{
                    var i, n;
                    const r = t[0], o = null !== (i = Us(r)) && void 0 !== i ? i : NaN;
                    if (Number.isNaN(o) || !Number.isInteger(o)) return void e1.signal(e1._fn("IntegerString", t), `Expected first argument as an integer. Got \\(${r.latex}$\\)`);
                    const a = t[1];
                    if (a.isNothing) {
                        const t1 = r.numericValue;
                        return "number" == typeof t1 ? e1.string(Math.abs(t1).toString()) : t1 instanceof oa ? e1.string(t1.abs().toString()) : e1.string(Math.abs(Math.round(null !== (n = Us(r)) && void 0 !== n ? n : NaN)).toString());
                    }
                    if (null === Zs(a)) return void e1.signal(e1._fn("IntegerString", t), `Expected \`base\` as an integer between 2 and 36. Got \\(${a.latex}$\\)`);
                    const s = Zs(a);
                    if (!(s < 2 || s > 36)) return e1.string(Math.abs(o).toString(s));
                    e1.signal(e1._fn("IntegerString", t), "Expected `base` as an integer between 2 and 36. Got " + s);
                }
            }
        },
        String: {
            threadable: !0,
            signature: {
                domain: [
                    "Function",
                    [
                        "Maybe",
                        "Anything"
                    ],
                    "String"
                ],
                evaluate: (e1, t)=>0 === t.length ? e1.string("") : e1.string(t.map((e1)=>{
                        var t;
                        return null !== (t = e1.string) && void 0 !== t ? t : e1.toString();
                    }).join(""))
            }
        }
    },
    {
        JoinLatexTokens: {
            signature: {
                domain: [
                    "Function",
                    [
                        "Maybe",
                        [
                            "Sequence",
                            "Anything"
                        ]
                    ],
                    "String"
                ],
                evaluate: (e1, t)=>e1.box([
                        "Latex",
                        e1.string(fa(t.map((e1)=>{
                            var t;
                            return null !== (t = e1.string) && void 0 !== t ? t : e1.latex;
                        })))
                    ])
            }
        },
        Latex: {
            signature: {
                domain: [
                    "Function",
                    [
                        "Maybe",
                        [
                            "Sequence",
                            "Anything"
                        ]
                    ],
                    "String"
                ],
                evaluate: (e1, t)=>0 === t.length ? e1.string("") : e1.string(pa(t.map((e1)=>{
                        var t;
                        return null !== (t = e1.string) && void 0 !== t ? t : e1.toString();
                    })))
            }
        },
        SerializeLatex: {
            hold: "all",
            signature: {
                domain: [
                    "Function",
                    [
                        "Maybe",
                        [
                            "Sequence",
                            "Anything"
                        ]
                    ],
                    "String"
                ],
                evaluate: (e1, t)=>e1.box([
                        "Latex",
                        e1.string(pa(t.map((e1)=>e1.latex)))
                    ])
            }
        },
        SplitAsLatexTokens: {
            description: "Split a LaTeX string into a list of LaTeX tokens",
            hold: "all",
            signature: {
                domain: [
                    "Function",
                    [
                        "Maybe",
                        "Anything"
                    ],
                    [
                        "List",
                        "String"
                    ]
                ],
                evaluate: (e1, t)=>{
                    var i;
                    if (0 === t.length) return e1._fn("List", []);
                    let n = "";
                    return n = "Latex" === t[0].head ? null !== (i = t[0].op1.string) && void 0 !== i ? i : "" : "LatexString" === t[0].head ? pa(t[0].ops.map((e1)=>e1.latex)) : t[0].latex, e1._fn("List", ma(n, []).map((t)=>e1.string(t)));
                }
            }
        },
        ParseLatex: {
            description: "Parse a LaTeX string and evaluate to a corresponding expression",
            signature: {
                domain: [
                    "Function",
                    [
                        "Maybe",
                        "String"
                    ],
                    "Anything"
                ],
                evaluate: (e1, t)=>{
                    var i;
                    return 0 !== t.length && t[0].string && null !== (i = e1.parse(t[0].string)) && void 0 !== i ? i : e1.box([
                        "Sequence"
                    ]);
                }
            }
        }
    }
], xc = {
    True: {
        wikidata: "Q16751793",
        domain: "Boolean",
        constant: !0
    },
    False: {
        wikidata: "Q5432619",
        domain: "Boolean",
        constant: !0
    },
    Maybe: {
        wikidata: "Q781546",
        domain: "MaybeBoolean",
        constant: !0
    },
    And: {
        wikidata: "Q191081",
        threadable: !0,
        associative: !0,
        commutative: !0,
        idempotent: !0,
        complexity: 1e4,
        signature: {
            domain: "LogicOperator",
            simplify: kc,
            evaluate: kc
        }
    },
    Or: {
        wikidata: "Q1651704",
        threadable: !0,
        associative: !0,
        commutative: !0,
        idempotent: !0,
        complexity: 1e4,
        signature: {
            domain: "LogicOperator",
            simplify: _c,
            evaluate: _c
        }
    },
    Not: {
        wikidata: "Q190558",
        involution: !0,
        complexity: 10100,
        signature: {
            domain: "LogicOperator",
            simplify: wc,
            evaluate: wc
        }
    },
    Equivalent: {
        wikidata: "Q220433",
        complexity: 10200,
        signature: {
            domain: "LogicOperator",
            simplify: Sc,
            evaluate: Sc
        }
    },
    Implies: {
        wikidata: "Q7881229",
        complexity: 10200,
        signature: {
            domain: "LogicOperator",
            simplify: Mc,
            evaluate: Mc
        }
    },
    Exists: {
        signature: {
            domain: "MaybeBoolean"
        }
    },
    If: {
        hold: "rest",
        signature: {
            domain: "Function",
            codomain: (e1, t)=>e1.domain([
                    "Union",
                    t[0],
                    t[1]
                ]),
            simplify: (e1, t)=>{
                const i = t[0];
                return i && "True" === i.symbol ? t[1] ? t[1].simplify() : e1.box("Nothing") : t[2] ? t[2].simplify() : e1.box("Nothing");
            },
            evaluate: (e1, t)=>{
                const i = t[0];
                return i && "True" === i.symbol ? t[1] ? t[1].evaluate() : e1.box("Nothing") : t[2] ? t[2].evaluate() : e1.box("Nothing");
            },
            N: (e1, t)=>{
                const i = t[0];
                return i && "True" === i.symbol ? t[1] ? t[1].N() : e1.box("Nothing") : t[2] ? t[2].N() : e1.box("Nothing");
            }
        }
    },
    Loop: {
        hold: "all",
        signature: {
            domain: "Function",
            simplify: (e1, t)=>{
                var i, n;
                return null !== (n = null === (i = t[0]) || void 0 === i ? void 0 : i.simplify()) && void 0 !== n ? n : e1.box("Nothing");
            },
            evaluate: (e1, t)=>{
                var i;
                const n = null !== (i = t[0]) && void 0 !== i ? i : e1.box("Nothing");
                if (n.isNothing) return n;
                let r, o = 0;
                do r = n.evaluate(), o += 1;
                while ("Return" !== r.head && o < e1.iterationLimit);
                return "Return" === r.head ? r.op1 : e1.error("iteration-limit-exceeded");
            },
            N: (e1, t)=>{
                const i = t[0];
                return i && "True" === i.symbol ? t[1] ? t[1].N() : e1.box("Nothing") : t[2] ? t[2].N() : e1.box("Nothing");
            }
        }
    },
    Which: {
        hold: "all",
        signature: {
            domain: "Function",
            codomain: (e1, t)=>(function(e1, t) {
                    let i = null;
                    for(let e2 = 1; e2 <= t.length - 1; e2 += 2)i = i ? Zu(i, t[e2].domain) : t[e2].domain;
                    return null != i ? i : e1.domain("Nothing");
                })(e1, t),
            evaluate: (e1, t)=>Nc(e1, t, "evaluate"),
            N: (e1, t)=>Nc(e1, t, "N")
        }
    }
};
function kc(e1, t) {
    if (0 === t.length) return e1.symbol("True");
    const i = [];
    for (const n of t){
        if ("False" === n.symbol) return e1.symbol("False");
        if ("True" !== n.symbol) {
            let t1 = !1;
            for (const r of i)if (r.isSame(n)) t1 = !0;
            else if ("Not" === n.head && n.op1.isSame(r) || "Not" === r.head && r.op1.isSame(n)) return e1.symbol("False");
            t1 || i.push(n);
        }
    }
    return 0 === i.length ? e1.symbol("True") : 1 === i.length ? i[0] : e1._fn("And", i);
}
function _c(e1, t) {
    if (0 === t.length) return e1.symbol("True");
    const i = [];
    for (const n of t){
        if ("True" === n.symbol) return e1.symbol("True");
        if ("False" !== n.symbol) {
            let t1 = !1;
            for (const r of i)if (r.isSame(n)) t1 = !0;
            else if ("Not" === n.head && n.op1.isSame(r) || "Not" === r.head && r.op1.isSame(n)) return e1.symbol("True");
            t1 || i.push(n);
        }
    }
    return 0 === i.length ? e1.symbol("True") : 1 === i.length ? i[0] : e1._fn("Or", i);
}
function wc(e1, t) {
    const i = t[0].symbol;
    return "True" === i ? e1.symbol("False") : "False" === i ? e1.symbol("True") : "Maybe" === i ? e1.symbol("Maybe") : void 0;
}
function Sc(e1, t) {
    const i = t[0].symbol, n = t[1].symbol;
    return "True" === i && "True" === n || "False" === i && "False" === n ? e1.symbol("True") : "True" === i && "False" === n || "False" === i && "True" === n ? e1.symbol("False") : "Maybe" === i || "Maybe" === n ? e1.symbol("Maybe") : void 0;
}
function Mc(e1, t) {
    const i = t[0].symbol, n = t[1].symbol;
    return "True" === i && "True" === n || "False" === i && "False" === n || "False" === i && "True" === n ? e1.symbol("True") : "True" === i && "False" === n ? e1.symbol("False") : "Maybe" === i || "Maybe" === n ? e1.symbol("Maybe") : void 0;
}
function Nc(e1, t, i) {
    let n = 0;
    for(; n < t.length - 1;){
        if ("True" === t[n].evaluate().symbol) return t[n + 1] ? "N" === i ? t[n + 1].N() : t[n + 1].evaluate() : e1.symbol("Undefined");
        n += 2;
    }
    return e1.symbol("Undefined");
}
const Lc = [
    {
        Expand: {
            description: "Expand out products and positive integer powers",
            signature: {
                domain: [
                    "Function",
                    "Value",
                    "Value"
                ],
                evaluate: (e1, t)=>Gl(t[0])
            }
        }
    }
], Ac = {
    Equal: {
        commutative: !0,
        complexity: 11e3,
        signature: {
            domain: "RelationalOperator",
            canonical: (e1, t)=>{
                var i;
                return t = null !== (i = ul(cl(t).map((e1)=>e1.canonical), "Equal")) && void 0 !== i ? i : t, e1._fn("Equal", t);
            },
            evaluate: (e1, t)=>{
                if (t.length < 2) return e1.symbol("True");
                let i;
                for (const n of t)if (i) {
                    if (!0 !== i.isEqual(n)) return e1.symbol("False");
                } else i = n;
                return e1.symbol("True");
            }
        }
    },
    NotEqual: {
        wikidata: "Q28113351",
        commutative: !0,
        complexity: 11e3,
        signature: {
            domain: "RelationalOperator",
            evaluate: (e1, t)=>{
                if (t.length < 2) return e1.symbol("False");
                let i;
                for (const n of t)if (i) {
                    if (!0 === i.isEqual(n)) return e1.symbol("False");
                } else i = n;
                return e1.symbol("True");
            }
        }
    },
    Less: {
        complexity: 11e3,
        signature: {
            domain: "RelationalOperator",
            canonical: (e1, t)=>{
                var i;
                return t = null !== (i = ul(cl(t).map((e1)=>e1.canonical), "Less")) && void 0 !== i ? i : t, e1._fn("Less", t);
            },
            evaluate: (e1, t)=>{
                if (t.length < 2) return e1.symbol("True");
                let i;
                for (const n of t){
                    if (!n.isNumber) return;
                    if (i) {
                        const t1 = e1.fn("Subtract", [
                            n,
                            i
                        ]).N().sgn;
                        if (null == t1) return;
                        if (t1 <= 0) return e1.symbol("False");
                        i = n;
                    } else i = n;
                }
                return e1.symbol("True");
            }
        }
    },
    NotLess: {
        complexity: 11e3,
        signature: {
            domain: "RelationalOperator",
            canonical: (e1, t)=>e1._fn("Not", [
                    e1._fn("Less", t)
                ])
        }
    },
    Greater: {
        complexity: 11e3,
        signature: {
            domain: "RelationalOperator",
            canonical: (e1, t)=>e1._fn("Less", t.reverse()),
            evaluate: (e1, t)=>{
                if (t.length < 2) return e1.symbol("True");
                let i;
                for (const n of t){
                    if (!n.isNumber) return;
                    if (i) {
                        const t1 = e1.fn("Subtract", [
                            n,
                            i
                        ]).N().sgn;
                        if (null == t1) return;
                        if (t1 >= 0) return e1.symbol("False");
                        i = n;
                    } else i = n;
                }
                return e1.symbol("True");
            }
        }
    },
    NotGreater: {
        complexity: 11e3,
        signature: {
            domain: "RelationalOperator",
            canonical: (e1, t)=>e1._fn("Not", [
                    e1._fn("Greater", t)
                ])
        }
    },
    LessEqual: {
        complexity: 11e3,
        signature: {
            domain: "RelationalOperator",
            evaluate: (e1, t)=>{
                if (t.length < 2) return e1.symbol("True");
                let i;
                for (const n of t){
                    if (!n.isNumber) return;
                    if (i) {
                        const t1 = e1.fn("Subtract", [
                            n,
                            i
                        ]).N().sgn;
                        if (null == t1) return;
                        if (t1 < 0) return e1.symbol("False");
                        i = n;
                    } else i = n;
                }
                return e1.symbol("True");
            }
        }
    },
    NotLessNotEqual: {
        complexity: 11e3,
        signature: {
            domain: "RelationalOperator",
            canonical: (e1, t)=>e1._fn("Not", [
                    e1._fn("LessEqual", t)
                ])
        }
    },
    GreaterEqual: {
        complexity: 11e3,
        signature: {
            domain: "RelationalOperator",
            canonical: (e1, t)=>e1._fn("LessEqual", t.reverse()),
            evaluate: (e1, t)=>{
                if (t.length < 2) return e1.symbol("True");
                let i;
                for (const n of t){
                    if (!n.isNumber) return;
                    if (i) {
                        const t1 = e1.fn("Subtract", [
                            n,
                            i
                        ]).N().sgn;
                        if (null == t1) return;
                        if (t1 > 0) return e1.symbol("False");
                        i = n;
                    } else i = n;
                }
                return e1.symbol("True");
            }
        }
    },
    NotGreaterNotEqual: {
        complexity: 11e3,
        signature: {
            domain: "RelationalOperator",
            canonical: (e1, t)=>e1._fn("Not", [
                    e1._fn("GreaterEqual", t)
                ])
        }
    },
    TildeFullEqual: {
        description: "Indicate isomorphism, congruence and homotopic equivalence",
        signature: {
            domain: "RelationalOperator"
        }
    },
    NotTildeFullEqual: {
        complexity: 11100,
        signature: {
            domain: "RelationalOperator",
            canonical: (e1, t)=>e1._fn("Not", [
                    e1._fn("TildeFullEqual", t)
                ])
        }
    },
    TildeEqual: {
        description: "Approximately or asymptotically equal",
        complexity: 11e3,
        signature: {
            domain: "RelationalOperator"
        }
    },
    NotTildeEqual: {
        complexity: 11100,
        signature: {
            domain: "RelationalOperator",
            canonical: (e1, t)=>e1._fn("Not", [
                    e1._fn("TildeEqual", t)
                ])
        }
    },
    Approx: {
        complexity: 11100,
        signature: {
            domain: "RelationalOperator"
        }
    },
    NotApprox: {
        complexity: 11100,
        signature: {
            domain: "RelationalOperator",
            canonical: (e1, t)=>e1._fn("Not", [
                    e1._fn("Approx", t)
                ])
        }
    },
    ApproxEqual: {
        complexity: 11100,
        signature: {
            domain: "RelationalOperator"
        }
    },
    NotApproxEqual: {
        complexity: 11100,
        signature: {
            domain: "RelationalOperator",
            canonical: (e1, t)=>e1._fn("Not", [
                    e1._fn("ApproxEqual", t)
                ])
        }
    },
    ApproxNotEqual: {
        complexity: 11100,
        signature: {
            domain: "RelationalOperator"
        }
    },
    NotApproxNotEqual: {
        complexity: 11100,
        signature: {
            domain: "RelationalOperator",
            canonical: (e1, t)=>e1._fn("Not", [
                    e1._fn("ApproxNotEqual", t)
                ])
        }
    },
    Precedes: {
        complexity: 11100,
        signature: {
            domain: "RelationalOperator"
        }
    },
    NotPrecedes: {
        complexity: 11100,
        signature: {
            domain: "RelationalOperator",
            canonical: (e1, t)=>e1._fn("Not", [
                    e1._fn("Precedes", t)
                ])
        }
    },
    Succeeds: {
        signature: {
            domain: "RelationalOperator"
        }
    },
    NotSucceeds: {
        complexity: 11100,
        signature: {
            domain: "RelationalOperator",
            canonical: (e1, t)=>e1._fn("Not", [
                    e1._fn("Succeeds", t)
                ])
        }
    }
}, Cc = {
    EmptySet: {
        domain: "Set",
        constant: !0,
        wikidata: "Q226183"
    },
    Element: {
        complexity: 11200,
        hold: "all",
        signature: {
            domain: "Predicate",
            canonical: (e1, t)=>2 === (t = dl(e1, cl(t).map((e1)=>e1.canonical), 2)).length && Hu(t[1]) ? e1._fn("Element", [
                    t[0],
                    e1.domain(t[1])
                ]) : e1._fn("Element", t),
            evaluate: (e1, t)=>(function(e1, t) {
                    const [i, n] = t;
                    if (n.string) return i.string && n.string.includes(i.string) ? e1.symbol("True") : e1.symbol("False");
                    if (n.keys) {
                        if (i.string) {
                            for (const t1 of n.keys)if (t1 === i.string) return e1.symbol("True");
                        }
                        return e1.symbol("False");
                    }
                    if ("List" === n.head) {
                        if ("List" === i.head) {
                            let t2 = !1;
                            for(let r = 0; r < n.nops - i.nops + 1; ++r){
                                t2 = !0;
                                for(let e2 = 0; e2 < i.nops; ++e2)if (!n.ops[r + e2].isEqual(i.ops[e2])) {
                                    t2 = !1;
                                    break;
                                }
                                if (t2) return e1.symbol("True");
                            }
                            return e1.symbol("False");
                        }
                        const t3 = "Hold" === i.head ? i.op1 : i;
                        for (const i1 of n.ops)if (t3.isEqual(i1)) return e1.symbol("True");
                        return e1.symbol("False");
                    }
                    return Hu(n) ? i.domain.isCompatible(e1.domain(n)) ? e1.symbol("True") : e1.symbol("False") : e1._fn("Element", [
                        i,
                        n
                    ]);
                })(e1, t)
        }
    },
    NotElement: {
        complexity: 11200,
        hold: "all",
        signature: {
            domain: "Predicate",
            canonical: (e1, t)=>e1.fn("Not", [
                    e1.fn("Element", t)
                ])
        }
    },
    Subset: {
        complexity: 11200,
        signature: {
            domain: "Predicate"
        }
    },
    NotSubset: {
        complexity: 11200,
        signature: {
            domain: "Predicate",
            canonical: (e1, t)=>e1.fn("Not", [
                    e1.fn("Subset", t)
                ])
        }
    },
    Superset: {
        complexity: 11200,
        signature: {
            domain: "Predicate"
        }
    },
    SupersetEqual: {
        complexity: 11200,
        signature: {
            domain: "Predicate"
        }
    },
    NotSuperset: {
        complexity: 11200,
        signature: {
            domain: "Predicate",
            canonical: (e1, t)=>e1.fn("Not", [
                    e1.fn("Superset", t)
                ])
        }
    },
    NotSupersetEqual: {
        complexity: 11200,
        signature: {
            domain: "Predicate",
            canonical: (e1, t)=>e1.fn("Not", [
                    e1.fn("SupersetEqual", t)
                ])
        }
    },
    SubsetEqual: {
        complexity: 11200,
        signature: {
            domain: "Predicate"
        }
    },
    NotSubsetNotEqual: {
        complexity: 11200,
        signature: {
            domain: "Predicate",
            canonical: (e1, t)=>e1.fn("Not", [
                    e1.fn("SubsetEqual", t)
                ])
        }
    },
    CartesianProduct: {
        wikidata: "Q173740",
        signature: {
            domain: [
                "Function",
                "Set",
                [
                    "Sequence",
                    "Set"
                ],
                "Set"
            ]
        }
    },
    Complement: {
        wikidata: "Q242767",
        signature: {
            domain: [
                "Function",
                "Set",
                "Set"
            ]
        }
    },
    Intersection: {
        wikidata: "Q185837",
        threadable: !0,
        associative: !0,
        commutative: !0,
        involution: !0,
        signature: {
            domain: [
                "Function",
                "Set",
                [
                    "Sequence",
                    "Set"
                ],
                "Set"
            ],
            evaluate: function(e1, t) {
                return e1.symbol("EmptySet");
            }
        }
    },
    Union: {
        wikidata: "Q185359",
        threadable: !0,
        associative: !0,
        commutative: !0,
        involution: !0,
        signature: {
            domain: [
                "Function",
                "Set",
                [
                    "Sequence",
                    "Set"
                ],
                "Set"
            ],
            evaluate: function(e1, t) {
                return e1.symbol("False");
            }
        }
    },
    SetMinus: {
        wikidata: "Q18192442",
        signature: {
            domain: [
                "Function",
                "Set",
                "Value",
                "Set"
            ],
            evaluate: function(e1, t) {
                return e1.symbol("EmptySet");
            }
        }
    },
    SymmetricDifference: {
        wikidata: "Q1147242",
        signature: {
            domain: [
                "Function",
                "Set",
                [
                    "Sequence",
                    "Set"
                ],
                "Set"
            ]
        }
    }
}, Ec = [
    {
        Pi: {
            domain: "TranscendentalNumber",
            flags: {
                algebraic: !1
            },
            constant: !0,
            holdUntil: "N",
            wikidata: "Q167",
            value: (e1)=>il(e1) ? e1._BIGNUM_PI : Math.PI
        }
    },
    {
        Degrees: {
            signature: {
                domain: [
                    "Function",
                    "Number",
                    "Number"
                ],
                canonical: (e1, t)=>{
                    if (1 !== (t = dl(e1, cl(t), 1)).length) return e1.box([
                        "Degrees",
                        t
                    ]);
                    const i = pl(e1, t[0].canonical, "Number");
                    return null !== i.numericValue && i.isValid ? e1.mul([
                        i,
                        e1.box([
                            "Divide",
                            "Pi",
                            180
                        ])
                    ]) : e1.box([
                        "Degrees",
                        i
                    ]);
                },
                evaluate: (e1, t)=>e1.mul([
                        t[0],
                        e1.box([
                            "Divide",
                            "Pi",
                            180
                        ])
                    ])
            }
        },
        Hypot: {
            signature: {
                domain: [
                    "Function",
                    "Number",
                    "Number",
                    "NonNegativeNumber"
                ],
                simplify: (e1, t)=>e1.box([
                        "Sqrt",
                        [
                            "Add",
                            [
                                "Square",
                                t[0]
                            ],
                            [
                                "Square",
                                t[1]
                            ]
                        ]
                    ]).simplify(),
                evaluate: [
                    "Lambda",
                    [
                        "Sqrt",
                        [
                            "Add",
                            [
                                "Square",
                                "_1"
                            ],
                            [
                                "Square",
                                "_2"
                            ]
                        ]
                    ]
                ]
            }
        },
        Sin: {
            complexity: 5e3,
            signature: {
                domain: [
                    "Function",
                    "Number",
                    [
                        "Interval",
                        -1,
                        1
                    ]
                ],
                simplify: (e1, t)=>{
                    var i, n;
                    return null !== (n = null === (i = Fc(e1, "Sin", t[0])) || void 0 === i ? void 0 : i.simplify()) && void 0 !== n ? n : nl(e1) ? e1.box([
                        "Divide",
                        [
                            "Subtract",
                            [
                                "Exp",
                                [
                                    "Multiply",
                                    "ImaginaryUnit",
                                    t[0]
                                ]
                            ],
                            [
                                "Exp",
                                [
                                    "Multiply",
                                    "ImaginaryUnit",
                                    [
                                        "Negate",
                                        t[0]
                                    ]
                                ]
                            ]
                        ],
                        [
                            "Complex",
                            0,
                            2
                        ]
                    ]).simplify() : void 0;
                },
                evaluate: (e1, t)=>$c(e1, "evaluate", "Sin", t[0]),
                N: (e1, t)=>$c(e1, "N", "Sin", t[0])
            }
        }
    },
    {
        Arctan: {
            wikidata: "Q2257242",
            complexity: 5200,
            signature: {
                domain: [
                    "Function",
                    "Number",
                    "ExtendedRealNumber"
                ],
                simplify: (e1, t)=>{
                    var i;
                    return null === (i = Fc(e1, "Arctan", t[0])) || void 0 === i ? void 0 : i.simplify();
                },
                evaluate: (e1, t)=>$c(e1, "evaluate", "Arctan", t[0]),
                N: (e1, t)=>$c(e1, "N", "Arctan", t[0])
            }
        },
        Arctan2: {
            wikidata: "Q776598",
            complexity: 5200,
            signature: {
                domain: [
                    "Function",
                    "Number",
                    "Number",
                    "Number"
                ],
                N: (e1, t)=>rc(t[0], t[1], Math.atan2, (e1, t)=>oa.atan2(e1, t))
            }
        },
        Cos: {
            complexity: 5050,
            signature: {
                domain: [
                    "Function",
                    "Number",
                    [
                        "Interval",
                        -1,
                        1
                    ]
                ],
                simplify: (e1, t)=>{
                    var i, n;
                    return null !== (n = null === (i = Fc(e1, "Cos", t[0])) || void 0 === i ? void 0 : i.simplify()) && void 0 !== n ? n : e1.box([
                        "Sin",
                        [
                            "Add",
                            t[0],
                            [
                                "Multiply",
                                "Half",
                                "Pi"
                            ]
                        ]
                    ]).simplify();
                },
                evaluate: (e1, t)=>$c(e1, "evaluate", "Cos", t[0]),
                N: (e1, t)=>$c(e1, "N", "Cos", t[0])
            }
        },
        Tan: {
            complexity: 5100,
            signature: {
                domain: [
                    "Function",
                    "Number",
                    "Number"
                ],
                simplify: (e1, t)=>{
                    var i, n;
                    return null !== (n = null === (i = Fc(e1, "Tan", t[0])) || void 0 === i ? void 0 : i.simplify()) && void 0 !== n ? n : e1.box([
                        "Divide",
                        [
                            "Sin",
                            t[0]
                        ],
                        [
                            "Cos",
                            t[0]
                        ]
                    ]).simplify();
                },
                evaluate: (e1, t)=>$c(e1, "evaluate", "Tan", t[0]),
                N: (e1, t)=>$c(e1, "N", "Tan", t[0])
            }
        }
    },
    {
        Arcosh: {
            complexity: 6200,
            signature: {
                domain: [
                    "Function",
                    "Number",
                    "Number"
                ],
                simplify: (e1, t)=>{
                    var i, n;
                    return null !== (n = null === (i = Fc(e1, "Arcosh", t[0])) || void 0 === i ? void 0 : i.simplify()) && void 0 !== n ? n : e1.box([
                        "Ln",
                        [
                            "Add",
                            t[0],
                            [
                                "Sqrt",
                                [
                                    "Subtract",
                                    [
                                        "Square",
                                        t[0]
                                    ],
                                    1
                                ]
                            ]
                        ]
                    ]).simplify();
                },
                evaluate: (e1, t)=>$c(e1, "evaluate", "Arcosh", t[0]),
                N: (e1, t)=>$c(e1, "N", "Arcosh", t[0])
            }
        },
        Arcsin: {
            complexity: 5500,
            signature: {
                domain: [
                    "Function",
                    "Number",
                    "Number"
                ],
                simplify: (e1, t)=>{
                    var i, n;
                    return null !== (n = null === (i = Fc(e1, "Arcsin", t[0])) || void 0 === i ? void 0 : i.simplify()) && void 0 !== n ? n : e1.box([
                        "Multiply",
                        2,
                        [
                            "Arctan2",
                            t[0],
                            [
                                "Add",
                                1,
                                [
                                    "Sqrt",
                                    [
                                        "Subtract",
                                        1,
                                        [
                                            "Square",
                                            t[0]
                                        ]
                                    ]
                                ]
                            ]
                        ]
                    ]).simplify();
                },
                evaluate: (e1, t)=>$c(e1, "evaluate", "Arcsin", t[0]),
                N: (e1, t)=>$c(e1, "N", "Arcsin", t[0])
            }
        },
        Arsinh: {
            complexity: 6100,
            signature: {
                domain: [
                    "Function",
                    "Number",
                    "Number"
                ],
                simplify: (e1, t)=>{
                    var i, n;
                    return null !== (n = null === (i = Fc(e1, "Arsinh", t[0])) || void 0 === i ? void 0 : i.simplify()) && void 0 !== n ? n : e1.box([
                        "Ln",
                        [
                            "Add",
                            t[0],
                            [
                                "Sqrt",
                                [
                                    "Add",
                                    [
                                        "Square",
                                        t[0]
                                    ],
                                    1
                                ]
                            ]
                        ]
                    ]).simplify();
                },
                evaluate: (e1, t)=>$c(e1, "evaluate", "Arsinh", t[0]),
                N: (e1, t)=>$c(e1, "N", "Arsinh", t[0])
            }
        },
        Artanh: {
            complexity: 6300,
            signature: {
                domain: [
                    "Function",
                    "Number",
                    "Number"
                ],
                simplify: (e1, t)=>{
                    var i, n;
                    return null !== (n = null === (i = Fc(e1, "Artanh", t[0])) || void 0 === i ? void 0 : i.simplify()) && void 0 !== n ? n : e1.box([
                        "Multiply",
                        "Half",
                        [
                            "Ln",
                            [
                                "Divide",
                                [
                                    "Add",
                                    1,
                                    t[0]
                                ],
                                [
                                    "Subtract",
                                    1,
                                    t[0]
                                ]
                            ]
                        ]
                    ]).simplify();
                },
                evaluate: (e1, t)=>$c(e1, "evaluate", "Artanh", t[0]),
                N: (e1, t)=>$c(e1, "N", "Artanh", t[0])
            }
        },
        Cosh: {
            complexity: 6050,
            signature: {
                domain: [
                    "Function",
                    "Number",
                    "Number"
                ],
                simplify: (e1, t)=>{
                    var i, n;
                    return null !== (n = null === (i = Fc(e1, "Cosh", t[0])) || void 0 === i ? void 0 : i.simplify()) && void 0 !== n ? n : e1.box([
                        "Multiply",
                        "Half",
                        [
                            "Add",
                            [
                                "Exp",
                                t[0]
                            ],
                            [
                                "Exp",
                                [
                                    "Negate",
                                    t[0]
                                ]
                            ]
                        ]
                    ]).simplify();
                },
                evaluate: (e1, t)=>$c(e1, "evaluate", "Cosh", t[0]),
                N: (e1, t)=>$c(e1, "N", "Cosh", t[0])
            }
        },
        Cot: {
            complexity: 5600,
            signature: {
                domain: [
                    "Function",
                    "Number",
                    "Number"
                ],
                simplify: (e1, t)=>{
                    var i, n;
                    return null !== (n = null === (i = Fc(e1, "Cot", t[0])) || void 0 === i ? void 0 : i.simplify()) && void 0 !== n ? n : e1.box([
                        "Divide",
                        [
                            "Cos",
                            t[0]
                        ],
                        [
                            "Sin",
                            t[0]
                        ]
                    ]).simplify();
                },
                evaluate: (e1, t)=>$c(e1, "evaluate", "Cot", t[0]),
                N: (e1, t)=>$c(e1, "N", "Cot", t[0])
            }
        },
        Csc: {
            description: "Cosecant",
            complexity: 5600,
            signature: {
                domain: [
                    "Function",
                    "Number",
                    "Number"
                ],
                simplify: (e1, t)=>{
                    var i, n;
                    return null !== (n = null === (i = Fc(e1, "Csc", t[0])) || void 0 === i ? void 0 : i.simplify()) && void 0 !== n ? n : e1.box([
                        "Divide",
                        1,
                        [
                            "Sin",
                            t[0]
                        ]
                    ]).simplify();
                },
                evaluate: (e1, t)=>$c(e1, "evaluate", "Csc", t[0]),
                N: (e1, t)=>$c(e1, "N", "Csc", t[0])
            }
        },
        Haversine: {
            wikidata: "Q2528380",
            signature: {
                domain: [
                    "Function",
                    "ExtendedRealNumber",
                    [
                        "Interval",
                        0,
                        1
                    ]
                ],
                evaluate: [
                    "Lambda",
                    [
                        "Divide",
                        [
                            "Subtract",
                            1,
                            [
                                "Cos",
                                "_1"
                            ]
                        ],
                        2
                    ]
                ]
            }
        },
        InverseHaversine: {
            signature: {
                domain: [
                    "Function",
                    "ExtendedRealNumber",
                    "RealNumber"
                ],
                evaluate: [
                    "Lambda",
                    [
                        "Multiply",
                        2,
                        [
                            "Arcsin",
                            [
                                "Sqrt",
                                "_1"
                            ]
                        ]
                    ]
                ]
            }
        },
        Sec: {
            description: "Secant, inverse of cosine",
            complexity: 5500,
            signature: {
                domain: [
                    "Function",
                    "Number",
                    "Number"
                ],
                simplify: (e1, t)=>{
                    var i, n;
                    return null !== (n = null === (i = Fc(e1, "Sec", t[0])) || void 0 === i ? void 0 : i.simplify()) && void 0 !== n ? n : e1.box([
                        "Divide",
                        1,
                        [
                            "Cos",
                            t[0]
                        ]
                    ]).simplify();
                },
                evaluate: (e1, t)=>$c(e1, "evaluate", "Sec", t[0]),
                N: (e1, t)=>$c(e1, "N", "Sec", t[0])
            }
        },
        Sinh: {
            complexity: 6e3,
            signature: {
                domain: [
                    "Function",
                    "Number",
                    "Number"
                ],
                simplify: (e1, t)=>{
                    var i, n;
                    return null !== (n = null === (i = Fc(e1, "Sinh", t[0])) || void 0 === i ? void 0 : i.simplify()) && void 0 !== n ? n : e1.box([
                        "Multiply",
                        "Half",
                        [
                            "Subtract",
                            [
                                "Exp",
                                t[0]
                            ],
                            [
                                "Exp",
                                [
                                    "Negate",
                                    t[0]
                                ]
                            ]
                        ]
                    ]).simplify();
                },
                evaluate: (e1, t)=>$c(e1, "evaluate", "Sinh", t[0]),
                N: (e1, t)=>$c(e1, "N", "Sinh", t[0])
            }
        }
    },
    {
        Csch: {
            complexity: 6200,
            signature: {
                domain: [
                    "Function",
                    "Number",
                    "ExtendedRealNumber"
                ],
                simplify: (e1, t)=>{
                    var i, n;
                    return null !== (n = null === (i = Fc(e1, "Csch", t[0])) || void 0 === i ? void 0 : i.simplify()) && void 0 !== n ? n : e1.box([
                        "Divide",
                        1,
                        [
                            "Sinh",
                            t[0]
                        ]
                    ]).simplify();
                },
                evaluate: (e1, t)=>$c(e1, "evaluate", "Csch", t[0]),
                N: (e1, t)=>$c(e1, "N", "Csch", t[0])
            }
        },
        Sech: {
            complexity: 6200,
            signature: {
                domain: [
                    "Function",
                    "Number",
                    [
                        "Interval",
                        -1,
                        1
                    ]
                ],
                simplify: (e1, t)=>{
                    var i, n;
                    return null !== (n = null === (i = Fc(e1, "Sech", t[0])) || void 0 === i ? void 0 : i.simplify()) && void 0 !== n ? n : e1.box([
                        "Divide",
                        1,
                        [
                            "Cosh",
                            t[0]
                        ]
                    ]).simplify();
                },
                evaluate: (e1, t)=>$c(e1, "evaluate", "Sech", t[0]),
                N: (e1, t)=>$c(e1, "N", "Sech", t[0])
            }
        },
        Tanh: {
            complexity: 6200,
            signature: {
                domain: [
                    "Function",
                    "Number",
                    "Number"
                ],
                simplify: (e1, t)=>{
                    var i, n;
                    return null !== (n = null === (i = Fc(e1, "Tanh", t[0])) || void 0 === i ? void 0 : i.simplify()) && void 0 !== n ? n : e1.box([
                        "Divide",
                        [
                            "Sinh",
                            t[0]
                        ],
                        [
                            "Cosh",
                            t[0]
                        ]
                    ]).simplify();
                },
                evaluate: (e1, t)=>$c(e1, "evaluate", "Tanh", t[0]),
                N: (e1, t)=>$c(e1, "N", "Tanh", t[0])
            }
        }
    },
    {
        Arccos: {
            complexity: 5550,
            signature: {
                domain: [
                    "Function",
                    "Number",
                    "ExtendedRealNumber"
                ],
                simplify: (e1, t)=>{
                    var i, n;
                    return null !== (n = null === (i = Fc(e1, "Arccos", t[0])) || void 0 === i ? void 0 : i.simplify()) && void 0 !== n ? n : e1.box([
                        "Subtract",
                        [
                            "Divide",
                            "Pi",
                            2
                        ],
                        [
                            "Arcsin",
                            t[0]
                        ]
                    ]).simplify();
                },
                evaluate: (e1, t)=>$c(e1, "evaluate", "Arccos", t[0]),
                N: (e1, t)=>$c(e1, "N", "Arccos", t[0])
            }
        },
        Arccot: {
            numeric: !0,
            signature: {
                domain: [
                    "Function",
                    "Number",
                    "ExtendedRealNumber"
                ],
                evaluate: (e1, t)=>$c(e1, "evaluate", "Arccot", t[0]),
                N: (e1, t)=>$c(e1, "N", "Arccot", t[0])
            }
        },
        Arcoth: {
            numeric: !0,
            signature: {
                domain: [
                    "Function",
                    "Number",
                    "ExtendedRealNumber"
                ],
                evaluate: (e1, t)=>$c(e1, "evaluate", "Arcoth", t[0]),
                N: (e1, t)=>$c(e1, "N", "Arcoth", t[0])
            }
        },
        Arcsch: {
            numeric: !0,
            signature: {
                domain: [
                    "Function",
                    "Number",
                    "ExtendedRealNumber"
                ],
                evaluate: (e1, t)=>$c(e1, "evaluate", "Arcsch", t[0]),
                N: (e1, t)=>$c(e1, "N", "Arcsch", t[0])
            }
        },
        Arcsec: {
            numeric: !0,
            signature: {
                domain: [
                    "Function",
                    "Number",
                    "ExtendedRealNumber"
                ],
                evaluate: (e1, t)=>$c(e1, "evaluate", "Arcsec", t[0]),
                N: (e1, t)=>$c(e1, "N", "Arcsec", t[0])
            }
        },
        Arsech: {
            numeric: !0,
            signature: {
                domain: [
                    "Function",
                    "Number",
                    "ExtendedRealNumber"
                ],
                evaluate: (e1, t)=>$c(e1, "evaluate", "Arsech", t[0]),
                N: (e1, t)=>$c(e1, "N", "Arsech", t[0])
            }
        },
        Arccsc: {
            numeric: !0,
            signature: {
                domain: [
                    "Function",
                    "Number",
                    "ExtendedRealNumber"
                ],
                evaluate: (e1, t)=>$c(e1, "evaluate", "Arccsc", t[0]),
                N: (e1, t)=>$c(e1, "N", "Arccsc", t[0])
            }
        },
        Coth: {
            complexity: 6300,
            signature: {
                domain: [
                    "Function",
                    "Number",
                    "Number"
                ],
                simplify: (e1, t)=>{
                    var i, n;
                    return null !== (n = null === (i = Fc(e1, "Coth", t[0])) || void 0 === i ? void 0 : i.simplify()) && void 0 !== n ? n : e1.box([
                        "Divide",
                        1,
                        [
                            "Tanh",
                            t[0]
                        ]
                    ]).simplify();
                },
                evaluate: (e1, t)=>$c(e1, "evaluate", "Coth", t[0]),
                N: (e1, t)=>$c(e1, "N", "Coth", t[0])
            }
        },
        InverseFunction: {
            signature: {
                domain: [
                    "Function",
                    "Function",
                    "Function"
                ],
                canonical: (e1, t)=>{
                    var i;
                    return null !== (i = Bc(e1, t = dl(e1, cl(t), 1).map((e1)=>e1.canonical))) && void 0 !== i ? i : e1._fn("InverseFunction", t);
                },
                simplify: (e1, t)=>Bc(e1, t),
                evaluate: (e1, t)=>Bc(e1, t)
            }
        }
    }
], Tc = [
    "Sqrt",
    2
], Dc = [
    "Sqrt",
    3
], zc = [
    "Sqrt",
    5
], qc = [
    "Sqrt",
    6
], Ic = [
    [
        [
            0,
            1
        ],
        {
            Sin: 0,
            Cos: 1,
            Tan: 0,
            Cot: NaN,
            Sec: 1,
            Csc: NaN
        }
    ],
    [
        [
            1,
            12
        ],
        {
            Sin: [
                "Divide",
                [
                    "Subtract",
                    qc,
                    Tc
                ],
                4
            ],
            Cos: [
                "Divide",
                [
                    "Add",
                    qc,
                    Tc
                ],
                4
            ],
            Tan: [
                "Subtract",
                2,
                Dc
            ],
            Cot: [
                "Add",
                2,
                Dc
            ],
            Sec: [
                "Subtract",
                qc,
                Tc
            ],
            Csc: [
                "Add",
                qc,
                Tc
            ]
        }
    ],
    [
        [
            1,
            10
        ],
        {
            Sin: [
                "Divide",
                [
                    "Subtract",
                    zc,
                    1
                ],
                4
            ],
            Cos: [
                "Divide",
                [
                    "Sqrt",
                    [
                        "Add",
                        10,
                        [
                            "Multiply",
                            2,
                            zc
                        ]
                    ]
                ],
                4
            ],
            Tan: [
                "Divide",
                [
                    "Sqrt",
                    [
                        "Subtract",
                        25,
                        [
                            "Multiply",
                            10,
                            zc
                        ]
                    ]
                ],
                4
            ],
            Cot: [
                "Sqrt",
                [
                    "Add",
                    5,
                    [
                        "Multiply",
                        2,
                        zc
                    ]
                ]
            ],
            Sec: [
                "Divide",
                [
                    "Sqrt",
                    [
                        "Subtract",
                        50,
                        [
                            "Multiply",
                            10,
                            zc
                        ]
                    ]
                ],
                5
            ],
            Csc: [
                "Add",
                1,
                zc
            ]
        }
    ],
    [
        [
            1,
            8
        ],
        {
            Sin: "$\\frac\\sqrt{2-\\sqrt2}{2}$",
            Cos: "$\\frac {\\sqrt {2+{\\sqrt {2}}}}{2}$",
            Tan: "$\\sqrt{2} - 1$",
            Cot: "$\\sqrt{2} + 1$",
            Sec: "$\\sqrt{ 4 - 2\\sqrt{2}}$",
            Csc: "$\\sqrt{ 4 + 2\\sqrt{2}}$"
        }
    ],
    [
        [
            1,
            6
        ],
        {
            Sin: "$\\frac{1}{2}$",
            Cos: "$\\frac{\\sqrt{3}}{2}$",
            Tan: "$\\frac{\\sqrt{3}}{3}$",
            Cot: "$\\frac{2\\sqrt{3}}{3}$",
            Sec: "$\\sqrt{3}$",
            Csc: 2
        }
    ],
    [
        [
            1,
            5
        ],
        {
            Sin: "$\\frac{\\sqrt{10- 2\\sqrt{5}}} {4}$",
            Cos: "$\\frac{1+ \\sqrt{5}} {4}$",
            Tan: "$\\sqrt{5-2\\sqrt5}$",
            Cot: "$\\frac{\\sqrt{25+10\\sqrt5}} {5}$",
            Sec: "$\\sqrt{5} - 1$",
            Csc: "$\\frac{\\sqrt{50+10\\sqrt{5}}} {5}$"
        }
    ],
    [
        [
            1,
            4
        ],
        {
            Sin: [
                "Divide",
                Tc,
                2
            ],
            Cos: [
                "Divide",
                Tc,
                2
            ],
            Tan: 1,
            Cot: 1,
            Sec: Tc,
            Csc: Tc
        }
    ],
    [
        [
            3,
            10
        ],
        {
            Sin: "$\\frac{1+ \\sqrt{5}} {4}$",
            Cos: "$\\frac{\\sqrt{10- 2\\sqrt{5}}} {4}$",
            Tan: "$\\frac{\\sqrt{25+10\\sqrt5}} {5}$",
            Cot: "$\\sqrt{5-2\\sqrt5}$",
            Sec: "$$",
            Csc: "$\\frac{\\sqrt{50+10\\sqrt{5}}} {5}$"
        }
    ],
    [
        [
            1,
            3
        ],
        {
            Sin: [
                "Divide",
                Dc,
                2
            ],
            Cos: "Half",
            Tan: Dc,
            Cot: [
                "Divide",
                Dc,
                3
            ],
            Sec: 2,
            Csc: [
                "Divide",
                [
                    "Multiply",
                    2,
                    Dc
                ],
                3
            ]
        }
    ],
    [
        [
            3,
            8
        ],
        {
            Sin: "$\\frac{ \\sqrt{2 + \\sqrt{2}} } {2}$",
            Cos: "$\\frac{ \\sqrt{2 - \\sqrt{2}} } {2}$",
            Tan: "$\\sqrt{2} + 1$",
            Cot: "$\\sqrt{2} - 1$",
            Sec: "$\\sqrt{ 4 + 2 \\sqrt{2} }$",
            Csc: "$\\sqrt{ 4 - 2 \\sqrt{2} }$"
        }
    ],
    [
        [
            2,
            5
        ],
        {
            Sin: "$\\frac{\\sqrt{10+ 2\\sqrt{5}}} {4}$",
            Cos: "$\\frac{\\sqrt{5}-1} {4}$",
            Tan: "$\\sqrt{5+2\\sqrt{5}}$",
            Cot: "$\\frac{\\sqrt{25-10\\sqrt{5}}} {5}$",
            Sec: "$1 + \\sqrt{5}$",
            Csc: "$\\frac{\\sqrt{50-10\\sqrt{5}}} {5}$"
        }
    ],
    [
        [
            5,
            12
        ],
        {
            Sin: "$\\frac{\\sqrt{6} + \\sqrt{2}} {4}$",
            Cos: "$\\frac{ \\sqrt{6} - \\sqrt{2}} {4}$",
            Tan: "$2+\\sqrt{3}$",
            Cot: "$2-\\sqrt{3}$",
            Sec: "$\\sqrt{6}+\\sqrt{2}$",
            Csc: "$\\sqrt{6} - \\sqrt{2}$"
        }
    ],
    [
        [
            1,
            2
        ],
        {
            Sin: 1,
            Cos: 0,
            Tan: NaN,
            Cot: 0,
            Sec: NaN,
            Csc: 1
        }
    ]
], Oc = {
    Sin: [
        [
            1,
            "Sin"
        ],
        [
            1,
            "Cos"
        ],
        [
            -1,
            "Sin"
        ],
        [
            -1,
            "Cos"
        ]
    ],
    Cos: [
        [
            1,
            "Cos"
        ],
        [
            -1,
            "Sin"
        ],
        [
            -1,
            "Cos"
        ],
        [
            1,
            "Sin"
        ]
    ],
    Sec: [
        [
            1,
            "Sec"
        ],
        [
            -1,
            "Csc"
        ],
        [
            -1,
            "Sec"
        ],
        [
            1,
            "Csc"
        ]
    ],
    Csc: [
        [
            1,
            "Csc"
        ],
        [
            1,
            "Sec"
        ],
        [
            -1,
            "Csc"
        ],
        [
            -1,
            "Sec"
        ]
    ],
    Tan: [
        [
            1,
            "Tan"
        ],
        [
            -1,
            "Cot"
        ],
        [
            1,
            "Tan"
        ],
        [
            -1,
            "Cot"
        ]
    ],
    Cot: [
        [
            1,
            "Cot"
        ],
        [
            -1,
            "Tan"
        ],
        [
            1,
            "Cot"
        ],
        [
            -1,
            "Tan"
        ]
    ]
};
function Fc(e1, t, i) {
    var n, r, o;
    const a = e1.cache("constructible-trigonometric-values", ()=>{
        var t;
        const i = [];
        for (const [n, r] of Ic){
            const o = {};
            for (const i1 of Object.keys(r))o[i1] = null !== (t = e1.parse(Xs(r[i1]))) && void 0 !== t ? t : e1.box(r[i1]);
            i.push([
                n,
                o
            ]);
        }
        return i;
    }, (e1)=>{
        for (const [t, i] of e1)for (const e2 of Object.values(i))e2.unbind();
        return e1;
    });
    if (null === (i = i.N()).numericValue) return;
    let s = null !== (n = Us(i)) && void 0 !== n ? n : null;
    if (null === s) return;
    s %= 2 * Math.PI;
    const l = "Cos" !== t && "Sec" !== t ? Math.sign(s) : 1;
    s = Math.abs(s);
    const u = Math.floor(2 * s / Math.PI);
    let c;
    s %= Math.PI / 2, [c, t] = null !== (o = null === (r = Oc[t]) || void 0 === r ? void 0 : r[u]) && void 0 !== o ? o : [
        1,
        t
    ], c *= l;
    for (const [[i1, n1], r1] of a)if (0 === e1.chop(s - Math.PI * i1 / n1)) return c < 0 ? Kl(r1[t]) : r1[t];
}
function Bc(e1, t) {
    if (1 !== t.length) return;
    const i = t[0], n = i.symbol;
    if ("string" != typeof n) return;
    if ("InverseFunction" === n) return i.op1;
    const r = {
        Sin: "Arcsin",
        Cos: "Arccos",
        Tan: "Arctan",
        Sec: "Arcsec",
        Csc: " Arccsc",
        Sinh: "Arsinh",
        Cosh: "Arcosh",
        Tanh: "Artanh",
        Sech: "Arcsech",
        Csch: "Arcsch",
        Arcosh: "Cosh",
        Arccos: "Cos",
        Arccsc: "Csc",
        Arcsch: "Csch",
        Arcsec: "Sec",
        Arcsin: "Sin",
        Arsinh: "Sinh",
        Arctan: "Tan",
        Artanh: "Tanh"
    }[n];
    return r ? e1.symbol(r) : void 0;
}
function $c(e1, t, i, n) {
    var r;
    if ("evaluate" === t) {
        const t1 = null === (r = Fc(e1, i, n)) || void 0 === r ? void 0 : r.evaluate();
        if (t1) return t1;
        if (n.isExact) return;
    }
    switch(i){
        case "Arccos":
            return nc(n, Math.acos, (e1)=>e1.acos(), (e1)=>e1.acos());
        case "Arccot":
            return nc(n, (e1)=>Math.atan2(1, e1), (t)=>oa.atan2(e1._BIGNUM_ONE, t), (e1)=>e1.inverse().atan());
        case "Arccsc":
            return nc(n, (e1)=>Math.asin(1 / e1), (t)=>e1._BIGNUM_ONE.div(t).asin(), (e1)=>e1.inverse().asin());
        case "Arcosh":
            return nc(n, Math.acosh, (e1)=>e1.acosh(), (e1)=>e1.acosh());
        case "Arcoth":
            return nc(n, (e1)=>e1, (e1)=>e1.acosh(), (e1)=>e1.acosh());
        case "Arcsch":
            return nc(n, (e1)=>Math.log(1 / e1 + Math.sqrt(1 / (e1 * e1) + 1)), (t)=>e1._BIGNUM_ONE.div(t.mul(t)).add(e1._BIGNUM_ONE).sqrt().add(e1._BIGNUM_ONE.div(t)).log(), (e1)=>e1.mul(e1).inverse().add(1).sqrt().add(e1.inverse()).log());
        case "Arcsec":
            return nc(n, (e1)=>Math.acos(1 / e1), (t)=>e1._BIGNUM_ONE.div(t).acos(), (e1)=>e1.inverse().acos());
        case "Arcsin":
            return nc(n, Math.asin, (e1)=>e1.asin(), (e1)=>e1.asin());
        case "Arsech":
            return nc(n, (e1)=>Math.log((1 + Math.sqrt(1 - e1 * e1)) / e1), (t)=>e1._BIGNUM_ONE.sub(t.mul(t).add(e1._BIGNUM_ONE).div(t)).log(), (t)=>e1.complex(1).sub(t.mul(t)).add(1).div(t).log());
        case "Arsinh":
            return nc(n, Math.asinh, (e1)=>e1.asinh(), (e1)=>e1.asinh());
        case "Arctan":
            return nc(n, Math.atan, (e1)=>e1.atan(), (e1)=>e1.atan());
        case "Artanh":
            return nc(n, Math.atanh, (e1)=>e1.atanh(), (e1)=>e1.atanh());
        case "Cos":
            return nc(n, Math.cos, (t)=>t.toSignificantDigits(e1.precision + 4).cos().toSignificantDigits(e1.precision), (e1)=>e1.cos());
        case "Cosh":
            return nc(n, Math.cosh, (e1)=>e1.cosh(), (e1)=>e1.cosh());
        case "Cot":
            return nc(n, (e1)=>1 / Math.tan(e1), (t)=>e1._BIGNUM_ONE.div(t.tan()), (e1)=>e1.tan().inverse());
        case "Coth":
            return nc(n, (e1)=>1 / Math.tanh(e1), (t)=>e1._BIGNUM_ONE.div(t.tanh()), (e1)=>e1.tanh().inverse());
        case "Csc":
            return nc(n, (e1)=>1 / Math.sin(e1), (t)=>e1._BIGNUM_ONE.div(t.sin()), (e1)=>e1.sin().inverse());
        case "Csch":
            return nc(n, (e1)=>1 / Math.sinh(e1), (t)=>e1._BIGNUM_ONE.div(t.sinh()), (e1)=>e1.sinh().inverse());
        case "Sec":
            return nc(n, (e1)=>1 / Math.cos(e1), (t)=>e1._BIGNUM_ONE.div(t.cos()), (e1)=>e1.cos().inverse());
        case "Sech":
            return nc(n, (e1)=>1 / Math.cosh(e1), (t)=>e1._BIGNUM_ONE.div(t.cosh()), (e1)=>e1.cosh().inverse());
        case "Sin":
            return nc(n, Math.sin, (t)=>t.toSignificantDigits(e1.precision + 4).sin().toSignificantDigits(e1.precision), (e1)=>e1.sin());
        case "Sinh":
            return nc(n, Math.sinh, (e1)=>e1.sinh(), (e1)=>e1.sinh());
        case "Tan":
            return nc(n, Math.tan, (t)=>t.toSignificantDigits(e1.precision + 4).tan().toSignificantDigits(e1.precision), (e1)=>e1.tan());
        case "Tanh":
            return nc(n, Math.tanh, (e1)=>e1.tanh(), (e1)=>e1.tanh());
    }
}
class Pc {
    reset() {
        this.constant && (this._value = null);
    }
    get value() {
        var e1, t, i, n;
        if (null === this._value) {
            const n1 = this._engine;
            if (Js(this._defValue) ? this._value = null !== (e1 = n1.parse(this._defValue)) && void 0 !== e1 ? e1 : n1.symbol("Undefined") : "function" == typeof this._defValue ? this._value = n1.box(null !== (t = this._defValue(n1)) && void 0 !== t ? t : "Undefined") : this._defValue ? this._value = n1.box(this._defValue) : this._value = void 0, null === (i = this._value) || void 0 === i ? void 0 : i.numericValue) {
                const e2 = this._value.numericValue;
                !il(n1) && e2 instanceof oa ? this._value = n1.number(e2.toNumber()) : !nl(n1) && e2 instanceof la && (this._value = n1._NAN);
            }
        }
        return null !== (n = this._value) && void 0 !== n ? n : void 0;
    }
    set value(e1) {
        var t;
        if (this.constant) throw Error(`The value of the constant "${this.name}" cannot be changed`);
        if ("number" == typeof e1) "number" == typeof (null === (t = this._value) || void 0 === t ? void 0 : t.numericValue) ? this._value._value = e1 : this._value = this._engine.number(e1);
        else if (e1) {
            const t1 = this._engine.box(e1);
            !this._domain || t1.domain.isCompatible(this._domain) ? this._value = t1 : this._value = void 0;
        } else this._value = void 0;
        void 0 !== this._value ? this._flags = void 0 : this._flags = Kc(this.domain);
    }
    get domain() {
        var e1, t, i;
        return null !== (i = null !== (e1 = this._domain) && void 0 !== e1 ? e1 : null === (t = this._value) || void 0 === t ? void 0 : t.domain) && void 0 !== i ? i : void 0;
    }
    set domain(e1) {
        var t, i, n;
        if (this.constant) throw Error(`The domain of the constant "${this.name}" cannot be changed`);
        if (!e1) return this._defValue = void 0, this._value = void 0, this._flags = void 0, void (this._domain = void 0);
        if (e1 = this._engine.domain(e1), null === (t = this._domain) || void 0 === t ? void 0 : t.isNumeric) {
            if (!e1.isNumeric) throw Error("Can't change from a numeric domain to a non-numeric one");
            return this._domain = e1, void (this._value || (this._flags = {
                ...null !== (i = this._flags) && void 0 !== i ? i : {},
                ...Kc(e1)
            }));
        }
        if (this._domain) throw Error("Can't change a non-numeric domain");
        this._flags = void 0, this._domain = e1, !this._value && e1.isNumeric && (this._flags = {
            ...null !== (n = this._flags) && void 0 !== n ? n : {},
            ...Kc(e1)
        });
    }
    get number() {
        var e1, t, i;
        return null !== (t = null === (e1 = this.value) || void 0 === e1 ? void 0 : e1.isNumber) && void 0 !== t ? t : null === (i = this._flags) || void 0 === i ? void 0 : i.number;
    }
    set number(e1) {
        this.updateFlags({
            number: e1
        });
    }
    get integer() {
        var e1, t, i;
        return null !== (t = null === (e1 = this.value) || void 0 === e1 ? void 0 : e1.isInteger) && void 0 !== t ? t : null === (i = this._flags) || void 0 === i ? void 0 : i.integer;
    }
    set integer(e1) {
        this.updateFlags({
            integer: e1
        });
    }
    get rational() {
        var e1, t, i;
        return null !== (t = null === (e1 = this.value) || void 0 === e1 ? void 0 : e1.isRational) && void 0 !== t ? t : null === (i = this._flags) || void 0 === i ? void 0 : i.rational;
    }
    set rational(e1) {
        this.updateFlags({
            rational: e1
        });
    }
    get algebraic() {
        var e1, t, i;
        return null !== (t = null === (e1 = this.value) || void 0 === e1 ? void 0 : e1.isAlgebraic) && void 0 !== t ? t : null === (i = this._flags) || void 0 === i ? void 0 : i.algebraic;
    }
    set algebraic(e1) {
        this.updateFlags({
            algebraic: e1
        });
    }
    get real() {
        var e1, t, i;
        return null !== (t = null === (e1 = this.value) || void 0 === e1 ? void 0 : e1.isReal) && void 0 !== t ? t : null === (i = this._flags) || void 0 === i ? void 0 : i.real;
    }
    set real(e1) {
        this.updateFlags({
            real: e1
        });
    }
    get extendedReal() {
        var e1, t, i;
        return null !== (t = null === (e1 = this.value) || void 0 === e1 ? void 0 : e1.isExtendedReal) && void 0 !== t ? t : null === (i = this._flags) || void 0 === i ? void 0 : i.extendedReal;
    }
    set extendedReal(e1) {
        this.updateFlags({
            extendedReal: e1
        });
    }
    get complex() {
        var e1, t, i;
        return null !== (t = null === (e1 = this.value) || void 0 === e1 ? void 0 : e1.isComplex) && void 0 !== t ? t : null === (i = this._flags) || void 0 === i ? void 0 : i.complex;
    }
    set complex(e1) {
        this.updateFlags({
            complex: e1
        });
    }
    get extendedComplex() {
        var e1, t, i;
        return null !== (t = null === (e1 = this.value) || void 0 === e1 ? void 0 : e1.isExtendedComplex) && void 0 !== t ? t : null === (i = this._flags) || void 0 === i ? void 0 : i.extendedComplex;
    }
    set extendedComplex(e1) {
        this.updateFlags({
            extendedComplex: e1
        });
    }
    get imaginary() {
        var e1, t, i;
        return null !== (t = null === (e1 = this.value) || void 0 === e1 ? void 0 : e1.isImaginary) && void 0 !== t ? t : null === (i = this._flags) || void 0 === i ? void 0 : i.imaginary;
    }
    set imaginary(e1) {
        this.updateFlags({
            imaginary: e1
        });
    }
    get positive() {
        var e1, t, i;
        return null !== (t = null === (e1 = this.value) || void 0 === e1 ? void 0 : e1.isPositive) && void 0 !== t ? t : null === (i = this._flags) || void 0 === i ? void 0 : i.positive;
    }
    set positive(e1) {
        this.updateFlags({
            positive: e1
        });
    }
    get nonPositive() {
        var e1, t, i;
        return null !== (t = null === (e1 = this.value) || void 0 === e1 ? void 0 : e1.isNonPositive) && void 0 !== t ? t : null === (i = this._flags) || void 0 === i ? void 0 : i.nonPositive;
    }
    set nonPositive(e1) {
        this.updateFlags({
            nonPositive: e1
        });
    }
    get negative() {
        var e1, t, i;
        return null !== (t = null === (e1 = this.value) || void 0 === e1 ? void 0 : e1.isNegative) && void 0 !== t ? t : null === (i = this._flags) || void 0 === i ? void 0 : i.negative;
    }
    set negative(e1) {
        this.updateFlags({
            negative: e1
        });
    }
    get nonNegative() {
        var e1, t, i;
        return null !== (t = null === (e1 = this.value) || void 0 === e1 ? void 0 : e1.isNonNegative) && void 0 !== t ? t : null === (i = this._flags) || void 0 === i ? void 0 : i.nonNegative;
    }
    set nonNegative(e1) {
        this.updateFlags({
            nonNegative: e1
        });
    }
    get zero() {
        var e1, t, i;
        return null !== (t = null === (e1 = this.value) || void 0 === e1 ? void 0 : e1.isZero) && void 0 !== t ? t : null === (i = this._flags) || void 0 === i ? void 0 : i.zero;
    }
    set zero(e1) {
        this.updateFlags({
            zero: e1
        });
    }
    get notZero() {
        var e1, t, i;
        return null !== (t = null === (e1 = this.value) || void 0 === e1 ? void 0 : e1.isNotZero) && void 0 !== t ? t : null === (i = this._flags) || void 0 === i ? void 0 : i.notZero;
    }
    set notZero(e1) {
        this.updateFlags({
            notZero: e1
        });
    }
    get one() {
        var e1, t, i;
        return null !== (t = null === (e1 = this.value) || void 0 === e1 ? void 0 : e1.isOne) && void 0 !== t ? t : null === (i = this._flags) || void 0 === i ? void 0 : i.one;
    }
    set one(e1) {
        this.updateFlags({
            one: e1
        });
    }
    get negativeOne() {
        var e1, t, i;
        return null !== (t = null === (e1 = this.value) || void 0 === e1 ? void 0 : e1.isNegativeOne) && void 0 !== t ? t : null === (i = this._flags) || void 0 === i ? void 0 : i.negativeOne;
    }
    set negativeOne(e1) {
        this.updateFlags({
            negativeOne: e1
        });
    }
    get infinity() {
        var e1, t, i;
        return null !== (t = null === (e1 = this.value) || void 0 === e1 ? void 0 : e1.isInfinity) && void 0 !== t ? t : null === (i = this._flags) || void 0 === i ? void 0 : i.infinity;
    }
    set infinity(e1) {
        this.updateFlags({
            infinity: e1
        });
    }
    get finite() {
        var e1, t, i;
        return null !== (t = null === (e1 = this.value) || void 0 === e1 ? void 0 : e1.isFinite) && void 0 !== t ? t : null === (i = this._flags) || void 0 === i ? void 0 : i.finite;
    }
    set finite(e1) {
        this.updateFlags({
            finite: e1
        });
    }
    get NaN() {
        var e1, t, i;
        return null !== (t = null === (e1 = this.value) || void 0 === e1 ? void 0 : e1.isNaN) && void 0 !== t ? t : null === (i = this._flags) || void 0 === i ? void 0 : i.NaN;
    }
    set NaN(e1) {
        this.updateFlags({
            NaN: e1
        });
    }
    get even() {
        var e1, t, i;
        return null !== (t = null === (e1 = this.value) || void 0 === e1 ? void 0 : e1.isEven) && void 0 !== t ? t : null === (i = this._flags) || void 0 === i ? void 0 : i.even;
    }
    set even(e1) {
        this.updateFlags({
            even: e1
        });
    }
    get odd() {
        var e1, t, i;
        return null !== (t = null === (e1 = this.value) || void 0 === e1 ? void 0 : e1.isOdd) && void 0 !== t ? t : null === (i = this._flags) || void 0 === i ? void 0 : i.odd;
    }
    set odd(e1) {
        this.updateFlags({
            odd: e1
        });
    }
    get prime() {
        var e1, t;
        const i = this._value;
        return i ? !(!i.isInteger || i.isNonPositive) && Su(null !== (e1 = Us(i)) && void 0 !== e1 ? e1 : NaN) : null === (t = this._flags) || void 0 === t ? void 0 : t.prime;
    }
    set prime(e1) {
        this.updateFlags({
            prime: e1
        });
    }
    get composite() {
        var e1, t;
        const i = this._value;
        return i ? !(!i.isInteger || i.isNonPositive || Su(null !== (e1 = Us(i)) && void 0 !== e1 ? e1 : NaN)) : null === (t = this._flags) || void 0 === t ? void 0 : t.composite;
    }
    set composite(e1) {
        this.updateFlags({
            composite: e1
        });
    }
    updateFlags(e1) {
        var t;
        if (this.constant) throw Error("The flags of constant cannot be changed");
        if (!1 === (null === (t = this.domain) || void 0 === t ? void 0 : t.isNumeric)) throw Error("Flags only apply to numeric domains");
        let i = 0, n = !0;
        for(const t1 in Object.keys(e1))if (i += 1, this._value && void 0 !== e1[t1]) switch(t1){
            case "number":
                n = this._value.isNumber === e1.number;
                break;
            case "integer":
                n = this._value.isInteger === e1.integer;
                break;
            case "rational":
                n = this._value.isRational === e1.rational;
                break;
            case "algebraic":
                n = this._value.isAlgebraic === e1.algebraic;
                break;
            case "real":
                n = this._value.isReal === e1.real;
                break;
            case "extendedReal":
                n = this._value.isExtendedReal === e1.extendedReal;
                break;
            case "complex":
                n = this._value.isComplex === e1.complex;
                break;
            case "extendedComplex":
                n = this._value.isExtendedComplex === e1.extendedComplex;
                break;
            case "imaginary":
                n = this._value.isImaginary === e1.imaginary;
                break;
            case "positive":
                n = this._value.isPositive === e1.positive;
                break;
            case "nonPositive":
                n = this._value.isNonPositive === e1.nonPositive;
                break;
            case "negative":
                n = this._value.isNegative === e1.negative;
                break;
            case "nonNegative":
                n = this._value.isNonNegative === e1.nonNegative;
                break;
            case "zero":
                n = this._value.isZero === e1.zero;
                break;
            case "notZero":
                n = this._value.isNotZero === e1.notZero;
                break;
            case "one":
                n = this._value.isOne === e1.one;
                break;
            case "negativeOne":
                n = this._value.isNegativeOne === e1.negativeOne;
                break;
            case "infinity":
                n = this._value.isInfinity === e1.infinity;
                break;
            case "NaN":
                n = this._value.isNaN === e1.NaN;
                break;
            case "finite":
                n = this._value.isFinite === e1.finite;
                break;
            case "even":
                n = this._value.isEven === e1.even;
                break;
            case "odd":
                n = this._value.isOdd === e1.odd;
                break;
            case "prime":
                n = this._value.isPrime === e1.prime;
                break;
            case "composite":
                n = this._value.isComposite === e1.composite;
        }
        i > 0 && (n || (this._defValue = void 0, this._value = void 0), this._domain = this._engine.domain("Number"), this._flags ? this._flags = {
            ...this._flags,
            ...Rc(e1)
        } : this._flags = Rc(e1));
    }
    constructor(e1, t, i){
        var n, r, o, a;
        if (!e1.context) throw Error("No context available");
        this.name = t, this.wikidata = i.wikidata, this.description = i.description, this.url = i.url, this._engine = e1, this.scope = e1.context, this.name = t, this._flags = i.flags ? Rc(i.flags) : void 0, this._domain = i.domain ? e1.domain(i.domain) : void 0, this.constant = null !== (n = i.constant) && void 0 !== n && n, this.holdUntil = null !== (r = i.holdUntil) && void 0 !== r ? r : "simplify", this.constant ? (this._defValue = i.value, this._value = null) : (i.value ? Js(i.value) ? this._value = null !== (o = e1.parse(i.value)) && void 0 !== o ? o : e1.symbol("Undefined") : "function" == typeof i.value ? this._value = e1.box(null !== (a = i.value(e1)) && void 0 !== a ? a : "Undefined") : i.value instanceof eu ? this._value = i.value : this._value = e1.box(i.value) : this._value = void 0, this._value || !this._domain || i.flags || (this._flags = Kc(this._domain)));
    }
}
function Rc(e1) {
    const t = {
        ...e1
    };
    return (e1.zero || e1.one || e1.negativeOne) && (t.zero = e1.zero && !e1.one && !e1.negativeOne, t.notZero = !e1.zero || e1.one || e1.negativeOne, t.one = e1.one && !e1.zero && !e1.negativeOne, t.negativeOne = e1.negativeOne && !e1.zero && !e1.one, t.infinity = !1, t.NaN = !1, t.finite = !0, t.integer = !0, t.finite = !0, t.infinity = !1, t.NaN = !1, t.even = e1.one, t.odd = !e1.one, t.prime = !1, t.composite = !1), t.zero && (t.positive = !1, t.negative = !1, t.nonPositive = !0, t.nonNegative = !0), !0 === t.notZero && (t.imaginary || (t.real = !0), t.zero = !1), t.one && (t.positive = !0), t.negativeOne && (t.nonPositive = !0), (t.positive || t.nonNegative) && (t.negativeOne = !1), t.positive ? (t.nonPositive = !1, t.negative = !1, t.nonNegative = !0) : t.nonPositive ? (t.positive = !1, t.negative = t.notZero, t.nonNegative = !t.zero) : t.negative ? (t.positive = !1, t.nonPositive = t.notZero, t.nonNegative = !1) : t.nonNegative && (t.positive = t.notZero, t.nonPositive = !t.zero, t.negative = !1), (t.positive || t.negative || t.nonPositive || t.nonNegative) && (t.number = !0, t.finite ? t.real = !0 : t.finite || (t.complex = !0), t.imaginary = !1), t.finite && (t.number = !0, t.complex = !0, t.infinity = !1, t.NaN = !1), t.infinity && (t.finite = !1, t.NaN = !1), !1 === t.infinity && (t.extendedComplex = !1, t.extendedReal = !1), e1.even && (t.odd = !1), e1.odd && (t.even = !1), t.integer && (t.rational = !0), t.rational && (t.algebraic = !0), t.algebraic && (t.real = !0), t.real && (t.complex = !0), t.imaginary && (t.complex = !0), t.complex && (t.number = !0), t.real && !1 !== t.infinity && (t.extendedReal = !0), t.complex && !1 !== t.infinity && (t.extendedComplex = !0), (t.even || t.infinity || t.NaN || t.negative || t.imaginary || !1 === t.integer) && (t.prime = !1), t.number && t.prime && (t.composite = !1), t;
}
function Kc(e1) {
    if (!e1) return {};
    const t = {};
    if (e1.isNumeric) {
        const i = e1.literal;
        t.number = !0, "Integer" === i && (t.integer = !0), "RationalNumber" === i && (t.rational = !0), "AlgebraicNumber" === i && (t.algebraic = !0), "TranscendentalNumber" === i && (t.algebraic = !1, t.real = !0), "ExtendedRealNumber" === i && (t.extendedReal = !0), "RealNumber" === i && (t.real = !0), "ImaginaryNumber" === i && (t.imaginary = !0), "ExtendedComplexNumber" === i && (t.extendedComplex = !0), "ComplexNumber" === i && (t.complex = !0), "PositiveNumber" === i && (t.notZero = !0, t.real = !0, t.positive = !0), "NegativeNumber" === i && (t.notZero = !0, t.real = !0, t.negative = !0), "NonNegativeNumber" === i && (t.real = !0, t.positive = !0), "NonPositiveNumber" === i && (t.real = !0, t.negative = !0), "PositiveInteger" === i && (t.notZero = !0, t.integer = !0, t.positive = !0), "NegativeNumber" === i && (t.notZero = !0, t.integer = !0, t.negative = !0), "NonNegativeNumber" === i && (t.integer = !0, t.positive = !0), "NonPositiveNumber" === i && (t.integer = !0, t.negative = !0);
    } else t.number = !1, t.integer = !1, t.rational = !1, t.algebraic = !1, t.real = !1, t.extendedReal = !1, t.complex = !1, t.extendedComplex = !1, t.imaginary = !1, t.positive = !1, t.nonPositive = !1, t.negative = !1, t.nonNegative = !1, t.zero = !1, t.notZero = !1, t.one = !1, t.negativeOne = !1, t.infinity = !1, t.NaN = !1, t.odd = !1, t.even = !1, t.prime = !1, t.composite = !1;
    var i1;
    return i1 = Rc(t), Object.fromEntries(Object.entries(i1).filter(([e1, t])=>void 0 !== t));
}
class Vc {
    reset() {}
    constructor(e1, t, i){
        var n, r, o, a, s, l, u, c, d, h, m, p;
        if (!e1.context) throw Error("No context available");
        this.engine = e1, this.scope = e1.context;
        const f = null !== (n = i.idempotent) && void 0 !== n && n, g = null !== (r = i.involution) && void 0 !== r && r;
        if (f && g) throw Error(`Function Definition "${t}": the 'idempotent' and 'involution' flags are mutually exclusive`);
        if (this.name = t, this.description = i.description, this.wikidata = i.wikidata, this.threadable = null !== (o = i.threadable) && void 0 !== o && o, this.associative = null !== (a = i.associative) && void 0 !== a && a, this.commutative = null !== (s = i.commutative) && void 0 !== s && s, this.idempotent = f, this.involution = g, this.inert = null !== (l = i.inert) && void 0 !== l && l, this.numeric = null !== (u = i.numeric) && void 0 !== u && u, this.pure = null === (c = i.pure) || void 0 === c || c, this.complexity = null !== (d = i.complexity) && void 0 !== d ? d : 1e5, this.hold = null !== (h = i.hold) && void 0 !== h ? h : "none", this.inert) {
            if (i.hold) throw Error(`Function Definition "${t}": an inert function should not have a hold`);
            if (this.hold = "rest", i.signature) {
                const e2 = i.signature;
                if ("simplify" in e2 || "evaluate" in e2 || "N" in e2 || "evalDimension" in e2 || "sgn" in e2 || "compile" in e2) throw Error(`Function Definition "${t}": an inert function should only have 'canonical' or 'codomain' handlers`);
            }
            if (this.threadable) throw Error(`Function Definition "${t}": an inert function should not be threadable`);
            if (this.associative) throw Error(`Function Definition "${t}": an inert function should not be associative`);
            if (this.commutative) throw Error(`Function Definition "${t}": an inert function should not be commutative`);
            if (this.idempotent) throw Error(`Function Definition "${t}": an inert function should not be idempotent`);
            if (this.involution) throw Error(`Function Definition "${t}": an inert function should not be involution`);
            if (!this.pure) throw Error(`Function Definition "${t}": an inert function should be pure`);
        }
        if (i.signature) {
            const n1 = i.signature, r1 = n1.domain ? e1.domain(n1.domain) : i.numeric ? e1.domain("NumericFunction") : e1.domain("Function");
            if (!r1.isValid) throw Error(`Function Definition "${t}": invalid domain ${JSON.stringify(n1.domain)}`);
            const o1 = null !== (p = null !== (m = n1.codomain) && void 0 !== m ? m : r1.codomain) && void 0 !== p ? p : i.numeric ? e1.domain("Number") : e1.domain("Anything");
            this.signature = {
                domain: r1,
                codomain: o1,
                canonical: n1.canonical,
                simplify: n1.simplify,
                evaluate: n1.evaluate ? "function" == typeof n1.evaluate ? n1.evaluate : e1.box(n1.evaluate, {
                    canonical: !1
                }) : void 0,
                N: n1.N,
                evalDimension: n1.evalDimension,
                sgn: n1.sgn,
                compile: n1.compile
            };
        } else i.numeric ? this.signature = {
            domain: e1.domain("NumericFunction"),
            codomain: e1.domain("Number")
        } : this.signature = {
            domain: e1.domain("Function"),
            codomain: e1.domain("Anything")
        };
    }
}
function jc(e1, t, i) {
    return i instanceof Vc ? i : new Vc(e1, t, i);
}
function Hc(e1) {
    return !!e1 && "object" == typeof e1 && ("domain" in e1 || "value" in e1 || "constant" in e1);
}
function Uc(e1) {
    return !!e1 && "object" == typeof e1 && ("complexity" in e1 || "numeric" in e1 || "signature" in e1);
}
function Gc(e1) {
    if ("all" === e1) return Gc([
        "domains",
        "core",
        "control-structures",
        "logic",
        "collections",
        "relop",
        "numeric",
        "arithmetic",
        "algebra",
        "calculus",
        "combinatorics",
        "linear-algebra",
        "other",
        "physics",
        "polynomials",
        "statistics",
        "trigonometry",
        "dimensions",
        "units"
    ]);
    "string" == typeof e1 && (e1 = [
        e1
    ]);
    const t = [];
    for (const i of e1){
        const e2 = Zc[i];
        if (!e2) throw Error("Unknown library category " + i);
        Array.isArray(e2) ? t.push(...e2) : t.push(e2);
    }
    return t;
}
const Zc = {
    algebra: [],
    arithmetic: gc,
    calculus: bc,
    combinatorics: [],
    "control-structures": [],
    dimensions: [],
    domains: [],
    core: vc,
    collections: [
        Cc,
        {
            Sequence: {
                signature: {
                    domain: "Function"
                }
            }
        }
    ],
    "linear-algebra": [],
    logic: xc,
    numeric: [],
    other: [],
    relop: Ac,
    polynomials: Lc,
    physics: {
        "Mu-0": {
            description: "Vaccum permeability",
            constant: !0,
            wikidata: "Q1515261",
            domain: "RealNumber",
            value: 125663706212e-17
        }
    },
    statistics: [],
    trigonometry: Ec,
    units: []
};
function Wc(e1) {
    if (!va(e1 = e1.normalize())) throw Error("Invalid definition name " + e1);
    return e1;
}
function Jc(e1, t) {
    var i, n;
    if (!e1.context) throw Error("No context available");
    null !== (i = (n = e1.context).idTable) && void 0 !== i || (n.idTable = new Map);
    const r = e1.context.idTable;
    for (let i1 of Object.keys(t)){
        const n1 = t[i1];
        if (i1 = Wc(i1), Uc(n1)) {
            const t1 = jc(e1, i1, n1);
            if (r.has(i1)) throw Error(`Duplicate function definition ${i1}:\n${JSON.stringify(r.get(i1))}\n${JSON.stringify(n1)}`);
            r.set(i1, t1);
        } else if (Hc(n1)) {
            const t2 = new Pc(e1, i1, n1);
            if (e1.strict && n1.wikidata) {
                for (const [e2, t3] of r)if (t3.wikidata === n1.wikidata) throw Error(`Duplicate entry with wikidata "${n1.wikidata}": "${i1}" and "${t3.name}"`);
            }
            if (r.has(i1)) throw Error(`Duplicate symbol definition "${i1}":\n${JSON.stringify(r.get(i1))}\n${JSON.stringify(n1)}`);
            r.set(i1, t2);
        } else {
            const t4 = new Pc(e1, i1, {
                value: e1.box(n1)
            });
            r.set(i1, t4);
        }
    }
}
function Xc(e1) {
    return Number.isInteger(e1) ? Math.floor(Math.log2(Math.abs(e1)) / Math.log2(10)) + (e1 > 0 ? 1 : 2) : 2;
}
const Yc = function e1(t) {
    var i, n;
    if (t.symbol) return 1;
    const r = t.numericValue;
    if (null !== r) {
        if (t.isZero) return 1;
        if (t.isInteger) return Xc(Us(t));
        if (_l(r)) return wl(r) ? Xc(r[0]) + Xc(r[1]) + 1 : Xc(r[0].toNumber()) + Xc(r[1].toNumber()) + 1;
        if (r instanceof la) return Xc(r.re) + Xc(r.im) + 1;
        if (t.isNumber) return 2;
    }
    const o = t.head;
    return ("string" == typeof o ? 1 : e1(o)) + (null !== (n = null === (i = t.ops) || void 0 === i ? void 0 : i.reduce((t, i)=>t + e1(i), 0)) && void 0 !== n ? n : 0);
};
class Qc {
    has(e1) {
        for (const t of this._items.keys())if (t.isSame(e1)) return !0;
        return !1;
    }
    get(e1) {
        for (const [t, i] of this._items)if (t.isSame(e1)) return i;
    }
    clear() {
        this._items.clear();
    }
    set(e1, t) {
        for (const i of this._items.keys())if (i.isSame(e1)) return void this._items.set(i, t);
        this._items.set(e1, t);
    }
    delete(e1) {
        this._items.delete(e1);
    }
    [Symbol.iterator]() {
        return this._items.entries();
    }
    entries() {
        return this._items.entries();
    }
    constructor(e1){
        this._items = e1 ? e1 instanceof Qc ? new Map(e1._items) : new Map(e1) : new Map;
    }
}
class ed extends eu {
    get hash() {
        return rl("Pattern") ^ this._pattern.hash;
    }
    unbind() {
        this._pattern.unbind();
    }
    get json() {
        return hu(this.engine, "Pattern", [
            this._pattern
        ]);
    }
    get head() {
        return "Pattern";
    }
    get domain() {
        return this.engine.domain("Pattern");
    }
    get isCanonical() {
        return !0;
    }
    set isCanonical(e1) {}
    isSame(e1) {
        return this === e1 || e1 instanceof ed && this._pattern.isSame(e1._pattern);
    }
    isEqual(e1) {
        return e1 instanceof ed && this._pattern.isEqual(e1._pattern);
    }
    match(e1, t) {
        var i, n, r;
        return function(e1, t, i) {
            var n, r;
            return nd(e1, t, null !== (n = i.substitution) && void 0 !== n ? n : {}, {
                numericTolerance: null !== (r = null == i ? void 0 : i.numericTolerance) && void 0 !== r ? r : 1e-10
            }) || null;
        }(e1, this._pattern, {
            recursive: null !== (i = null == t ? void 0 : t.recursive) && void 0 !== i && i,
            numericTolerance: null !== (n = null == t ? void 0 : t.numericTolerance) && void 0 !== n ? n : 0,
            substitution: null !== (r = null == t ? void 0 : t.substitution) && void 0 !== r ? r : {}
        });
    }
    test(e1, t) {
        return null !== this.match(e1, t);
    }
    count(e1, t) {
        let i = 0;
        for (const n of e1)null !== this.match(n, t) && (i += 1);
        return i;
    }
    subs(e1, t) {
        return this._pattern.subs(e1, t);
    }
    constructor(e1, t, i){
        super(e1, i), this._pattern = Js(t) ? e1.parse(t, {
            canonical: !1
        }) : e1.box(t, {
            canonical: !1
        });
    }
}
function td(e1) {
    var t;
    if ("string" == typeof e1) return e1.startsWith("_");
    if (null === (t = e1.symbol) || void 0 === t ? void 0 : t.startsWith("_")) return !0;
    if (e1.ops) return td(e1.head) || e1.ops.some(td);
    if (e1.keys) {
        for (const t1 of e1.keys)if (td(e1.getKey(t1))) return !0;
    }
    return !1;
}
function id(e1, t, i) {
    const n = function(e1) {
        const t = e1.match(/^(__?_?[a-zA-Z0-9]+)/);
        return null === t ? "" : t[1];
    }(e1);
    return "" === n ? i : void 0 !== i[n] ? t.isSame(i[n]) ? i : null : td(t) ? null : {
        ...i,
        [n]: t
    };
}
function nd(e1, t, i, n) {
    const r = e1.engine;
    if ("Pattern" === t.head) return t.match(e1, {
        substitution: i,
        ...n
    });
    if (t instanceof Mu) return e1 instanceof Mu ? 0 === n.numericTolerance ? t.isSame(e1) ? i : null : t.isEqualWithTolerance(e1, n.numericTolerance) ? i : null : null;
    const o = t.string;
    if (null !== o) return e1.string === o ? i : null;
    const a = t.symbol;
    if (null !== a) return a.startsWith("_") ? id(a, e1, i) : a === e1.symbol ? i : null;
    if (t.nops !== e1.nops) return null;
    const s = t.keys;
    if (null !== s) {
        const t1 = e1.keys;
        if (null === t1) return null;
        for (const e2 of s){
            const r1 = nd(t1[e2], s[e2], i, n);
            if (null === r1) return null;
            i = r1;
        }
        return i;
    }
    if (t.ops) {
        const o1 = t.head;
        if ("string" == typeof o1 && o1.startsWith("_")) return id(o1, r.box(e1.head), i);
        let a1;
        if ("string" == typeof o1 && "string" == typeof e1.head) {
            if (o1 !== e1.head) return null;
            a1 = r.lookupFunction(o1);
        } else {
            const t2 = nd(r.box(e1.head, {
                canonical: !1
            }), r.box(o1, {
                canonical: !1
            }), i, n);
            if (null === t2) return null;
            i = t2;
        }
        return (null == a1 ? void 0 : a1.commutative) ? function(e1, t, i, n) {
            const r = function(e1) {
                const t = [], i = (e1, n = [])=>{
                    if (0 === e1.length) t.push(n);
                    else for(let t1 = 0; t1 < e1.length; t1++){
                        const r = e1.slice(), o = r.splice(t1, 1);
                        i(r.slice(), n.concat(o));
                    }
                };
                return i(e1), t;
            }(t.ops);
            for (const t1 of r){
                const r1 = rd(e1.engine, e1.ops, t1, i, n);
                if (null !== r1) return r1;
            }
            return null;
        }(e1, t, i, n) : function(e1, t, i, n) {
            const r = e1.engine, o = [
                ...e1.ops
            ];
            let a = {
                ...i
            }, s = 0;
            const l = t.ops;
            for(; s < t.nops;){
                const e2 = l[s], t1 = e2.symbol;
                if (null !== t1) {
                    if (t1.startsWith("__")) {
                        let e3 = 0;
                        if (void 0 === l[s + 1]) e3 = o.length + 1;
                        else {
                            let t2 = !1;
                            for(; !t2 && e3 < o.length;)t2 = null !== nd(o[e3], l[s + 1], a, n), e3 += 1;
                            if (!t2) return null;
                        }
                        if (!t1.startsWith("___") && e3 <= 1) return null;
                        a = id(t1, r.fn("Sequence", o.splice(0, e3 - 1)), a);
                    } else if (t1.startsWith("_")) a = id(t1, o.shift(), a);
                    else {
                        const t3 = nd(o.shift(), e2, a, n);
                        if (null === t3) return null;
                        a = t3;
                    }
                } else {
                    const t4 = nd(o.shift(), e2, a, n);
                    if (null === t4) return null;
                    a = t4;
                }
                if (null === a) return null;
                s += 1;
            }
            return a;
        }(e1, t, i, n);
    }
    return null;
}
function rd(e1, t, i, n, r) {
    var o;
    let a = {
        ...n
    };
    t = [
        ...t
    ];
    let s = !1;
    for (const e2 of i)if ("__" === e2.symbol) s = !0;
    else {
        let i1 = null;
        if (null === (o = e2.symbol) || void 0 === o ? void 0 : o.startsWith("_")) {
            for(let n1 = 0; n1 <= t.length - 1; n1++)if (i1 = id(e2.symbol, t[n1], a), null !== i1) {
                t.splice(n1, 1);
                break;
            }
        } else for(let n2 = 0; n2 <= t.length - 1; n2++)if (i1 = nd(t[n2], e2, a, r), null !== i1) {
            t.splice(n2, 1);
            break;
        }
        if (null === i1) return null;
        a = i1;
    }
    return !s && t.length > 0 ? null : (null !== a && s && (a.__ = e1._fn("Sequence", t)), a);
}
function od(e1) {
    return null != e1 && "constant" in e1;
}
class ad extends eu {
    get hash() {
        return void 0 === this._hash && (this._hash = rl(this._name)), this._hash;
    }
    unbind() {
        var e1;
        null === (e1 = this._def) || void 0 === e1 || e1.reset(), this._def = null;
    }
    get isPure() {
        var e1, t, i, n, r;
        return null !== (r = null !== (i = (null === (e1 = this.symbolDefinition) || void 0 === e1 ? void 0 : e1.constant) && (null === (t = this.symbolDefinition.value) || void 0 === t ? void 0 : t.isPure)) && void 0 !== i ? i : null === (n = this.functionDefinition) || void 0 === n ? void 0 : n.pure) && void 0 !== r && r;
    }
    get json() {
        return mu(this.engine, this._name, {
            latex: this._latex,
            wikidata: this._wikidata
        });
    }
    get scope() {
        return this._scope;
    }
    get isFree() {
        var e1;
        return !(null === (e1 = this.symbolDefinition) || void 0 === e1 ? void 0 : e1.value);
    }
    get isConstant() {
        var e1, t;
        return null !== (t = null === (e1 = this.symbolDefinition) || void 0 === e1 ? void 0 : e1.constant) && void 0 !== t && t;
    }
    get isCanonical() {
        return null !== this._scope;
    }
    set isCanonical(e1) {
        this._scope = e1 ? this.engine.context : null, this._def = null;
    }
    get canonical() {
        return this._scope ? this : this.engine.box(this._name);
    }
    get wikidata() {
        var e1, t, i;
        return null !== (i = null !== (e1 = this._wikidata) && void 0 !== e1 ? e1 : null === (t = this.baseDefinition) || void 0 === t ? void 0 : t.wikidata) && void 0 !== i ? i : void 0;
    }
    get description() {
        if (this.baseDefinition && this.baseDefinition.description) return "string" == typeof this.baseDefinition.description ? [
            this.baseDefinition.description
        ] : this.baseDefinition.description;
    }
    get url() {
        var e1, t;
        return null !== (t = null === (e1 = this.baseDefinition) || void 0 === e1 ? void 0 : e1.url) && void 0 !== t ? t : void 0;
    }
    get complexity() {
        return 7;
    }
    get head() {
        return "Symbol";
    }
    get symbol() {
        return this._name;
    }
    get isNothing() {
        return "Nothing" === this._name;
    }
    get baseDefinition() {
        var e1;
        return null === this._def && this.bind(this._scope), null !== (e1 = this._def) && void 0 !== e1 ? e1 : void 0;
    }
    get symbolDefinition() {
        return null === this._def && this.bind(this._scope), od(this._def) ? this._def : void 0;
    }
    get functionDefinition() {
        var e1;
        return null === this._def && this.bind(this._scope), null != (e1 = this._def) && "signature" in e1 ? this._def : void 0;
    }
    bind(e1) {
        if (null === e1) return void (this._def = void 0);
        let t;
        if (t = this.engine.lookupSymbol(this._name, this._wikidata, e1), (null == t ? void 0 : t.wikidata) && this._wikidata && t.wikidata !== this._wikidata && (t = void 0), t) return this._name = t.name, void (this._def = t);
        t = this.engine.lookupFunction(this._name, e1), t ? this._def = t : null !== this.engine.defaultDomain && (this._def = this.engine.defineSymbol(this._name, {
            wikidata: this._wikidata,
            domain: this.engine.defaultDomain
        }), this._name = this._def.name);
    }
    get value() {
        var e1;
        return null === (e1 = this.symbolDefinition) || void 0 === e1 ? void 0 : e1.value;
    }
    set value(e1) {
        var t;
        if ("_" === this._name[0]) throw Error(`The value of the wildcard "${this._name}" cannot be changed`);
        let i;
        if (this.engine.forget(this._name), void 0 !== e1) {
            const n = this.engine.box(e1);
            i = null !== (t = n.value) && void 0 !== t ? t : n.evaluate();
        }
        if (null == i ? void 0 : i.domain.isCompatible("Function")) this._def = this.engine.defineFunction(this._name, {
            signature: {
                domain: i.domain,
                evaluate: i
            }
        });
        else if (this._def && od(this._def)) this._def.value = i;
        else {
            let e2 = null == i ? void 0 : i.domain;
            (null == e2 ? void 0 : e2.isNumeric) && (e2 = this.engine.domain("Number")), this._def = this.engine.defineSymbol(this._name, {
                value: i,
                domain: null != e2 ? e2 : void 0
            });
        }
    }
    get domain() {
        var e1, t, i;
        return this.functionDefinition ? this.engine.domain("Function") : null !== (i = null !== (t = null === (e1 = this.symbolDefinition) || void 0 === e1 ? void 0 : e1.domain) && void 0 !== t ? t : this.engine.defaultDomain) && void 0 !== i ? i : this.engine.domain("Value");
    }
    set domain(e1) {
        if ("_" === this._name[0]) throw Error(`The domain of the wildcard "${this._name}" cannot be changed`);
        const t = this.engine.domain(e1);
        t.isCompatible("Function") ? (this.engine.forget(this._name), this._def = this.engine.defineFunction(this._name, {
            signature: {
                domain: t
            }
        })) : od(this._def) ? this._def.domain = t : (this.engine.forget(this._name), this._def = this.engine.defineSymbol(this._name, {
            domain: t
        }));
    }
    get explicitDomain() {
        var e1, t;
        return this.functionDefinition ? this.engine.domain("Function") : null !== (t = null === (e1 = this.symbolDefinition) || void 0 === e1 ? void 0 : e1.domain) && void 0 !== t ? t : void 0;
    }
    get sgn() {
        const e1 = this.value;
        if (e1 && e1 !== this) {
            const t = e1.sgn;
            if (void 0 !== t) return t;
        }
        const t1 = this.symbolDefinition;
        return t1 ? !0 === t1.zero ? 0 : !0 === t1.positive ? 1 : !0 === t1.negative ? -1 : void 0 : null;
    }
    has(e1) {
        return "string" == typeof e1 ? this._name === e1 : e1.includes(this._name);
    }
    isSame(e1) {
        return this === e1 || e1 instanceof ad && this._name === e1._name;
    }
    match(e1, t) {
        return e1 instanceof ad && this._name === e1._name ? {} : null;
    }
    isEqual(e1) {
        var t, i;
        if (!this.isCanonical) return this.canonical.isEqual(e1);
        if (this === (e1 = e1.canonical)) return !0;
        if (null !== e1.symbol) return e1.symbol === this._name;
        const n = null === (i = null === (t = this.symbolDefinition) || void 0 === t ? void 0 : t.value) || void 0 === i ? void 0 : i.N();
        if (n) return n.isEqual(e1.N());
        if (e1.isZero) {
            if (this.isZero) return !0;
            if (this.isNotZero) return !1;
        }
        return !(this.isZero && e1.isNotZero || !(this.engine.ask([
            "Equal",
            this,
            e1
        ]).length > 0) && (this.engine.ask([
            "NotEqual",
            this,
            e1
        ]).length, 1));
    }
    isLess(e1) {
        var t, i;
        if (null !== e1.symbol && e1.symbol === this._name) return !1;
        const n = null === (i = null === (t = this.symbolDefinition) || void 0 === t ? void 0 : t.value) || void 0 === i ? void 0 : i.N();
        if (n) return n.isLess(e1.N());
        if (e1.isZero) {
            const e2 = this.sgn;
            if (null === e2) return !1;
            if (void 0 !== e2) return e2 < 0;
        }
    }
    isLessEqual(e1) {
        var t, i;
        if (null !== e1.symbol && e1.symbol === this._name) return !0;
        const n = null === (i = null === (t = this.symbolDefinition) || void 0 === t ? void 0 : t.value) || void 0 === i ? void 0 : i.N();
        if (n) return n.isLessEqual(e1.N());
        if (e1.isZero) {
            const e2 = this.sgn;
            if (null === e2) return !1;
            if (void 0 !== e2) return e2 <= 0;
        }
        return this.isLess(e1) || this.isEqual(e1);
    }
    isGreater(e1) {
        var t, i;
        if (null !== e1.symbol && e1.symbol === this._name) return !1;
        const n = null === (i = null === (t = this.symbolDefinition) || void 0 === t ? void 0 : t.value) || void 0 === i ? void 0 : i.N();
        if (n) return n.isGreater(e1.N());
        if (e1.isZero) {
            const e2 = this.sgn;
            if (null === e2) return !1;
            if (void 0 !== e2) return e2 > 0;
        }
    }
    isGreaterEqual(e1) {
        var t, i;
        if (null !== e1.symbol && e1.symbol === this._name) return !0;
        const n = null === (i = null === (t = this.symbolDefinition) || void 0 === t ? void 0 : t.value) || void 0 === i ? void 0 : i.N();
        if (n) return n.isGreaterEqual(e1.N());
        if (e1.isZero) {
            const e2 = this.sgn;
            if (null === e2) return !1;
            if (void 0 !== e2) return e2 >= 0;
        }
        return this.isGreater(e1) || this.isEqual(e1);
    }
    get isFunction() {
        return !!this.functionDefinition;
    }
    get isZero() {
        var e1;
        return null === (e1 = this.symbolDefinition) || void 0 === e1 ? void 0 : e1.zero;
    }
    get isNotZero() {
        var e1;
        return null === (e1 = this.symbolDefinition) || void 0 === e1 ? void 0 : e1.notZero;
    }
    get isOne() {
        var e1;
        return null === (e1 = this.symbolDefinition) || void 0 === e1 ? void 0 : e1.one;
    }
    get isNegativeOne() {
        var e1;
        return null === (e1 = this.symbolDefinition) || void 0 === e1 ? void 0 : e1.negativeOne;
    }
    get isOdd() {
        var e1;
        return null === (e1 = this.symbolDefinition) || void 0 === e1 ? void 0 : e1.odd;
    }
    get isEven() {
        var e1;
        return null === (e1 = this.symbolDefinition) || void 0 === e1 ? void 0 : e1.even;
    }
    get isPrime() {
        var e1;
        return null === (e1 = this.symbolDefinition) || void 0 === e1 ? void 0 : e1.prime;
    }
    get isComposite() {
        var e1;
        return null === (e1 = this.symbolDefinition) || void 0 === e1 ? void 0 : e1.composite;
    }
    get isInfinity() {
        var e1;
        return null === (e1 = this.symbolDefinition) || void 0 === e1 ? void 0 : e1.infinity;
    }
    get isNaN() {
        var e1;
        return null === (e1 = this.symbolDefinition) || void 0 === e1 ? void 0 : e1.NaN;
    }
    get isPositive() {
        var e1;
        return null === (e1 = this.symbolDefinition) || void 0 === e1 ? void 0 : e1.positive;
    }
    get isNonPositive() {
        var e1;
        return null === (e1 = this.symbolDefinition) || void 0 === e1 ? void 0 : e1.nonPositive;
    }
    get isNegative() {
        var e1;
        return null === (e1 = this.symbolDefinition) || void 0 === e1 ? void 0 : e1.negative;
    }
    get isNonNegative() {
        var e1;
        return null === (e1 = this.symbolDefinition) || void 0 === e1 ? void 0 : e1.nonNegative;
    }
    get isNumber() {
        var e1;
        return null === (e1 = this.symbolDefinition) || void 0 === e1 ? void 0 : e1.number;
    }
    get isInteger() {
        var e1;
        return null === (e1 = this.symbolDefinition) || void 0 === e1 ? void 0 : e1.integer;
    }
    get isRational() {
        var e1;
        return null === (e1 = this.symbolDefinition) || void 0 === e1 ? void 0 : e1.rational;
    }
    get isAlgebraic() {
        var e1;
        return null === (e1 = this.symbolDefinition) || void 0 === e1 ? void 0 : e1.rational;
    }
    get isReal() {
        var e1;
        return null === (e1 = this.symbolDefinition) || void 0 === e1 ? void 0 : e1.real;
    }
    get isExtendedReal() {
        var e1;
        return null === (e1 = this.symbolDefinition) || void 0 === e1 ? void 0 : e1.extendedReal;
    }
    get isComplex() {
        var e1;
        return null === (e1 = this.symbolDefinition) || void 0 === e1 ? void 0 : e1.complex;
    }
    get isImaginary() {
        var e1;
        return null === (e1 = this.symbolDefinition) || void 0 === e1 ? void 0 : e1.imaginary;
    }
    simplify(e1) {
        var t;
        const i = this.symbolDefinition;
        return "never" !== (null == i ? void 0 : i.holdUntil) && "simplify" !== (null == i ? void 0 : i.holdUntil) || !i.value ? (null == e1 ? void 0 : e1.rules) && null !== (t = this.replace(e1.rules)) && void 0 !== t ? t : this : i.value.simplify(e1);
    }
    evaluate(e1) {
        var t, i;
        const n = this.symbolDefinition;
        return "N" !== (null == n ? void 0 : n.holdUntil) && null !== (i = null === (t = null == n ? void 0 : n.value) || void 0 === t ? void 0 : t.evaluate(e1)) && void 0 !== i ? i : this;
    }
    N(e1) {
        var t, i, n;
        return null !== (n = null === (i = null === (t = this.symbolDefinition) || void 0 === t ? void 0 : t.value) || void 0 === i ? void 0 : i.N(e1)) && void 0 !== n ? n : this;
    }
    replace(e1, t) {
        return ll(this, e1, t);
    }
    subs(e1, t) {
        return void 0 === e1[this._name] ? (null == t ? void 0 : t.canonical) ? this.canonical : this : this.engine.box(e1[this._name], t);
    }
    constructor(e1, t, i){
        var n;
        super(e1, null == i ? void 0 : i.metadata), this._name = t, this._scope = (null == i ? void 0 : i.canonical) ? e1.context : null, this._def = null !== (n = null == i ? void 0 : i.def) && void 0 !== n ? n : null;
    }
}
function sd(e1, t) {
    const i = e1.lookupSymbol(t, void 0, e1.context);
    return "never" === (null == i ? void 0 : i.holdUntil) && i.value ? i.value : new ad(e1, t, {
        canonical: !0,
        def: i
    });
}
class ld {
    static getStandardLibrary(e1 = "all") {
        return Gc(e1);
    }
    reset() {
        var e1;
        this._BIGNUM_NEGATIVE_ONE = this.bignum(-1), this._BIGNUM_NAN = this.bignum(NaN), this._BIGNUM_ZERO = this.bignum(0), this._BIGNUM_ONE = this.bignum(1), this._BIGNUM_TWO = this.bignum(2), this._BIGNUM_HALF = this._BIGNUM_ONE.div(this._BIGNUM_TWO), this._BIGNUM_PI = this._BIGNUM_NEGATIVE_ONE.acos();
        const t = this._stats.symbols.values(), i = this._stats.expressions.values();
        this._stats.symbols = new Set, this._stats.expressions = new Set;
        for (const e2 of t)e2.unbind();
        for (const e3 of i)e3.unbind();
        for (const e4 of Object.values(this._commonDomains))null == e4 || e4.unbind();
        for (const e5 of Object.values(this._commonSymbols))null == e5 || e5.unbind();
        let n = this.context;
        for(; n;){
            if (n.idTable) for (const [e6, t1] of n.idTable)t1.reset();
            n = null !== (e1 = n.parentScope) && void 0 !== e1 ? e1 : null;
        }
        for (const e7 of Object.keys(this._cache))this._cache[e7].value && (this._cache[e7].purge ? this._cache[e7].value = this._cache[e7].purge(this._cache[e7].value) : delete this._cache[e7]);
    }
    _register(e1) {
        this._stats.highwaterMark += 1;
    }
    _unregister(e1) {}
    get stats() {
        const e1 = this._stats.expressions;
        return this._stats.expressions = null, this._stats.expressions = e1, {
            ...this._stats
        };
    }
    get precision() {
        return "machine" === this._numericMode || "complex" === this._numericMode ? Math.floor(Fs) : this._precision;
    }
    set precision(e1) {
        var t;
        if ("machine" === e1 && (e1 = Math.floor(Fs)), e1 !== this._precision) {
            if ("number" != typeof e1 || e1 <= 0) throw Error('Expected "machine" or a positive number');
            null === (t = this._latexSyntax) || void 0 === t || t.updateOptions({
                precision: e1,
                avoidExponentsInRange: [
                    -6,
                    e1
                ]
            }), this._precision = Math.max(e1, Math.floor(Fs)), this.jsonSerializationOptions.precision > this._precision && (this.jsonSerializationOptions = {
                precision: this._precision
            }), "auto" !== this._numericMode && "bignum" !== this._numericMode && this._precision > Math.floor(Fs) && (this._numericMode = "auto"), this._bignum = this._bignum.config({
                precision: this._precision
            }), this.reset();
        }
    }
    get numericMode() {
        return this._numericMode;
    }
    set numericMode(e1) {
        if (e1 !== this._numericMode) {
            if ("string" != typeof e1) throw Error("Expected a string");
            this._numericMode = e1, "complex" !== e1 && "machine" !== e1 || (this._precision = Math.floor(Fs)), this._latexSyntax && this.latexSyntax.options.precision > this._precision && this.latexSyntax.updateOptions({
                precision: this._precision
            }), this.jsonSerializationOptions.precision > this._precision && (this.jsonSerializationOptions = {
                precision: this._precision
            }), this.reset();
        }
    }
    get timeLimit() {
        var e1;
        let t = this.context;
        for(; t;){
            if (void 0 !== t.timeLimit) return t.timeLimit;
            t = null !== (e1 = t.parentScope) && void 0 !== e1 ? e1 : null;
        }
        return 2;
    }
    get iterationLimit() {
        var e1;
        let t = this.context;
        for(; t;){
            if (void 0 !== t.iterationLimit) return t.iterationLimit;
            t = null !== (e1 = t.parentScope) && void 0 !== e1 ? e1 : null;
        }
        return 1024;
    }
    get recursionLimit() {
        var e1;
        let t = this.context;
        for(; t;){
            if (void 0 !== t.recursionLimit) return t.recursionLimit;
            t = null !== (e1 = t.parentScope) && void 0 !== e1 ? e1 : null;
        }
        return 1024;
    }
    get defaultDomain() {
        return this._defaultDomain;
    }
    set defaultDomain(e1) {
        if (null === e1) this._defaultDomain = null;
        else {
            const t = this.domain(e1);
            if (!t.isValid) throw Error("Invalid domain " + e1);
            this._defaultDomain = t;
        }
    }
    get tolerance() {
        return this._tolerance;
    }
    set tolerance(e1) {
        this._tolerance = "number" == typeof e1 && Number.isFinite(e1) ? Math.max(e1, 0) : 1e-10, this._bignumTolerance = this.bignum(this._tolerance);
    }
    bignum(e1) {
        return new this._bignum(e1);
    }
    complex(e1, t) {
        return new sa.exports.Complex(e1, t);
    }
    chop(e1) {
        return "number" == typeof e1 && Math.abs(e1) <= this._tolerance || e1 instanceof oa && e1.abs().lte(this._bignumTolerance) || e1 instanceof sa.exports.Complex && Math.abs(e1.re) <= this._tolerance && Math.abs(e1.im) <= this._tolerance ? 0 : e1;
    }
    get latexSyntax() {
        return this._latexSyntax || (this._latexSyntax = new Os({
            computeEngine: this,
            dictionary: this._latexDictionary,
            precision: this.precision,
            avoidExponentsInRange: [
                -6,
                this.precision
            ],
            onError: (e1)=>{
                throw Error(e1[0].message.toString());
            }
        })), this._latexSyntax;
    }
    static getLatexDictionary(e1 = "all") {
        return Os.getDictionary(e1);
    }
    set costFunction(e1) {
        "function" != typeof e1 && (this._cost = Yc), this._cost = e1;
    }
    get costFunction() {
        var e1;
        return null !== (e1 = this._cost) && void 0 !== e1 ? e1 : Yc;
    }
    lookupSymbol(e1, t, i) {
        var n, r, o;
        if (!this.strict) {
            for(null != i || (i = null !== (n = this.context) && void 0 !== n ? n : void 0); i;){
                const t1 = null === (r = i.idTable) || void 0 === r ? void 0 : r.get(e1);
                if (Hc(t1)) return t1;
                i = i.parentScope;
            }
            return;
        }
        if ("string" != typeof e1) throw Error("Expected a string");
        if (0 === e1.length || !this.context) return;
        const a = null != i ? i : this.context;
        if (t) for(i = a; i;){
            if (i.idTable) {
                for (const [e2, n1] of i.idTable)if (Hc(n1) && n1.wikidata === t) return n1;
            }
            i = i.parentScope;
        }
        for(i = a; i;){
            const t2 = null === (o = i.idTable) || void 0 === o ? void 0 : o.get(e1);
            if (Hc(t2)) return t2;
            i = i.parentScope;
        }
    }
    lookupFunction(e1, t) {
        var i;
        if ("string" == typeof e1 && this.context) for(null != t || (t = this.context); t;){
            const n = null === (i = t.idTable) || void 0 === i ? void 0 : i.get(e1);
            if (Uc(n)) return n;
            t = t.parentScope;
        }
    }
    defineSymbol(e1, t) {
        if (!this.context) throw Error("Symbol cannot be defined: no scope available");
        if (0 === e1.length || !va(e1)) throw Error("Invalid identifier " + e1);
        this.context.idTable || (this.context.idTable = new Map);
        const i = new Pc(this, e1, t);
        return i.name && this.context.idTable.set(i.name, i), i;
    }
    defineFunction(e1, t) {
        if (!this.context) throw Error("Function cannot be defined: no scope available");
        if (0 === e1.length || !va(e1)) throw Error("Invalid identifier " + e1);
        this.context.idTable || (this.context.idTable = new Map);
        const i = jc(this, e1, t);
        return i.name && this.context.idTable.set(e1, i), i;
    }
    pushScope(e1, t) {
        if (null === this.context) throw Error("No parent scope available");
        if (this.context = {
            ...null != t ? t : {},
            parentScope: this.context,
            assumptions: new Qc(this.context.assumptions)
        }, e1) {
            if (Array.isArray(e1)) for (const t1 of e1)Jc(this, t1);
            else Jc(this, e1);
        }
    }
    popScope() {
        var e1;
        if (!this.context) throw Error("No scope available");
        const t = null === (e1 = this.context) || void 0 === e1 ? void 0 : e1.parentScope;
        if (this.context.warnings) {
            const e2 = [
                ...this.context.warnings
            ];
            this.context.warnings = [], this.context.warn && this.context.warn(e2);
        }
        t && this.context.warnings && this.context.warnings.length > 0 && (t.warnings ? t.warnings = [
            ...t.warnings,
            ...this.context.warnings
        ] : t.warnings = [
            ...this.context.warnings
        ]), this.context = null != t ? t : null;
    }
    set(e1) {
        if (this.strict) {
            for (const t of Object.keys(e1))if ("Nothing" !== t) {
                const i = this.lookupSymbol(t), n = e1[t];
                if (null == n) i && (i.value = void 0);
                else {
                    const e2 = this.box(n);
                    if (i) {
                        if (i.domain && !e2.domain.isCompatible(i.domain)) throw Error(`Expected value with domain ${i.domain.toString()} for "${t}"`);
                        i.value = e2;
                    } else e2.domain.isNumeric ? this.defineSymbol(t, {
                        value: e2,
                        domain: "Number"
                    }) : this.defineSymbol(t, {
                        value: e2
                    });
                }
            }
        } else for (const t1 of Object.keys(e1))if ("Nothing" !== t1) {
            const i1 = this.lookupSymbol(t1), n1 = e1[t1];
            if (i1) i1.value = null != n1 ? n1 : void 0;
            else if (null != n1) {
                const e3 = this.box(n1);
                e3.domain.isNumeric ? this.defineSymbol(t1, {
                    value: e3,
                    domain: "Number"
                }) : this.defineSymbol(t1, {
                    value: e3
                });
            }
        }
    }
    let(e1) {
        for (const t of Object.keys(e1))if ("Nothing" !== t) {
            const i = e1[t];
            "value" in i || "domain" in i && "Function" !== i.domain ? this.defineSymbol(t, i) : this.defineFunction(t, i);
        }
    }
    get assumptions() {
        if (!this.context) throw Error("No scope available");
        return this.context.assumptions || (this.context.assumptions = new Qc), this.context.assumptions;
    }
    shouldContinueExecution() {
        return void 0 === this.deadline || this.deadline >= Date.now();
    }
    checkContinueExecution() {
        if (!this.shouldContinueExecution()) throw Error("timeout");
    }
    assert(e1, t, i, n) {
        e1 || this.signal(t, i, n);
    }
    signal(e1, t, i) {
        "object" == typeof e1 && "message" in e1 ? i = e1.message : e1.latex, void 0 === i || "string" == typeof i || Array.isArray(i) && i.map((e1)=>e1.toString()).join(", ");
    }
    cache(e1, t, i) {
        var n;
        if (void 0 === this._cache[e1]) try {
            this._cache[e1] = {
                build: t,
                purge: i,
                value: t()
            };
        } catch (e2) {}
        return null === (n = this._cache[e1]) || void 0 === n ? void 0 : n.value;
    }
    box(e1, t) {
        return Tu(this, e1, t);
    }
    fn(e1, t, i) {
        return Eu(this, e1, t, {
            metadata: i,
            canonical: !0
        });
    }
    _fn(e1, t, i) {
        return new vu(this, e1, t, {
            metadata: i,
            canonical: !0,
            def: this.lookupFunction(e1, this.context)
        });
    }
    error(e1, t) {
        if (t instanceof eu ? t = this.rawJson(t) : t && Array.isArray(t) && "Latex" === t[0] && (void 0 !== t[1] && t[1] || (t = ""), "object" == typeof t[1] && "str" in t[1] && !t[1].str && (t = "")), Array.isArray(e1) && "invalid-domain" === e1[0]) return Ru(this, [
            "Error",
            [
                "ErrorCode",
                "'invalid-domain'",
                e1[1]
            ]
        ]);
        const i = "string" == typeof e1 ? this.string(e1) : new vu(this, "ErrorCode", [
            this.string(e1[0]),
            ...e1.slice(1).map((e1)=>this.box(e1, {
                    canonical: !1
                }))
        ]);
        return new vu(this, "Error", t ? [
            i,
            this.box(t, {
                canonical: !1
            })
        ] : [
            i
        ], {
            canonical: !1
        });
    }
    hold(e1) {
        return this._fn("Hold", [
            this.box(e1, {
                canonical: !1
            })
        ]);
    }
    add(e1, t) {
        const i = Qu(this, e1);
        return void 0 !== (null == t ? void 0 : t.latex) && (i.latex = t.latex), void 0 !== (null == t ? void 0 : t.wikidata) && (i.wikidata = t.wikidata), i;
    }
    negate(e1, t) {
        return Kl(e1, t);
    }
    mul(e1, t) {
        const i = cc(this, e1 = cl(e1));
        return void 0 !== (null == t ? void 0 : t.latex) && (i.latex = t.latex), void 0 !== (null == t ? void 0 : t.wikidata) && (i.wikidata = t.wikidata), i;
    }
    divide(e1, t, i) {
        const n = pc(this, e1, t);
        return void 0 !== (null == i ? void 0 : i.latex) && (n.latex = i.latex), void 0 !== (null == i ? void 0 : i.wikidata) && (n.wikidata = i.wikidata), n;
    }
    sqrt(e1, t) {
        return this.power(e1, [
            1,
            2
        ], t);
    }
    power(e1, t, i) {
        var n;
        let r = null;
        if (t instanceof eu) {
            const e2 = t.numericValue;
            null !== e2 && ("number" == typeof e2 && (t = e2), _l(e2) && (t = e2));
        }
        if ("number" == typeof t ? r = t : _l(t) && (wl(t) && 1 === t[1] && (r = t[0]), Sl(t) && t[1].equals(1) && (r = t[0].toNumber())), 1 === r) return e1;
        const o = e1.numericValue;
        if (-1 === r && null !== o) {
            if ("number" == typeof o && Number.isInteger(o)) return this.number([
                1,
                o
            ]);
            if (o instanceof oa && o.isInteger()) return this.number([
                e1.engine._BIGNUM_ONE,
                o
            ]);
            if (_l(o)) return this.number((Sl(o), [
                o[1],
                o[0]
            ]));
        }
        return ("number" == typeof t || _l(t)) && (t = this.number(t)), null !== (n = oc(this, e1, t, i)) && void 0 !== n ? n : this._fn("Power", [
            e1,
            t
        ], i);
    }
    inverse(e1, t) {
        var i;
        let n = this._NEGATIVE_ONE;
        if ("Power" === e1.head) {
            if (e1.op2.isNegativeOne) return e1.op1;
            n = Kl(e1.op2), e1 = e1.op1;
        }
        return null !== (i = oc(this, e1, n, t)) && void 0 !== i ? i : this._fn("Power", [
            e1,
            n
        ], t);
    }
    pair(e1, t, i) {
        return new vu(this, "Tuple", [
            e1.canonical,
            t.canonical
        ], {
            metadata: i,
            canonical: !0
        });
    }
    tuple(e1, t) {
        return new vu(this, "Tuple", e1.map((e1)=>e1.canonical), {
            metadata: t,
            canonical: !0
        });
    }
    string(e1, t) {
        return new Lu(this, e1, t);
    }
    symbol(e1, t) {
        var i, n, r;
        if (null != t || (t = {}), "canonical" in t || (t.canonical = !0), "NaN" === (e1 = e1.normalize())) return this._NAN;
        if ("Infinity" === e1) return this._POSITIVE_INFINITY;
        if ("+Infinity" === e1) return this._POSITIVE_INFINITY;
        if ("-Infinity" === e1) return this._NEGATIVE_INFINITY;
        if ("Half" === e1) return this._HALF;
        if (this.strict && !va(e1)) {
            const n1 = null === (i = null == t ? void 0 : t.metadata) || void 0 === i ? void 0 : i.latex, r1 = `'${e1}'`;
            if (n1) return this.error([
                "invalid-symbol-name",
                r1
            ], n1 ? [
                "Latex",
                `'${n1}'`
            ] : r1);
        }
        if (void 0 !== (null === (n = null == t ? void 0 : t.metadata) || void 0 === n ? void 0 : n.latex) && !t.canonical) return new ad(this, e1, t);
        const o = this._commonSymbols[e1];
        return o ? (null === (r = null == t ? void 0 : t.metadata) || void 0 === r ? void 0 : r.wikidata) && o.wikidata && o.wikidata !== t.metadata.wikidata ? t.canonical ? sd(this, e1) : new ad(this, e1, t) : o : t.canonical ? sd(this, e1) : new ad(this, e1, t);
    }
    domain(e1, t) {
        var i;
        return e1 instanceof Pu ? e1 : (e1 instanceof eu && e1.symbol && (e1 = e1.symbol), "string" == typeof e1 && this._commonDomains[e1] ? this._commonDomains[e1] : Hu(e1) ? Ru(this, e1, t) : this.error([
            "invalid-domain",
            {
                str: JSON.stringify(e1)
            }
        ], [
            "Latex",
            {
                str: null !== (i = null == t ? void 0 : t.latex) && void 0 !== i ? i : ""
            }
        ]));
    }
    number(e1, t) {
        var i, n;
        if (null != t || (t = {}), "canonical" in t || (t.canonical = !0), void 0 === t.metadata && "number" == typeof e1) {
            const t1 = e1;
            if (1 === t1) return this._ONE;
            if (0 === t1) return this._ZERO;
            if (-1 === t1) return this._NEGATIVE_ONE;
            if (Number.isInteger(t1) && void 0 !== this._commonNumbers[t1]) return null === this._commonNumbers[t1] && (this._commonNumbers[t1] = null !== (i = Au(this, e1)) && void 0 !== i ? i : this._NAN), this._commonNumbers[t1];
            if (Number.isNaN(t1)) return this._NAN;
            if (!Number.isFinite(t1)) return t1 < 0 ? this._NEGATIVE_INFINITY : this._POSITIVE_INFINITY;
        }
        return null !== (n = Au(this, e1, t)) && void 0 !== n ? n : this._NAN;
    }
    rules(e1) {
        return al(this, e1);
    }
    pattern(e1) {
        return new ed(this, e1);
    }
    parse(e1, t) {
        var i;
        return "string" != typeof e1 ? null : this.box(this.latexSyntax.parse(null !== (i = Xs(e1)) && void 0 !== i ? i : e1), t);
    }
    serialize(e1) {
        if ("object" == typeof e1 && "json" in e1) {
            const t = "engine" in e1 ? e1.engine : this;
            return this.latexSyntax.serialize(this.rawJson(t.box(e1, {
                canonical: !1
            })));
        }
        return this.latexSyntax.serialize(e1);
    }
    get latexOptions() {
        const e1 = this.latexSyntax;
        return new Proxy({
            ...this.latexSyntax.options,
            ...this.latexSyntax.serializer.options
        }, {
            set: (t, i, n)=>i in t && (e1.updateOptions({
                    [i]: n
                }), !0)
        });
    }
    set latexOptions(e1) {
        this.latexSyntax.updateOptions(e1);
    }
    get jsonSerializationOptions() {
        return this._useRawJsonSerializationOptions ? this._rawJsonSerializationOptions : this._jsonSerializationOptions;
    }
    set jsonSerializationOptions(e1) {
        e1.exclude && (this._jsonSerializationOptions.exclude = [
            ...e1.exclude
        ]), e1.shorthands && ("all" === e1.shorthands || e1.shorthands.includes("all") ? this._jsonSerializationOptions.shorthands = [
            "function",
            "symbol",
            "string",
            "dictionary",
            "number"
        ] : this._jsonSerializationOptions.shorthands = [
            ...e1.shorthands
        ]), e1.metadata && ("all" === e1.metadata || e1.metadata.includes("all") ? this._jsonSerializationOptions.metadata = [
            "latex",
            "wikidata"
        ] : this._jsonSerializationOptions.metadata = [
            ...e1.metadata
        ]), "number" == typeof e1.precision && e1.precision > 0 && (this._jsonSerializationOptions.precision = e1.precision), "boolean" == typeof e1.repeatingDecimals && (this._jsonSerializationOptions.repeatingDecimals = e1.repeatingDecimals);
    }
    rawJson(e1) {
        const t = this._useRawJsonSerializationOptions;
        this._useRawJsonSerializationOptions = !0;
        const i = e1.json;
        return this._useRawJsonSerializationOptions = t, i;
    }
    ask(e1) {
        const t = this.pattern(e1), i = [];
        for (const [e2, n] of this.assumptions){
            const r = t.match(e2, {
                numericTolerance: this._tolerance
            });
            null !== r && !0 === n && i.push(r);
        }
        return i;
    }
    infer(e1, t) {
        if ("string" != typeof e1) {
            if (!e1.symbol) return "internal-error";
            e1 = e1.symbol;
        }
        return "ok";
    }
    assume(e1, t) {
        try {
            const i = Xs(e1), n = i ? this.parse(i, {
                canonical: !1
            }) : this.box(e1, {
                canonical: !1
            });
            return t ? Hu(t) ? Jl(this.box([
                "Element",
                n,
                this.domain(t)
            ])) : Jl(this.box([
                "Equal",
                n,
                t
            ])) : Jl(n);
        } catch (e2) {
            return "internal-error";
        }
    }
    forget(e1) {
        var t, i;
        if (!this.context) throw Error("No scope available");
        if (void 0 !== e1) {
            if (Array.isArray(e1)) for (const t1 of e1)this.forget(t1);
            else if ("string" == typeof e1) {
                if (this.context.idTable) {
                    const n = this.context.idTable.get(e1);
                    Hc(n) && (n.value = void 0, (null === (t = n.domain) || void 0 === t ? void 0 : t.isNumeric) ? n.domain = null !== (i = this.defaultDomain) && void 0 !== i ? i : this.domain("Number") : n.domain = void 0);
                }
                for (const [t2, i1] of this.assumptions)Qs(t2).includes(e1) && this.assumptions.delete(t2);
            }
        } else {
            if (this.context.idTable) for (const e2 of this.context.idTable.keys())this.forget(e2);
            this.assumptions.clear();
        }
    }
    constructor(e1){
        var t, i, n, r;
        if (this._cache = {}, this._commonSymbols = {
            True: null,
            False: null,
            Maybe: null,
            All: null,
            Nothing: null,
            None: null,
            Undefined: null,
            Function: null,
            Pi: null,
            ImaginaryUnit: null
        }, this._commonNumbers = {
            "-5": null,
            "-4": null,
            "-3": null,
            "-2": null,
            2: null,
            3: null,
            4: null,
            5: null,
            6: null,
            7: null,
            8: null,
            9: null,
            10: null,
            11: null,
            12: null,
            36: null
        }, this._commonDomains = {
            Anything: null,
            Nothing: null,
            Boolean: null,
            MaybeBoolean: null,
            String: null,
            Domain: null,
            Symbol: null,
            Integer: null,
            RationalNumber: null,
            AlgebraicNumber: null,
            RealNumber: null,
            ExtendedRealNumber: null,
            ImaginaryNumber: null,
            ComplexNumber: null,
            ExtendedComplexNumber: null,
            Number: null,
            PositiveInteger: null,
            TranscendentalNumber: null,
            PositiveNumber: null,
            Function: null,
            NumericFunction: null,
            RealFunction: null,
            TrigonometricFunction: null,
            LogicOperator: null,
            Predicate: null,
            RelationalOperator: null
        }, void 0 !== e1 && "object" != typeof e1) throw Error("Unexpected argument");
        this.strict = !0, this._latexDictionary = null == e1 ? void 0 : e1.latexDictionary, this._jsonSerializationOptions = {
            exclude: [],
            shorthands: [
                "function",
                "symbol",
                "string",
                "dictionary",
                "number"
            ],
            metadata: [],
            precision: "max",
            repeatingDecimals: !0
        }, this._useRawJsonSerializationOptions = !1, this._rawJsonSerializationOptions = {
            exclude: [],
            shorthands: [
                "function",
                "symbol",
                "string",
                "dictionary",
                "number"
            ],
            metadata: [],
            precision: "max",
            repeatingDecimals: !0
        }, this._stats = {
            highwaterMark: 0,
            symbols: new Set,
            expressions: new Set
        }, this._defaultDomain = null, this._numericMode = null !== (t = null == e1 ? void 0 : e1.numericMode) && void 0 !== t ? t : "auto", this._precision = Math.max(null !== (i = null == e1 ? void 0 : e1.numericPrecision) && void 0 !== i ? i : 100, Math.floor(Fs)), this._bignum = oa.clone({
            precision: this._precision
        }), this.tolerance = null !== (n = null == e1 ? void 0 : e1.tolerance) && void 0 !== n ? n : 1e-10, this._ZERO = new Mu(this, 0), this._ONE = new Mu(this, 1), this._HALF = new Mu(this, [
            1,
            2
        ]), this._NEGATIVE_ONE = new Mu(this, -1), this._I = new Mu(this, sa.exports.Complex.I), this._NAN = new Mu(this, NaN), this._POSITIVE_INFINITY = new Mu(this, 1 / 0), this._NEGATIVE_INFINITY = new Mu(this, -1 / 0), this._COMPLEX_INFINITY = new Mu(this, sa.exports.Complex.INFINITY), this.reset(), this.context = {
            assumptions: new Qc,
            warn: (e1)=>{
                for (const t of e1)t.message;
            },
            timeLimit: 2,
            memoryLimit: 1,
            recursionLimit: 1024
        };
        const o = null !== (r = null == e1 ? void 0 : e1.ids) && void 0 !== r ? r : ld.getStandardLibrary();
        for (const e2 of o)Jc(this, e2);
        for (const e3 of Object.keys(this._commonDomains))this._commonDomains[e3] && !this._commonDomains[e3].symbolDefinition ? this._commonDomains[e3].bind(this.context) : this._commonDomains[e3] = Ru(this, e3);
        for (const e4 of Object.keys(this._commonSymbols))this._commonSymbols[e4] = new ad(this, e4, {
            canonical: !0
        }), this._commonSymbols[e4].bind(this.context);
        if (null == e1 ? void 0 : e1.defaultDomain) {
            const t1 = this.domain(e1.defaultDomain);
            t1.isValid ? this._defaultDomain = t1 : this._defaultDomain = this.domain("ExtendedRealNumber");
        } else this._defaultDomain = this.domain("ExtendedRealNumber");
        this.pushScope();
    }
}
var ud, cd, dd = '@keyframes ML__caret-blink{0%,to{opacity:1}50%{opacity:0}}.ML__caret:after{animation:ML__caret-blink 1.05s step-end infinite forwards;border:none;border-radius:2px;border-right:2px solid var(--caret-color,var(--ML__caret-color));content:"";left:-1px;margin-right:-2px;position:relative}.ML__text-caret:after{animation:ML__caret-blink 1.05s step-end infinite forwards;border:none;border-radius:1px;border-right:1px solid var(--caret-color,var(--ML__caret-color));content:"";left:0;margin-right:-1px;position:relative}.ML__latex-caret:after{animation:ML__caret-blink 1.05s step-end infinite forwards;border:none;color:var(--caret-color,var(--ML__caret-color));content:"_";margin-right:calc(-1ex - 2px);position:relative}.ML__container{--ML__selection-background-color:hsl(var(--hue,212),97%,85%);--ML__text-highlight-background-color:hsla(var(--hue,212),40%,50%,0.1);--ML__contains-highlight-background-color:hsl(var(--hue,212),40%,95%);--ML__selection-color:currentColor;--ML__caret-color:hsl(var(--hue,212),40%,49%);--ML__smart-fence-color:currentColor;--ML__latex-color:var(--primary,hsl(var(--hue,212),40%,50%));--ML__placeholder-color:hsl(var(--hue,212),40%,49%);align-items:flex-end;display:flex;flex-flow:row;isolation:isolate;justify-content:space-between;min-height:39px;touch-action:none;width:100%}@media (prefers-color-scheme:dark){.ML__container{--ML__selection-background-color:hsl(var(--hue,212),25%,45%);--ML__text-highlight-background-color:hsla(var(--hue,212),40%,50%,0.2);--ML__contains-highlight-background-color:hsl(var(--hue,212),5%,34%);--ML__caret-color:hsl(var(--hue,212),60%,69%);--ML__latex-color:var(--primary,hsl(var(--hue,212),40%,50%));--ML__placeholder-color:hsl(var(--hue,212),60%,69%)}}.ML__content{align-items:center;align-self:center;display:flex;overflow:hidden;padding:2px 0 2px 1px;position:relative;width:100%}.ML__virtual-keyboard-toggle{box-sizing:border-box;display:none}.ML__virtual-keyboard-toggle>span{align-items:center;align-self:center;display:flex}.ML__virtual-keyboard-toggle.is-visible{fill:currentColor;align-items:center;align-self:center;background:transparent;border:1px solid transparent;border-radius:8px;color:var(--primary,hsl(var(--hue,212),40%,50%));cursor:pointer;display:flex;flex-direction:column;flex-shrink:0;height:34px;justify-content:center;margin-right:4px;padding:0;transition:background .2s cubic-bezier(.64,.09,.08,1);width:34px}.ML__virtual-keyboard-toggle.is-visible:hover{fill:currentColor;background:hsla(0,0%,70%,.5);border-radius:8px;color:#333}.ML__textarea__textarea{clip:rect(0 0 0 0);border:none;display:inline-block;font-family:KaTeX_Main;font-size:1em;height:1px;outline:none;position:absolute;resize:none;transform:scale(0);width:1px}.ML__focused .ML__text{background:var(--highlight-text,var(--ML__text-highlight-background-color))}.ML__smart-fence__close{color:var(--smart-fence-color,var(--ML__smart-fence-color));opacity:var(--smart-fence-opacity,.5)}.ML__focused .ML__selection{background:var(--selection-background-color-focused,var(--selection-background-color,var(--ML__selection-background-color)))!important}.ML__focused .ML__selected,.ML__focused .ML__selected .ML__contains-caret,.ML__focused .ML__selected .ML__placeholder,.ML__focused .ML__selected .ML__smart-fence__close{color:var(--selection-color-focused,var(--selection-color,var(--ML__selection-color)))!important}.ML__selection{background:var(--selection-background-color,var(--ML__selection-background-color))!important;box-sizing:border-box}.ML__selected,.ML__selected .ML__contains-caret,.ML__selected .ML__placeholder,.ML__selected .ML__smart-fence__close{color:var(--selection-color,var(--ML__selection-color));opacity:1}.ML__contains-caret .ML__sqrt-line,.ML__contains-caret .ML__sqrt-sign,.ML__contains-caret.ML__close,.ML__contains-caret.ML__open,.ML__contains-caret>.ML__close,.ML__contains-caret>.ML__open{color:var(--caret-color,var(--ML__caret-color))}.ML__contains-highlight{background:var(--contains-highlight-backround-color,var(--ML__contains-highlight));box-sizing:border-box}.ML__latex{color:var(--latex-color,var(--ML__latex-color));font-family:IBM Plex Mono,Source Code Pro,Consolas,Roboto Mono,Menlo,Bitstream Vera Sans Mono,DejaVu Sans Mono,Monaco,Courier,monospace;font-weight:400}.ML__suggestion{opacity:.5}.ML__virtual-keyboard-toggle.is-visible.is-pressed:hover{fill:currentColor;background:hsl(var(--hue,212),25%,35%);color:#fafafa}.ML__virtual-keyboard-toggle:focus{border:2px solid var(--primary,hsl(var(--hue,212),40%,50%));border-radius:8px;outline:none}.ML__virtual-keyboard-toggle.is-active,.ML__virtual-keyboard-toggle.is-active:hover,.ML__virtual-keyboard-toggle.is-pressed{fill:currentColor;background:hsl(var(--hue,212),25%,35%);color:#fafafa}.ML__tooltip-container{position:relative;transform:scale(0)}.ML__tooltip-container .ML__tooltip-content{background:#616161;border-radius:8px;box-shadow:0 2px 2px 0 rgba(0,0,0,.14),0 1px 5px 0 rgba(0,0,0,.12),0 3px 1px -2px rgba(0,0,0,.2);color:#fff;display:inline-table;font-size:.75em;max-width:400px;opacity:0;padding:12px;position:fixed;transform:scale(.5);transition:opacity .15s cubic-bezier(.4,0,1,1);visibility:hidden;width:max-content;z-index:2}.ML__tooltip-container .ML__tooltip-content .ML__text{white-space:normal}.ML__tooltip-container .ML__tooltip-content .ML__base{display:contents}.ML__tooltip-container:hover .ML__tooltip-content{opacity:1;transform:scale(1) translateY(3em);visibility:visible}[data-ML__tooltip]{position:relative}[data-ML__tooltip][data-placement=top]:after{bottom:100%;top:inherit}[data-ML__tooltip]:after{background:#616161;border-radius:2px;box-shadow:0 2px 2px 0 rgba(0,0,0,.14),0 1px 5px 0 rgba(0,0,0,.12),0 3px 1px -2px rgba(0,0,0,.2);color:#fff;content:attr(data-ML__tooltip);display:none;font-family:system-ui,-apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Oxygen,Ubuntu,Cantarell,Fira Sans,Droid Sans,Helvetica Neue,sans-serif;font-size:12px;font-weight:400;max-width:200px;opacity:0;padding:8px;position:absolute;right:110%;text-align:center;transform:scale(.5);transition:all .15s cubic-bezier(.4,0,1,1);width:max-content;z-index:2}@media only screen and (max-width:767px){[data-ML__tooltip]:after{font-size:16px;padding:8px 16px}}:not(.tracking) [data-ML__tooltip]:hover{position:relative}:not(.tracking) [data-ML__tooltip]:hover:after{display:inline-table;opacity:1;transform:scale(1);visibility:visible}[data-ML__tooltip][data-delay]:after{transition-delay:0s}[data-ML__tooltip][data-delay]:hover:after{transition-delay:1s}';
let hd = null;
function md(e1) {
    if (/^(?:[a-z+]+:)?\/\//i.test(e1)) return new URL(e1).href;
    if (null === hd) try {
        const e2 = new XMLHttpRequest;
        e2.open("HEAD", pd, !1), e2.send(null), 200 === e2.status && (hd = e2.responseURL);
    } catch (e3) {}
    return hd ? new URL(e1, hd).href : "";
}
const pd = (null === (cd = null === (ud = null === globalThis || void 0 === globalThis ? void 0 : globalThis.document) || void 0 === ud ? void 0 : ud.currentScript) || void 0 === cd ? void 0 : cd.src) || function() {
    const e1 = String((new Error).stack).replace(/^Error.*\n/, "").split("\n");
    if (0 === e1.length) return "";
    let t = e1[1], i = t.match(/http.*\.ts[\?:]/);
    return i && (t = e1[2]), i = t.match(/(https?:.*):[0-9]+:[0-9]+/), i || (i = t.match(/at (.*(\.ts))[\?:]/), i || (i = t.match(/at (.*(\.mjs|\.js))[\?:]/))), i ? i[1] : "";
}();
async function fd(e1) {
    var i;
    if (t() && !document.body.classList.contains("ML__fonts-loading") && (null === (i = getComputedStyle(document.documentElement).getPropertyValue("--ML__static-fonts")) || void 0 === i || !i) && (document.body.classList.remove("ML__fonts-did-not-load"), "fonts" in document)) {
        const t1 = [
            "KaTeX_Main",
            "KaTeX_Math",
            "KaTeX_AMS",
            "KaTeX_Caligraphic",
            "KaTeX_Fraktur",
            "KaTeX_SansSerif",
            "KaTeX_Script",
            "KaTeX_Typewriter",
            "KaTeX_Size1",
            "KaTeX_Size2",
            "KaTeX_Size3",
            "KaTeX_Size4"
        ], i1 = Array.from(document.fonts).map((e1)=>e1.family);
        if (t1.every((e1)=>i1.includes(e1))) return;
        const n = md(null != e1 ? e1 : "./fonts");
        if (!n) return;
        document.body.classList.add("ML__fonts-loading");
        const r = [
            [
                "KaTeX_Main-Regular"
            ],
            [
                "KaTeX_Main-BoldItalic",
                {
                    style: "italic",
                    weight: "bold"
                }
            ],
            [
                "KaTeX_Main-Bold",
                {
                    weight: "bold"
                }
            ],
            [
                "KaTeX_Main-Italic",
                {
                    style: "italic"
                }
            ],
            [
                "KaTeX_Math-Italic",
                {
                    style: "italic"
                }
            ],
            [
                "KaTeX_Math-BoldItalic",
                {
                    style: "italic",
                    weight: "bold"
                }
            ],
            [
                "KaTeX_AMS-Regular"
            ],
            [
                "KaTeX_Caligraphic-Regular"
            ],
            [
                "KaTeX_Caligraphic-Bold",
                {
                    weight: "bold"
                }
            ],
            [
                "KaTeX_Fraktur-Regular"
            ],
            [
                "KaTeX_Fraktur-Bold",
                {
                    weight: "bold"
                }
            ],
            [
                "KaTeX_SansSerif-Regular",
                {
                    style: "italic"
                }
            ],
            [
                "KaTeX_SansSerif-Bold",
                {
                    weight: "bold"
                }
            ],
            [
                "KaTeX_SansSerif-Italic",
                {
                    style: "italic"
                }
            ],
            [
                "KaTeX_Script-Regular"
            ],
            [
                "KaTeX_Typewriter-Regular"
            ],
            [
                "KaTeX_Size1-Regular"
            ],
            [
                "KaTeX_Size2-Regular"
            ],
            [
                "KaTeX_Size3-Regular"
            ],
            [
                "KaTeX_Size4-Regular"
            ]
        ].map((e1)=>(function(e1, t, i = {}) {
                return new FontFace(e1, `url(${t}.woff2) format('woff2')`, i);
            })(e1[0].replace(/-[a-zA-Z]+$/, ""), n + "/" + e1[0], e1[1]));
        try {
            const e2 = await Promise.all(r.map((e1)=>{
                try {
                    return e1.load();
                } catch  {}
            }));
            e2.forEach((e1)=>document.fonts.add(e1));
        } catch (e3) {
            document.body.classList.add("ML__fonts-did-not-load");
        }
        document.body.classList.remove("ML__fonts-loading");
    }
}
function gd(e1) {
    return "number" == typeof e1 && !Number.isNaN(e1);
}
function yd(e1) {
    return Array.isArray(e1) && 2 === e1.length;
}
function bd(e1) {
    return null != e1 && "object" == typeof e1 && "ranges" in e1 && Array.isArray(e1.ranges);
}
const vd = {
    "\\ne": "≠",
    "\\neq": "≠",
    "−": "-",
    "-": "-",
    "\\alpha": "alpha",
    "\\beta": "beta",
    "\\gamma": "gamma",
    "\\delta": "delta",
    "\\epsilon": "epsilon",
    "\\varepsilon": "varepsilon",
    "\\zeta": "zeta",
    "\\eta": "eta",
    "\\theta": "theta",
    "\\vartheta": "vartheta",
    "\\iota": "iota",
    "\\kappa": "kappa",
    "\\lambda": "lambda",
    "\\mu": "mu",
    "\\nu": "nu",
    "\\xi": "xi",
    "\\pi": "pi",
    "\\rho": "rho",
    "\\sigma": "sigma",
    "\\tau": "tau",
    "\\upsilon": "upsilon",
    "\\phi": "phi",
    "\\varphi": "varphi",
    "\\chi": "chi",
    "\\psi": "psi",
    "\\omega": "omega",
    "\\Gamma": "Gamma",
    "\\Delta": "Delta",
    "\\Theta": "Theta",
    "\\Lambda": "Lambda",
    "\\Xi": "Xi",
    "\\Pi": "Pi",
    "\\Sigma": "Sigma",
    "\\Phi": "Phi",
    "\\Psi": "Psi",
    "\\Omega": "Omega",
    "\\exponentialE": "e",
    "\\imaginaryI": "i",
    "\\imaginaryJ": "j",
    "\\!": " ",
    "\\,": " ",
    "\\:": " ",
    "\\;": " ",
    "\\enskip": " ",
    "\\enspace": " ",
    "\\qquad": " ",
    "\\quad": " "
}, xd = {
    "\\pm": "+-",
    "\\times": "xx",
    "\\colon": ":",
    "\\vert": "|",
    "\\Vert": "||",
    "\\mid": "|",
    "\\lbrace": "{",
    "\\rbrace": "}",
    "\\lparen": "(",
    "\\rparen": ")",
    "\\langle": "(:",
    "\\rangle": ":)"
};
function kd(t) {
    var i, n, r, o, a, s, l, u, c, d, h, m, p;
    if (!t) return "";
    if (e1(t)) {
        if (0 === t.length) return "";
        if ("first" === t[0].type && (t = t.slice(1)), 0 === t.length) return "";
        let e2 = "";
        if ("latex" === t[0].mode) for (const i1 of t)e2 += kd(i1);
        else if ("text" === t[0].mode) {
            let n1 = 0;
            for(e2 = '"'; "text" === (null === (i = t[n1]) || void 0 === i ? void 0 : i.mode);)e2 += t[n1].body ? kd(t[n1].body) : t[n1].value, n1++;
            e2 += '"' + kd(t.slice(n1));
        } else if ("math" === t[0].mode) {
            let i2 = 0;
            for(; t[i2] && "math" === t[i2].mode;)e2 += kd(t[i2]), i2++;
            e2 += kd(t.slice(i2));
        }
        return e2.trim();
    }
    if ("text" === t.mode) return '"' + t.value + '"';
    let f = "";
    const { command: g  } = t;
    let y;
    switch(t.type){
        case "first":
            return "";
        case "group":
        case "root":
            f = null !== (n = vd[g]) && void 0 !== n ? n : kd(t.body);
            break;
        case "genfrac":
            {
                const e3 = t;
                (e3.leftDelim || e3.rightDelim) && (f += "." !== e3.leftDelim && e3.leftDelim ? e3.leftDelim : "{:"), e3.hasBarLine ? (f += "(", f += kd(e3.above), f += ")/(", f += kd(e3.below), f += ")") : (f += "(" + kd(e3.above) + "),", f += "(" + kd(e3.below) + ")"), (e3.leftDelim || e3.rightDelim) && (f += "." !== e3.rightDelim && e3.rightDelim ? e3.rightDelim : "{:");
            }
            break;
        case "surd":
            f += t.hasEmptyBranch("above") ? "sqrt(" + kd(t.body) + ")" : "root(" + kd(t.above) + ")(" + kd(t.body) + ")";
            break;
        case "latex":
            f = t.value;
            break;
        case "leftright":
            {
                const e4 = t;
                f += "." !== e4.leftDelim && e4.leftDelim ? e4.leftDelim : "{:", f += kd(e4.body), f += "." !== e4.rightDelim && e4.rightDelim ? e4.rightDelim : ":}";
            }
            break;
        case "sizeddelim":
        case "delim":
        case "overlap":
        case "overunder":
        case "box":
            break;
        case "mord":
            f = null !== (o = null !== (r = vd[g]) && void 0 !== r ? r : g) && void 0 !== o ? o : "string" == typeof t.value ? t.value : "", f.startsWith("\\") && (f += " "), y = g ? g.match(/{?\\char"([\dabcdefABCDEF]*)}?/) : null, y ? f = String.fromCodePoint(Number.parseInt("0x" + y[1])) : f.length > 0 && f.startsWith("\\") && (f = "string" == typeof t.value ? t.value.charAt(0) : t.command);
            break;
        case "mbin":
        case "mrel":
        case "minner":
            f = null !== (s = null !== (a = vd[g]) && void 0 !== a ? a : xd[g]) && void 0 !== s ? s : t.value;
            break;
        case "mopen":
        case "mclose":
            f += t.value;
            break;
        case "mpunct":
            f = null !== (l = xd[g]) && void 0 !== l ? l : g;
            break;
        case "mop":
            "​" !== t.value && (f = "", f += "\\operatorname" === g ? kd(t.body) : null !== (u = t.value) && void 0 !== u ? u : g, f += " ");
            break;
        case "array":
            const e5 = t.array, i3 = t.environmentName, b = null !== (c = ({
                bmatrix: [
                    "[",
                    "]"
                ],
                "bmatrix*": [
                    "[",
                    "]"
                ]
            })[i3]) && void 0 !== c ? c : [
                "(",
                ")"
            ], v = [];
            for (const t1 of e5){
                const e6 = [];
                for (const i4 of t1)e6.push(b[0] + kd(i4) + b[1]);
                v.push(e6.join(","));
            }
            const x = null !== (d = ({
                bmatrix: [
                    "[",
                    "]"
                ],
                "bmatrix*": [
                    "[",
                    "]"
                ],
                cases: [
                    "{",
                    ":}"
                ]
            })[i3]) && void 0 !== d ? d : [
                "(",
                ")"
            ];
            f = x[0] + v.join(",") + x[1];
            break;
        case "spacing":
            f = null !== (h = vd[g]) && void 0 !== h ? h : " ";
            break;
        case "enclose":
            f = "(" + kd(t.body) + ")";
            break;
        case "space":
            f = " ";
            break;
        case "msubsup":
            f = "";
            break;
        case "macro":
            f = null !== (p = null !== (m = vd[g]) && void 0 !== m ? m : xd[g]) && void 0 !== p ? p : kd(t.body);
    }
    if (!t.hasEmptyBranch("subscript")) {
        f += "_";
        const e7 = kd(t.subscript);
        f += e7.length > 1 ? "(" + e7 + ")" : e7;
    }
    if (!t.hasEmptyBranch("superscript")) {
        f += "^";
        const e8 = kd(t.superscript);
        f += e8.length > 1 ? "(" + e8 + ")" : e8;
    }
    return f;
}
function _d(e1) {
    let t;
    if ("body" === e1.treeBranch) t = ({
        enclose: "cross out",
        leftright: "delimiter",
        surd: "square root",
        root: "math field",
        mop: "operator"
    })[e1.type];
    else if ("genfrac" === e1.parent.type) {
        if ("above" === e1.treeBranch) return "numerator";
        if ("below" === e1.treeBranch) return "denominator";
    } else "surd" === e1.parent.type ? "above" === e1.treeBranch && (t = "index") : "superscript" === e1.treeBranch ? t = "superscript" : "subscript" === e1.treeBranch && (t = "subscript");
    return null != t ? t : "parent";
}
class wd {
    get atoms() {
        return this.root.children;
    }
    get selection() {
        return this._selection;
    }
    set selection(e1) {
        this.setSelection(e1);
    }
    setSelection(e1, t) {
        return this.deferNotifications({
            selection: !0
        }, ()=>{
            const i = this.normalizeSelection(e1, t);
            if (void 0 === i) throw new TypeError("Invalid selection");
            if (1 === i.ranges.length && i.ranges[0][0] === i.ranges[0][1]) {
                const e2 = i.ranges[0][0];
                this._position = e2, this._anchor = e2, this._selection = i;
            } else {
                const e3 = Si(i);
                "backward" === i.direction ? [this._position, this._anchor] = e3 : [this._anchor, this._position] = e3;
                const t1 = this.at(e3[0] + 1), n = this.at(e3[1]), r = ot.commonAncestor(t1, n);
                "array" === (null == r ? void 0 : r.type) && t1.parent === r && n.parent, this._selection = {
                    ranges: [
                        e3
                    ],
                    direction: i.direction
                };
            }
        });
    }
    setPositionHandlingPlaceholder(e1) {
        var t, i, n;
        "placeholder" === (null === (t = this.at(e1)) || void 0 === t ? void 0 : t.type) ? this.setSelection(e1 - 1, e1) : "placeholder" === (null === (n = null === (i = this.at(e1)) || void 0 === i ? void 0 : i.rightSibling) || void 0 === n ? void 0 : n.type) ? this.setSelection(e1, e1 + 1) : this.position = e1;
    }
    getState() {
        return {
            content: this.root.toJson(),
            selection: this.selection
        };
    }
    setState(e1, t) {
        var i;
        const n = this.suppressChangeNotifications;
        this.suppressChangeNotifications = null === (i = null == t ? void 0 : t.suppressChangeNotifications) || void 0 === i || i;
        let r = {};
        "undo" === (null == t ? void 0 : t.type) && (r = {
            inputType: "historyUndo"
        }), "redo" === (null == t ? void 0 : t.type) && (r = {
            inputType: "historyRedo"
        }), Vn(this, r) && (this.root = fi(e1.content, this.mathfield), this.selection = e1.selection, jn(this, r)), this.suppressChangeNotifications = n;
    }
    get position() {
        return this._position;
    }
    set position(e1) {
        this.setSelection(e1, e1);
    }
    get anchor() {
        return this._anchor;
    }
    get selectionIsCollapsed() {
        return this._anchor === this._position;
    }
    get selectionIsPlaceholder() {
        return 1 === Math.abs(this._anchor - this._position) && "placeholder" === this.at(Math.max(this._anchor, this._position)).type;
    }
    collapseSelection(e1 = "forward") {
        return this._anchor !== this._position && (this.position = "backward" === e1 ? Math.min(this._anchor, this._position) : Math.max(this._anchor, this._position), !0);
    }
    get lastOffset() {
        return this.atoms.length - 1;
    }
    at(e1) {
        return this.atoms[e1];
    }
    offsetOf(e1) {
        return this.atoms.indexOf(e1);
    }
    getSiblingsRange(e1) {
        const t = this.at(e1), { parent: i  } = t;
        if (!i) return [
            0,
            this.lastOffset
        ];
        const n = t.parent.branch(t.treeBranch);
        return [
            this.offsetOf(n[0]),
            this.offsetOf(n[n.length - 1])
        ];
    }
    getBranchRange(e1, t) {
        const i = this.at(e1).branch(t);
        return [
            this.offsetOf(i[0]),
            this.offsetOf(i[i.length - 1])
        ];
    }
    getAtoms(e1, t, i) {
        var n, r;
        let o, a, s = null != i ? i : {};
        if (bd(e1)) {
            if (s = null !== (n = t) && void 0 !== n ? n : {}, e1.ranges.length > 1) return e1.ranges.reduce((e1, t)=>[
                    ...e1,
                    ...this.getAtoms(t, s)
                ], []);
            e1 = e1.ranges[0];
        }
        if (gd(e1)) {
            if (o = e1, !gd(t)) return [];
            a = t;
        } else [o, a] = e1, s = null !== (r = t) && void 0 !== r ? r : {};
        if (!Number.isFinite(o)) return [];
        void 0 === s.includeChildren && (s.includeChildren = !1), o < 0 && (o = this.lastOffset - o + 1), a < 0 && (a = this.lastOffset - a + 1);
        const l = Math.min(o, a) + 1, u = Math.max(o, a);
        if (1 === l && u === this.lastOffset) return [
            this.root
        ];
        let c = [];
        for(let e2 = l; e2 <= u; e2++){
            const t1 = this.atoms[e2];
            Sd(this, t1, l, u) && c.push(t1);
        }
        return s.includeChildren || (c = c.filter((e1)=>{
            let t = !1, { parent: i  } = e1;
            for(; i && !t;)t = Sd(this, i, l, u), i = i.parent;
            return !t;
        })), c;
    }
    getAllAtoms(e1) {
        const t = [], i = this.lastOffset;
        for(let n = e1; n <= i; n++)t.push(this.atoms[n]);
        for(let i1 = 0; i1 < e1; i1++)t.push(this.atoms[i1]);
        return t;
    }
    extractAtoms(e1) {
        let t = this.getAtoms(e1);
        1 === t.length && "root" === t[0].type && (t = t[0].children);
        for (const e2 of t)e2.parent.removeChild(e2);
        return t;
    }
    deleteAtoms(e1) {
        this.extractAtoms(e1), this.position = e1[0];
    }
    atomToString(e1, t) {
        const i = null != t ? t : "latex";
        if (i.startsWith("latex")) return Ce.serialize([
            e1
        ], {
            expandMacro: "latex-expanded" === i,
            skipStyles: "latex-unstyled" === i,
            defaultMode: this.mathfield.options.defaultMode
        });
        if ("math-ml" === i) return Wi(e1, this.mathfield.options);
        if ("spoken" === i) return en(e1, this.mathfield.options);
        if ("spoken-text" === i) {
            const t1 = this.mathfield.options.textToSpeechMarkup;
            this.mathfield.options.textToSpeechMarkup = "";
            const i1 = en(e1, this.mathfield.options);
            return this.mathfield.options.textToSpeechMarkup = t1, i1;
        }
        if ("spoken-ssml" === i || "spoken-ssml-with-highlighting" === i) {
            const t2 = this.mathfield.options.textToSpeechMarkup;
            this.mathfield.options.textToSpeechMarkup = "ssml";
            const i2 = en(e1, this.mathfield.options);
            return this.mathfield.options.textToSpeechMarkup = t2, i2;
        }
        if ("math-json" === i && this.mathfield.computeEngine) try {
            const t3 = this.mathfield.computeEngine.parse(ot.serialize(e1, {
                expandMacro: !1,
                defaultMode: "math"
            }));
            return JSON.stringify(t3.json);
        } catch (e2) {
            return JSON.stringify([
                "Error",
                "Nothing",
                `'${e2.toString()}'`
            ]);
        }
        return "ascii-math" === i ? kd(e1) : "";
    }
    getValue(e1, t, i) {
        if (void 0 === e1) return this.atomToString(this.root, "latex");
        if ("string" == typeof e1) return this.atomToString(this.root, e1);
        let n, r;
        if (gd(e1) && gd(t) ? (n = [
            this.normalizeRange([
                e1,
                t
            ])
        ], r = null != i ? i : "latex") : yd(e1) ? (n = [
            this.normalizeRange(e1)
        ], r = t) : bd(e1) ? (n = e1.ranges, r = t) : (n = [], r = "latex"), r.startsWith("latex")) {
            const e2 = {
                expandMacro: "latex-expanded" === r,
                skipStyles: "latex-unstyled" === r,
                defaultMode: this.mathfield.options.defaultMode
            };
            return Qe(n.map((t)=>ot.serialize(this.getAtoms(t), e2)));
        }
        return n.map((e1)=>this.getAtoms(e1).map((e1)=>this.atomToString(e1, r)).join("")).join("");
    }
    extendSelection(e1) {
        let t = this._anchor;
        if ("forward" === e1) {
            let e2 = this._position;
            do {
                let t1 = this.at(e2 + 1);
                if (null == t1 ? void 0 : t1.inCaptureSelection) {
                    for(; !t1.captureSelection;)t1 = t1.parent;
                    e2 = this.offsetOf(null == t1 ? void 0 : t1.lastChild) + 1;
                } else e2 += 1;
            }while (e2 <= this.lastOffset && this.at(e2).isFirstSibling);
            return e2 === t - 1 && "first" === this.at(t).type && (e2 = t), this.extendSelectionTo(t, e2);
        }
        let i = this._position - 1;
        if (i < 0) return !1;
        for(; i >= 0 && this.at(i).isLastSibling;){
            let e3 = this.at(i);
            if (null == e3 ? void 0 : e3.inCaptureSelection) {
                for(; !e3.captureSelection;)e3 = e3.parent;
                i = this.offsetOf(e3.firstChild) - 1;
            } else i -= 1;
        }
        return i < 0 && (i = 0), i === t + 1 && "first" === this.at(i).type && (t = i), this.extendSelectionTo(t, i);
    }
    extendSelectionTo(e1, t) {
        return this.deferNotifications({
            selection: !0
        }, ()=>{
            const i = this.normalizeRange([
                e1,
                t
            ]);
            let [n, r] = i, { parent: o  } = this.at(r);
            if (o && ("genfrac" === o.type || "msubsup" === o.type)) for(; o !== this.root && Md(this, o, [
                n,
                r
            ]);)r = this.offsetOf(o), o = o.parent;
            for(o = this.at(n).parent; o !== this.root && Md(this, o, [
                n,
                r
            ]);)n = this.offsetOf(o.leftSibling), o = o.parent;
            if (o = this.at(r).parent, "genfrac" === (null == o ? void 0 : o.type)) for(; o !== this.root && Md(this, o, [
                n,
                r
            ]);)r = this.offsetOf(o), o = o.parent;
            this._position = this.normalizeOffset(t), this._selection = {
                ranges: [
                    [
                        n,
                        r
                    ]
                ],
                direction: "none"
            };
        });
    }
    setListeners(e1) {
        this.listeners = e1;
    }
    announce(e1, t, i = []) {
        var n, r;
        null === (r = null === (n = this.mathfield.host) || void 0 === n ? void 0 : n.dispatchEvent(new CustomEvent("announce", {
            detail: {
                command: e1,
                previousPosition: t,
                atoms: i
            },
            cancelable: !0,
            bubbles: !0,
            composed: !0
        }))) || void 0 === r || r || function(e1, t, i, n) {
            let r = "";
            "plonk" === t ? (e1.playSound("plonk"), e1.flushInlineShortcutBuffer()) : "delete" === t ? r = dr(e1.options, "deleted: ", n) : "focus" === t || t.includes("move") ? r = function(e1, t) {
                if (Number.isNaN(t)) return "";
                const i = e1.at(t);
                if (!i) return "";
                if (i.treeDepth <= e1.at(e1.position).treeDepth) return "";
                let n = "", r = i.parent;
                const o = e1.at(e1.position).parent;
                for(; r !== e1.root && r !== o;)n += `out of ${_d(r)};`, r = r.parent;
                return n;
            }(e1.model, i) + (e1.model.selectionIsCollapsed ? "" : "selected: ") + function(e1, t) {
                if (!e1.selectionIsCollapsed) return dr(t, "", e1.getAtoms(e1.selection));
                let i = "";
                const n = e1.at(e1.position), r = _d(n);
                return n.isFirstSibling && (i = (r ? "start of " + r : "unknown") + ": "), n.isLastSibling ? n.isFirstSibling || (i += r ? "end of " + r : "unknown") : i += dr(t, "", n), i;
            }(e1.model, e1.options) : "replacement" === t ? r = dr(e1.options, "", e1.model.at(e1.model.position)) : "line" === t ? (r = dr(e1.options, "", e1.model.root), e1.keyboardDelegate.setAriaLabel("after: " + r)) : r = n ? dr(e1.options, t + " ", n) : t;
            const o = e1.ariaLiveText.textContent.includes("\xa0") ? "   " : " \xa0 ";
            e1.ariaLiveText.textContent = r + o;
        }(this.mathfield, e1, t, i);
    }
    deferNotifications(e1, t) {
        const i = this._selection, n = this._anchor, r = this._position, o = this.suppressChangeNotifications;
        this.suppressChangeNotifications = !0;
        const a = this.root.changeCounter;
        t();
        const s = this.root.changeCounter !== a, l = n !== this._anchor || r !== this._position || "different" === function(e1, t) {
            if (e1.direction === t.direction) {
                const i = e1.ranges.length;
                if (t.ranges.length === i) {
                    let n = 0;
                    for(; n < i && "equal" === wi(e1.ranges[n], t.ranges[n]);)n++;
                    return n === i ? "equal" : "different";
                }
            }
            return "different";
        }(this._selection, i);
        return this.suppressChangeNotifications = o, e1.content && s && jn(this, {
            data: e1.data,
            inputType: e1.type
        }), e1.selection && l && Kn(this), s || l;
    }
    normalizeOffset(e1) {
        return e1 > 0 ? e1 = Math.min(e1, this.lastOffset) : e1 < 0 && (e1 = this.lastOffset + e1 + 1), e1;
    }
    normalizeRange(e1) {
        let [t, i] = e1;
        return t = this.normalizeOffset(t), i = this.normalizeOffset(i), t < i ? [
            t,
            i
        ] : [
            i,
            t
        ];
    }
    normalizeSelection(e1, t) {
        var i;
        let n;
        if (gd(e1)) {
            const i1 = this.normalizeOffset(e1);
            if (gd(t)) {
                const e2 = this.normalizeOffset(t);
                n = i1 <= e2 ? {
                    ranges: [
                        [
                            i1,
                            e2
                        ]
                    ],
                    direction: "none"
                } : {
                    ranges: [
                        [
                            e2,
                            i1
                        ]
                    ],
                    direction: "backward"
                };
            } else n = {
                ranges: [
                    [
                        i1,
                        i1
                    ]
                ],
                direction: "none"
            };
        } else if (yd(e1)) {
            const t1 = this.normalizeOffset(e1[0]), i2 = this.normalizeOffset(e1[1]);
            n = t1 <= i2 ? {
                ranges: [
                    [
                        t1,
                        i2
                    ]
                ],
                direction: "none"
            } : {
                ranges: [
                    [
                        i2,
                        t1
                    ]
                ],
                direction: "backward"
            };
        } else bd(e1) && (n = {
            ranges: e1.ranges.map((e1)=>this.normalizeRange(e1)),
            direction: null !== (i = e1.direction) && void 0 !== i ? i : "none"
        });
        return n;
    }
    constructor(e1, t, i){
        this.options = e1, this._selection = {
            ranges: [
                [
                    0,
                    0
                ]
            ],
            direction: "none"
        }, this._anchor = 0, this._position = 0, this.mathfield = i, this.suppressChangeNotifications = !1, this.root = new ot("root", i, {
            mode: e1.mode
        }), this.root.body = [], this.setListeners(t);
    }
}
function Sd(e1, t, i, n) {
    const r = e1.offsetOf(t);
    if (r < i || r > n) return !1;
    if (!t.hasChildren) return !0;
    const o = e1.offsetOf(t.firstChild);
    if (o >= i && o <= n) {
        const r1 = e1.offsetOf(t.lastChild);
        if (r1 >= i && r1 <= n) return !0;
    }
    return !1;
}
function Md(e1, t, i) {
    if (!(null == t ? void 0 : t.hasChildren)) return !1;
    const [n, r] = i, o = e1.offsetOf(t.firstChild), a = e1.offsetOf(t.lastChild);
    return o >= n && o <= r && a >= o && a <= r;
}
function Nd(e1, t) {
    let i = e1.at(e1.position);
    for(; i && !(Array.isArray(i.treeBranch) && i.parent instanceof Pt);)i = i.parent;
    if (Array.isArray(null == i ? void 0 : i.treeBranch) && (null == i ? void 0 : i.parent) instanceof Pt) {
        const n = i.parent;
        let r;
        switch(t){
            case "after row":
                n.addRowAfter(i.treeBranch[0]), r = e1.offsetOf(n.getCell(i.treeBranch[0] + 1, 0)[0]);
                break;
            case "after column":
                if (n.maxColumns <= n.colCount) return void e1.announce("plonk");
                n.addColumnAfter(i.treeBranch[1]), r = e1.offsetOf(n.getCell(i.treeBranch[0], i.treeBranch[1] + 1)[0]);
                break;
            case "before row":
                n.addRowBefore(i.treeBranch[0]), r = e1.offsetOf(n.getCell(i.treeBranch[0] - 1, 0)[0]);
                break;
            case "before column":
                if (n.maxColumns <= n.colCount) return void e1.announce("plonk");
                n.addColumnBefore(i.treeBranch[1]), r = e1.offsetOf(n.getCell(i.treeBranch[0], i.treeBranch[1] - 1)[0]);
        }
        e1.setSelection(r, r + 1);
    }
}
function Ld(e1) {
    return !!Vn(e1, {
        inputType: "insertText"
    }) && (Nd(e1, "after row"), jn(e1, {
        inputType: "insertText"
    }), !0);
}
function Ad(e1) {
    return !!Vn(e1, {
        inputType: "insertText"
    }) && (Nd(e1, "after column"), jn(e1, {
        inputType: "insertText"
    }), !0);
}
function Cd(e1, t) {
    let i = e1.at(e1.position);
    for(; i && !(Array.isArray(i.treeBranch) && i.parent instanceof Pt);)i = i.parent;
    if (Array.isArray(null == i ? void 0 : i.treeBranch) && (null == i ? void 0 : i.parent) instanceof Pt) {
        const n = i.parent, r = i.treeBranch;
        let o;
        switch(t){
            case "row":
                if (n.rowCount > 1) {
                    n.removeRow(r[0]);
                    const t1 = n.getCell(Math.max(0, r[0] - 1), r[1]);
                    o = e1.offsetOf(t1[t1.length - 1]);
                }
                break;
            case "column":
                if (n.colCount > n.minColumns) {
                    n.removeColumn(r[1]);
                    const t2 = n.getCell(r[0], Math.max(0, r[1] - 1));
                    o = e1.offsetOf(t2[t2.length - 1]);
                }
        }
        o && e1.setPositionHandlingPlaceholder(o);
    }
}
function Ed(e1, t, i, n) {
    var r, o, a, s, l, u;
    const c = i.parent;
    if (i instanceof Lt) {
        const r1 = !n && "forward" === t || "body" === n && "backward" === t;
        let o1 = r1 ? e1.offsetOf(i.firstChild) : e1.offsetOf(i.lastChild);
        return r1 ? "?" !== i.rightDelim && "." !== i.rightDelim ? (i.leftDelim = ".", i.isDirty = !0) : (c.addChildrenAfter(i.removeBranch("body"), i), c.removeChild(i), o1--) : "?" !== i.leftDelim && "." !== i.leftDelim ? (i.rightDelim = ".", i.isDirty = !0) : (c.addChildrenAfter(i.removeBranch("body"), i), c.removeChild(i), o1--), e1.position = o1, !0;
    }
    if ("surd" === i.type) {
        if ("forward" === t && !n || "backward" === t && "body" === n) {
            const t1 = i.leftSibling;
            i.hasChildren && c.addChildrenAfter(i.removeBranch("body"), i), c.removeChild(i), e1.position = e1.offsetOf(t1);
        } else "forward" === t && "body" === n ? e1.position = e1.offsetOf(i) : n || "backward" !== t ? "above" === n && (i.hasEmptyBranch("above") && i.removeBranch("above"), e1.position = "backward" === t ? e1.offsetOf(i.leftSibling) : e1.offsetOf(i.body[0])) : i.hasChildren ? e1.position = e1.offsetOf(i.lastChild) : (e1.position = Math.max(0, e1.offsetOf(i) - 1), c.removeChild(i));
        return !0;
    }
    if ("box" === i.type || "enclose" === i.type) {
        const r2 = n && "backward" === t || !n && "forward" === t ? i.leftSibling : i.lastChild;
        return c.addChildrenAfter(i.removeBranch("body"), i), c.removeChild(i), e1.position = e1.offsetOf(r2), !0;
    }
    if ("genfrac" === i.type || "overunder" === i.type) {
        if (!n) return !("overunder" === i.type && i.hasEmptyBranch("body") || "genfrac" === i.type && i.hasEmptyBranch("below") && i.hasEmptyBranch("above") || (e1.position = e1.offsetOf("forward" === t ? i.firstChild : i.lastChild), 0));
        const r3 = "numerator-denominator" === i.context.fractionNavigationOrder ? "above" : "below", o2 = "above" === r3 ? "below" : "above";
        if ("forward" === t && n === r3 || "backward" === t && n === o2) {
            const t2 = i.removeBranch(r3), n1 = i.removeBranch(o2);
            return c.addChildrenAfter([
                ...t2,
                ...n1
            ], i), c.removeChild(i), e1.position = e1.offsetOf(t2.length > 0 ? t2[t2.length - 1] : n1[0]), !0;
        }
        return "backward" === t ? (e1.position = e1.offsetOf(i.leftSibling), !0) : (e1.position = e1.offsetOf(i), !0);
    }
    if (i.isExtensibleSymbol || "msubsup" === i.type) {
        if (!n && "forward" === t) return !1;
        if (!n) {
            if (i.subscript || i.superscript) {
                const n2 = "forward" === t ? null !== (o = null === (r = i.superscript) || void 0 === r ? void 0 : r[0]) && void 0 !== o ? o : null === (a = i.subscript) || void 0 === a ? void 0 : a[0] : null !== (l = null === (s = i.subscript) || void 0 === s ? void 0 : s[0].lastSibling) && void 0 !== l ? l : null === (u = i.superscript) || void 0 === u ? void 0 : u[0].lastSibling;
                return n2 && (e1.position = e1.offsetOf(n2)), !0;
            }
            return !1;
        }
        if (n && i.hasEmptyBranch(n) && i.removeBranch(n), !i.hasChildren) {
            const n3 = "forward" === t ? e1.offsetOf(i) : Math.max(0, e1.offsetOf(i) - 1);
            return i.parent.removeChild(i), e1.position = n3, !0;
        }
        if ("superscript" === n) {
            if ("backward" === t) {
                const t3 = e1.offsetOf(i.firstChild) - 1;
                e1.position = t3;
            } else i.subscript ? e1.position = e1.offsetOf(i.subscript[0]) : e1.position = e1.offsetOf(i);
        } else "subscript" === n && ("backward" === t && i.superscript ? e1.position = e1.offsetOf(i.superscript[0].lastSibling) : e1.position = "backward" === t ? e1.offsetOf(i.firstChild) - 1 : e1.offsetOf(i));
        return !0;
    }
    return !1;
}
function Td(e1, t, i) {
    const n = e1.getAtoms(t);
    if (n.length > 0 && n[0].parent) {
        let i1 = n[0].parent.firstChild;
        "first" === i1.type && (i1 = i1.rightSibling);
        const r = n[n.length - 1].parent.lastChild;
        let o = n[0];
        "first" === o.type && (o = o.rightSibling);
        const a = n[n.length - 1];
        if (o === i1 && a === r) {
            const i2 = n[0].parent;
            "root" !== i2.type && (t = [
                e1.offsetOf(i2.leftSibling),
                e1.offsetOf(i2.rightSibling)
            ]);
        }
    }
    return e1.deferNotifications({
        content: !0,
        selection: !0,
        type: i
    }, ()=>e1.deleteAtoms(t));
}
function Dd(e1, t) {
    const i = e1.at(t);
    let n;
    if (i) {
        n = i.mode;
        let e2 = i.parent;
        for(; !n && e2;)e2 && (n = e2.mode), e2 = e2.parent;
    }
    return n;
}
function zd(t, i) {
    t && i && (e1(t) ? t.forEach((e1)=>zd(e1, i)) : "object" == typeof t && (t.style.color || t.style.backgroundColor || t.style.fontFamily || t.style.fontShape || t.style.fontSeries || t.style.fontSize || t.style.variant || t.style.variantStyle || (t.applyStyle(i), zd(t.body, i), zd(t.above, i), zd(t.below, i), zd(t.subscript, i), zd(t.superscript, i))));
}
function qd(e1, t, i, n) {
    function r(e1, t) {
        for (const i of o)if (i.style[e1] !== t) return !1;
        return !0;
    }
    if ((t = e1.normalizeRange(t))[0] === t[1]) return !1;
    const o = e1.getAtoms(t, {
        includeChildren: !0
    });
    "toggle" === n.operation && (i.color && r("color", i.color) && (i.color = "none", i.verbatimColor = void 0), i.backgroundColor && r("backgroundColor", i.backgroundColor) && (i.backgroundColor = "none", i.verbatimBackgroundColor = void 0), i.fontFamily && r("fontFamily", i.fontFamily) && (i.fontFamily = "none"), i.fontSeries && r("fontSeries", i.fontSeries) && (i.fontSeries = "auto"), i.fontShape && r("fontShape", i.fontShape) && (i.fontShape = "auto"), i.fontSize && r("fontSize", i.fontSize) && (i.fontSize = 5));
    for (const e2 of o)e2.applyStyle(i);
    return !0;
}
function Id(e1, t, i) {
    if ("text" !== e1.at(t).mode) return t;
    const n = "backward" === i ? -1 : 1;
    let r;
    if (A.test(e1.at(t).value)) {
        let i1, o = t;
        do i1 = "text" === e1.at(o).mode && A.test(e1.at(o).value), o += n;
        while (e1.at(o) && i1);
        r = e1.at(o) ? o - 2 * n : o - n;
    } else if (/\s/.test(e1.at(t).value)) {
        let i2 = t;
        for(; e1.at(i2) && "text" === e1.at(i2).mode && /\s/.test(e1.at(i2).value);)i2 += n;
        if (e1.at(i2)) {
            let t1 = !0;
            do t1 = "text" === e1.at(i2).mode && !/\s/.test(e1.at(i2).value), i2 += n;
            while (e1.at(i2) && t1);
            r = e1.at(i2) ? i2 - 2 * n : i2 - n;
        } else r = i2 - n;
    } else {
        let i3 = t;
        for(; e1.at(i3) && "text" === e1.at(i3).mode && !/\s/.test(e1.at(i3).value);)i3 += n;
        r = e1.at(i3) ? i3 : i3 - n;
        let o1 = !0;
        for(; e1.at(i3) && o1;)o1 = "text" === e1.at(i3).mode && /\s/.test(e1.at(i3).value), o1 && (r = i3), i3 += n;
        r = e1.at(i3) ? i3 - 2 * n : i3 - n;
    }
    return r - (n > 0 ? 0 : 1);
}
function Od(e1, t, i) {
    var n, r, o, a, s, l, u;
    const c = e1.position;
    null !== (n = null == i ? void 0 : i.extend) && void 0 !== n && n || e1.collapseSelection(t);
    let d = e1.at(e1.position);
    if ("forward" === t && ("msubsup" === d.type ? (d = d.rightSibling, d || (d = e1.at(e1.position + 1))) : d = e1.at(e1.position + 1)), !d) return e1.announce("plonk"), !1;
    let h = e1.offsetOf(d);
    if (d instanceof Dt) h = Id(e1, h, t);
    else if (d instanceof Yt) {
        if (d.isSuggestion) for(; d && d instanceof Yt;)d.isSuggestion = !1, h = e1.offsetOf(d), d = d.rightSibling;
        else if ("forward" === t) {
            if (d = d.rightSibling, !(d && d instanceof Yt)) return e1.announce("plonk"), !1;
            for(; d && d instanceof Yt && /[a-zA-Z\*]/.test(d.value);)h = e1.offsetOf(d), d = d.rightSibling;
        } else {
            if (d = d.leftSibling, !(d && d instanceof Yt)) return e1.announce("plonk"), !1;
            for(; d && d instanceof Yt && /[a-zA-Z\*]/.test(d.value);)h = e1.offsetOf(d), d = d.leftSibling;
        }
    } else if ("forward" === t && "mopen" === d.type) {
        let t1 = 0;
        do "mopen" === d.type ? t1 += 1 : "mclose" === d.type && (t1 -= 1), d = d.rightSibling;
        while (!d.isLastSibling && 0 !== t1);
        h = e1.offsetOf(d.leftSibling);
    } else if ("backward" === t && "mclose" === d.type) {
        let t2 = 0;
        do "mopen" === d.type ? t2 += 1 : "mclose" === d.type && (t2 -= 1), d = d.leftSibling;
        while (!d.isFirstSibling && 0 !== t2);
        h = e1.offsetOf(d);
    } else if ("backward" === t) {
        if ("first" === d.type) for(; h > 0 && "first" === d.type;)h -= 1, d = e1.at(h);
        else {
            const t3 = d.type;
            "msubsup" === d.type && (h = e1.offsetOf(e1.at(h).leftSibling)), h -= 1;
            let i1 = null === (r = e1.at(h)) || void 0 === r ? void 0 : r.type;
            for(; h >= 0 && i1 === t3;)"msubsup" === (null === (o = e1.at(h)) || void 0 === o ? void 0 : o.type) ? h = e1.offsetOf(e1.at(h).leftSibling) : h -= 1, i1 = e1.at(h).type;
        }
    } else {
        const { type: t4  } = d;
        let i2 = null === (a = e1.at(h)) || void 0 === a ? void 0 : a.type;
        const { lastOffset: n1  } = e1;
        for(; h <= n1 && (i2 === t4 || "msubsup" === i2);){
            for(; "msubsup" === (null === (s = e1.at(h).rightSibling) || void 0 === s ? void 0 : s.type);)h = e1.offsetOf(e1.at(h).rightSibling);
            h += 1, i2 = null === (l = e1.at(h)) || void 0 === l ? void 0 : l.type;
        }
        h -= 1;
    }
    if (null !== (u = null == i ? void 0 : i.extend) && void 0 !== u && u) {
        if (!e1.setSelection(e1.anchor, h)) return e1.announce("plonk"), !1;
    } else {
        if (h === e1.position) return e1.announce("plonk"), !1;
        e1.position = h;
    }
    return e1.announce("move", c), !0;
}
function Fd(e1, t, i) {
    var n, r, o, a;
    if (i = null != i ? i : {
        extend: !1
    }, "forward" !== t) {
        const [t1, i1] = Un(e1);
        void 0 !== t1 && void 0 !== i1 && e1.deleteAtoms([
            t1,
            i1
        ]);
    }
    if ("upward" === t) return function(e1, t) {
        var i, n, r, o;
        const a = null !== (i = null == t ? void 0 : t.extend) && void 0 !== i && i;
        a || e1.collapseSelection("backward");
        const s = e1.at(e1.position);
        let l = s;
        for(; l && "below" !== l.treeBranch && !(Array.isArray(l.treeBranch) && l.parent instanceof Pt);)l = l.parent;
        if (Array.isArray(null == l ? void 0 : l.treeBranch) && l.parent instanceof Pt) {
            const t1 = l.parent, i1 = Math.max(0, l.treeBranch[0] - 1);
            Bd(e1, s, t1.array[i1][l.treeBranch[1]], a, "up");
        } else {
            if (!l) {
                let t2 = !0;
                return e1.suppressChangeNotifications || (t2 = null === (o = null === (r = e1.mathfield.host) || void 0 === r ? void 0 : r.dispatchEvent(new CustomEvent("move-out", {
                    detail: {
                        direction: "upward"
                    },
                    cancelable: !0,
                    bubbles: !0,
                    composed: !0
                }))) || void 0 === o || o), e1.announce(t2 ? "plonk" : "line"), t2;
            }
            Bd(e1, s, null !== (n = l.parent.branch("above")) && void 0 !== n ? n : l.parent.createBranch("above"), a, "up");
        }
        return !0;
    }(e1, i);
    if ("downward" === t) return function(e1, t) {
        var i, n, r, o;
        const a = null !== (i = null == t ? void 0 : t.extend) && void 0 !== i && i;
        a || e1.collapseSelection("forward");
        const s = e1.at(e1.position);
        let l = s;
        for(; l && "above" !== l.treeBranch && !(Array.isArray(l.treeBranch) && l.parent instanceof Pt);)l = l.parent;
        if (Array.isArray(null == l ? void 0 : l.treeBranch) && l.parent instanceof Pt) {
            const t1 = l.parent, i1 = Math.min(t1.array.length - 1, l.treeBranch[0] + 1);
            Bd(e1, s, t1.array[i1][l.treeBranch[1]], a, "down");
        } else {
            if (!l) {
                let t2 = !0;
                return e1.suppressChangeNotifications || (t2 = null === (o = null === (r = e1.mathfield.host) || void 0 === r ? void 0 : r.dispatchEvent(new CustomEvent("move-out", {
                    detail: {
                        direction: "downward"
                    },
                    cancelable: !0,
                    bubbles: !0,
                    composed: !0
                }))) || void 0 === o || o), e1.announce(t2 ? "plonk" : "line"), t2;
            }
            Bd(e1, s, null !== (n = l.parent.branch("below")) && void 0 !== n ? n : l.parent.createBranch("below"), a, "down");
        }
        return !0;
    }(e1, i);
    const s = e1.position;
    if (i.extend) return e1.extendSelection(t);
    if (e1.selectionIsPlaceholder) return e1.collapseSelection(t), Fd(e1, t);
    if (!e1.collapseSelection(t)) {
        let s1 = e1.position + ("forward" === t ? 1 : -1), l = e1.at(s1);
        if (s1 >= 0 && s1 <= e1.lastOffset) {
            if ("forward" === t) {
                if (l.inCaptureSelection) {
                    for(; !l.captureSelection;)l = l.parent;
                    s1 = e1.offsetOf(l);
                } else if (!l.isFirstSibling && l.isLastSibling && (null === (n = l.parent) || void 0 === n ? void 0 : n.skipBoundary)) {
                    if (s1 + 1 !== e1.lastOffset) return e1.position = s1, Fd(e1, "forward", i);
                    s1 += 1;
                } else l instanceof Yt && l.isSuggestion && (l.isSuggestion = !1);
            } else if ("backward" === t) {
                if (null === (r = l.parent) || void 0 === r ? void 0 : r.inCaptureSelection) {
                    for(; !l.captureSelection;)l = l.parent;
                    s1 = Math.max(0, e1.offsetOf(l.leftSibling));
                } else l.skipBoundary && (s1 = Math.max(0, e1.position - 2));
            }
        }
        if (s1 < 0 || s1 > e1.lastOffset) {
            let i2 = !0;
            return e1.suppressChangeNotifications || (i2 = null === (a = null === (o = e1.mathfield.host) || void 0 === o ? void 0 : o.dispatchEvent(new CustomEvent("move-out", {
                detail: {
                    direction: t
                },
                cancelable: !0,
                bubbles: !0,
                composed: !0
            }))) || void 0 === a || a), i2 && e1.announce("plonk"), i2;
        }
        e1.setPositionHandlingPlaceholder(s1);
    }
    return e1.announce("move", s), !0;
}
function Bd(e1, t, i, n, r) {
    const o = pn(e1.mathfield.getHTMLElement(t)).right, a = e1.offsetOf(function(e1, t, i) {
        let n = 1 / 0, r = 0;
        for(; r < t.length; r++){
            const o = pn(e1.getHTMLElement(t[r])).right, a = Math.abs(i - o);
            if (!(a <= n)) break;
            n = a;
        }
        return t[r - 1];
    }(e1.mathfield, i, o));
    if (n) {
        const [t1, i1] = e1.selection.ranges[0];
        let n1;
        n1 = a < ("up" === r ? t1 : i1) ? {
            ranges: [
                [
                    a,
                    i1
                ]
            ],
            direction: "backward"
        } : {
            ranges: [
                [
                    t1,
                    a
                ]
            ],
            direction: "forward"
        }, e1.setSelection(n1);
    } else e1.setPositionHandlingPlaceholder(a);
    e1.announce(`move ${r}`);
}
function $d(e1) {
    const t = e1.position, i = e1.at(t).parent;
    return i && "root" !== i.type ? (e1.position = e1.offsetOf(i), e1.announce("move", t), !0) : (e1.announce("plonk"), !1);
}
function Pd(e1) {
    var t;
    if (e1.collapseSelection(), function(e1) {
        let t = 0, i = e1.at(e1.position), n = !1;
        for(; i;)i.hasEmptyBranch("superscript") && i.hasEmptyBranch("subscript") || (t += 1), i.hasEmptyBranch("superscript") ? i.hasEmptyBranch("subscript") || (n = !1) : n = !0, i = i.parent;
        return n ? t : 0;
    }(e1) >= e1.mathfield.options.scriptDepth[1]) return e1.announce("plonk"), !1;
    let i = e1.at(e1.position);
    return void 0 === i.subsupPlacement && ("msubsup" !== (null === (t = i.rightSibling) || void 0 === t ? void 0 : t.type) && i.parent.addChildAfter(new At(e1.mathfield, {
        style: i.computedStyle
    }), i), i = i.rightSibling), i.createBranch("superscript"), e1.setSelection(e1.getSiblingsRange(e1.offsetOf(i.superscript[0]))), !0;
}
function Rd(e1) {
    var t;
    if (e1.collapseSelection(), function(e1) {
        let t = 0, i = e1.at(e1.position), n = !1;
        for(; i;)i.hasEmptyBranch("superscript") && i.hasEmptyBranch("subscript") || (t += 1), i.hasEmptyBranch("superscript") ? i.hasEmptyBranch("subscript") || (n = !0) : n = !1, i = i.parent;
        return n ? t : 0;
    }(e1) >= e1.mathfield.options.scriptDepth[0]) return e1.announce("plonk"), !1;
    let i = e1.at(e1.position);
    return void 0 === i.subsupPlacement && ("msubsup" !== (null === (t = e1.at(e1.position + 1)) || void 0 === t ? void 0 : t.type) && i.parent.addChildAfter(new At(e1.mathfield, {
        style: e1.at(e1.position).computedStyle
    }), i), i = e1.at(e1.position + 1)), i.createBranch("subscript"), e1.setSelection(e1.getSiblingsRange(e1.offsetOf(i.subscript[0]))), !0;
}
function Kd(e1, i, n = !0) {
    var r, o;
    const a = "forward" === i ? 1 : -1;
    "placeholder" === e1.at(e1.anchor).type && Fd(e1, i);
    const s = e1.getAllAtoms(Math.max(e1.position + a, 0));
    "backward" === i && s.reverse();
    const l = s.filter((e1)=>"placeholder" === e1.type || e1.treeDepth > 2 && e1.isFirstSibling && e1.isLastSibling);
    if (0 === l.length) {
        if (!n || null !== (o = null === (r = e1.mathfield.host) || void 0 === r ? void 0 : r.dispatchEvent(new CustomEvent("focus-out", {
            detail: {
                direction: i
            },
            cancelable: !0,
            bubbles: !0,
            composed: !0
        }))) && void 0 !== o && !o) return e1.announce("plonk"), !1;
        const s1 = function() {
            function e1(e1) {
                var n;
                return !((n = e1).disabled || "hidden" === n.type && "INPUT" === n.tagName.toUpperCase() || function(e1) {
                    if (!t() || e1 === document.activeElement || e1.contains(document.activeElement)) return !1;
                    if ("hidden" === getComputedStyle(e1).visibility) return !0;
                    const i = e1.getBoundingClientRect();
                    if (0 === i.width || 0 === i.height) return !0;
                    for(; e1;){
                        if ("none" === getComputedStyle(e1).display) return !0;
                        e1 = e1.parentElement;
                    }
                    return !1;
                }(n) || function(e1) {
                    return "INPUT" === e1.tagName.toUpperCase() && "radio" === e1.type && !function(e1) {
                        var t;
                        if (!e1.name) return !0;
                        const i = function(e1, t) {
                            for (const i of e1)if (i.checked && i.form === t) return i;
                            return null;
                        }((null !== (t = e1.form) && void 0 !== t ? t : e1.ownerDocument).querySelectorAll('input[type="radio"][name="' + e1.name + '"]'), e1.form);
                        return !i || i === e1;
                    }(e1);
                }(e1) || i(e1) < 0);
            }
            function i(e1) {
                var t;
                const i = Number.parseInt(null !== (t = e1.getAttribute("tabindex")) && void 0 !== t ? t : "NaN", 10);
                return Number.isNaN(i) ? "true" === e1.contentEditable ? 0 : "AUDIO" !== e1.nodeName && "VIDEO" !== e1.nodeName || null !== e1.getAttribute("tabindex") ? e1.tabIndex : 0 : i;
            }
            return t() ? function(t) {
                const n = [], r = [];
                return [
                    ...t.querySelectorAll('input, select, textarea, a[href], button,\n        [tabindex], audio[controls], video[controls],\n        [contenteditable]:not([contenteditable="false"]), details>summary')
                ].filter(e1).forEach((e1, t)=>{
                    const o = i(e1);
                    0 === o ? n.push(e1) : r.push({
                        documentOrder: t,
                        tabIndex: o,
                        node: e1
                    });
                }), r.sort((e1, t)=>e1.tabIndex === t.tabIndex ? e1.documentOrder - t.documentOrder : e1.tabIndex - t.tabIndex).map((e1)=>e1.node).concat(n);
            }(document.body) : [];
        }();
        if (!document.activeElement || 1 === s1.length) return e1.announce("plonk"), !1;
        let l1 = s1.indexOf(document.activeElement) + a;
        return !!(document.activeElement instanceof tm && u(document.activeElement, i, a)) || (l1 < 0 && (l1 = s1.length - 1), l1 >= s1.length && (l1 = 0), !!(s1[l1] instanceof tm && u(s1[l1], i, a)) || (s1[l1].focus(), 0 !== l1 || (e1.announce("plonk"), !1)));
    }
    function u(e1, t, i) {
        var n, r, o;
        const a = [
            ...null !== (r = null === (n = e1.shadowRoot) || void 0 === n ? void 0 : n.querySelectorAll("math-field")) && void 0 !== r ? r : []
        ];
        if (a.length) {
            const n1 = null === (o = e1.shadowRoot) || void 0 === o ? void 0 : o.activeElement, r1 = a.indexOf(n1);
            let s = r1 + i;
            if (r1 < 0 && "backward" === t && (s = a.length - 1), s >= 0 && s < a.length) return a[s].focus(), !0;
        }
        return !1;
    }
    const c = e1.position, d = e1.offsetOf(l[0]);
    return "placeholder" === l[0].type ? e1.setSelection(d - 1, d) : e1.position = d, e1.announce("move", c), !0;
}
function Vd(e1) {
    var t, i, n, r, o, a;
    if ("text" === Dd(e1, e1.position)) {
        let t1 = Math.min(e1.anchor, e1.position), i1 = Math.max(e1.anchor, e1.position), n1 = !1;
        for(; !n1 && t1 > 0;){
            const i2 = e1.at(t1);
            "text" === i2.mode && A.test(i2.value) ? t1 -= 1 : n1 = !0;
        }
        for(n1 = !1; !n1 && i1 <= e1.lastOffset;){
            const t2 = e1.at(i1);
            "text" === t2.mode && A.test(t2.value) ? i1 += 1 : n1 = !0;
        }
        if (n1 && (i1 -= 1), t1 >= i1) return e1.setSelection(i1 - 1, i1), !0;
        e1.setSelection(t1, i1);
    } else {
        const s = e1.at(e1.position);
        if (s.isDigit()) {
            let n2 = Math.min(e1.anchor, e1.position), r1 = Math.max(e1.anchor, e1.position);
            for(; null === (t = e1.at(n2)) || void 0 === t ? void 0 : t.isDigit();)n2 -= 1;
            for(; null === (i = e1.at(r1)) || void 0 === i ? void 0 : i.isDigit();)r1 += 1;
            e1.setSelection(n2, r1 - 1);
        } else if (s.style.variant || s.style.variantStyle) {
            let t3 = Math.min(e1.anchor, e1.position), i3 = Math.max(e1.anchor, e1.position), l = null === (n = e1.at(t3)) || void 0 === n ? void 0 : n.style;
            for(; l && l.variant === s.style.variant && l.variantStyle === s.style.variantStyle;)t3 -= 1, l = null === (r = e1.at(t3)) || void 0 === r ? void 0 : r.style;
            for(l = null === (o = e1.at(i3)) || void 0 === o ? void 0 : o.style; l && l.variant === s.style.variant && l.variantStyle === s.style.variantStyle;)i3 += 1, l = null === (a = e1.at(i3)) || void 0 === a ? void 0 : a.style;
            e1.setSelection(t3, i3 - 1);
        } else e1.setSelection(e1.offsetOf(s.firstSibling), e1.offsetOf(s.lastSibling));
    }
    return !0;
}
ur({
    addRowAfter: Ld,
    addColumnAfter: Ad,
    addRowBefore: function(e1) {
        return !!Vn(e1, {
            inputType: "insertText"
        }) && (Nd(e1, "before row"), jn(e1, {
            inputType: "insertText"
        }), !0);
    },
    addColumnBefore: function(e1) {
        return !!Vn(e1, {
            inputType: "insertText"
        }) && (Nd(e1, "before column"), jn(e1, {
            inputType: "insertText"
        }), !0);
    },
    removeRow: function(e1) {
        return !!Vn(e1, {
            inputType: "deleteContent"
        }) && (Cd(e1, "row"), jn(e1, {
            inputType: "deleteContent"
        }), !0);
    },
    removeColumn: function(e1) {
        return !!Vn(e1, {
            inputType: "deleteContent"
        }) && (Cd(e1, "column"), jn(e1, {
            inputType: "deleteContent"
        }), !0);
    }
}, {
    target: "model",
    category: "array-edit"
}), ur({
    deleteAll: (e1)=>Vn(e1, {
            inputType: "deleteContent"
        }) && Td(e1, [
            0,
            -1
        ], "deleteContent"),
    deleteForward: (e1)=>(function(e1) {
            return !!Vn(e1, {
                inputType: "deleteContentForward"
            }) && (e1.selectionIsCollapsed ? e1.deferNotifications({
                content: !0,
                selection: !0,
                type: "deleteContentForward"
            }, ()=>{
                var t, i;
                let n = e1.at(e1.position).rightSibling;
                if (n && Ed(e1, "forward", n)) return;
                if (n) {
                    if (e1.at(e1.position).isLastSibling && Ed(e1, "forward", n.parent, n.treeBranch)) return;
                } else {
                    if (n = e1.at(e1.position), n.isLastSibling && Ed(e1, "forward", n.parent, n.treeBranch)) return;
                    n = null;
                }
                if (e1.position === e1.lastOffset || !n) return void e1.announce("plonk");
                n.parent.removeChild(n);
                let r = null === (t = e1.at(e1.position)) || void 0 === t ? void 0 : t.rightSibling;
                for(; "msubsup" === (null == r ? void 0 : r.type);)r.parent.removeChild(r), r = null === (i = e1.at(e1.position)) || void 0 === i ? void 0 : i.rightSibling;
                e1.announce("delete", void 0, [
                    n
                ]);
            }) : Td(e1, Si(e1.selection), "deleteContentForward"));
        })(e1),
    deleteBackward: (e1)=>(function(e1) {
            return !!Vn(e1, {
                inputType: "deleteContentBackward"
            }) && (e1.selectionIsCollapsed ? e1.deferNotifications({
                content: !0,
                selection: !0,
                type: "deleteContentBackward"
            }, ()=>{
                let t = e1.at(e1.position);
                if (!t || !Ed(e1, "backward", t)) {
                    if (null == t ? void 0 : t.isFirstSibling) {
                        if (Ed(e1, "backward", t.parent, t.treeBranch)) return;
                        t = null;
                    }
                    t ? (e1.position = e1.offsetOf(t.leftSibling), t.parent.removeChild(t), e1.announce("delete", void 0, [
                        t
                    ])) : e1.announce("plonk");
                }
            }) : Td(e1, Si(e1.selection), "deleteContentBackward"));
        })(e1),
    deleteNextWord: (e1)=>Vn(e1, {
            inputType: "deleteWordForward"
        }) && Td(e1, [
            e1.anchor,
            Id(e1, e1.position, "forward")
        ], "deleteWordForward"),
    deletePreviousWord: (e1)=>Vn(e1, {
            inputType: "deleteWordBackward"
        }) && Td(e1, [
            e1.anchor,
            Id(e1, e1.position, "backward")
        ], "deleteWordBackward"),
    deleteToGroupStart: (e1)=>Vn(e1, {
            inputType: "deleteSoftLineBackward"
        }) && Td(e1, [
            e1.anchor,
            e1.offsetOf(e1.at(e1.position).firstSibling)
        ], "deleteSoftLineBackward"),
    deleteToGroupEnd: (e1)=>Vn(e1, {
            inputType: "deleteSoftLineForward"
        }) && Td(e1, [
            e1.anchor,
            e1.offsetOf(e1.at(e1.position).lastSibling)
        ], "deleteSoftLineForward"),
    deleteToMathFieldStart: (e1)=>Vn(e1, {
            inputType: "deleteHardLineBackward"
        }) && Td(e1, [
            e1.anchor,
            0
        ], "deleteHardLineBackward"),
    deleteToMathFieldEnd: (e1)=>Vn(e1, {
            inputType: "deleteHardLineForward"
        }) && Td(e1, [
            e1.anchor,
            -1
        ], "deleteHardLineForward")
}, {
    target: "model",
    category: "delete"
}), ur({
    moveToOpposite: (e1)=>{
        const t = e1.at(e1.position), { parent: i  } = t;
        if (!i) return e1.announce("plonk"), !1;
        const n = t.treeBranch;
        let r;
        return "string" == typeof n && (r = ({
            superscript: "subscript",
            subscript: "superscript",
            above: "below",
            below: "above"
        })[n]), r ? (i.branch(r) || i.createBranch(r), e1.setSelection(e1.getBranchRange(e1.offsetOf(i), r))) : t.subsupPlacement ? Rd(e1) : Pd(e1);
    },
    moveBeforeParent: (e1)=>{
        const { parent: t  } = e1.at(e1.position);
        return t ? (e1.position = e1.offsetOf(t), !0) : (e1.announce("plonk"), !1);
    },
    moveAfterParent: (e1)=>$d(e1),
    moveToNextPlaceholder: (e1)=>Kd(e1, "forward"),
    moveToPreviousPlaceholder: (e1)=>Kd(e1, "backward"),
    moveToNextChar: (e1)=>Fd(e1, "forward"),
    moveToPreviousChar: (e1)=>Fd(e1, "backward"),
    moveUp: (e1)=>Fd(e1, "upward"),
    moveDown: (e1)=>Fd(e1, "downward"),
    moveToNextWord: (e1)=>Od(e1, "forward"),
    moveToPreviousWord: (e1)=>Od(e1, "backward"),
    moveToGroupStart: (e1)=>{
        const t = e1.offsetOf(e1.at(e1.position).firstSibling);
        return t === e1.position ? (e1.announce("plonk"), !1) : (e1.position = t, !0);
    },
    moveToGroupEnd: (e1)=>{
        const t = e1.offsetOf(e1.at(e1.position).lastSibling);
        return t === e1.position ? (e1.announce("plonk"), !1) : (e1.position = t, !0);
    },
    moveToMathFieldStart: (e1)=>0 === e1.position ? (e1.announce("plonk"), !1) : (e1.position = 0, !0),
    moveToMathFieldEnd: (e1)=>e1.position === e1.lastOffset ? (e1.announce("plonk"), !1) : (e1.position = e1.lastOffset, !0),
    moveToSuperscript: (e1)=>Pd(e1),
    moveToSubscript: (e1)=>Rd(e1)
}, {
    target: "model",
    category: "selection-anchor"
}), ur({
    selectGroup: (e1)=>{
        const t = Vd(e1);
        return t || e1.announce("plonk"), t;
    },
    selectAll: (e1)=>e1.setSelection(0, e1.lastOffset),
    extendSelectionForward: (e1)=>{
        const t = e1.extendSelection("forward");
        return t || e1.announce("plonk"), t;
    },
    extendSelectionBackward: (e1)=>{
        const t = e1.extendSelection("backward");
        return t || e1.announce("plonk"), t;
    },
    extendToNextWord: (e1)=>Od(e1, "forward", {
            extend: !0
        }),
    extendToPreviousWord: (e1)=>Od(e1, "backward", {
            extend: !0
        }),
    extendSelectionUpward: (e1)=>Fd(e1, "upward", {
            extend: !0
        }),
    extendSelectionDownward: (e1)=>Fd(e1, "downward", {
            extend: !0
        }),
    extendToNextBoundary: (e1)=>Od(e1, "forward", {
            extend: !0
        }),
    extendToPreviousBoundary: (e1)=>Od(e1, "backward", {
            extend: !0
        }),
    extendToGroupStart: (e1)=>{
        const t = e1.setSelection(e1.anchor, e1.offsetOf(e1.at(e1.position).firstSibling));
        return t || e1.announce("plonk"), t;
    },
    extendToGroupEnd: (e1)=>{
        const t = e1.setSelection(e1.anchor, e1.offsetOf(e1.at(e1.position).lastSibling));
        return t || e1.announce("plonk"), t;
    },
    extendToMathFieldStart: (e1)=>{
        const t = e1.setSelection(e1.anchor, 0);
        return t || e1.announce("plonk"), t;
    },
    extendToMathFieldEnd: (e1)=>{
        const t = e1.setSelection(e1.anchor, e1.lastOffset);
        return t || e1.announce("plonk"), t;
    }
}, {
    target: "model",
    category: "selection-extend"
});
class jd {
    get element() {
        if (this._element) return this._element;
        const e1 = document.createElement("div");
        return e1.setAttribute("role", "presentation"), e1.style.position = "fixed", e1.style.contain = "content", e1.style.top = "0", e1.style.left = "0", e1.style.right = "0", e1.style.bottom = "0", e1.style.zIndex = "var(--scrim-zindex, 10099)", e1.style.outline = "none", this.translucent ? (e1.style.background = "rgba(255, 255, 255, .2)", e1.style.backdropFilter = "contrast(40%)") : e1.style.background = "transparent", this._element = e1, e1;
    }
    open(e1) {
        var t;
        if ("closed" !== this.state) return;
        this.state = "opening", this.savedActiveElement = Hd();
        const { element: i  } = this;
        (null !== (t = null == e1 ? void 0 : e1.root) && void 0 !== t ? t : document.body).appendChild(i), i.addEventListener("click", this), document.addEventListener("touchmove", this, !1), document.addEventListener("scroll", this, !1);
        const n = window.innerWidth - document.documentElement.clientWidth;
        this.savedMarginRight = document.body.style.marginRight, this.savedOverflow = document.body.style.overflow, document.body.style.overflow = "hidden";
        const r = Number.parseFloat(getComputedStyle(document.body).marginRight);
        document.body.style.marginRight = `${r + n}px`, (null == e1 ? void 0 : e1.child) && i.append(e1.child), this.state = "open";
    }
    close() {
        var e1, t, i, n;
        if ("open" !== this.state) return;
        this.state = "closing", "function" == typeof this.onClose && this.onClose();
        const { element: r  } = this;
        r.removeEventListener("click", this), document.removeEventListener("touchmove", this, !1), document.removeEventListener("scroll", this, !1), r.remove(), document.body.style.overflow = null !== (e1 = this.savedOverflow) && void 0 !== e1 ? e1 : "", document.body.style.marginRight = null !== (t = this.savedMarginRight) && void 0 !== t ? t : "", Hd() !== this.savedActiveElement && (null === (n = null === (i = this.savedActiveElement) || void 0 === i ? void 0 : i.focus) || void 0 === n || n.call(i)), r.innerHTML = "", this.state = "closed";
    }
    handleEvent(e1) {
        this.preventOverlayClose || (e1.target === this._element && "click" === e1.type ? (this.close(), e1.preventDefault(), e1.stopPropagation()) : e1.target !== document || "touchmove" !== e1.type && "scroll" !== e1.type || (this.close(), e1.preventDefault(), e1.stopPropagation()));
    }
    constructor(e1){
        var t, i;
        this.preventOverlayClose = null !== (t = null == e1 ? void 0 : e1.preventOverlayClose) && void 0 !== t && t, this.translucent = null !== (i = null == e1 ? void 0 : e1.translucent) && void 0 !== i && i, this.state = "closed";
    }
}
function Hd() {
    var e1;
    let t = document.activeElement;
    for(; null === (e1 = null == t ? void 0 : t.shadowRoot) || void 0 === e1 ? void 0 : e1.activeElement;)t = t.shadowRoot.activeElement;
    return t;
}
const Ud = new Set([
    "Backquote",
    "Digit0",
    "Digit1",
    "Digit2",
    "Digit3",
    "Digit4",
    "Digit5",
    "Digit6",
    "Digit7",
    "Digit8",
    "Digit9",
    "Minus",
    "Equal",
    "IntlYen",
    "KeyQ",
    "KeyW",
    "KeyE",
    "KeyR",
    "KeyT",
    "KeyY",
    "KeyU",
    "KeyI",
    "KeyO",
    "KeyP",
    "BracketLeft",
    "BracketRight",
    "Backslash",
    "KeyA",
    "KeyS",
    "KeyD",
    "KeyF",
    "KeyG",
    "KeyH",
    "KeyJ",
    "KeyK",
    "KeyL",
    "Semicolon",
    "Quote",
    "IntlBackslash",
    "KeyZ",
    "KeyX",
    "KeyC",
    "KeyV",
    "KeyB",
    "KeyN",
    "KeyM",
    "Comma",
    "Period",
    "Slash",
    "IntlRo",
    "Space",
    "Numpad0",
    "Numpad1",
    "Numpad2",
    "Numpad3",
    "Numpad4",
    "Numpad5",
    "Numpad6",
    "Numpad7",
    "Numpad8",
    "Numpad9",
    "NumpadAdd",
    "NumpadComma",
    "NumpadDecimal",
    "NumpadDivide",
    "NumpadEqual",
    "NumpadHash",
    "NumpadMultiply",
    "NumpadParenLeft",
    "NumpadParenRight",
    "NumpadStar",
    "NumpadSubstract"
]);
function Gd(e1) {
    return !e1.ctrlKey && !e1.metaKey && "Dead" !== e1.key && ("" === e1.code || Ud.has(e1.code));
}
function Zd(e1) {
    const t = [];
    return (e1 = function(e1) {
        if (e1.code) return e1;
        const t = Object.entries(Dn().mapping);
        let i = !1, n = !1, r = "";
        for(let o = 0; o < 4; o++){
            for (const [a, s] of t)if (s[o] === e1.key) {
                r = a, 3 === o ? (i = !0, n = !0) : 2 === o ? i = !0 : 1 === o && (n = !0);
                break;
            }
            if (r) break;
        }
        return new KeyboardEvent(e1.type, {
            ...e1,
            altKey: i,
            shiftKey: n,
            code: r
        });
    }(e1)).ctrlKey && t.push("ctrl"), e1.metaKey && t.push("meta"), e1.altKey && t.push("alt"), e1.shiftKey && t.push("shift"), 0 === t.length ? "[" + e1.code + "]" : (t.push("[" + e1.code + "]"), t.join("+"));
}
function Wd() {
    var e1;
    if (!t()) return null;
    let i = document.activeElement;
    for(; null === (e1 = null == i ? void 0 : i.shadowRoot) || void 0 === e1 ? void 0 : e1.activeElement;)i = i.shadowRoot.activeElement;
    return i;
}
function Jd(e1) {
    var t;
    if (!e1) return "";
    let i;
    return "Unidentified" === e1.key && e1.target && (i = e1.target.value), i = null !== (t = null != i ? i : e1.key) && void 0 !== t ? t : e1.code, /^(Dead|Return|Enter|Tab|Escape|Delete|PageUp|PageDown|Home|End|Help|ArrowLeft|ArrowRight|ArrowUp|ArrowDown)$/.test(i) && (i = ""), i;
}
class Xd {
    get maximumDepth() {
        return 1e3;
    }
    reset() {
        this.stack = [], this.index = -1;
    }
    startRecording() {
        this.recording = !0;
    }
    canUndo() {
        return this.index > 0;
    }
    canRedo() {
        return this.index !== this.stack.length - 1;
    }
    undo() {
        return !!this.canUndo() && (this.model.setState(this.stack[this.index - 1], {
            suppressChangeNotifications: !1,
            type: "undo"
        }), this.index -= 1, this.canCoalesce = !1, !0);
    }
    redo() {
        return !!this.canRedo() && (this.index += 1, this.model.setState(this.stack[this.index], {
            suppressChangeNotifications: !1,
            type: "redo"
        }), this.canCoalesce = !1, !0);
    }
    pop() {
        this.canUndo() && (this.index -= 1, this.stack.pop());
    }
    snapshot() {
        return !!this.recording && (this.stack.splice(this.index + 1, this.stack.length - this.index - 1), this.stack.push(this.model.getState()), this.index++, this.stack.length > this.maximumDepth && this.stack.shift(), this.canCoalesce = !1, !0);
    }
    snapshotAndCoalesce() {
        if (!this.recording) return !1;
        this.canCoalesce && this.pop();
        const e1 = this.snapshot();
        return this.canCoalesce = !0, e1;
    }
    constructor(e1){
        this.recording = !1, this.canCoalesce = !1, this.model = e1, this.reset();
    }
}
var Yd = '.ML__keyboard{--hue:206;--keyboard-background:rgba(209,213,217,.97);--keyboard-text:#000;--keyboard-text-active:var(--primary,hsl(var(--hue),40%,50%));--keyboard-background-border:#ddd;--keycap-background:#fff;--keycap-background-active:#e5e5e5;--keycap-background-border:#e5e6e9;--keycap-background-border-bottom:#8d8f92;--keycap-text:#000;--keycap-text-active:#fff;--keycap-secondary-text:#000;--keycap-modifier-background:#b9bdc7;--keycap-modifier-border:#c5c9d0;--keycap-modifier-border-bottom:#989da6;--keyboard-alternate-background:#fff;--keyboard-alternate-background-active:var(--primary,hsl(var(--hue),40%,50%));--keyboard-alternate-text:var(--keycap-text,#000);--keyboard-alternate-text-active:#fff;--keyboard-alternate-key-length:70px;--keyboard-alternate-key-font-size:30px;--keyboard-alternate-key-aside-font-size:12px;--keyboard-height:276px;--keycap-height:52px;--keycap-font-size:20px;--keycap-small-font-size:calc(var(--keycap-font-size)*0.8);--keycap-extra-small-font-size:calc(var(--keycap-font-size)/1.42);--keycap-tt-font-size:calc(var(--keycap-font-size)*1.5);height:100%;left:0;pointer-events:none;position:fixed;top:0;width:100%;z-index:var(--keyboard-zindex,105)}.ML__keyboard.is-visible .ML__keyboard--plate{opacity:1;transform:translateY(calc(var(--keyboard-height, 276px)*-1));transition-timing-function:cubic-bezier(.4,0,1,1);visibility:visible}.ML__keyboard.alternate-keys{align-content:center;background-color:var(--keyboard-alternate-background);border-radius:6px;bottom:auto;box-shadow:0 14px 28px rgba(0,0,0,.25),0 10px 10px rgba(0,0,0,.22);box-sizing:content-box;display:flex;flex-direction:row;justify-content:center;max-width:286px;position:fixed;text-align:center;top:0;transform:none;transition:none;visibility:hidden;z-index:calc(var(--keyboard-zindex, 105) + 1)}@media only screen and (max-height:412px){.ML__keyboard.alternate-keys{max-width:320px}}.ML__keyboard.alternate-keys.is-visible{visibility:visible}.ML__keyboard.alternate-keys.compact{--keyboard-alternate-key-length:50px;--keyboard-alternate-key-font-size:24px;--keyboard-alternate-key-aside-font-size:10px}.ML__keyboard.alternate-keys ul{display:flex;flex-flow:row wrap-reverse;justify-content:center;list-style:none;margin:3px;padding:0}.ML__keyboard.alternate-keys ul>li{fill:currentColor;align-items:center;background:transparent;border:1px solid transparent;border-radius:5px;box-sizing:border-box;color:var(--keyboard-alternate-text);display:flex;flex-flow:column;font-size:var(--keyboard-alternate-key-font-size);height:var(--keyboard-alternate-key-length);justify-content:center;margin:0;pointer-events:all;width:var(--keyboard-alternate-key-length)}@media only screen and (max-height:412px){.ML__keyboard.alternate-keys ul>li{font-size:24px;height:50px;width:50px}}.ML__keyboard.alternate-keys ul>li.is-active,.ML__keyboard.alternate-keys ul>li.is-pressed,.ML__keyboard.alternate-keys ul>li:hover{background:var(--keyboard-alternate-background-active);color:var(--keyboard-alternate-text-active)}.ML__keyboard.alternate-keys ul>li.small{font-size:var(--keycap-small-font-size,16px)}.ML__keyboard.alternate-keys ul>li.small-button{background:#fbfbfb;height:42px;margin:2px;width:42px}.ML__keyboard.alternate-keys ul>li.small-button:hover{background:var(--keyboard-alternate-background-active)}.ML__keyboard.alternate-keys ul>li.box>div,.ML__keyboard.alternate-keys ul>li.box>span{border:1px dashed rgba(0,0,0,.24)}.ML__keyboard.alternate-keys ul>li .warning{align-items:center;background:#cd0030;border-radius:5px;color:#fff;display:flex;justify-content:center;min-height:60px;min-width:60px;padding:5px}.ML__keyboard.alternate-keys ul>li .warning.is-active,.ML__keyboard.alternate-keys ul>li .warning.is-pressed,.ML__keyboard.alternate-keys ul>li .warning:hover{background:red}.ML__keyboard.alternate-keys ul>li .warning svg.svg-glyph{height:50px;width:50px}.ML__keyboard.alternate-keys ul>li aside{font-size:var(--keyboard-alternate-key-aside-font-size);line-height:12px;opacity:.78;padding-top:2px}.ML__keyboard .ML__keyboard--plate{-webkit-backdrop-filter:grayscale(50%);backdrop-filter:grayscale(50%);background-color:var(--keyboard-background);border:1px solid var(--keyboard-background-border);bottom:calc(var(--keyboard-height, 276px)*-1);box-shadow:0 3px 6px rgba(0,0,0,.16),0 3px 6px rgba(0,0,0,.23);box-sizing:border-box;cursor:pointer;font-family:system-ui,-apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Oxygen,Ubuntu,Cantarell,Fira Sans,Droid Sans,Helvetica Neue,sans-serif;font-size:16px;font-weight:400;left:0;margin:0;opacity:0;padding-top:5px;pointer-events:all;position:absolute;text-shadow:none;touch-action:none;transform:translate(0);transition:.28s cubic-bezier(0,0,.2,1);transition-property:transform,opacity;-webkit-user-select:none;user-select:none;visibility:hidden;width:100%}.ML__keyboard .ML__keyboard--plate .tex{font-family:KaTeX_Math,KaTeX_Main,Cambria Math,Asana Math,OpenSymbol,Symbola,STIX,Times,serif!important}.ML__keyboard .ML__keyboard--plate .tex-math{font-family:KaTeX_Math,Cambria Math,Asana Math,OpenSymbol,Symbola,STIX,Times,serif!important}.ML__keyboard .ML__keyboard--plate .tt{font-family:IBM Plex Mono,Source Code Pro,Consolas,Roboto Mono,Menlo,Bitstream Vera Sans Mono,DejaVu Sans Mono,Monaco,Courier,monospace!important;font-size:var(--keycap-tt-font-size,30px);font-weight:400}.ML__keyboard .ML__keyboard--plate>div.keyboard-layer{display:none;outline:none}.ML__keyboard .ML__keyboard--plate>div.keyboard-layer.is-visible{display:flex;flex-flow:column}.ML__keyboard .ML__keyboard--plate>div>div.keyboard-toolbar{align-self:center;display:flex;flex-flow:row;justify-content:space-between;min-width:736px}@media only screen and (min-width:768px) and (max-width:1024px){.ML__keyboard .ML__keyboard--plate>div>div.keyboard-toolbar{min-width:556px}}@media only screen and (max-width:767px){.ML__keyboard .ML__keyboard--plate>div>div.keyboard-toolbar{max-width:100vw;min-width:365px;width:365px}}.ML__keyboard .ML__keyboard--plate>div>div.keyboard-toolbar svg{height:20px;width:20px}@media only screen and (max-width:767px){.ML__keyboard .ML__keyboard--plate>div>div.keyboard-toolbar svg{height:13px;width:17px}}.ML__keyboard .ML__keyboard--plate>div>div.keyboard-toolbar>.left{display:flex;flex-flow:row;justify-content:flex-start;position:relative}.ML__keyboard .ML__keyboard--plate>div>div.keyboard-toolbar>.right{display:flex;flex-flow:row;justify-content:flex-end}.ML__keyboard .ML__keyboard--plate>div>div.keyboard-toolbar>div>div{fill:currentColor;align-items:baseline;background:0;border:none;border-bottom:2px solid transparent;box-shadow:none;color:var(--keyboard-text);cursor:pointer;display:flex;font-size:110%;justify-content:center;margin:7px 4px 6px;min-height:0;padding:4px 10px}.ML__keyboard .ML__keyboard--plate>div>div.keyboard-toolbar>div>div.disabled svg,.ML__keyboard .ML__keyboard--plate>div>div.keyboard-toolbar>div>div.disabled.is-pressed svg,.ML__keyboard .ML__keyboard--plate>div>div.keyboard-toolbar>div>div.disabled:hover svg{color:var(--keyboard-text);opacity:.2}@media only screen and (max-width:414px){.ML__keyboard .ML__keyboard--plate>div>div.keyboard-toolbar>div>div{font-size:100%;padding:0 6px 0 0}}@media only screen and (max-width:767px){.ML__keyboard .ML__keyboard--plate>div>div.keyboard-toolbar>div>div{font-size:90%;padding-left:4px;padding-right:4px}}.ML__keyboard .ML__keyboard--plate>div>div.keyboard-toolbar>div>div.is-active,.ML__keyboard .ML__keyboard--plate>div>div.keyboard-toolbar>div>div.is-pressed,.ML__keyboard .ML__keyboard--plate>div>div.keyboard-toolbar>div>div:active,.ML__keyboard .ML__keyboard--plate>div>div.keyboard-toolbar>div>div:hover{color:var(--keyboard-text-active)}.ML__keyboard .ML__keyboard--plate>div>div.keyboard-toolbar>div>div.selected{border-bottom:2px solid var(--keyboard-text-active);color:var(--keyboard-text-active);margin-bottom:8px;padding-bottom:0}.ML__keyboard .ML__keyboard--plate [data-tooltip]{position:relative}.ML__keyboard .ML__keyboard--plate [data-tooltip]:after{background:#616161;border-radius:2px;bottom:100%;box-shadow:0 2px 2px 0 rgba(0,0,0,.14),0 1px 5px 0 rgba(0,0,0,.12),0 3px 1px -2px rgba(0,0,0,.2);color:#fff;content:attr(data-tooltip);display:inline-table;font-family:system-ui,-apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Oxygen,Ubuntu,Cantarell,Fira Sans,Droid Sans,Helvetica Neue,sans-serif;font-size:12px;font-weight:400;max-width:200px;opacity:0;padding:8px;position:absolute;text-align:center;top:inherit;transform:scale(.5);transition:all .15s cubic-bezier(.4,0,1,1) 1s;width:max-content;z-index:2}@media only screen and (max-width:767px){.ML__keyboard .ML__keyboard--plate [data-tooltip]:after{font-size:16px;padding:8px 16px}}.ML__keyboard .ML__keyboard--plate [data-tooltip]:hover{position:relative}.ML__keyboard .ML__keyboard--plate [data-tooltip]:hover:after{opacity:1;transform:scale(1)}.ML__keyboard .ML__keyboard--plate div .rows{align-items:center;border:0;border-collapse:separate;clear:both;display:flex;flex-flow:column;margin:auto}.ML__keyboard .ML__keyboard--plate div .rows>ul{height:40px;list-style:none;margin:0 0 3px;padding:0}.ML__keyboard .ML__keyboard--plate div .rows>ul>li{fill:currentColor;-webkit-tap-highlight-color:transparent;align-items:center;background:var(--keycap-background);border:1px solid var(--keycap-background-border);border-bottom-color:var(--keycap-background-border-bottom);border-radius:5px;box-sizing:border-box;color:var(--keycap-text);display:flex;flex-flow:column;float:left;font-size:var(--keycap-font-size,20px);height:40px;justify-content:center;margin-right:2px;overflow:hidden;padding:8px 0;position:relative;text-align:center;-webkit-user-select:none;user-select:none;vertical-align:top;width:34px}.ML__keyboard .ML__keyboard--plate div .rows>ul>li:last-child{margin-right:0}.ML__keyboard .ML__keyboard--plate div .rows>ul>li.small{font-size:var(--keycap-small-font-size,16px)}.ML__keyboard .ML__keyboard--plate div .rows>ul>li.tt{color:var(--keyboard-text-active)}.ML__keyboard .ML__keyboard--plate div .rows>ul>li.bottom{justify-content:flex-end}.ML__keyboard .ML__keyboard--plate div .rows>ul>li.left{align-items:flex-start;padding-left:4px}.ML__keyboard .ML__keyboard--plate div .rows>ul>li.right{align-items:flex-end;padding-right:4px}.ML__keyboard .ML__keyboard--plate div .rows>ul>li svg.svg-glyph{height:20px;width:20px}.ML__keyboard .ML__keyboard--plate div .rows>ul>li .warning{align-items:center;background:#cd0030;border-radius:100%;color:#fff;display:flex;height:25px;justify-content:center;margin-bottom:-2px;min-height:25px;min-width:25px;padding:5px;width:25px}.ML__keyboard .ML__keyboard--plate div .rows>ul>li .warning svg.svg-glyph{height:16px;width:16px}@media only screen and (max-width:768px){.ML__keyboard .ML__keyboard--plate div .rows>ul>li .warning{height:16px;min-height:16px;min-width:16px;width:16px}.ML__keyboard .ML__keyboard--plate div .rows>ul>li .warning svg.svg-glyph{height:14px;width:14px}}.ML__keyboard .ML__keyboard--plate div .rows>ul>li>.w0{width:0}.ML__keyboard .ML__keyboard--plate div .rows>ul>li>.w5{width:16px}.ML__keyboard .ML__keyboard--plate div .rows>ul>li>.w15{width:52px}.ML__keyboard .ML__keyboard--plate div .rows>ul>li>.w20{width:70px}.ML__keyboard .ML__keyboard--plate div .rows>ul>li>.w50{width:178px}.ML__keyboard .ML__keyboard--plate div .rows>ul>li.separator{background:transparent;border:none;pointer-events:none}@media only screen and (max-width:560px){.ML__keyboard .ML__keyboard--plate div .rows>ul>li.if-wide{display:none}}.ML__keyboard .ML__keyboard--plate div .rows>ul>li.tex-math{font-size:25px}.ML__keyboard .ML__keyboard--plate div .rows>ul>li.is-pressed,.ML__keyboard .ML__keyboard--plate div .rows>ul>li:hover{background:var(--keycap-background-active);color:var(--keyboard-text-active)}.ML__keyboard .ML__keyboard--plate div .rows>ul>li.action.is-active,.ML__keyboard .ML__keyboard--plate div .rows>ul>li.action:active,.ML__keyboard .ML__keyboard--plate div .rows>ul>li.keycap.is-active,.ML__keyboard .ML__keyboard--plate div .rows>ul>li.keycap:active{color:var(--keyboard-text-active);transform:translateY(calc(var(--keycap-height, 52px)*-.2)) scale(1.4);z-index:calc(var(--keyboard-zindex, 105) - 5)}.ML__keyboard .ML__keyboard--plate div .rows>ul>li.modifier.is-active,.ML__keyboard .ML__keyboard--plate div .rows>ul>li.modifier:active{background:var(--keyboard-text-active);color:var(--keycap-text-active)}.ML__keyboard .ML__keyboard--plate div .rows>ul>li.action.font-glyph,.ML__keyboard .ML__keyboard--plate div .rows>ul>li.modifier.font-glyph{font-size:18px}@media only screen and (max-width:767px){.ML__keyboard .ML__keyboard--plate div .rows>ul>li.action.font-glyph,.ML__keyboard .ML__keyboard--plate div .rows>ul>li.modifier.font-glyph{font-size:16px}}@media only screen and (max-width:767px){.ML__keyboard .ML__keyboard--plate div .rows>ul>li.fnbutton{font-size:12px}}.ML__keyboard .ML__keyboard--plate div .rows>ul>li.bigfnbutton{font-size:var(--keycap-extra-small-font-size,14px)}@media only screen and (max-width:767px){.ML__keyboard .ML__keyboard--plate div .rows>ul>li.bigfnbutton{font-size:calc(var(--keycap-extra-small-font-size, 14px)/1.55)}}.ML__keyboard .ML__keyboard--plate div .rows>ul>li.action,.ML__keyboard .ML__keyboard--plate div .rows>ul>li.modifier{background-color:var(--keycap-modifier-background);border-color:var(--keycap-modifier-border);border-bottom-color:var(--keycap-modifier-border-bottom);font-size:65%;font-weight:100}.ML__keyboard .ML__keyboard--plate div .rows>ul>li.action.selected,.ML__keyboard .ML__keyboard--plate div .rows>ul>li.modifier.selected{color:var(--keyboard-text-active)}.ML__keyboard .ML__keyboard--plate div .rows>ul>li.action.selected.is-active,.ML__keyboard .ML__keyboard--plate div .rows>ul>li.action.selected.is-pressed,.ML__keyboard .ML__keyboard--plate div .rows>ul>li.action.selected:active,.ML__keyboard .ML__keyboard--plate div .rows>ul>li.action.selected:hover,.ML__keyboard .ML__keyboard--plate div .rows>ul>li.modifier.selected.is-active,.ML__keyboard .ML__keyboard--plate div .rows>ul>li.modifier.selected.is-pressed,.ML__keyboard .ML__keyboard--plate div .rows>ul>li.modifier.selected:active,.ML__keyboard .ML__keyboard--plate div .rows>ul>li.modifier.selected:hover{color:#fff}.ML__keyboard .ML__keyboard--plate div .rows>ul>li.keycap.w50{font-size:80%;font-weight:100;padding-top:10px}.ML__keyboard .ML__keyboard--plate div .rows>ul>li small{color:#555}@media only screen and (max-width:767px){.ML__keyboard .ML__keyboard--plate div .rows>ul>li small{font-size:9px}}.ML__keyboard .ML__keyboard--plate div .rows>ul>li aside{color:#666;font-family:system-ui,-apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Oxygen,Ubuntu,Cantarell,Fira Sans,Droid Sans,Helvetica Neue,sans-serif;font-size:10px;line-height:10px}@media only screen and (max-width:767px){.ML__keyboard .ML__keyboard--plate div .rows>ul>li aside{display:none}}@media only screen and (max-width:414px){.ML__keyboard .ML__keyboard--plate div .rows>ul>li{margin-right:2px;width:calc(10vw - 2px)}.ML__keyboard .ML__keyboard--plate div .rows>ul>.w5{width:calc(5vw - 2px)}.ML__keyboard .ML__keyboard--plate div .rows>ul>.w15{width:calc(15vw - 2px)}.ML__keyboard .ML__keyboard--plate div .rows>ul>.w20{width:calc(20vw - 2px)}.ML__keyboard .ML__keyboard--plate div .rows>ul>.w50{width:calc(50vw - 2px)}}@media only screen and (min-width:415px) and (max-width:768px){.ML__keyboard .ML__keyboard--plate div .rows>ul>li{margin-right:3px;width:37px}.ML__keyboard .ML__keyboard--plate div .rows>ul>.w5{width:17px}.ML__keyboard .ML__keyboard--plate div .rows>ul>.w15{width:57px}.ML__keyboard .ML__keyboard--plate div .rows>ul>.w20{width:77px}.ML__keyboard .ML__keyboard--plate div .rows>ul>.w50{width:197px}}@media only screen and (min-width:768px) and (max-width:1024px){.ML__keyboard .ML__keyboard--plate div .rows>ul{height:var(--keycap-height,52px)}.ML__keyboard .ML__keyboard--plate div .rows>ul>li{height:var(--keycap-height,52px);margin-right:4px;width:51px}.ML__keyboard .ML__keyboard--plate div .rows>ul>.w5{width:23.5px}.ML__keyboard .ML__keyboard--plate div .rows>ul>.w15{width:78.5px}.ML__keyboard .ML__keyboard--plate div .rows>ul>.w20{width:106px}.ML__keyboard .ML__keyboard--plate div .rows>ul>.w50{width:271px}}@media only screen and (min-width:1025px){.ML__keyboard .ML__keyboard--plate div .rows>ul{height:var(--keycap-height,52px)}.ML__keyboard .ML__keyboard--plate div .rows>ul>li{height:var(--keycap-height,52px);margin-right:6px;width:66px}.ML__keyboard .ML__keyboard--plate div .rows>ul>.action,.ML__keyboard .ML__keyboard--plate div .rows>ul>.modifier{font-size:80%}.ML__keyboard .ML__keyboard--plate div .rows>ul>.w5{width:30px}.ML__keyboard .ML__keyboard--plate div .rows>ul>.w15{width:102px}.ML__keyboard .ML__keyboard--plate div .rows>ul>.w20{width:138px}.ML__keyboard .ML__keyboard--plate div .rows>ul>.w50{width:354px}}@media (prefers-color-scheme:dark){body:not([theme=light]) .ML__keyboard{--hue:206;--keyboard-background:#4e6373;--keyboard-background:#4e6073;--keyboard-background:hsl(var(--hue),19%,38%);--keyboard-text:#f0f0f0;--keyboard-text-active:hsl(var(--hue),100%,60%);--keyboard-background-border:#333;--keycap-background:hsl(var(--hue),25%,39%);--keycap-background-active:hsl(var(--hue),35%,42%);--keycap-background-border:hsl(var(--hue),25%,35%);--keycap-background-border-bottom:#426b8a;--keycap-text:#d0d0d0;--keycap-text-active:#000;--keycap-secondary-text:#fff;--keycap-modifier-background:hsl(var(--hue),35%,40%);--keycap-modifier-border:hsl(var(--hue),35%,35%);--keycap-modifier-border-bottom:hsl(var(--hue),35%,42%);--keyboard-alternate-background:hsl(var(--hue),19%,38%)}}body[theme=dark] .ML__keyboard{--hue:206;--keyboard-background:hsl(var(--hue),19%,38%);--keyboard-text:#f0f0f0;--keyboard-text-active:hsl(var(--hue),100%,60%);--keyboard-background-border:#333;--keycap-background:hsl(var(--hue),25%,39%);--keycap-background-active:hsl(var(--hue),35%,42%);--keycap-background-border:hsl(var(--hue),25%,35%);--keycap-background-border-bottom:#426b8a;--keycap-text:#d0d0d0;--keycap-text-active:#000;--keycap-secondary-text:#fff;--keycap-modifier-background:hsl(var(--hue),35%,40%);--keycap-modifier-border:hsl(var(--hue),35%,35%);--keycap-modifier-border-bottom:hsl(var(--hue),35%,42%);--keyboard-alternate-background:hsl(var(--hue),19%,38%)}div.ML__keyboard.material{--keyboard-background:rgba(209,213,217,.9);--keyboard-background-border:#ddd;--keycap-background:transparent;--keycap-background-active:#cccfd1;--keycap-background-border:transparent;--keyboard-alternate-background:#efefef;--keyboard-alternate-text:#000;font-family:Roboto,sans-serif}div.ML__keyboard.material.alternate-keys{background:var(--keyboard-alternate-background);border:1px solid transparent;border-radius:5px;box-shadow:0 14px 28px rgba(0,0,0,.25),0 10px 10px rgba(0,0,0,.22)}div.ML__keyboard.material.alternate-keys ul li.is-active,div.ML__keyboard.material.alternate-keys ul li.is-pressed,div.ML__keyboard.material.alternate-keys ul li:active,div.ML__keyboard.material.alternate-keys ul li:hover{fill:currentColor;background:#5f97fc;border:1px solid transparent;color:#fff}div.ML__keyboard.material .ML__keyboard__plate .keyboard-toolbar>div>div{font-size:16px}div.ML__keyboard.material .ML__keyboard__plate .keyboard-toolbar div div:active,div.ML__keyboard.material .ML__keyboard__plate .keyboard-toolbar div div:hover,div.ML__keyboard.material .ML__keyboard__plate .keyboard-toolbar div.div.is-active,div.ML__keyboard.material .ML__keyboard__plate .keyboard-toolbar div.div.is-pressed{fill:currentColor;color:#5f97fc}div.ML__keyboard.material .ML__keyboard__plate .keyboard-toolbar>div>.selected{fill:currentColor;border-bottom:2px solid #5f97fc;color:#5f97fc;margin-bottom:8px;padding-bottom:0}div.ML__keyboard.material .ML__keyboard__plate div>.rows>ul>.keycap{fill:currentColor;background:transparent;border:1px solid transparent;border-radius:5px;color:var(--keycap-text);transition:none}div.ML__keyboard.material .ML__keyboard__plate div>.rows>ul>.keycap.tt{color:#5f97fc}div.ML__keyboard.material .ML__keyboard__plate div>.rows>ul>.keycap[data-key=" "]{background:#e0e0e0;height:20px;margin-bottom:10px;margin-top:10px}div.ML__keyboard.material .ML__keyboard__plate div>.rows>ul>.keycap[data-key=" "].is-active,div.ML__keyboard.material .ML__keyboard__plate div>.rows>ul>.keycap[data-key=" "].is-pressed,div.ML__keyboard.material .ML__keyboard__plate div>.rows>ul>.keycap[data-key=" "]:active,div.ML__keyboard.material .ML__keyboard__plate div>.rows>ul>.keycap[data-key=" "]:hover{background:#d0d0d0;box-shadow:none;transform:none}div.ML__keyboard.material .ML__keyboard__plate div>.rows>ul>.keycap:not([data-key=" "]):hover{background:var(--keycap-background-active);border:1px solid transparent;box-shadow:none}div.ML__keyboard.material .ML__keyboard__plate div>.rows>ul>.keycap:not([data-key=" "]).is-active,div.ML__keyboard.material .ML__keyboard__plate div>.rows>ul>.keycap:not([data-key=" "]).is-pressed,div.ML__keyboard.material .ML__keyboard__plate div>.rows>ul>.keycap:not([data-key=" "]):active{background:var(--keyboard-alternate-background);box-shadow:0 10px 20px rgba(0,0,0,.19),0 6px 6px rgba(0,0,0,.23);color:var(--keyboard-alternate-text)}@media only screen and (max-width:767px){div.ML__keyboard.material .ML__keyboard__plate div>.rows>ul>.keycap:not([data-key=" "]).is-active,div.ML__keyboard.material .ML__keyboard__plate div>.rows>ul>.keycap:not([data-key=" "]).is-pressed,div.ML__keyboard.material .ML__keyboard__plate div>.rows>ul>.keycap:not([data-key=" "]):active{box-shadow:0 10px 20px rgba(0,0,0,.19),0 6px 6px rgba(0,0,0,.23);font-size:10px;justify-content:flex-start;margin-left:10px;margin-right:10px;padding:2px 0 0;transform:translateY(-10px) scale(2);transition:none;vertical-align:top;width:19.5px;z-index:calc(var(--ML_keyboard-zindex, 105) - 5)}}@media only screen and (max-width:414px){div.ML__keyboard.material .ML__keyboard__plate div>.rows>ul>.keycap:not([data-key=" "]).is-active,div.ML__keyboard.material .ML__keyboard__plate div>.rows>ul>.keycap:not([data-key=" "]).is-pressed,div.ML__keyboard.material .ML__keyboard__plate div>.rows>ul>.keycap:not([data-key=" "]):active{width:16.5px}}@media only screen and (max-width:767px){div.ML__keyboard.material .ML__keyboard__plate div>.rows>ul>.keycap:last-child.is-active,div.ML__keyboard.material .ML__keyboard__plate div>.rows>ul>.keycap:last-child:active{margin-left:14px;margin-right:0}}div.ML__keyboard.material .ML__keyboard__plate div div.rows ul li.action,div.ML__keyboard.material .ML__keyboard__plate div div.rows ul li.modifier{fill:currentColor;background:transparent;border:0;color:#869096;font-size:16px;transition:none}div.ML__keyboard.material .ML__keyboard__plate div div.rows ul li.action.selected,div.ML__keyboard.material .ML__keyboard__plate div div.rows ul li.modifier.selected{border-bottom:2px solid #5f97fc;border-radius:0;color:#5f97fc}div.ML__keyboard.material .ML__keyboard__plate div div.rows ul li.action.is-active,div.ML__keyboard.material .ML__keyboard__plate div div.rows ul li.action.is-pressed,div.ML__keyboard.material .ML__keyboard__plate div div.rows ul li.action:active,div.ML__keyboard.material .ML__keyboard__plate div div.rows ul li.action:hover,div.ML__keyboard.material .ML__keyboard__plate div div.rows ul li.modifier.is-active,div.ML__keyboard.material .ML__keyboard__plate div div.rows ul li.modifier.is-pressed,div.ML__keyboard.material .ML__keyboard__plate div div.rows ul li.modifier:active,div.ML__keyboard.material .ML__keyboard__plate div div.rows ul li.modifier:hover{background:var(--keycap-background-active);border:0;box-shadow:none;color:var(--keycap-text)}div.ML__keyboard.material .ML__keyboard__plate div div.rows ul li.bigfnbutton,div.ML__keyboard.material .ML__keyboard__plate div div.rows ul li.fnbutton{background:transparent;border:0}div.ML__keyboard.material .ML__keyboard__plate div div.rows ul li.bigfnbutton.selected,div.ML__keyboard.material .ML__keyboard__plate div div.rows ul li.fnbutton.selected{fill:currentColor;border-bottom:2px solid #5f97fc;border-radius:0;color:#5f97fc}div.ML__keyboard.material .ML__keyboard__plate div div.rows ul li.bigfnbutton.is-active,div.ML__keyboard.material .ML__keyboard__plate div div.rows ul li.bigfnbutton.is-pressed,div.ML__keyboard.material .ML__keyboard__plate div div.rows ul li.bigfnbutton:active,div.ML__keyboard.material .ML__keyboard__plate div div.rows ul li.bigfnbutton:hover,div.ML__keyboard.material .ML__keyboard__plate div div.rows ul li.fnbutton.is-active,div.ML__keyboard.material .ML__keyboard__plate div div.rows ul li.fnbutton.is-pressed,div.ML__keyboard.material .ML__keyboard__plate div div.rows ul li.fnbutton:active,div.ML__keyboard.material .ML__keyboard__plate div div.rows ul li.fnbutton:hover{fill:currentColor;background:var(--keycap-background-active);border:0;box-shadow:none;color:#5f97fc}@media (prefers-color-scheme:dark){body:not([theme=light]) div.ML__keyboard.material{--hue:198;--keyboard-background:hsl(var(--hue),19%,18%);--keyboard-text:#d4d6d7;--keyboard-text-active:#5f97fc;--keyboard-background-border:#333;--keycap-background:hsl(var(--hue),25%,39%);--keycap-background-active:#5f97fc;--keycap-background-border:transparent;--keycap-background-border-bottom:transparent;--keycap-text:#d0d0d0;--keycap-text-active:#d4d6d7;--keycap-secondary-text:#5f97fc;--keycap-modifier-background:hsl(var(--hue),35%,40%);--keycap-modifier-border:hsl(var(--hue),35%,35%);--keycap-modifier-border-bottom:hsl(var(--hue),35%,42%);--keyboard-alternate-background:hsl(var(--hue),8%,2%);--keyboard-alternate-background-active:hsl(var(--hue),35%,42%);--keyboard-alternate-text:#d1d1d1}}body[theme=dark] div.ML__keyboard.material{--hue:198;--keyboard-background:hsl(var(--hue),19%,18%);--keyboard-text:#d4d6d7;--keyboard-text-active:#5f97fc;--keyboard-background-border:#333;--keycap-background:hsl(var(--hue),25%,39%);--keycap-background-active:#5f97fc;--keycap-background-border:transparent;--keycap-background-border-bottom:transparent;--keycap-text:#d0d0d0;--keycap-text-active:#d4d6d7;--keycap-secondary-text:#5f97fc;--keycap-modifier-background:hsl(var(--hue),35%,40%);--keycap-modifier-border:hsl(var(--hue),35%,35%);--keycap-modifier-border-bottom:hsl(var(--hue),35%,42%);--keyboard-alternate-background:hsl(var(--hue),8%,2%);--keyboard-alternate-background-active:hsl(var(--hue),35%,42%);--keyboard-alternate-text:#d1d1d1}';
function Qd(e1, t, i) {
    let n, r, o, a, s;
    !function(e1) {
        return "object" == typeof e1 && ("default" in e1 || "pressed" in e1);
    }(i) ? t.dataset.command = JSON.stringify(i) : (i.default && (t.dataset.command = JSON.stringify(i.default)), i.alt && (t.dataset.commandAlt = JSON.stringify(i.alt)), i.altshift && (t.dataset.commandAltshift = JSON.stringify(i.altshift)), i.shift && (t.dataset.commandShift = JSON.stringify(i.shift)), i.pressed && (t.dataset.commandPressed = JSON.stringify(i.pressed)), i.pressAndHoldStart && (t.dataset.commandPressAndHoldStart = JSON.stringify(i.pressAndHoldStart)), i.pressAndHoldEnd && (t.dataset.commandPressAndHoldEnd = JSON.stringify(i.pressAndHoldEnd))), tn(t, "mousedown touchstart:passive", (i)=>{
        if ("mousedown" !== i.type || 1 === i.buttons) {
            i.stopPropagation(), "touchstart" !== i.type && i.preventDefault(), document.body.style["-webkit-user-select"] = "none", t.classList.add("is-pressed"), n = Date.now(), "touchstart" === i.type && (o = i.changedTouches[0].identifier);
            const a = t.getAttribute("data-command-pressed");
            a && e1(JSON.parse(a));
            const l = t.getAttribute("data-command-press-and-hold-start");
            l && (r = t, s && clearTimeout(s), s = setTimeout(()=>{
                t.classList.contains("is-pressed") && e1(JSON.parse(l));
            }, 300));
        }
    }), tn(t, "mouseleave touchcancel", ()=>{
        t.classList.remove("is-pressed");
    }), tn(t, "touchmove:passive", (e1)=>{
        for(let t = 0; t < e1.changedTouches.length; t++)if (e1.changedTouches[t].identifier === o) {
            const i = document.elementsFromPoint(e1.changedTouches[t].clientX, e1.changedTouches[t].clientY), n = i[i.length - 1];
            n !== a && a && (a.dispatchEvent(new MouseEvent("mouseleave"), {
                bubbles: !0
            }), a = null), n && (a = n, n.dispatchEvent(new MouseEvent("mouseenter", {
                bubbles: !0,
                buttons: 1
            })));
        }
    }), tn(t, "mouseenter", (e1)=>{
        1 === e1.buttons && t.classList.add("is-pressed");
    }), tn(t, "mouseup touchend click", (i)=>{
        if (document.body.style["-webkit-user-select"] = "", a) {
            i.stopPropagation(), i.preventDefault();
            const e2 = a;
            return a = null, void e2.dispatchEvent(new MouseEvent("mouseup", {
                bubbles: !0
            }));
        }
        if (t.classList.remove("is-pressed"), t.classList.add("is-active"), "click" === i.type && 0 !== i.detail) return i.stopPropagation(), void i.preventDefault();
        setTimeout(()=>t.classList.remove("is-active"), 150);
        let o = t.getAttribute("data-command-press-and-hold-end");
        const s = Date.now();
        (t !== r || s < n + 300) && (o = null), !o && i.altKey && i.shiftKey && (o = t.getAttribute("data-command-altshift")), !o && i.altKey && (o = t.getAttribute("data-command-alt")), !o && i.shiftKey && (o = t.getAttribute("data-command-shift")), o || (o = t.getAttribute("data-command")), o && e1(JSON.parse(o)), i.stopPropagation(), i.preventDefault();
    });
}
let eh;
function th() {
    var e1;
    i();
    const t = document.querySelector("#mathlive-alternate-keys-panel");
    return t && (t.classList.remove("is-visible"), t.innerHTML = ""), null === (e1 = jd.scrim) || void 0 === e1 || e1.close(), !1;
}
class ih {
    setOptions(e1) {
        var t, i;
        let n = "";
        if (this._element) {
            const e2 = this._element.querySelector("div.keyboard-layer.is-visible");
            e2 && (n = null !== (t = e2.getAttribute("data-layer")) && void 0 !== t ? t : ""), this._element.remove(), this._element = void 0;
        }
        if (this.options = e1, this.visible) {
            this.buildAndAttachElement(e1.virtualKeyboardTheme);
            const t1 = this.element.querySelector(`.keyboard-layer[data-layer="${n}"]`);
            t1 && (null === (i = this.element.querySelector(".keyboard-layer.is-visible")) || void 0 === i || i.classList.remove("is-visible"), t1.classList.add("is-visible")), this.element.classList.add("is-visible");
        }
    }
    get element() {
        return this._element;
    }
    set element(e1) {
        var t;
        this._element !== e1 && (null === (t = this._element) || void 0 === t || t.remove(), this._element = e1);
    }
    get visible() {
        return this._visible;
    }
    set visible(e1) {
        this._visible = e1;
    }
    get height() {
        var e1, t;
        return null !== (t = null === (e1 = this.element) || void 0 === e1 ? void 0 : e1.offsetHeight) && void 0 !== t ? t : 0;
    }
    buildAndAttachElement(e1) {
        var t;
        this.element = function(e1, t) {
            var n, r, o, a;
            i();
            let s = '<svg xmlns="http://www.w3.org/2000/svg" style="display: none;">\n\n    <symbol id="svg-delete-backward" viewBox="0 0 576 512">\n      <path d="M432.1 208.1L385.9 256L432.1 303C442.3 312.4 442.3 327.6 432.1 336.1C423.6 346.3 408.4 346.3 399 336.1L352 289.9L304.1 336.1C295.6 346.3 280.4 346.3 271 336.1C261.7 327.6 261.7 312.4 271 303L318.1 256L271 208.1C261.7 199.6 261.7 184.4 271 175C280.4 165.7 295.6 165.7 304.1 175L352 222.1L399 175C408.4 165.7 423.6 165.7 432.1 175C442.3 184.4 442.3 199.6 432.1 208.1V208.1zM512 64C547.3 64 576 92.65 576 128V384C576 419.3 547.3 448 512 448H205.3C188.3 448 172 441.3 160 429.3L9.372 278.6C3.371 272.6 0 264.5 0 256C0 247.5 3.372 239.4 9.372 233.4L160 82.75C172 70.74 188.3 64 205.3 64L512 64zM528 128C528 119.2 520.8 112 512 112H205.3C201 112 196.9 113.7 193.9 116.7L54.63 256L193.9 395.3C196.9 398.3 201 400 205.3 400H512C520.8 400 528 392.8 528 384V128z"/>\n    </symbol>\n\n    <symbol id="svg-shift" viewBox="0 0 384 512">\n      <path d="M2.438 252.3C7.391 264.2 19.06 272 32 272h80v160c0 26.51 21.49 48 48 48h64C250.5 480 272 458.5 272 432v-160H352c12.94 0 24.61-7.797 29.56-19.75c4.953-11.97 2.219-25.72-6.938-34.88l-160-176C208.4 35.13 200.2 32 192 32S175.6 35.13 169.4 41.38l-160 176C.2188 226.5-2.516 240.3 2.438 252.3zM192 86.63L313.4 224H224v208H160V224H70.63L192 86.63z"/>\n    </symbol>\n\n    <symbol id="svg-commit" viewBox="0 0 512 512">\n      <path d="M135 432.1l-128-128C2.344 300.3 0 294.2 0 288s2.344-12.28 7.031-16.97l128-128c9.375-9.375 24.56-9.375 33.94 0s9.375 24.56 0 33.94L81.94 264H464v-208C464 42.75 474.8 32 488 32S512 42.75 512 56V288c0 13.25-10.75 24-24 24H81.94l87.03 87.03c9.375 9.375 9.375 24.56 0 33.94S144.4 442.3 135 432.1z"/>\n    </symbol>\n\n    <symbol id="svg-command" viewBox="0 0 640 512">\n      <path d="M34.495 36.465l211.051 211.05c4.686 4.686 4.686 12.284 0 16.971L34.495 475.535c-4.686 4.686-12.284 4.686-16.97 0l-7.071-7.07c-4.686-4.686-4.686-12.284 0-16.971L205.947 256 10.454 60.506c-4.686-4.686-4.686-12.284 0-16.971l7.071-7.07c4.686-4.687 12.284-4.687 16.97 0zM640 468v-10c0-6.627-5.373-12-12-12H300c-6.627 0-12 5.373-12 12v10c0 6.627 5.373 12 12 12h328c6.627 0 12-5.373 12-12z"/>\n    </symbol>\n\n    <symbol id="svg-undo" viewBox="0 0 512 512">\n      <path d="M20 8h10c6.627 0 12 5.373 12 12v110.625C85.196 57.047 165.239 7.715 256.793 8.001 393.18 8.428 504.213 120.009 504 256.396 503.786 393.181 392.834 504 256 504c-63.926 0-122.202-24.187-166.178-63.908-5.113-4.618-5.354-12.561-.482-17.433l7.069-7.069c4.503-4.503 11.749-4.714 16.482-.454C150.782 449.238 200.935 470 256 470c117.744 0 214-95.331 214-214 0-117.744-95.331-214-214-214-82.862 0-154.737 47.077-190.289 116H180c6.627 0 12 5.373 12 12v10c0 6.627-5.373 12-12 12H20c-6.627 0-12-5.373-12-12V20c0-6.627 5.373-12 12-12z"/>\n    </symbol>\n    <symbol id="svg-redo" viewBox="0 0 512 512">\n      <path d="M492 8h-10c-6.627 0-12 5.373-12 12v110.625C426.804 57.047 346.761 7.715 255.207 8.001 118.82 8.428 7.787 120.009 8 256.396 8.214 393.181 119.166 504 256 504c63.926 0 122.202-24.187 166.178-63.908 5.113-4.618 5.354-12.561.482-17.433l-7.069-7.069c-4.503-4.503-11.749-4.714-16.482-.454C361.218 449.238 311.065 470 256 470c-117.744 0-214-95.331-214-214 0-117.744 95.331-214 214-214 82.862 0 154.737 47.077 190.289 116H332c-6.627 0-12 5.373-12 12v10c0 6.627 5.373 12 12 12h160c6.627 0 12-5.373 12-12V20c0-6.627-5.373-12-12-12z"/>\n    </symbol>\n    <symbol id="svg-arrow-left" viewBox="0 0 320 512">\n      <path d="M206.7 464.6l-183.1-191.1C18.22 267.1 16 261.1 16 256s2.219-11.97 6.688-16.59l183.1-191.1c9.152-9.594 24.34-9.906 33.9-.7187c9.625 9.125 9.938 24.37 .7187 33.91L73.24 256l168 175.4c9.219 9.5 8.906 24.78-.7187 33.91C231 474.5 215.8 474.2 206.7 464.6z"/>\n    </symbol>\n    <symbol id="svg-arrow-right" viewBox="0 0 320 512">\n      <path d="M113.3 47.41l183.1 191.1c4.469 4.625 6.688 10.62 6.688 16.59s-2.219 11.97-6.688 16.59l-183.1 191.1c-9.152 9.594-24.34 9.906-33.9 .7187c-9.625-9.125-9.938-24.38-.7187-33.91l168-175.4L78.71 80.6c-9.219-9.5-8.906-24.78 .7187-33.91C88.99 37.5 104.2 37.82 113.3 47.41z"/>\n    </symbol>\n    <symbol id="svg-tab" viewBox="0 0 448 512">\n      <path d="M32 217.1c0-8.8 7.2-16 16-16h144v-93.9c0-7.1 8.6-10.7 13.6-5.7l143.5 143.1c6.3 6.3 6.3 16.4 0 22.7L205.6 410.4c-5 5-13.6 1.5-13.6-5.7v-93.9H48c-8.8 0-16-7.2-16-16v-77.7m-32 0v77.7c0 26.5 21.5 48 48 48h112v61.9c0 35.5 43 53.5 68.2 28.3l143.6-143c18.8-18.8 18.8-49.2 0-68L228.2 78.9c-25.1-25.1-68.2-7.3-68.2 28.3v61.9H48c-26.5 0-48 21.6-48 48zM436 64h-8c-6.6 0-12 5.4-12 12v360c0 6.6 5.4 12 12 12h8c6.6 0 12-5.4 12-12V76c0-6.6-5.4-12-12-12z"/>\n    </symbol>\n    <symbol id="svg-copy" viewBox="0 0 448 512">\n      <path d="M433.941 65.941l-51.882-51.882A48 48 0 0 0 348.118 0H176c-26.51 0-48 21.49-48 48v48H48c-26.51 0-48 21.49-48 48v320c0 26.51 21.49 48 48 48h224c26.51 0 48-21.49 48-48v-48h80c26.51 0 48-21.49 48-48V99.882a48 48 0 0 0-14.059-33.941zM352 32.491a15.88 15.88 0 0 1 7.431 4.195l51.882 51.883A15.885 15.885 0 0 1 415.508 96H352V32.491zM288 464c0 8.822-7.178 16-16 16H48c-8.822 0-16-7.178-16-16V144c0-8.822 7.178-16 16-16h80v240c0 26.51 21.49 48 48 48h112v48zm128-96c0 8.822-7.178 16-16 16H176c-8.822 0-16-7.178-16-16V48c0-8.822 7.178-16 16-16h144v72c0 13.2 10.8 24 24 24h72v240z"/>\n    </symbol>\n    <symbol id="svg-angle-double-right" viewBox="0 0 320 512">\n      <path d="M166.9 264.5l-117.8 116c-4.7 4.7-12.3 4.7-17 0l-7.1-7.1c-4.7-4.7-4.7-12.3 0-17L127.3 256 25.1 155.6c-4.7-4.7-4.7-12.3 0-17l7.1-7.1c4.7-4.7 12.3-4.7 17 0l117.8 116c4.6 4.7 4.6 12.3-.1 17zm128-17l-117.8-116c-4.7-4.7-12.3-4.7-17 0l-7.1 7.1c-4.7 4.7-4.7 12.3 0 17L255.3 256 153.1 356.4c-4.7 4.7-4.7 12.3 0 17l7.1 7.1c4.7 4.7 12.3 4.7 17 0l117.8-116c4.6-4.7 4.6-12.3-.1-17z"/>\n    </symbol>\n    <symbol id="svg-angle-double-left" viewBox="0 0 320 512">\n      <path d="M153.1 247.5l117.8-116c4.7-4.7 12.3-4.7 17 0l7.1 7.1c4.7 4.7 4.7 12.3 0 17L192.7 256l102.2 100.4c4.7 4.7 4.7 12.3 0 17l-7.1 7.1c-4.7 4.7-12.3 4.7-17 0L153 264.5c-4.6-4.7-4.6-12.3.1-17zm-128 17l117.8 116c4.7 4.7 12.3 4.7 17 0l7.1-7.1c4.7-4.7 4.7-12.3 0-17L64.7 256l102.2-100.4c4.7-4.7 4.7-12.3 0-17l-7.1-7.1c-4.7-4.7-12.3-4.7-17 0L25 247.5c-4.6 4.7-4.6 12.3.1 17z"/>\n    </symbol>\n    <symbol id="svg-trash" viewBox="0 0 448 512">\n      <path d="M336 64l-33.6-44.8C293.3 7.1 279.1 0 264 0h-80c-15.1 0-29.3 7.1-38.4 19.2L112 64H24C10.7 64 0 74.7 0 88v2c0 3.3 2.7 6 6 6h26v368c0 26.5 21.5 48 48 48h288c26.5 0 48-21.5 48-48V96h26c3.3 0 6-2.7 6-6v-2c0-13.3-10.7-24-24-24h-88zM184 32h80c5 0 9.8 2.4 12.8 6.4L296 64H152l19.2-25.6c3-4 7.8-6.4 12.8-6.4zm200 432c0 8.8-7.2 16-16 16H80c-8.8 0-16-7.2-16-16V96h320v368zm-176-44V156c0-6.6 5.4-12 12-12h8c6.6 0 12 5.4 12 12v264c0 6.6-5.4 12-12 12h-8c-6.6 0-12-5.4-12-12zm-80 0V156c0-6.6 5.4-12 12-12h8c6.6 0 12 5.4 12 12v264c0 6.6-5.4 12-12 12h-8c-6.6 0-12-5.4-12-12zm160 0V156c0-6.6 5.4-12 12-12h8c6.6 0 12 5.4 12 12v264c0 6.6-5.4 12-12 12h-8c-6.6 0-12-5.4-12-12z"/>\n    </symbol>\n</svg>\n        ';
            e1.create(), oh["foreground-color"] = [];
            for (const e2 of Object.keys(h))oh["foreground-color"].push({
                class: "small-button",
                content: '<span style="border-radius:50%;width:32px;height:32px; box-sizing: border-box; border: 3px solid ' + h[e2] + '"></span>',
                command: [
                    "applyStyle",
                    {
                        color: e2
                    }
                ]
            });
            oh["background-color"] = [];
            for (const e3 of Object.keys(d))oh["background-color"].push({
                class: "small-button",
                content: '<span style="border-radius:50%;width:32px;height:32px; background:' + d[e3] + '"></span>',
                command: [
                    "applyStyle",
                    {
                        backgroundColor: e3
                    }
                ]
            });
            ah = {
                ...oh
            };
            for (const e4 of Object.keys(ah))ah[e4] = ah[e4].slice();
            for(let e5 = 0; e5 < 26; e5++){
                const t1 = "ABCDEFGHIJKLMNOPQRSTUVWXYZ"[e5];
                ah[t1] || (ah[t1] = []), ah[t1].unshift({
                    latex: "\\mathbb{" + t1 + "}",
                    aside: "blackboard",
                    insert: "\\mathbb{" + t1 + "}"
                }), ah[t1].unshift({
                    latex: "\\mathbf{" + t1 + "}",
                    aside: "bold",
                    insert: "\\mathbf{" + t1 + "}"
                }), ah[t1].unshift({
                    latex: "\\mathsf{" + t1 + "}",
                    aside: "sans",
                    insert: "\\mathsf{" + t1 + "}"
                }), ah[t1].unshift({
                    latex: "\\mathtt{" + t1 + "}",
                    aside: "monospace",
                    insert: "\\mathtt{" + t1 + "}"
                }), ah[t1].unshift({
                    latex: "\\mathcal{" + t1 + "}",
                    aside: "calligraphy",
                    insert: "\\mathcal{" + t1 + "}"
                }), ah[t1].unshift({
                    latex: "\\mathfrak{" + t1 + "}",
                    aside: "fraktur",
                    insert: "\\mathfrak{" + t1 + "}"
                });
            }
            for(let e6 = 0; e6 <= 26; e6++){
                const t2 = "abcdefghijklmnopqrstuvwxyz"[e6];
                ah[t2] || (ah[t2] = []), ah[t2].unshift({
                    latex: "\\mathsf{" + t2 + "}",
                    aside: "sans",
                    insert: "\\mathsf{" + t2 + "}"
                }), ah[t2].unshift({
                    latex: "\\mathbf{" + t2 + "}",
                    aside: "bold",
                    insert: "\\mathbf{" + t2 + "}"
                }), ah[t2].unshift({
                    latex: "\\mathtt{" + t2 + "}",
                    aside: "monospace",
                    insert: "\\mathtt{" + t2 + "}"
                }), ah[t2].unshift({
                    latex: "\\mathfrak{" + t2 + "}",
                    aside: "fraktur",
                    insert: "\\mathfrak{" + t2 + "}"
                });
            }
            for(let e7 = 0; e7 < 10; e7++){
                const t3 = "0123456789"[e7];
                ah[t3] || (ah[t3] = []), ah[t3].unshift({
                    latex: "\\mathbf{" + t3 + "}",
                    aside: "bold",
                    insert: "\\mathbf{" + t3 + "}"
                }), ah[t3].unshift({
                    latex: "\\mathsf{" + t3 + "}",
                    aside: "sans",
                    insert: "\\mathsf{" + t3 + "}"
                }), ah[t3].unshift({
                    latex: "\\mathtt{" + t3 + "}",
                    aside: "monospace",
                    insert: "\\mathtt{" + t3 + "}"
                }), ah[t3].unshift({
                    latex: "\\mathcal{" + t3 + "}",
                    aside: "script",
                    insert: "\\mathcal{" + t3 + "}"
                }), ah[t3].unshift({
                    latex: "\\mathfrak{" + t3 + "}",
                    aside: "fraktur",
                    insert: "\\mathfrak{" + t3 + "}"
                });
            }
            let l = e1.options.virtualKeyboards;
            l || (l = "all"), l = l.replace(/\ball\b/i, "numeric functions symbols roman  greek");
            const u = {
                ...sh,
                ...null !== (n = e1.options.customVirtualKeyboardLayers) && void 0 !== n ? n : {}
            }, c = {
                ...nh,
                ...null !== (r = e1.options.customVirtualKeyboards) && void 0 !== r ? r : {}
            }, m = l.replace(/\s+/g, " ").split(" ");
            for (const t4 of m){
                if (!c[t4]) continue;
                let i1 = null !== (o = c[t4].layers) && void 0 !== o ? o : [];
                c[t4].layer && i1.push(c[t4].layer), i1 = [
                    ...new Set(i1)
                ];
                for (const n1 of i1){
                    if (!u[n1]) break;
                    if ("object" == typeof u[n1]) {
                        const e8 = u[n1];
                        let t5 = "";
                        if ("string" == typeof e8.styles ? t5 += `<style>${e8.styles}</style>` : "object" == typeof e8.styles && (t5 += `<style>${mh(e8.styles)}</style>`), e8.backdrop && (t5 += `<div class='${e8.backdrop}'>`), e8.container && (t5 += `<div class='${e8.container}'>`), e8.rows) {
                            t5 += "<div class='rows'>";
                            for (const i2 of e8.rows){
                                t5 += "<ul>";
                                for (const e9 of i2){
                                    if (t5 += "<li", e9.class) {
                                        let i3 = e9.class;
                                        e9.layer && !/layer-switch/.test(i3) && (i3 += " layer-switch"), /separator/.test(i3) || (i3 += " keycap"), t5 += ` class="${i3}"`;
                                    } else t5 += ' class="keycap"';
                                    if (e9.key && (t5 += ` data-key="${e9.key}"`), e9.command && ("string" == typeof e9.command ? t5 += ` data-command='"${e9.command}"'` : (t5 += " data-command='", t5 += JSON.stringify(e9.command), t5 += "'")), e9.insert && (t5 += ` data-insert="${e9.insert}"`), e9.latex && (t5 += ` data-latex="${e9.latex}"`), e9.aside && (t5 += ` data-aside="${e9.aside}"`), e9.variants) {
                                        const i4 = Date.now().toString(36).slice(-2) + Math.floor(1e5 * Math.random()).toString(36);
                                        ah[i4] = e9.variants, t5 += ` data-alt-keys="${i4}"`;
                                    }
                                    e9.shifted && (t5 += ` data-shifted="${e9.shifted}"`), e9.shiftedCommand && (t5 += ` data-shifted-command="${e9.shiftedCommand}"`), e9.layer && (t5 += ` data-layer="${e9.layer}"`), t5 += `>${e9.label ? e9.label : ""}</li>`;
                                }
                                t5 += "</ul>";
                            }
                            t5 += "</div>";
                        }
                        e8.container && (t5 += "</div>"), e8.backdrop && (t5 += "</div>"), u[n1] = t5;
                    }
                    s += `<div tabindex="-1" class='keyboard-layer' data-layer='${n1}'>`, s += uh(e1.options, l, t4);
                    const i5 = u[n1];
                    "string" == typeof i5 && (s += dh(e1.options, i5)), s += "</div>";
                }
            }
            const p = document.createElement("div");
            p.className = "ML__keyboard", t ? p.classList.add(t) : e1.options.virtualKeyboardTheme && p.classList.add(e1.options.virtualKeyboardTheme);
            const f = document.createElement("div");
            f.className = "ML__keyboard--plate", f.innerHTML = e1.options.createHTML(s), p.appendChild(f);
            const g = p.querySelectorAll(".keycap, .action, .fnbutton, .bigfnbutton");
            for (const e10 of g)e10.id = "ML__k" + Date.now().toString(36).slice(-2) + Math.floor(1e5 * Math.random()).toString(36);
            ch(e1, [
                ...g
            ]);
            const y = p.querySelectorAll(".layer-switch");
            for (const t6 of y)t6.classList.contains("shift") ? Qd((t)=>e1.executeCommand(t), t6, {
                pressed: "shiftKeyboardLayer",
                default: [
                    "switchKeyboardLayer",
                    t6.getAttribute("data-layer")
                ],
                pressAndHoldEnd: "unshiftKeyboardLayer"
            }) : Qd((t)=>e1.executeCommand(t), t6, {
                default: [
                    "switchKeyboardLayer",
                    t6.getAttribute("data-layer")
                ]
            });
            const b = p.querySelectorAll(".keyboard-layer");
            for (const e11 of b)e11.addEventListener("mousedown", (e1)=>{
                e1.preventDefault(), e1.stopPropagation();
            }), e11.addEventListener("touchstart", (e1)=>{
                e1.preventDefault(), e1.stopPropagation();
            }, {
                passive: !1
            });
            return null === (a = b[0]) || void 0 === a || a.classList.add("is-visible"), p;
        }(this, null != e1 ? e1 : ""), tn(this.element, "touchstart:passive mousedown", ()=>this.focusMathfield()), null === (t = this.options.virtualKeyboardContainer) || void 0 === t || t.appendChild(this.element);
    }
    handleEvent(e1) {
        if (this.element) switch(e1.type){
            case "mouseup":
            case "blur":
            case "touchend":
            case "touchcancel":
                document.body.style.userSelect = "", hh(this);
        }
    }
    focusMathfield() {
        var e1, t;
        null === (t = null === (e1 = this._mathfield) || void 0 === e1 ? void 0 : e1.focus) || void 0 === t || t.call(e1);
    }
    blurMathfield() {
        var e1, t;
        null === (t = null === (e1 = this._mathfield) || void 0 === e1 ? void 0 : e1.blur) || void 0 === t || t.call(e1);
    }
    stateChanged() {
        var e1, t;
        null === (t = null === (e1 = this._mathfield) || void 0 === e1 ? void 0 : e1.element) || void 0 === t || t.dispatchEvent(new Event("virtual-keyboard-toggle", {
            bubbles: !0,
            cancelable: !1,
            composed: !0
        }));
    }
    executeCommand(t) {
        var i, n, r;
        let o, a = [];
        return e1(t) ? (o = t[0], a = t.slice(1)) : o = t, o = o.replace(/-\w/g, (e1)=>e1[1].toUpperCase()), "virtual-keyboard" === (null === (i = lr[o]) || void 0 === i ? void 0 : i.target) ? lr[o].fn(this, ...a) : null !== (r = null === (n = this._mathfield) || void 0 === n ? void 0 : n.executeCommand(t)) && void 0 !== r && r;
    }
    create() {
        this.virtualKeyboardStylesheet || (eh || (eh = wn(Yd).toString(36)), this.virtualKeyboardStylesheet = Sn(null, Yd, eh)), this.coreStylesheet || (this.coreStylesheet = Sn(null, Rn, wn(Rn).toString(36))), null !== this.options.fontsDirectory && fd(this.options.fontsDirectory);
    }
    enable() {
        t() && (window.addEventListener("mouseup", this), window.addEventListener("blur", this), window.addEventListener("touchend", this), window.addEventListener("touchcancel", this));
    }
    disable() {
        t() && (window.removeEventListener("mouseup", this), window.removeEventListener("blur", this), window.removeEventListener("touchend", this), window.removeEventListener("touchcancel", this));
    }
    dispose() {}
    constructor(e1, t){
        this.originalContainerBottomPadding = null, this.options = e1, this.visible = !1, this._mathfield = t, this.coreStylesheet = null, this.virtualKeyboardStylesheet = null;
    }
}
const nh = {
    numeric: {
        tooltip: "keyboard.tooltip.numeric",
        layer: "math",
        label: "123",
        layers: [
            "math"
        ]
    },
    roman: {
        tooltip: "keyboard.tooltip.roman",
        layer: "lower-roman",
        label: "ABC",
        layers: [
            "lower-roman",
            "upper-roman"
        ]
    },
    greek: {
        tooltip: "keyboard.tooltip.greek",
        layer: "lower-greek",
        label: "&alpha;&beta;&gamma;",
        classes: "tex-math",
        layers: [
            "lower-greek",
            "upper-greek"
        ]
    },
    functions: {
        tooltip: "keyboard.tooltip.functions",
        layer: "functions",
        label: "<i>f</i>&thinsp;()",
        classes: "tex",
        layers: [
            "functions"
        ]
    },
    symbols: {
        tooltip: "keyboard.tooltip.symbols",
        layer: "symbols",
        label: "&infin;≠∈",
        classes: "tex",
        layers: [
            "symbols"
        ]
    },
    latex: {
        tooltip: "keyboard.tooltip.command",
        command: [
            "switchMode",
            "latex"
        ],
        label: "<svg class=\"svg-glyph\"><use xlink:href='#svg-command' /></svg>",
        layers: [
            "latex-lower",
            "latex-upper",
            "latex-symbols"
        ]
    },
    style: {
        tooltip: "keyboard.tooltip.style",
        layer: "style",
        label: "<b>b</b><i>i</i>\uD835\uDD39"
    }
}, rh = {
    "\\varphi ": [
        "&Phi;",
        "\\Phi "
    ],
    "\\varsigma ": [
        "&Sigma;",
        "\\Sigma "
    ],
    "\\epsilon ": [
        "&#x0190;",
        '\\char"0190'
    ],
    "\\rho ": [
        "&#x3A1",
        '\\char"3A1'
    ],
    "\\tau ": [
        "&#x3A4;",
        '\\char"3A4'
    ],
    "\\upsilon ": [
        "&Upsilon;",
        "\\Upsilon "
    ],
    "\\theta ": [
        "&Theta;",
        "\\Theta "
    ],
    "\\iota ": [
        "&Iota;",
        '\\char"399'
    ],
    "\\omicron ": [
        "&#x039F;",
        '\\char"39F'
    ],
    "\\pi ": [
        "&Pi;",
        "\\Pi "
    ],
    "\\alpha ": [
        "&Alpha;",
        '\\char"391'
    ],
    "\\sigma ": [
        "&Sigma;",
        "\\Sigma "
    ],
    "\\delta ": [
        "&Delta;",
        "\\Delta "
    ],
    "\\phi ": [
        "&#x03a6;",
        "\\Phi "
    ],
    "\\gamma ": [
        "&Gamma;",
        "\\Gamma "
    ],
    "\\eta ": [
        "&Eta;",
        '\\char"397'
    ],
    "\\xi ": [
        "&Xi;",
        "\\Xi "
    ],
    "\\kappa ": [
        "&Kappa;",
        '\\char"39A'
    ],
    "\\lambda ": [
        "&Lambda;",
        "\\Lambda "
    ],
    "\\zeta ": [
        "&Zeta;",
        '\\char"396'
    ],
    "\\chi ": [
        "&Chi;",
        '\\char"3A7'
    ],
    "\\psi ": [
        "&Psi;",
        "\\Psi "
    ],
    "\\omega ": [
        "&Omega;",
        "\\Omega "
    ],
    "\\beta ": [
        "&Beta;",
        '\\char"392'
    ],
    "\\nu ": [
        "&Nu;",
        '\\char"39D'
    ],
    "\\mu ": [
        "&Mu;",
        '\\char"39C'
    ]
}, oh = {
    0: [
        "\\emptyset",
        "\\varnothing",
        "\\infty",
        {
            latex: "#?_0",
            insert: "#@_0"
        },
        "\\circ",
        "\\bigcirc",
        "\\bullet"
    ],
    2: [
        "\\frac{1}{2}",
        {
            latex: "#?^2",
            insert: "#@^2"
        }
    ],
    3: [
        "\\frac{1}{3}",
        {
            latex: "#?^3",
            insert: "#@^3"
        }
    ],
    ".": [
        ".",
        ",",
        ";",
        "\\colon",
        {
            latex: ":",
            aside: "ratio"
        },
        {
            latex: "\\cdotp",
            aside: "center dot",
            class: "box"
        },
        {
            latex: "\\cdots",
            aside: "center ellipsis",
            class: "box"
        },
        {
            latex: "\\ldotp",
            aside: "low dot",
            class: "box"
        },
        {
            latex: "\\ldots",
            aside: "low ellipsis",
            class: "box"
        },
        {
            latex: "\\vdots",
            aside: "",
            class: "box"
        },
        {
            latex: "\\ddots",
            aside: "",
            class: "box"
        },
        "\\odot",
        "\\oslash",
        "\\circledcirc"
    ],
    "*": [
        "\\cdot",
        "\\ast",
        "\\star",
        "\\bigstar",
        "\\ltimes",
        "\\rtimes",
        "\\rightthreetimes",
        "\\leftthreetimes",
        "\\intercal",
        "\\prod",
        {
            latex: "\\prod_{n\\mathop=0}^{\\infty}",
            class: "small"
        }
    ],
    "+": [
        "\\pm",
        "\\mp",
        "\\sum",
        {
            latex: "\\sum_{n\\mathop=0}^{\\infty}",
            class: "small"
        },
        "\\dotplus",
        "\\oplus"
    ],
    "-": [
        "\\pm",
        "\\mp",
        "\\ominus",
        "\\vert #0  \\vert"
    ],
    "/": [
        "\\divideontimes",
        "/",
        "\\div",
        "\\%"
    ],
    "(": [
        "\\left( #0\\right)",
        "\\left[ #0\\right]",
        "\\left\\{ #0\\right\\}",
        "\\left\\langle #0\\right\\rangle",
        "\\lfloor",
        "\\llcorner",
        "(",
        "\\lbrack",
        "\\lvert",
        "\\lVert",
        "\\lgroup",
        "\\langle",
        "\\lceil",
        "\\ulcorner",
        "\\lmoustache",
        "\\lbrace"
    ],
    ")": [
        "\\rfloor",
        "\\lrcorner",
        ")",
        "\\rbrack",
        "\\rvert",
        "\\rVert",
        "\\rgroup",
        "\\rangle",
        "\\rceil",
        "\\urcorner",
        "\\rmoustache",
        "\\rbrace"
    ],
    "=": [
        "\\cong",
        "\\asymp",
        "\\equiv",
        "\\differencedelta",
        "\\varpropto",
        "\\thickapprox",
        "\\approxeq",
        "\\thicksim",
        "\\backsim",
        "\\eqsim",
        "\\simeq",
        "\\Bumpeq",
        "\\bumpeq",
        "\\doteq",
        "\\Doteq",
        "\\fallingdotseq",
        "\\risingdotseq",
        "\\coloneq",
        "\\eqcirc",
        "\\circeq",
        "\\triangleq",
        "\\between"
    ],
    "!=": [
        "\\neq",
        "\\ncong",
        "",
        "\\nsim"
    ],
    "<": [
        "\\leq",
        "\\leqq",
        "\\lneqq",
        "\\ll",
        "\\lessgtr",
        "\\nless",
        "\\nleq",
        "\\lesssim",
        "\\precsim",
        "\\prec",
        "\\nprec",
        "\\preccurlyeq",
        "\\lessdot"
    ],
    ">": [
        "\\geq",
        "\\geqq",
        "\\gneqq",
        "\\gg",
        "\\gtrless",
        "\\ngtr",
        "\\ngeq",
        "\\gtrsim",
        "\\succsim",
        "\\succ",
        "\\nsucc",
        "\\succcurlyeq",
        "\\gtrdot"
    ],
    in: [
        "\\owns"
    ],
    "!in": [
        "\\backepsilon"
    ],
    subset: [
        "\\subseteq",
        "\\nsubset",
        "\\nsubseteq"
    ],
    superset: [
        "\\supseteq",
        "\\nsupset",
        "\\nsupseteq"
    ],
    infinity: [
        "\\aleph_0",
        "\\aleph_1",
        "\\omega",
        "\\mathfrak{m}"
    ],
    "numeric-pi": [
        "\\prod",
        "\\theta",
        "\\rho",
        "\\sin",
        "\\cos",
        "\\tan"
    ],
    ee: [
        "\\times 10^{#?}",
        "\\ln",
        "\\ln_{10}",
        "\\log"
    ],
    "^": [
        "_{#?}"
    ],
    int: [
        {
            latex: "\\int_{#?}^{#?}",
            class: "small"
        },
        {
            latex: "\\int",
            class: "small"
        },
        {
            latex: "\\smallint",
            class: "small"
        },
        {
            latex: "\\iint",
            class: "small"
        },
        {
            latex: "\\iiint",
            class: "small"
        },
        {
            latex: "\\oint",
            class: "small"
        },
        {
            latex: "\\dfrac{\\rd}{\\rd x}",
            class: "small"
        },
        {
            latex: "\\frac{\\partial}{\\partial x}",
            class: "small"
        },
        "\\capitalDifferentialD",
        "\\rd",
        "\\partial"
    ],
    nabla: [
        "\\nabla\\times",
        "\\nabla\\cdot",
        "\\nabla^{2}"
    ],
    "!": [
        "!!",
        "\\Gamma",
        "\\Pi"
    ],
    accents: [
        "\\bar{#@}",
        "\\vec{#@}",
        "\\hat{#@}",
        "\\check{#@}",
        "\\dot{#@}",
        "\\ddot{#@}",
        "\\mathring{#@}",
        "\\breve{#@}",
        "\\acute{#@}",
        "\\tilde{#@}",
        "\\grave{#@}"
    ],
    underline: [
        "\\underbrace{#@}",
        "\\underlinesegment{#@}",
        "\\underleftrightarrow{#@}",
        "\\underrightarrow{#@}",
        "\\underleftarrow{#@}",
        "\\undergroup{#@}"
    ],
    overline: [
        "\\overbrace{#@}",
        "\\overlinesegment{#@}",
        "\\overleftrightarrow{#@}",
        "\\overrightarrow{#@}",
        "\\overleftarrow{#@}",
        "\\overgroup{#@}"
    ],
    xleftarrows: [
        "\\xlongequal{}",
        "\\xleftrightarrow{}",
        "\\xLeftrightarrow{}",
        "\\xleftrightharpoons{}",
        "\\xLeftarrow{}",
        "\\xleftharpoonup{}",
        "\\xleftharpoondown{}",
        "\\xtwoheadleftarrow{}",
        "\\xhookleftarrow{}",
        "\\xtofrom{}",
        "\\xleftequilibrium{}",
        "\\xrightleftarrows{}"
    ],
    xrightarrows: [
        "\\xlongequal{}",
        "\\xleftrightarrow{}",
        "\\xLeftrightarrow{}",
        "\\xleftrightharpoons{}",
        "\\xRightarrow{}",
        "\\xrightharpoonup{}",
        "\\xrightharpoondown{}",
        "\\xtwoheadrightarrow{}",
        "\\xrightleftharpoons{}",
        "\\xhookrightarrow{}",
        "\\xmapsto{}",
        "\\xrightequilibrium{}",
        "\\xrightleftarrows{}"
    ],
    A: [
        {
            latex: "\\aleph",
            aside: "aleph"
        },
        {
            latex: "\\forall",
            aside: "for all"
        }
    ],
    a: [
        {
            latex: "\\aleph",
            aside: "aleph"
        },
        {
            latex: "\\forall",
            aside: "for all"
        }
    ],
    b: [
        {
            latex: "\\beth",
            aside: "beth"
        }
    ],
    B: [
        {
            latex: "\\beth",
            aside: "beth"
        }
    ],
    c: [
        {
            latex: "\\C",
            aside: "set of complex numbers"
        }
    ],
    d: [
        {
            latex: "\\daleth",
            aside: "daleth"
        }
    ],
    D: [
        {
            latex: "\\daleth",
            aside: "daleth"
        }
    ],
    e: [
        {
            latex: "\\exponentialE",
            aside: "exponential e"
        },
        {
            latex: "\\exists",
            aside: "there is"
        },
        {
            latex: "\\nexists",
            aside: "there isn’t"
        }
    ],
    g: [
        {
            latex: "\\gimel",
            aside: "gimel"
        }
    ],
    G: [
        {
            latex: "\\gimel",
            aside: "gimel"
        }
    ],
    h: [
        {
            latex: "\\hbar",
            aside: "h bar"
        },
        {
            latex: "\\hslash",
            aside: "h slash"
        }
    ],
    i: [
        {
            latex: "\\imaginaryI",
            aside: "imaginary i"
        }
    ],
    j: [
        {
            latex: "\\imaginaryJ",
            aside: "imaginary j"
        }
    ],
    l: [
        {
            latex: "\\ell",
            aside: "ell"
        }
    ],
    n: [
        {
            latex: "\\mathbb{N}",
            aside: "set of natural numbers"
        }
    ],
    p: [
        {
            latex: "\\mathbb{P}",
            aside: "set of primes"
        }
    ],
    q: [
        {
            latex: "\\mathbb{Q}",
            aside: "set of rational numbers"
        }
    ],
    r: [
        {
            latex: "\\mathbb{R}",
            aside: "set of real numbers"
        }
    ],
    z: [
        {
            latex: "\\mathbb{Z}",
            aside: "set of integers"
        }
    ],
    "x-var": [
        "y",
        "z",
        "t",
        "r",
        {
            latex: "f(#?)",
            class: "small"
        },
        {
            latex: "g(#?)",
            class: "small"
        },
        "x^2",
        "x^n",
        "x_n",
        "x_{n+1}",
        "x_i",
        "x_{i+1}"
    ],
    "n-var": [
        "i",
        "j",
        "p",
        "k",
        "a",
        "u"
    ],
    ii: [
        "\\Re",
        "\\Im",
        "\\imaginaryJ",
        "\\Vert #0 \\Vert"
    ],
    logic: [
        {
            latex: "\\exists",
            aside: "there is"
        },
        {
            latex: "\\nexists",
            aside: "there isn’t"
        },
        {
            latex: "\\ni",
            aside: "such that"
        },
        {
            latex: "\\Colon",
            aside: "such that"
        },
        {
            latex: "\\implies",
            aside: "implies"
        },
        {
            latex: "\\impliedby",
            aside: "implied by"
        },
        {
            latex: "\\iff",
            aside: "if and only if"
        },
        {
            latex: "\\land",
            aside: "and"
        },
        {
            latex: "\\lor",
            aside: "or"
        },
        {
            latex: "\\oplus",
            aside: "xor"
        },
        {
            latex: "\\lnot",
            aside: "not"
        },
        {
            latex: "\\downarrow",
            aside: "nor"
        },
        {
            latex: "\\uparrow",
            aside: "nand"
        },
        {
            latex: "\\curlywedge",
            aside: "nor"
        },
        {
            latex: "\\bar\\curlywedge",
            aside: "nand"
        },
        {
            latex: "\\therefore",
            aside: "therefore"
        },
        {
            latex: "\\because",
            aside: "because"
        },
        {
            latex: "^\\biconditional",
            aside: "biconditional"
        },
        "\\leftrightarrow",
        "\\Leftrightarrow",
        "\\to",
        "\\models",
        "\\vdash",
        "\\gets",
        "\\dashv",
        "\\roundimplies"
    ],
    "set-operators": [
        "\\cap",
        "\\cup",
        "\\setminus",
        "\\smallsetminus",
        "\\complement"
    ],
    "set-relations": [
        "\\in",
        "\\notin",
        "\\ni",
        "\\owns",
        "\\subset",
        "\\supset",
        "\\subseteq",
        "\\supseteq",
        "\\subsetneq",
        "\\supsetneq",
        "\\varsubsetneq",
        "\\subsetneqq",
        "\\nsubset",
        "\\nsupset",
        "\\nsubseteq",
        "\\nsupseteq"
    ],
    space: [
        {
            latex: '\\char"203A\\!\\char"2039',
            insert: "\\!",
            aside: "negative thin space<br>⁻\xb3⧸₁₈ em"
        },
        {
            latex: '\\unicode{"203A}\\,\\unicode{"2039}',
            insert: "\\,",
            aside: "thin space<br>\xb3⧸₁₈ em"
        },
        {
            latex: '\\unicode{"203A}\\:\\unicode{"2039}',
            insert: "\\:",
            aside: "medium space<br>⁴⧸₁₈ em"
        },
        {
            latex: '\\unicode{"203A}\\;\\unicode{"2039}',
            insert: "\\;",
            aside: "thick space<br>⁵⧸₁₈ em"
        },
        {
            latex: '\\unicode{"203A}\\ \\unicode{"2039}',
            insert: "\\ ",
            aside: "⅓ em"
        },
        {
            latex: '\\unicode{"203A}\\enspace\\unicode{"2039}',
            insert: "\\enspace",
            aside: "\xbd em"
        },
        {
            latex: '\\unicode{"203A}\\quad\\unicode{"2039}',
            insert: "\\quad",
            aside: "1 em"
        },
        {
            latex: '\\unicode{"203A}\\qquad\\unicode{"2039}',
            insert: "\\qquad",
            aside: "2 em"
        }
    ],
    delete: [
        {
            label: '<span class="warning"><svg class="svg-glyph"><use xlink:href="#svg-trash" /></svg></span>',
            command: "deleteAll"
        }
    ],
    "->|": []
};
let ah = {};
const sh = {
    math: "\n        <div class='rows'>\n            <ul>\n                <li class='keycap tex' data-alt-keys='x-var'><i>x</i></li>\n                <li class='keycap tex' data-alt-keys='n-var'><i>n</i></li>\n                <li class='separator w5'></li>\n                <row name='numpad-1'/>\n                <li class='separator w5'></li>\n                <li class='keycap tex' data-latex='\\exponentialE' data-alt-keys='ee'>e</li>\n                <li class='keycap tex' data-latex='\\imaginaryI' data-alt-keys='ii'>i</li>\n                <li class='keycap tex' data-latex='\\pi' data-alt-keys='numeric-pi'></li>\n            </ul>\n            <ul>\n                <li class='keycap tex' data-key='<' data-alt-keys='<'>&lt;</li>\n                <li class='keycap tex' data-key='>' data-alt-keys='>'>&gt;</li>\n                <li class='separator w5'></li>\n                <row name='numpad-2'/>\n                <li class='separator w5'></li>\n                <li class='keycap tex' data-latex='#@^{2}' data-latex='x^2'></li>\n                <li class='keycap tex' data-alt-keys='^' data-insert='#@^{#?}' data-latex='x^\\placeholder'></li>\n                <li class='keycap tex small' data-insert='\\sqrt{#0}' data-latex='\\sqrt{#0}'></li>\n            </ul>\n            <ul>\n                <li class='keycap tex' data-alt-keys='(' >(</li>\n                <li class='keycap tex' data-alt-keys=')' >)</li>\n                <li class='separator w5'></li>\n                <row name='numpad-3'/>\n                <li class='separator w5'></li>\n                <li class='keycap small' data-alt-keys='int' data-latex='\\int_0^\\infty'></li>\n                <li class='keycap' data-latex='\\forall' data-alt-keys='logic' ></li>\n                <li class='action font-glyph bottom right' data-alt-keys='delete' data-command='[\"performWithFeedback\",\"deleteBackward\"]'><svg class=\"svg-glyph\"><use xlink:href=\"#svg-delete-backward\" /></svg></li></ul>\n            </ul>\n            <ul>\n                <li class='keycap' data-alt-keys='foreground-color' data-command='[\"applyStyle\",{\"color\":\"red\"}]'><span style='border-radius: 50%;width:22px;height:22px; border: 3px solid #cc2428; box-sizing: border-box'></span></li>\n                <li class='keycap' data-alt-keys='background-color' data-command='[\"applyStyle\",{\"backgroundColor\":\"yellow\"}]'><span style='border-radius: 50%;width:22px;height:22px; background:#fff590; box-sizing: border-box'></span></li>\n                <li class='separator w5'></li>\n                <row name='numpad-4'/>\n                <li class='separator w5'></li>\n                <arrows/>\n            </ul>\n        </div>\n    ",
    "lower-roman": "\n        <div class='rows'>\n            <ul>\n                <row name='numpad-1' class='if-wide'/>\n                <row name='lower-1' shift-layer='upper-roman'/>\n            </ul>\n            <ul>\n                <row name='numpad-2' class='if-wide'/>\n                <row name='lower-2'  shift-layer='upper-roman''/>\n            </ul>\n            <ul>\n                <row name='numpad-3' class='if-wide'/>\n                <row name='lower-3'  shift-layer='upper-roman''/>\n            </ul>\n            <ul>\n                <row name='numpad-4' class='if-wide'/>\n                <li class='keycap' >;</li>\n                <li class='keycap' >,</li>\n                <li class='keycap w50' data-key=' ' data-alt-keys='space'>&nbsp;</li>\n                <arrows/>\n            </ul>\n        </div>",
    "upper-roman": "\n        <div class='rows'>\n            <ul>\n                <row name='numpad-1' class='if-wide'/>\n                <row name='upper-1'  shift-layer='lower-roman'/>\n            </ul>\n            <ul>\n                <row name='numpad-2' class='if-wide'/>\n                <row name='upper-2' shift-layer='lower-roman'/>\n            </ul>\n            <ul>\n                <row name='numpad-3' class='if-wide'/>\n                <row name='upper-3' shift-layer='lower-roman'/>\n            </ul>\n            <ul>\n                <row name='numpad-4' class='if-wide'/>\n                <li class='keycap' >;</li>\n                <li class='keycap' data-alt-keys='.'>;</li>\n                <li class='keycap w50' data-key=' '>&nbsp;</li>\n                <arrows/>\n            </ul>\n        </div>",
    symbols: "\n        <div class='rows'>\n            <ul>\n                <row name='numpad-1' class='if-wide'/>\n                <li class='keycap tex' data-alt-keys='(' data-insert='\\lbrace '>{</li>\n                <li class='keycap tex' data-alt-keys=')' data-insert='\\rbrace '>}</li>\n                <li class='separator w5'></li>\n                <li class='keycap tex' data-alt-keys='in' data-insert='\\in '>&#x2208;</li>\n                <li class='keycap tex' data-alt-keys='!in' data-insert='\\notin '>&#x2209;</li>\n                <li class='keycap tex' data-insert='\\Re '>&#x211c;<aside>Real</aside></li>\n                <li class='keycap tex' data-insert='\\Im '>&#x2111;<aside>Imaginary</aside></li>\n                <li class='keycap w15' data-insert='\\ulcorner#0\\urcorner '><span><sup>&#x250c;</sup><span><span style='color:#ddd'>o</span><sup>&#x2510;</sup></span><aside>ceil</aside></li>\n                <li class='keycap tex' data-alt-keys='nabla' data-insert='\\nabla '>&#x2207;<aside>nabla</aside></li>\n                <li class='keycap tex' data-alt-keys='infinity' data-insert='\\infty '>&#x221e;</li>\n\n            </ul>\n            <ul>\n                <row name='numpad-2' class='if-wide'/>\n                <li class='keycap tex' data-alt-keys='(' data-insert='\\lbrack '>[</li>\n                <li class='keycap tex' data-alt-keys=')' data-insert='\\rbrack '>]</li>\n                <li class='separator w5'></li>\n                <li class='keycap tex' data-alt-keys='subset' data-insert='\\subset '>&#x2282;</li>\n                <li class='keycap tex' data-alt-keys='superset' data-insert='\\supset '>&#x2283;</li>\n                <li class='keycap tex' data-key='!' data-alt-keys='!'>!<aside>factorial</aside></li>\n                <li class='keycap' data-latex='^{\\prime} '><span><sup><span><span style='color:#ddd'>o</span>&#x2032</sup></span><aside>prime</aside></li>\n                <li class='keycap w15' data-insert='\\llcorner#0\\lrcorner '><span><sub>&#x2514;</sub><span style='color:#ddd'>o</span><sub>&#x2518;</sub></span><aside>floor</aside></li>\n                <li class='keycap tex' data-insert='\\partial '>&#x2202;<aside>partial<br>derivative</aside></li>\n                <li class='keycap tex' data-insert='\\emptyset '>&#x2205;<aside>empty set</aside></li>\n\n            </ul>\n            <ul>\n                <row name='numpad-3' class='if-wide'/>\n                <li class='keycap tex' data-alt-keys='(' data-insert='\\langle '>&#x27e8;</li>\n                <li class='keycap tex' data-alt-keys=')' data-insert='\\rangle '>&#x27e9;</li>\n                <li class='separator w5'></li>\n                <li class='keycap tex' data-alt-keys='overline' data-latex='\\overline{#@}' data-aside='overline'></li>\n                <li class='keycap tex' data-alt-keys='underline' data-latex='\\underline{#@}' data-aside='underline'></li>\n                <li class='keycap tex' data-alt-keys='accents' data-insert='\\vec{#@}' data-latex='\\vec{#?}' data-aside='vector'></li>\n                <li class='keycap tex small' data-alt-keys='xleftarrows' data-latex='\\xleftarrow{}' ></li>\n                <li class='keycap tex small' data-alt-keys='xrightarrows' data-latex='\\xrightarrow{}' ></li>\n                <li class='keycap tex' data-alt-keys='absnorm' data-insert='\\left| #0 \\right|' data-latex='\\left| #? \\right|' data-aside='abs'></li>\n\n                <li class='action font-glyph bottom right w15'\n                    data-shifted='<span class=\"warning\"><svg class=\"svg-glyph\"><use xlink:href=\"#svg-trash\" /></svg></span>'\n                    data-shifted-command='\"deleteAll\"'\n                    data-alt-keys='delete' data-command='[\"performWithFeedback\",\"deleteBackward\"]'\n                ><svg class=\"svg-glyph\"><use xlink:href=\"#svg-delete-backward\" /></svg></li>\n            </ul>\n            <ul>\n                <row name='numpad-4' class='if-wide'/>\n                <li class='keycap tex' data-insert=','>,</li>\n                <li class='keycap tex' data-insert='\\cdot '>&#x22c5;<aside>centered dot</aside></li>\n                <li class='keycap tex' data-insert='\\colon '>:<aside>colon</aside></li>\n                <li class='keycap tex' data-insert='\\circ '>&#x2218;<aside>circle</aside></li>\n                <li class='keycap tex' data-insert='\\approx '>&#x2248;<aside>approx.</aside></li>\n                <li class='keycap tex' data-insert='\\ne '>&#x2260;</li>\n                <li class='keycap tex' data-insert='\\pm '>&#x00b1;</li>\n                <arrows/>\n            </ul>\n        </div>",
    "lower-greek": "\n        <div class='rows'>\n            <ul><li class='keycap tex' data-insert='\\varphi '><i>&#x03c6;</i><aside>phi var.</aside></li>\n                <li class='keycap tex' data-insert='\\varsigma '><i>&#x03c2;</i><aside>sigma var.</aside></li>\n                <li class='keycap tex' data-insert='\\epsilon '><i>&#x03f5;</i></li>\n                <li class='keycap tex' data-insert='\\rho '><i>&rho;</i></li>\n                <li class='keycap tex' data-insert='\\tau '><i>&tau;</i></li>\n                <li class='keycap tex' data-insert='\\upsilon '><i>&upsilon;</i></li>\n                <li class='keycap tex' data-insert='\\theta '><i>&theta;</i></li>\n                <li class='keycap tex' data-insert='\\iota '><i>&iota;</i></li>\n                <li class='keycap tex' data-insert='\\omicron '>&omicron;</i></li>\n                <li class='keycap tex' data-insert='\\pi '><i>&pi;</i></li>\n            </ul>\n            <ul><li class='keycap tex' data-insert='\\alpha ' data-shifted='&Alpha;' data-shifted-command='[\"insert\",\"\\\\char\\\"391\"]'><i>&alpha;</i></li>\n                <li class='keycap tex' data-insert='\\sigma '><i>&sigma;</i></li>\n                <li class='keycap tex' data-insert='\\delta '><i>&delta;</i></li>\n                <li class='keycap tex' data-insert='\\phi '><i>&#x03d5;</i></i></li>\n                <li class='keycap tex' data-insert='\\gamma '><i>&gamma;</i></li>\n                <li class='keycap tex' data-insert='\\eta '><i>&eta;</i></li>\n                <li class='keycap tex' data-insert='\\xi '><i>&xi;</i></li>\n                <li class='keycap tex' data-insert='\\kappa '><i>&kappa;</i></li>\n                <li class='keycap tex' data-insert='\\lambda '><i>&lambda;</i></li>\n            </ul>\n            <ul><li class='shift modifier font-glyph bottom left w15 layer-switch' data-layer='upper-greek'><svg class=\"svg-glyph\"><use xlink:href=\"#svg-shift\" /></svg></li>\n                <li class='keycap tex' data-insert='\\zeta '><i>&zeta;</i></li>\n                <li class='keycap tex' data-insert='\\chi '><i>&chi;</i></li>\n                <li class='keycap tex' data-insert='\\psi '><i>&psi;</i></li>\n                <li class='keycap tex' data-insert='\\omega '><i>&omega;</i></li>\n                <li class='keycap tex' data-insert='\\beta '><i>&beta;</i></li>\n                <li class='keycap tex' data-insert='\\nu '><i>&nu;</i></li>\n                <li class='keycap tex' data-insert='\\mu '><i>&mu;</i></li>\n                <li class='action font-glyph bottom right w15'\n                    data-shifted='<span class=\"warning\"><svg class=\"svg-glyph\"><use xlink:href=\"#svg-trash\" /></svg></span>'\n                    data-shifted-command='\"deleteAll\"'\n                    data-alt-keys='delete' data-command='[\"performWithFeedback\",\"deleteBackward\"]'\n                ><svg class=\"svg-glyph\"><use xlink:href=\"#svg-delete-backward\" /></svg></li>\n            </ul>\n            <ul>\n                <li class='keycap ' data-key=' '>&nbsp;</li>\n                <li class='keycap'>,</li>\n                <li class='keycap tex' data-insert='\\varepsilon '><i>&#x03b5;</i><aside>epsilon var.</aside></li>\n                <li class='keycap tex' data-insert='\\vartheta '><i>&#x03d1;</i><aside>theta var.</aside></li>\n                <li class='keycap tex' data-insert='\\varkappa '><i>&#x3f0;</i><aside>kappa var.</aside></li>\n                <li class='keycap tex' data-insert='\\varpi '><i>&#x03d6;<aside>pi var.</aside></i></li>\n                <li class='keycap tex' data-insert='\\varrho '><i>&#x03f1;</i><aside>rho var.</aside></li>\n                <arrows/>\n            </ul>\n        </div>",
    "upper-greek": "\n        <div class='rows'>\n            <ul><li class='keycap tex' data-insert='\\Phi '>&Phi;<aside>phi</aside></li>\n                <li class='keycap tex' data-insert='\\Sigma '>&Sigma;<aside>sigma</aside></li>\n                <li class='keycap tex' data-insert='\\char\"0190'>&#x0190;<aside>epsilon</aside></li>\n                <li class='keycap tex' data-insert='\\char\"3A1'>&#x3A1;<aside>rho</aside></li>\n                <li class='keycap tex' data-insert='\\char\"3A4'>&#x3A4;<aside>tau</aside></li>\n                <li class='keycap tex' data-insert='\\Upsilon '>&Upsilon;<aside>upsilon</aside></li>\n                <li class='keycap tex' data-insert='\\Theta '>&Theta;<aside>theta</aside></li>\n                <li class='keycap tex' data-insert='\\char\"399'>&Iota;<aside>iota</aside></li>\n                <li class='keycap tex' data-insert='\\char\"39F'>&#x039F;<aside>omicron</aside></li>\n                <li class='keycap tex' data-insert='\\Pi '>&Pi;<aside>pi</aside></li></ul>\n            <ul><li class='keycap tex' data-insert='\\char\"391'>&#x391;<aside>alpha</aside></li>\n                <li class='keycap tex' data-insert='\\Sigma '>&Sigma;<aside>sigma</aside></li>\n                <li class='keycap tex' data-insert='\\Delta '>&Delta;<aside>delta</aside></li>\n                <li class='keycap tex' data-insert='\\Phi '>&#x03a6;<aside>phi</aside></li>\n                <li class='keycap tex' data-insert='\\Gamma '>&Gamma;<aside>gamma</aside></li>\n                <li class='keycap tex' data-insert='\\char\"397'>&Eta;<aside>eta</aside></li>\n                <li class='keycap tex' data-insert='\\Xi '>&Xi;<aside>xi</aside></li>\n                <li class='keycap tex' data-insert='\\char\"39A'>&Kappa;<aside>kappa</aside></li>\n                <li class='keycap tex' data-insert='\\Lambda '>&Lambda;<aside>lambda</aside></li></ul>\n            <ul><li class='shift modifier font-glyph bottom left selected w15 layer-switch' data-layer='lower-greek'><svg class=\"svg-glyph\"><use xlink:href=\"#svg-shift\" /></svg></li>\n                <li class='keycap tex' data-insert='\\char\"396'>&Zeta;<aside>zeta</aside></li>\n                <li class='keycap tex' data-insert='\\char\"3A7'>&Chi;<aside>chi</aside></li>\n                <li class='keycap tex' data-insert='\\Psi '>&Psi;<aside>psi</aside></li>\n                <li class='keycap tex' data-insert='\\Omega '>&Omega;<aside>omega</aside></li>\n                <li class='keycap tex' data-insert='\\char\"392'>&Beta;<aside>beta</aside></li>\n                <li class='keycap tex' data-insert='\\char\"39D'>&Nu;<aside>nu</aside></li>\n                <li class='keycap tex' data-insert='\\char\"39C'>&Mu;<aside>mu</aside></li>\n                <li class='action font-glyph bottom right w15' data-command='[\"performWithFeedback\",\"deleteBackward\"]'><svg class=\"svg-glyph\"><use xlink:href=\"#svg-delete-backward\" /></svg></li></ul>\n            <ul>\n                <li class='separator w10'>&nbsp;</li>\n                <li class='keycap'>.</li>\n                <li class='keycap w50' data-key=' '>&nbsp;</li>\n                <arrows/>\n            </ul>\n        </div>",
    "latex-lower": "\n        <div class='rows'>\n            <ul><row name='lower-1' class='tt' shift-layer='latex-upper'/></ul>\n            <ul><row name='lower-2' class='tt' shift-layer='latex-upper'/></ul>\n            <ul><row name='lower-3' class='tt' shift-layer='latex-upper'/></ul>\n            <ul>\n                <li class='layer-switch font-glyph modifier bottom left' data-layer='latex-symbols'>01#</li>\n                <li class='keycap tt' data-shifted='[' data-shifted-command='[\"insertAndUnshiftKeyboardLayer\", \"[\"]'>{</li>\n                <li class='keycap tt' data-shifted=']' data-shifted-command='[\"insertAndUnshiftKeyboardLayer\", \"]\"]'>}</li>\n                <li class='keycap tt' data-shifted='(' data-shifted-command='[\"insertAndUnshiftKeyboardLayer\", \"(\"]'>^</li>\n                <li class='keycap tt' data-shifted=')' data-shifted-command='[\"insertAndUnshiftKeyboardLayer\", \")\"]'>_</li>\n                <li class='keycap w20' data-key=' '>&nbsp;</li>\n                <arrows/>\n            </ul>\n        </div>",
    "latex-upper": "\n        <div class='rows'>\n            <ul><row name='upper-1' class='tt' shift-layer='latex-lower'/></ul>\n            <ul><row name='upper-2' class='tt' shift-layer='latex-lower'/></ul>\n            <ul><row name='upper-3' class='tt' shift-layer='latex-lower'/></ul>\n            <ul>\n                <li class='layer-switch font-glyph modifier bottom left' data-layer='latex-symbols'01#</li>\n                <li class='keycap tt'>[</li>\n                <li class='keycap tt'>]</li>\n                <li class='keycap tt'>(</li>\n                <li class='keycap tt'>)</li>\n                <li class='keycap w20' data-key=' '>&nbsp;</li>\n                <arrows/>\n            </ul>\n        </div>",
    "latex-symbols": "\n        <div class='rows'>\n            <ul><li class='keycap tt'>1</li><li class='keycap tt'>2</li><li class='keycap tt'>3</li><li class='keycap tt'>4</li><li class='keycap tt'>5</li><li class='keycap tt'>6</li><li class='keycap tt'>7</li><li class='keycap tt'>8</li><li class='keycap tt'>9</li><li class='keycap tt'>0</li></ul>\n            <ul><li class='keycap tt'>!</li><li class='keycap tt'>@</li><li class='keycap tt'>#</li><li class='keycap tt'>$</li><li class='keycap tt'>%</li><li class='keycap tt'>^</li><li class='keycap tt'>&</li><li class='keycap tt'>*</li><li class='keycap tt'>+</li><li class='keycap tt'>=</li></ul>\n            <ul>\n                <li class='keycap tt'>\\</li>\n                <li class='keycap tt'>|</li>\n                <li class='keycap tt'>/</li>\n                <li class='keycap tt'>`</li>\n                <li class='keycap tt'>;</li>\n                <li class='keycap tt'>:</li>\n                <li class='keycap tt'>?</li>\n                <li class='keycap tt'>'</li>\n                <li class='keycap tt'>\"</li>\n                <li class='action font-glyph bottom right'\n                    data-shifted='<span class=\"warning\"><svg class=\"svg-glyph\"><use xlink:href=\"#svg-trash\" /></svg></span>'\n                    data-shifted-command='\"deleteAll\"'\n                    data-alt-keys='delete' data-command='[\"performWithFeedback\",\"deleteBackward\"]'\n                ><svg class=\"svg-glyph\"><use xlink:href=\"#svg-delete-backward\" /></svg></li>\n            </ul>\n            <ul>\n                <li class='layer-switch font-glyph modifier bottom left' data-layer='latex-lower'>abc</li>\n                <li class='keycap tt'>&lt;</li>\n                <li class='keycap tt'>&gt;</li>\n                <li class='keycap tt'>~</li>\n                <li class='keycap tt'>,</li>\n                <li class='keycap tt'>.</li>\n                <li class='keycap' data-key=' '>&nbsp;</li>\n                <arrows/>\n            </ul>\n        </div>",
    functions: "\n        <div class='rows'>\n            <ul><li class='separator'></li>\n                <li class='fnbutton' data-insert='\\sin'></li>\n                <li class='fnbutton' data-insert='\\sin^{-1}'></li>\n                <li class='fnbutton' data-insert='\\ln'></li>\n                <li class='fnbutton' data-insert='\\exponentialE^{#?}'></li>\n                <li class='bigfnbutton' data-insert='\\operatorname{lcm}(#?)' data-latex='\\operatorname{lcm}()'></li>\n                <li class='bigfnbutton' data-insert='\\operatorname{ceil}(#?)' data-latex='\\operatorname{ceil}()'></li>\n                <li class='bigfnbutton' data-insert='\\lim_{n\\to\\infty}'></li>\n                <li class='bigfnbutton' data-insert='\\int'></li>\n                <li class='bigfnbutton' data-insert='\\operatorname{abs}(#?)' data-latex='\\operatorname{abs}()'></li>\n            </ul>\n            <ul><li class='separator'></li>\n                <li class='fnbutton' data-latex='\\cos'></li>\n                <li class='fnbutton' data-latex='\\cos^{-1}'></li>\n                <li class='fnbutton' data-latex='\\ln_{10}'></li>\n                <li class='fnbutton' data-latex='10^{#?}'></li>\n                <li class='bigfnbutton' data-latex='\\operatorname{gcd}(#?)' data-latex='\\operatorname{gcd}()'></li>\n                <li class='bigfnbutton' data-latex='\\operatorname{floor}(#?)' data-latex='\\operatorname{floor}()'></li>\n                <li class='bigfnbutton' data-latex='\\sum_{n\\mathop=0}^{\\infty}'></li>\n                <li class='bigfnbutton' data-latex='\\int_{0}^{\\infty}'></li>\n                <li class='bigfnbutton' data-latex='\\operatorname{sign}(#?)' data-latex='\\operatorname{sign}()'></li>\n            </ul>\n            <ul><li class='separator'></li>\n                <li class='fnbutton' data-latex='\\tan'></li>\n                <li class='fnbutton' data-latex='\\tan^{-1}'></li>\n                <li class='fnbutton' data-latex='\\log_{#?}'></li>\n                <li class='fnbutton' data-latex='\\sqrt[#?]{#0}'></li>\n                <li class='bigfnbutton' data-insert='#0 \\mod' data-latex='\\mod'></li>\n                <li class='bigfnbutton' data-insert='\\operatorname{round}(#?) ' data-latex='\\operatorname{round}()'></li>\n                <li class='bigfnbutton' data-insert='\\prod_{n\\mathop=0}^{\\infty}' data-latex='{\\scriptstyle \\prod_{n=0}^{\\infty}}'></li>\n                <li class='bigfnbutton' data-insert='\\frac{\\differentialD #0}{\\differentialD x}'></li>\n                <li class='action font-glyph bottom right' data-command='[\"performWithFeedback\",\"deleteBackward\"]'><svg class=\"svg-glyph\"><use xlink:href=\"#svg-delete-backward\" /></svg></li></ul>\n            <ul><li class='separator'></li>\n                <li class='fnbutton'>(</li>\n                <li class='fnbutton'>)</li>\n                <li class='fnbutton' data-insert='^{#?}' data-latex='x^{#?}'></li>\n                <li class='fnbutton' data-insert='_{#?}' data-latex='x_{#?}'></li>\n                <li class='keycap w20 ' data-key=' '>&nbsp;</li>\n                <arrows/>\n            </ul>\n        </div>",
    style: "\n        <div class='rows'>\n            <ul>\n                <li class='keycap' data-alt-keys='foreground-color' data-command='[\"applyStyle\",{\"color\":\"red\"}]'><span style='border-radius: 50%;width:22px;height:22px; border: 3px solid #cc2428'></span></li>\n                <li class='keycap' data-alt-keys='background-color' data-command='[\"applyStyle\",{\"backgroundColor\":\"yellow\"}]'><span style='border-radius: 50%;width:22px;height:22px; background:#fff590'></span></li>\n                <li class='separator w5'></li>\n                <li class='keycap' data-command='[\"applyStyle\",{\"size\":\"3\"}]' data-latex='\\scriptsize\\text{small}'></li>\n                <li class='keycap' data-command='[\"applyStyle\",{\"size\":\"5\"}]' data-latex='\\scriptsize\\text{normal}'></li>\n                <li class='keycap' data-command='[\"applyStyle\",{\"size\":\"9\"}]' data-latex='\\huge\\text{big}'></li>\n                <li class='separator w5'></li>\n                <li class='keycap' data-latex='\\langle' data-command='[\"insert\", \"\\\\langle\", {\"smartFence\":true}]'></li>\n            </ul>\n            <ul>\n                <li class='keycap' data-command='[\"applyStyle\",{\"series\":\"l\"}]' data-latex='\\fontseries{l}\\text{Ab}'></li>\n                <li class='keycap' data-command='[\"applyStyle\",{\"series\":\"m\"}]' data-latex='\\fontseries{m}\\text{Ab}'></li>\n                <li class='keycap' data-command='[\"applyStyle\",{\"series\":\"b\"}]' data-latex='\\fontseries{b}\\text{Ab}'></li>\n                <li class='keycap' data-command='[\"applyStyle\",{\"series\":\"bx\"}]' data-latex='\\fontseries{bx}\\text{Ab}'></li>\n                <li class='keycap' data-command='[\"applyStyle\",{\"series\":\"sb\"}]' data-latex='\\fontseries{sb}\\text{Ab}'></li>\n                <li class='keycap' data-command='[\"applyStyle\",{\"series\":\"c\"}]' data-latex='\\fontseries{c}\\text{Ab}'></li>\n            </ul>\n            <ul>\n                <li class='keycap' data-command='[\"applyStyle\",{\"shape\":\"up\"}]' data-latex='\\textup{Ab}'></li>\n                <li class='keycap' data-command='[\"applyStyle\",{\"shape\":\"it\"}]' data-latex='\\textit{Ab}'></li>\n                <li class='keycap' data-command='[\"applyStyle\",{\"shape\":\"sl\"}]' data-latex='\\textsl{Ab}'></li>\n                <li class='keycap' data-command='[\"applyStyle\",{\"shape\":\"sc\"}]' data-latex='\\textsc{Ab}'></li>\n                <li class='separator w5'></li>\n                <li class='keycap' data-insert='\\emph{#@} ' data-latex='\\text{\\emph{emph}}'></li>\n            </ul>\n            <ul>\n                <li class='keycap' data-command='[\"applyStyle\",{\"fontFamily\":\"cmr\"}]' data-latex='\\textrm{Az}'></li>\n                <li class='keycap' data-command='[\"applyStyle\",{\"fontFamily\":\"cmtt\"}]' data-latex='\\texttt{Az}'></li>\n                <li class='keycap' data-command='[\"applyStyle\",{\"fontFamily\":\"cmss\"}]' data-latex='\\textsf{Az}'></li>\n\n                <li class='keycap' data-command='[\"applyStyle\",{\"fontFamily\":\"bb\"}]'  data-latex='\\mathbb{AZ}'></li>\n                <li class='keycap' data-command='[\"applyStyle\",{\"fontFamily\":\"scr\"}]'  data-latex='\\mathscr{AZ}'></li>\n                <li class='keycap' data-command='[\"applyStyle\",{\"fontFamily\":\"cal\"}]' data-latex='\\mathcal{A1}'></li>\n                <li class='keycap' data-command='[\"applyStyle\",{\"fontFamily\":\"frak\"}]' data-latex='\\mathfrak{Az}'></li>\n            </ul>\n        </div>"
};
function lh(e1, t) {
    e1 = e1.replace(/(^|[^\\])#@/g, "$1#?");
    const i = di(), n = new ot("root", i);
    return n.body = It(e1, i, {
        parseMode: "math",
        args: t
    }), Re(Fe(Pe(new Ie(n.render(new Me({
        registers: i.registers
    }, {
        fontSize: 5
    }, "displaystyle")), {
        classes: "ML__base"
    }))), {
        classes: "ML__mathlive"
    }).toMarkup();
}
function uh(e1, t, i) {
    var n, r, o;
    let a = "<div class='left'>";
    const s = t.replace(/\s+/g, " ").split(" ");
    if (s.length > 1) {
        const t1 = {
            ...nh,
            ...null !== (n = e1.customVirtualKeyboards) && void 0 !== n ? n : {}
        };
        for (const e2 of s){
            if (!t1[e2]) break;
            a += "<div class='", e2 === i ? a += "selected " : t1[e2].command ? a += "action " : a += "layer-switch ", a += (null !== (r = t1[e2].classes) && void 0 !== r ? r : "") + "'", t1[e2].tooltip && (a += "data-tooltip='" + (null !== (o = l(t1[e2].tooltip)) && void 0 !== o ? o : t1[e2].tooltip) + "' "), e2 !== i && ("string" == typeof t1[e2].command ? a += `data-command='"${t1[e2].command}"'` : Array.isArray(t1[e2].command) && (a += `data-command='"${t1[e2].command.join("")}"'`), t1[e2].layer && (a += "data-layer='" + t1[e2].layer + "'")), a += ">" + t1[e2].label + "</div>";
        }
    }
    a += "</div>";
    const u = "default" === e1.virtualKeyboardToolbar ? [
        "copyToClipboard",
        "undo",
        "redo"
    ] : [], c = {
        copyToClipboard: `\n            <div class='action'\n                data-command='"copyToClipboard"'\n                data-tooltip='${l("tooltip.copy to clipboard")}'>\n                <svg><use xlink:href='#svg-copy' /></svg>\n            </div>\n        `,
        undo: `\n            <div class='action disabled'\n                data-command='"undo"'\n                data-tooltip='${l("tooltip.undo")}'>\n                <svg><use xlink:href='#svg-undo' /></svg>\n            </div>\n        `,
        redo: `\n            <div class='action disabled'\n                data-command='"redo"'\n                data-tooltip='${l("tooltip.redo")}'>\n                <svg><use xlink:href='#svg-redo' /></svg>\n            </div>\n        `
    };
    return u.length > 0 && (a += `\n            <div class='right'>\n                ${u.map((e1)=>c[e1]).join("")}\n            </div>\n        `), "<div class='keyboard-toolbar' role='toolbar'>" + a + "</div>";
}
function ch(e1, t, i) {
    var n, r;
    for (const o of t){
        let t1;
        o.getAttribute("data-latex") ? t1 = lh(o.getAttribute("data-latex").replace(/&quot;/g, '"'), ()=>"\\placeholder{}") : o.getAttribute("data-insert") && "" === o.innerHTML ? t1 = lh(o.getAttribute("data-insert").replace(/&quot;/g, '"'), ()=>"\\placeholder{}") : o.getAttribute("data-content") && (t1 = o.getAttribute("data-content").replace(/&quot;/g, '"')), o.getAttribute("data-aside") && (t1 = (null != t1 ? t1 : "") + "<aside>" + o.getAttribute("data-aside").replace(/&quot;/g, '"') + "</aside>"), void 0 !== t1 && (o.innerHTML = e1.options.createHTML(t1)), o.getAttribute("data-classes") && o.classList.add(o.getAttribute("data-classes"));
        const a = null === (n = o.getAttribute("data-insert")) || void 0 === n ? void 0 : n.replace(/&quot;/g, '"');
        let s;
        a && rh[a] && (o.dataset.shifted = rh[a][0], o.dataset.shiftedCommand = JSON.stringify([
            "insertAndUnshiftKeyboardLayer",
            rh[a][1]
        ]));
        const l = o.getAttribute("data-command");
        if (l) {
            if (/^[a-zA-Z]+$/.test(l)) s = l;
            else try {
                s = JSON.parse(l);
            } catch (e2) {}
        } else s = o.getAttribute("data-insert") ? [
            "insert",
            o.getAttribute("data-insert"),
            {
                focus: !0,
                feedback: !0,
                scrollIntoView: !0,
                mode: "math",
                format: "latex",
                resetStyle: !0
            }
        ] : o.getAttribute("data-latex") ? [
            "insert",
            o.getAttribute("data-latex"),
            {
                focus: !0,
                feedback: !0,
                scrollIntoView: !0,
                mode: "math",
                format: "latex",
                resetStyle: !0
            }
        ] : [
            "typedText",
            null !== (r = o.getAttribute("data-key")) && void 0 !== r ? r : o.textContent,
            {
                focus: !0,
                feedback: !0,
                simulateKeystroke: !0
            }
        ];
        if (s) {
            i && (s = [
                i,
                s
            ]);
            let t2 = s;
            const n1 = o.getAttribute("data-alt-keys");
            n1 && ah[n1] && (t2 = {
                default: s,
                pressAndHoldStart: [
                    "showAlternateKeys",
                    n1
                ],
                pressAndHoldEnd: "hideAlternateKeys"
            }), Qd((t)=>e1.executeCommand(t), o, t2);
        }
    }
}
function dh(e1, t) {
    var i, n, r, o;
    const a = {
        qwerty: {
            "lower-1": "qwertyuiop",
            "lower-2": " asdfghjkl ",
            "lower-3": "^zxcvbnm~",
            "upper-1": "QWERTYUIOP",
            "upper-2": " ASDFGHJKL ",
            "upper-3": "^ZXCVBNM~",
            "numpad-1": "789/",
            "numpad-2": "456*",
            "numpad-3": "123-",
            "numpad-4": "0.=+"
        },
        azerty: {
            "lower-1": "azertyuiop",
            "lower-2": "qsdfghjklm",
            "lower-3": "^ wxcvbn ~",
            "upper-1": "AZERTYUIOP",
            "upper-2": "QSDFGHJKLM",
            "upper-3": "^ WXCVBN ~"
        },
        qwertz: {
            "lower-1": "qwertzuiop",
            "lower-2": " asdfghjkl ",
            "lower-3": "^yxcvbnm~",
            "upper-1": "QWERTZUIOP",
            "upper-2": " ASDFGHJKL",
            "upper-3": "^YXCVBNM~"
        },
        dvorak: {
            "lower-1": "^  pyfgcrl ",
            "lower-2": "aoeuidhtns",
            "lower-3": "qjkxbmwvz~",
            "upper-1": "^  PYFGCRL ",
            "upper-2": "AOEUIDHTNS",
            "upper-3": "QJKXBMWVZ~"
        },
        colemak: {
            "lower-1": " qwfpgjluy ",
            "lower-2": "arstdhneio",
            "lower-3": "^zxcvbkm~",
            "upper-1": " QWFPGNLUY ",
            "upper-2": "ARSTDHNEIO",
            "upper-3": "^ZXCVBKM~"
        }
    };
    let l = e1.virtualKeyboardLayout;
    if ("auto" === l) {
        const e2 = Dn();
        e2 && (l = e2.virtualLayout), l && "auto" !== l || (l = null !== (i = ({
            fr: "azerty",
            be: "azerty",
            al: "qwertz",
            ba: "qwertz",
            cz: "qwertz",
            de: "qwertz",
            hu: "qwertz",
            sk: "qwertz",
            ch: "qwertz"
        })[s.locale.slice(0, 2)]) && void 0 !== i ? i : "qwerty");
    }
    const u = null !== (n = a[l]) && void 0 !== n ? n : a.qwerty;
    let c, d = t;
    d = d.replace(/<arrows\/>/g, '\n        <li class=\'action\' data-command=\'["performWithFeedback","moveToPreviousChar"]\'\n            data-shifted=\'<svg class="svg-glyph"><use xlink:href="#svg-angle-double-left" /></svg>\'\n            data-shifted-command=\'["performWithFeedback","extendToPreviousChar"]\'>\n            <svg class="svg-glyph"><use xlink:href=\'#svg-arrow-left\' /></svg>\n        </li>\n        <li class=\'action\' data-command=\'["performWithFeedback","moveToNextChar"]\'\n            data-shifted=\'<svg class="svg-glyph"><use xlink:href="#svg-angle-double-right" /></svg>\'\n            data-shifted-command=\'["performWithFeedback","extendToNextChar"]\'>\n            <svg class="svg-glyph"><use xlink:href=\'#svg-arrow-right\' /></svg>\n        </li>\n        <li class=\'action\' data-command=\'["performWithFeedback","commit"]\'>\n        <svg class="svg-glyph"><use xlink:href=\'#svg-commit\' /></svg></li>');
    let h = d.match(/(<row\s+)(.*)((?:<\/row|\/)>)/);
    for(; h;){
        c = "";
        const t1 = h[2].match(/[a-zA-Z][a-zA-Z\d-]*=(['"])(.*?)\1/g), i1 = {};
        if (t1) for (const e3 of t1){
            const t2 = e3.match(/([a-zA-Z][a-zA-Z\d-]*)=(['"])(.*?)\2/);
            t2 && (i1[t2[1]] = t2[3]);
        }
        let n1 = u[i1.name];
        if (n1 || (n1 = a.qwerty[i1.name]), n1) for (const t3 of n1){
            let a1 = null !== (r = i1.class) && void 0 !== r ? r : "";
            a1 && (a1 = ` ${a1}`), "~" === t3 ? (c += "<li class='action font-glyph bottom right ", c += n1.length - (n1.match(/ /g) || []).length / 2 == 10 ? "w10" : "w15", c += '\' data-shifted=\'<span class="warning"><svg class="svg-glyph"><use xlink:href="#svg-trash" /></svg></span>\'\n                        data-shifted-command=\'"deleteAll"\'\n                        data-alt-keys=\'delete\' data-command=\'["performWithFeedback","deleteBackward"]\'\n                        ><svg class="svg-glyph"><use xlink:href="#svg-delete-backward" /></svg></li>') : " " === t3 ? c += "<li class='separator w5'></li>" : "^" === t3 ? c += "<li class='shift modifier font-glyph bottom left w15 layer-switch' data-layer='" + i1["shift-layer"] + '\'><svg class="svg-glyph"><use xlink:href="#svg-shift" /></svg></li>' : "/" === t3 ? c += "<li class='keycap" + a1 + "' data-alt-keys='/' data-insert='\\frac{#@}{#?}'>&divide;</li>" : "*" === t3 ? c += "<li class='keycap" + a1 + "' data-alt-keys='*' data-insert='\\times '>&times;</li>" : "-" === t3 ? c += "<li class='keycap" + a1 + "' data-alt-keys='-' data-key='-'>&#x2212;</li>" : "." === t3 ? c += "<li class='keycap" + a1 + "' data-alt-keys='.' data-command='\"insertDecimalSeparator\"'>" + (null !== (o = e1.decimalSeparator) && void 0 !== o ? o : ".") + "</li>" : a1.includes("tt") ? c += `<li class='keycap${a1}' data-alt-keys='${t3}' data-command='["typedText","${t3}",{"mode":"command", "focus":true, "feedback":true}]'>${t3}</li>` : c += "<li class='keycap" + a1 + "' data-alt-keys='" + t3 + "'>" + t3 + "</li>";
        }
        d = d.replace(new RegExp(h[1] + h[2] + h[3]), c), h = d.match(/(<row\s+)(.*)((?:<\/row|\/)>)/);
    }
    return d;
}
function hh(e1) {
    th();
    const t = e1.element.querySelectorAll("div.keyboard-layer.is-visible .rows .keycap, div.keyboard-layer.is-visible .rows .action");
    if (t) for (const i of t){
        const t1 = i.getAttribute("data-unshifted-content");
        t1 && (i.innerHTML = e1.options.createHTML(t1), i.dataset.unshiftedContent = "");
        const n = i.getAttribute("data-unshifted-command");
        n && (i.dataset.command = n, i.dataset.unshiftedCommand = "");
    }
    return !1;
}
function mh(e1) {
    return Object.keys(e1).map((t)=>`${t} {${function(e1) {
            return "string" == typeof e1 ? e1 : Object.entries(e1).map(([e1, t])=>`${e1}:${t} !important`).join(";");
        }(e1[t])}}`).join("");
}
function ph(e1, t) {
    "lower-command" !== t && "upper-command" !== t && "symbols-command" !== t && e1.executeCommand("complete"), fh(e1), th(), hh(e1);
    const i = null == e1 ? void 0 : e1.element.querySelectorAll(".keyboard-layer");
    let n = !1;
    for (const e2 of i)if (e2.dataset.layer === t) {
        n = !0;
        break;
    }
    if (n) for (const e3 of i)e3.dataset.layer === t ? e3.classList.add("is-visible") : e3.classList.remove("is-visible");
    return e1.focusMathfield(), !0;
}
function fh(e1, t = "") {
    const i = e1.options.virtualKeyboardContainer;
    if (!i) return !1;
    if (e1.element ? e1.element.classList.add("is-visible") : e1.buildAndAttachElement(t), !e1.visible) {
        const t1 = gm();
        t1.visibleVirtualKeyboard && gh(t1.visibleVirtualKeyboard), t1.visibleVirtualKeyboard = e1;
        const n = i.style.paddingBottom;
        e1.originalContainerBottomPadding = n, i.style.paddingBottom = n ? `calc(${n} + var(--keyboard-height, 276px) - 1px)` : "calc(var(--keyboard-height, 276px) - 1px)";
    }
    return setTimeout(()=>{
        var t;
        null === (t = e1.element) || void 0 === t || t.classList.add("is-visible"), e1.focusMathfield();
    }, 1), e1.visible = !0, e1.stateChanged(), !1;
}
function gh(e1) {
    var t, i, n;
    const r = e1.options.virtualKeyboardContainer;
    return !!r && (e1.element && (gm().visibleVirtualKeyboard = void 0, e1.disable(), th(), e1.visible = !1, null === (t = e1.coreStylesheet) || void 0 === t || t.release(), e1.coreStylesheet = null, null === (i = e1.virtualKeyboardStylesheet) || void 0 === i || i.release(), e1.virtualKeyboardStylesheet = null, null === (n = e1._element) || void 0 === n || n.remove(), e1._element = void 0, null !== e1.originalContainerBottomPadding && (r.style.paddingBottom = e1.originalContainerBottomPadding)), e1.visible = !1, e1.stateChanged(), !1);
}
function yh(e1, t, i) {
    "function" == typeof t && (i = t, t = 1 / 0), void 0 === t && (t = 1 / 0);
    let n = e1.position, r = !1, o = "";
    for(; !r;){
        const a = e1.at(n);
        r = 0 === t || void 0 === a || "math" !== a.mode || !(/mord|textord|mpunct/.test(a.type) || "mop" === a.type && /[a-zA-Z]+/.test(a.value)) || !a.hasEmptyBranch("superscript") || !a.hasEmptyBranch("subscript") || "function" == typeof i && !i(a), r || (a.mode = "text", a.command = a.value, a.verbatimLatex = void 0, o += a.value), n -= 1, t -= 1;
    }
    jn(e1, {
        data: o,
        inputType: "insertText"
    });
}
function bh(e1, t, i) {
    "function" == typeof t && (i = t, t = 1 / 0), void 0 === t && (t = 1 / 0);
    let n = e1.position, r = !1;
    const o = [];
    for(; !r;){
        const a = e1.at(n);
        r = 0 === t || !a || a.isFirstSibling || "text" !== a.mode || " " === a.value || i && !i(a), r || (o.push(a.serialize({
            defaultMode: "math"
        })), a.mode = "math"), n -= 1, t -= 1;
    }
    vh(e1), jn(e1, {
        data: Qe(o),
        inputType: "insertText"
    });
}
function vh(e1) {
    var t;
    let i = e1.position - 1;
    for(; i >= 0 && "math" === (null === (t = e1.at(i)) || void 0 === t ? void 0 : t.mode);)i -= 1;
    if (!(i < 0) && "text" === e1.at(i).mode && " " === e1.at(i).value && "math" === e1.at(i - 1).mode) {
        e1.at(i - 1).parent.removeChild(e1.at(i - 1));
        const t1 = e1.suppressChangeNotifications;
        e1.suppressChangeNotifications = !0, e1.position -= 1, e1.suppressChangeNotifications = t1, jn(e1, {
            inputType: "deleteContent"
        });
    }
}
ur({
    showAlternateKeys: function(e1, t) {
        var n;
        i();
        const r = ah[t], o = document.createElement("div");
        o.setAttribute("aria-hidden", "true"), o.className = "ML__keyboard alternate-keys" + (e1.element.classList.contains("material") ? " material" : ""), o.id = "mathlive-alternate-keys-panel", r.length >= 14 ? o.style.width = "236px" : r.length >= 7 ? o.style.width = "286px" : 4 === r.length || 2 === r.length ? o.style.width = "146px" : 1 === r.length ? o.style.width = "86px" : o.style.width = "146px", o.style.height = "auto";
        let a = "";
        for (const e2 of r)a += "<li", "string" == typeof e2 ? a += ' data-latex="' + e2.replace(/"/g, "&quot;") + '"' : (e2.latex && (a += ' data-latex="' + e2.latex.replace(/"/g, "&quot;") + '"'), e2.content && (a += ' data-content="' + e2.content.replace(/"/g, "&quot;") + '"'), e2.insert && (a += ' data-insert="' + e2.insert.replace(/"/g, "&quot;") + '"'), e2.command && ("string" == typeof e2.command ? a += ` data-command="${e2.command.replace(/"/g, "&quot;")}"` : a += " data-command='" + JSON.stringify(e2.command).replace(/"/g, "&quot;") + "'"), e2.aside && (a += ` data-aside="${e2.aside.replace(/"/g, "&quot;")}"`), e2.class && (a += ` data-classes="${e2.class}"`)), a += ">", a += "string" == typeof e2 ? e2 : null !== (n = e2.label) && void 0 !== n ? n : "", a += "</li>";
        a = "<ul>" + a + "</ul>", o.innerHTML = e1.options.createHTML(a), ch(e1, [
            ...o.querySelectorAll("li")
        ], "performAlternateKeys"), jd.scrim || (jd.scrim = new jd), jd.scrim.open({
            root: e1.options.virtualKeyboardContainer,
            child: o
        });
        const s = null == e1 ? void 0 : e1.element.querySelector('div.keyboard-layer.is-visible div.rows ul li[data-alt-keys="' + t + '"]'), l = null == s ? void 0 : s.getBoundingClientRect();
        if (l) {
            l.top - o.clientHeight < 0 && (o.style.width = "auto", r.length <= 6 ? o.style.height = "56px" : r.length <= 12 ? o.style.height = "108px" : r.length <= 18 ? o.style.height = "205px" : o.classList.add("compact"));
            const e3 = (l.top - o.clientHeight + 5).toString() + "px", t1 = Math.max(0, Math.min(window.innerWidth - o.offsetWidth, (l.left + l.right - o.offsetWidth) / 2)) + "px";
            o.style.transform = "translate(" + t1 + "," + e3 + ")", o.classList.add("is-visible");
        }
        return !1;
    }
}, {
    target: "virtual-keyboard"
}), ur({
    shiftKeyboardLayer: function(t) {
        const i = null == t ? void 0 : t.element.querySelectorAll("div.keyboard-layer.is-visible .rows .keycap, div.keyboard-layer.is-visible .rows .action");
        if (i) for (const n of i){
            if (n.dataset.unshiftedContent) return !1;
            let i1 = n.getAttribute("data-shifted");
            if (i1 || /^[a-z]$/.test(n.innerHTML)) {
                n.dataset.unshiftedContent = n.innerHTML, i1 || (i1 = n.innerHTML.toUpperCase()), n.innerHTML = t.options.createHTML(i1);
                const r = n.getAttribute("data-command");
                if (r) {
                    n.dataset.unshiftedCommand = r;
                    const t1 = n.getAttribute("data-shifted-command");
                    if (t1) n.dataset.command = t1;
                    else {
                        const t2 = JSON.parse(r);
                        e1(t2) && (t2[1] = t2[1].toUpperCase()), n.dataset.command = JSON.stringify(t2);
                    }
                }
            }
        }
        return !1;
    }
}, {
    target: "virtual-keyboard"
}), ur({
    hideAlternateKeys: ()=>th(),
    performAlternateKeys: function(e1, t) {
        return th(), e1.executeCommand(t);
    },
    switchKeyboardLayer: (e1, t)=>ph(e1, t),
    unshiftKeyboardLayer: (e1)=>hh(e1),
    insertAndUnshiftKeyboardLayer: function(e1, t) {
        return e1.executeCommand([
            "insert",
            t
        ]), hh(e1), !0;
    }
}, {
    target: "virtual-keyboard"
}), ur({
    toggleVirtualKeyboardAlt: function(e1) {
        let t = !1;
        return (null == e1 ? void 0 : e1.element) && (t = null == e1 ? void 0 : e1.element.classList.contains("material"), e1.disable()), fh(e1, t ? "" : "material"), !1;
    },
    toggleVirtualKeyboardShift: function(e1) {
        var t, i;
        e1.options.virtualKeyboardLayout = ({
            qwerty: "azerty",
            azerty: "qwertz",
            qwertz: "dvorak",
            dvorak: "colemak",
            colemak: "qwerty"
        })[e1.options.virtualKeyboardLayout];
        const n = null !== (i = null === (t = null == e1 ? void 0 : e1.element.querySelector("div.keyboard-layer.is-visible")) || void 0 === t ? void 0 : t.id) && void 0 !== i ? i : "";
        return e1 && e1.disable(), fh(e1), n && ph(e1, n), !1;
    }
}, {
    target: "virtual-keyboard"
}), ur({
    toggleVirtualKeyboard: (e1, t)=>(function(e1, t) {
            return e1.visible ? gh(e1) : fh(e1, t), !1;
        })(e1, t),
    hideVirtualKeyboard: (e1)=>gh(e1),
    showVirtualKeyboard: (e1, t)=>fh(e1, t),
    onUndoStateChanged: (e1, t, i)=>(function(e1, t, i) {
            var n;
            const r = null === (n = e1.element) || void 0 === n ? void 0 : n.querySelector(".keyboard-toolbar");
            if (!r) return !1;
            const o = r.querySelector("[data-command='\"undo\"']"), a = r.querySelector("[data-command='\"redo\"']");
            return a && (i ? a.classList.remove("disabled") : a.classList.add("disabled")), o && (t ? o.classList.remove("disabled") : o.classList.add("disabled")), !1;
        })(e1, t, i)
}, {
    target: "virtual-keyboard"
});
var xh = "#mathlive-keystroke-caption-panel{--keystroke:#fff;--on-keystroke:#555;--keystroke-border:#f7f7f7;background:var(--secondary,hsl(var(--hue,212),19%,26%));border-color:var(--secondary-border,#e8e8e8);border-radius:6px;box-shadow:0 3px 6px rgba(0,0,0,.16),0 3px 6px rgba(0,0,0,.23);display:flex;flex-direction:row-reverse;justify-content:center;padding:16px;position:absolute;text-align:center;visibility:hidden;z-index:1}@media (prefers-color-scheme:dark){body:not([theme=light]) #mathlive-keystroke-caption-panel{--keystroke:hsl(var(--hue,212),50%,30%);--on-keystroke:#fafafa;--keystroke-border:hsl(var(--hue,212),50%,25%)}}body[theme=dark] #mathlive-keystroke-caption-panel{--keystroke:hsl(var(--hue,212),50%,30%);--on-keystroke:#fafafa;--keystroke-border:hsl(var(--hue,212),50%,25%)}#mathlive-keystroke-caption-panel>span{fill:currentColor;background-color:var(--keystroke);border:2px solid var(--keystroke-border);border-radius:6px;color:var(--on-keystroke);font-family:system-ui,-apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Oxygen,Ubuntu,Cantarell,Fira Sans,Droid Sans,Helvetica Neue,sans-serif;font-size:1em;margin:0 8px 0 0;min-width:14px;padding:4px}";
let kh, _h = null, wh = null;
function Sh(e1) {
    return e1.keystrokeCaption || (e1.keystrokeCaption = rn("mathlive-keystroke-caption-panel"), void 0 === kh && (kh = wn(xh).toString(36)), _h = Sn(null, xh, kh), wh = Sn(null, Rn, wn(Rn).toString(36))), e1.keystrokeCaption;
}
function Mh(e1) {
    if (!e1) return null;
    if (e1.length > 1) return null;
    const t = e1[0];
    return t instanceof Lt && "(" === t.leftDelim && ")" === t.rightDelim ? t.removeBranch("body") : null;
}
function Nh(e1) {
    if (e1) {
        for(let t = 0; e1[t]; t++){
            const i = e1[t];
            if (i instanceof Lt && "(" === i.leftDelim) {
                let n = 0, r = 0, o = 0;
                for(let e2 = 0; i.body[e2]; e2++)"genfrac" === i.body[e2].type && (n++, r = e2), o++;
                0 === o && 1 === n && (e1[t] = i.body[r]);
            }
        }
        for (const t1 of e1){
            for (const e3 of t1.branches)if (!t1.hasEmptyBranch(e3)) {
                Nh(t1.branch(e3));
                const i1 = Mh(t1.branch(e3));
                i1 && t1.setChildren(i1, e3);
            }
            if (t1 instanceof Pt) for (const e4 of t1.cells)Nh(e4);
        }
    }
}
function Lh(e1) {
    if (!e1) return [];
    const t = [];
    for (const i of e1){
        for (const e2 of i.branches)if (!i.hasEmptyBranch(e2)) {
            const n = Lh(i.branch(e2));
            t.push(...n);
        }
        i instanceof Ct && t.push(i);
    }
    return t;
}
function Ah(e1) {
    return !!/^(mord|surd|msubsup|leftright|mop|mclose)$/.test(e1.type) && !e1.isExtensibleSymbol && !e1.isFunction;
}
function Ch(e1, t, i) {
    const n = e1.at(e1.position), { parent: r  } = n;
    let o = r instanceof Lt ? r.leftDelim + r.rightDelim : "";
    if ("\\lbrace\\rbrace" === o && (o = "{}"), "\\{\\}" === o && (o = "{}"), "\\lparen\\rparen" === o && (o = "()"), "{}" === o && /\||\\vert|\\Vert|\\mvert|\\mid/.test(t)) return qi.insert("math", e1, "\\,\\middle" + t + "\\, ", {
        format: "latex",
        style: i
    }), !0;
    if ("{" !== t && "\\{" !== t || (t = "\\lbrace"), "}" !== t && "\\}" !== t || (t = "\\rbrace"), "[" === t && (t = "\\lbrack"), "]" === t && (t = "\\rbrack"), ut[t]) {
        const o1 = r;
        if ("leftright" === o1.type && o1.firstChild === n && ("?" === o1.leftDelim || "." === o1.leftDelim)) return o1.leftDelim = t, o1.isDirty = !0, !0;
        if (!(r instanceof Lt && "|" === r.leftDelim)) {
            if (qi.insert("math", e1, `\\left${t}\\right?`, {
                format: "latex",
                style: i
            }), "first" !== n.lastSibling.type) {
                const t1 = e1.offsetOf(n.lastSibling), i1 = e1.extractAtoms([
                    e1.position,
                    t1
                ]);
                e1.at(e1.position).body = i1, e1.position -= 1;
            }
            return !0;
        }
    }
    let a = "";
    if (Object.keys(ut).forEach((e1)=>{
        t === ut[e1] && (a = e1);
    }), a) {
        if (r instanceof Lt && n.isLastSibling) return r.isDirty = !0, r.rightDelim = t, e1.position += 1, jn(e1, {
            data: t,
            inputType: "insertText"
        }), !0;
        const o2 = e1.offsetOf(n.firstSibling);
        let a1;
        for(a1 = e1.position; a1 >= o2; a1--){
            const t2 = e1.at(a1);
            if (t2 instanceof Lt && "?" === t2.rightDelim) break;
        }
        const s = e1.at(a1);
        if (a1 >= o2 && s instanceof Lt) return s.rightDelim = t, s.addChildren(e1.extractAtoms([
            a1,
            e1.position
        ]), n.treeBranch), e1.position = a1, jn(e1, {
            data: t,
            inputType: "insertText"
        }), !0;
        if (r instanceof Lt && "?" === r.rightDelim) return r.isDirty = !0, r.rightDelim = t, r.parent.addChildren(e1.extractAtoms([
            e1.position,
            e1.offsetOf(n.lastSibling)
        ]), r.treeBranch), e1.position = e1.offsetOf(r), jn(e1, {
            data: t,
            inputType: "insertText"
        }), !0;
        const l = r.parent;
        return !!(l instanceof Lt && "?" === l.rightDelim && e1.at(e1.position).isLastSibling) && (e1.position = e1.offsetOf(l), Ch(e1, t, i));
    }
    return !1;
}
function Eh(e1, t, i) {
    var n, r, o, a;
    const { model: s  } = e1;
    !function(e1) {
        var t, i;
        if (!e1) return;
        if ("Unidentified" === e1.key) return;
        if ("Dead" === e1.key) return;
        const n = e1.shiftKey && e1.altKey ? 3 : e1.altKey ? 2 : e1.shiftKey ? 1 : 0;
        for (const r of Cn)(null === (t = r.mapping[e1.code]) || void 0 === t ? void 0 : t[n]) === e1.key ? r.score += 1 : (null === (i = r.mapping[e1.code]) || void 0 === i ? void 0 : i[n]) && (r.score = 0);
        Cn.sort((e1, t)=>t.score - e1.score);
    }(i);
    const l = Dn();
    if (e1.keyboardLayout !== l.id && (e1.keyboardLayout = l.id, e1._keybindings = void 0), clearTimeout(e1.inlineShortcutBufferFlushTimer), e1.inlineShortcutBufferFlushTimer = 0, function(e1, t) {
        if (e1.options.readOnly || !e1.keystrokeCaptionVisible) return;
        const i = Sh(e1), n = e1.element.getBoundingClientRect();
        i.style.left = `${n.left}px`, i.style.top = n.top - 64 + "px", i.innerHTML = e1.options.createHTML("<span>" + (Fn(t) || t) + "</span>" + i.innerHTML), i.style.visibility = "visible", setTimeout(()=>{
            i.childNodes.length > 0 && i.childNodes[i.childNodes.length - 1].remove(), 0 === i.childNodes.length && (i.style.visibility = "hidden");
        }, 3e3);
    }(e1, t), i.defaultPrevented) return e1.flushInlineShortcutBuffer(), !1;
    let u, c, d = "";
    if (!e1.options.readOnly) {
        if ("math" === e1.mode && !i.ctrlKey && !i.metaKey) {
            if ("[Backspace]" === t) e1.inlineShortcutBuffer.pop(), e1.flushInlineShortcutBuffer({
                defer: !0
            });
            else if (Gd(i)) {
                const t1 = Jd(i), o1 = (null !== (r = null === (n = e1.inlineShortcutBuffer[e1.inlineShortcutBuffer.length - 1]) || void 0 === n ? void 0 : n.keystrokes) && void 0 !== r ? r : "") + t1;
                e1.inlineShortcutBuffer.push({
                    state: s.getState(),
                    keystrokes: o1,
                    leftSiblings: Dh(e1)
                });
                let a1 = 0, l1 = "";
                for(; !u && a1 < o1.length;){
                    c = e1.inlineShortcutBuffer.length - (o1.length - a1), l1 = o1.slice(a1);
                    const t2 = e1.inlineShortcutBuffer[c].leftSiblings;
                    u = Mi(t2, l1, e1.options.inlineShortcuts), !u && /^[a-zA-Z][a-zA-Z0-9]+?([_\^][a-zA-Z0-9\*\+\-]+?)?$/.test(l1) && (u = e1.options.onInlineShortcut(e1, l1)), a1 += 1;
                }
                e1.flushInlineShortcutBuffer({
                    defer: !0
                });
            } else e1.flushInlineShortcutBuffer(), e1.snapshot();
        }
        if (e1.options.smartMode) {
            const n1 = e1.mode;
            u ? e1.mode = "math" : function(e1, t, i) {
                if (e1.smartModeSuppressed) return !1;
                const { model: n  } = e1;
                if (!n.at(n.position).isLastSibling) return !1;
                if (!i || !Gd(i)) return !1;
                const r = Jd(i);
                if (!n.selectionIsCollapsed) return !("text" !== e1.mode || !/[/_^]/.test(r));
                const o = function(e1) {
                    let t = "", i = e1.position, n = !1;
                    for(; !n;){
                        const r = e1.at(i);
                        n = !(r && ("text" === r.mode || "math" === r.mode && /mord|textord|mpunct/.test(r.type))), n || (t = r.value + t), i -= 1;
                    }
                    return t;
                }(n) + r;
                if ("text" === e1.mode) {
                    if ("Esc" === t || /[/\\]/.test(r)) return !0;
                    if (/[\^_]/.test(r)) return /(^|\s)[a-zA-Z][^_]$/.test(o) && bh(n, 1), !0;
                    const e2 = {
                        ")": "(",
                        "}": "{",
                        "]": "["
                    }[r], { parent: i1  } = n.at(n.position);
                    if (e2 && i1 instanceof Lt && i1.leftDelim === e2) return !0;
                    if (/(^|[^a-zA-Z])(a|I) $/.test(o)) return !1;
                    if (/[$\u20ac\xa3\u20a4\u20ba\xa5\xa4\u0e3f\xa2\u20a1\u20a7\u20a8\u20b9\u20a9\u20b1]/u.test(r)) return !0;
                    if (/(^|[^a-zA-Z'\u2019])[a-zA-Z] $/.test(o)) return bh(n, 1), !1;
                    if (/\D\.[^\d\s]$/.test(o)) {
                        bh(n, 1);
                        const e3 = n.at(n.position);
                        return e3.value = "⋅", e3.style.variant = "normal", e3.command = "\\cdot", e3.verbatimLatex = void 0, jn(n, {
                            data: "\\cdot",
                            inputType: "insertText"
                        }), !0;
                    }
                    if (/(^|\s)[a-zA-Z][^a-zA-Z]$/.test(o)) return bh(n, 1), !0;
                    if (/\.\d$/.test(o)) return bh(n, 1), !0;
                    if (/\([\d+\-.]$/.test(o)) return bh(n, 1), !0;
                    if (/\([a-z][,;]$/.test(o)) return bh(n, 2), !0;
                    if (/[\d+\-=><*|]$/.test(r)) return vh(n), !0;
                } else {
                    if ("[Space]" === t) return yh(n, void 0, (e1)=>/[a-z][:,;.]$/.test(e1.value)), !0;
                    if (/[a-zA-Z]{3,}$/.test(o) && !/(dxd|abc|xyz|uvw)$/.test(o)) return yh(n, void 0, (e1)=>/[a-zA-Z]/.test(e1.value)), !0;
                    if (/(^|\W)(if)$/i.test(o)) return yh(n, 1), !0;
                    if (/(\u0393|\u0394|\u0398|\u039B|\u039E|\u03A0|\u03A3|\u03A5|\u03A6|\u03A8|\u03A9|[\u03B1-\u03C9]|\u03D1|\u03D5|\u03D6|\u03F1|\u03F5){3,}$/u.test(o) && !/(\u03b1\u03b2\u03b3)$/.test(o)) return yh(n, void 0, (e1)=>/(:|,|;|.|\u0393|\u0394|\u0398|\u039B|\u039E|\u03A0|\u03A3|\u03A5|\u03A6|\u03A8|\u03A9|[\u03B1-\u03C9]|\u03D1|\u03D5|\u03D6|\u03F1|\u03F5)/u.test(e1.value)), !0;
                    if ("?" === r) return !0;
                    if ("." === r && !/[\d-+]\.$/.test(o)) return !0;
                }
                return !1;
            }(e1, t, i) && (e1.mode = ({
                math: "text",
                text: "math"
            })[e1.mode], d = ""), e1.mode !== n1 && ((null === (o = e1.host) || void 0 === o ? void 0 : o.dispatchEvent(new Event("mode-change", {
                bubbles: !0,
                composed: !0,
                cancelable: !0
            }))) || (e1.mode = n1));
        }
    }
    if (!u) {
        if (d || (d = function(e1, t, i) {
            if (0 === e1.length) return "";
            const n = Nn(Mn(i));
            for(let i1 = e1.length - 1; i1 >= 0; i1--)if (e1[i1].key === n && (!e1[i1].ifMode || e1[i1].ifMode === t)) return e1[i1].command;
            return "";
        }(e1.keybindings, e1.mode, t)), !d && ("[Enter]" === t || "[Return]" === t)) {
            let t3 = !1;
            return Vn(s, {
                inputType: "insertLineBreak"
            }) && (e1.host && (t3 = !e1.host.dispatchEvent(new Event("change", {
                bubbles: !0,
                composed: !0
            }))), t3 || i.preventDefault && (i.preventDefault(), i.stopPropagation()), jn(s, {
                inputType: "insertLineBreak"
            })), t3;
        }
        if ("math" === e1.mode) {
            if ("[Space]" === t) {
                if (e1.flushInlineShortcutBuffer(), e1.options.mathModeSpace) return e1.snapshot(), qi.insert("math", s, e1.options.mathModeSpace, {
                    format: "latex"
                }), d = "", e1.dirty = !0, e1.scrollIntoView(), i.preventDefault && (i.preventDefault(), i.stopPropagation()), !1;
                const t4 = s.at(s.position + 1), n2 = s.at(s.position - 1);
                "text" !== (null == t4 ? void 0 : t4.mode) && "text" !== (null == n2 ? void 0 : n2.mode) || (e1.snapshot(), qi.insert("text", s, " "), e1.dirty = !0);
            }
            (null === (a = s.at(s.position)) || void 0 === a ? void 0 : a.isDigit()) && "," === e1.options.decimalSeparator && "," === Jd(i) && (d = "insertDecimalSeparator");
        }
    }
    if (!u && !d) return !0;
    const h = s.at(Math.max(s.position, s.anchor)), { parent: m  } = h;
    if ("moveAfterParent" === d && "leftright" === (null == m ? void 0 : m.type) && h.isLastSibling && e1.options.smartFence && Ch(s, ".", e1.style) && (d = "", or(e1)), d) e1.executeCommand(d);
    else if (u) {
        e1.keyboardDelegate.cancelComposition();
        const t5 = {
            ...s.at(s.position).computedStyle,
            ...e1.style
        };
        if (!/^\\({|}|\[|]|@|#|\$|%|&|\^|_|backslash)$/.test(u)) {
            const n3 = e1.mode;
            qi.insert(e1.mode, s, Jd(i), {
                suppressChangeNotifications: !0,
                style: t5
            }), e1.snapshot(), s.setState(e1.inlineShortcutBuffer[c].state), e1.mode = n3;
        }
        s.deferNotifications({
            content: !0,
            selection: !0,
            data: null != u ? u : null,
            type: "insertText"
        }, ()=>(qi.insert(e1.mode, s, u, {
                format: "latex",
                style: t5
            }), vh(e1.model), u.endsWith(" ") && (e1.mode = "text", qi.insert("text", s, " ", {
                style: t5
            })), !0)), e1.snapshot(), e1.dirty = !0, s.announce("replacement");
    }
    return e1.scrollIntoView(), i.preventDefault && i.preventDefault(), !1;
}
function Th(e1, t, i) {
    var n;
    const { model: o  } = e1;
    if (e1.options.readOnly) return void o.announce("plonk");
    if ((i = null != i ? i : {}).focus && e1.focus(), i.feedback && (e1.options.keypressVibration && r() && navigator.vibrate(3), e1.playSound("keypress")), "string" == typeof i.mode && e1.mode !== i.mode && e1.switchMode(i.mode), i.simulateKeystroke) {
        const i1 = t.charAt(0), n1 = new KeyboardEvent("keypress", {
            key: i1
        });
        if (!Eh(e1, i1, n1)) return;
    }
    const a = o.at(o.position), s = {
        ...a.computedStyle,
        ...e1.style
    };
    o.selectionIsCollapsed || (o.deleteAtoms(Si(o.selection)), e1.snapshot());
    const l = We(t);
    if ("latex" === e1.mode) o.deferNotifications({
        content: !0,
        selection: !0,
        data: t,
        type: "insertText"
    }, ()=>{
        Gn(e1);
        for (const e2 of l)qi.insert("latex", o, e2);
        Zn(e1);
    });
    else if ("text" === e1.mode) for (const e2 of l)qi.insert("text", o, e2, {
        style: s
    });
    else if ("math" === e1.mode) for (const t1 of l){
        let i2 = {
            "^": "moveToSuperscript",
            _: "moveToSubscript",
            " ": "moveAfterParent"
        }[t1];
        " " === t1 && e1.options.mathModeSpace && (i2 = [
            "insert",
            e1.options.mathModeSpace
        ]), i2 ? e1.executeCommand(i2) : /\d/.test(t1) && e1.options.smartSuperscript && "superscript" === a.treeBranch && "mop" !== (null === (n = a.parent) || void 0 === n ? void 0 : n.type) && a.hasNoSiblings ? (qi.insert("math", o, t1, {
            style: s
        }), $d(o)) : ("mord" === a.type && /[a-zA-Z]/.test(a.value) && /[a-zA-Z]/.test(t1) && (a.style.variant && (s.variant = a.style.variant), a.style.variantStyle && (s.variantStyle = a.style.variantStyle)), qi.insert("math", o, t1, {
            style: s
        }));
    }
    e1.snapshotAndCoalesce(), e1.dirty = !0, e1.scrollIntoView();
}
function Dh(e1) {
    const t = e1.model, i = [];
    let n = t.at(Math.min(t.position, t.anchor));
    for(; "first" !== n.type;)i.push(n), n = n.leftSibling;
    return i;
}
function zh(e1, t) {
    var i, n, r, o, a, s;
    const l = {};
    "string" == typeof t.color && (l.verbatimColor = t.color, l.color = null !== (i = e1.colorMap(t.color)) && void 0 !== i ? i : "none"), "string" == typeof t.backgroundColor && (l.verbatimBackgroundColor = t.backgroundColor, l.backgroundColor = null !== (n = e1.backgroundColorMap(t.backgroundColor)) && void 0 !== n ? n : "none"), "string" == typeof t.fontFamily && (l.fontFamily = t.fontFamily), "string" == typeof t.series && (l.fontSeries = t.series), "string" == typeof t.fontSeries && (l.fontSeries = t.fontSeries.toLowerCase()), l.fontSeries && (l.fontSeries = null !== (r = ({
        bold: "b",
        medium: "m",
        normal: "m"
    })[l.fontSeries]) && void 0 !== r ? r : l.fontSeries), "string" == typeof t.shape && (l.fontShape = t.shape), "string" == typeof t.fontShape && (l.fontShape = t.fontShape.toLowerCase()), l.fontShape && (l.fontShape = null !== (o = ({
        italic: "it",
        up: "n",
        upright: "n",
        normal: "n"
    })[l.fontShape]) && void 0 !== o ? o : l.fontShape);
    const u = null !== (a = t.size) && void 0 !== a ? a : t.fontSize;
    return "number" == typeof u ? l.fontSize = Math.max(1, Math.min(10, u)) : "string" == typeof u && (l.fontSize = null !== (s = ({
        size1: 1,
        size2: 2,
        size3: 3,
        size4: 4,
        size5: 5,
        size6: 6,
        size7: 7,
        size8: 8,
        size9: 9,
        size10: 10
    })[u.toLowerCase()]) && void 0 !== s ? s : ({
        tiny: 1,
        scriptsize: 2,
        footnotesize: 3,
        small: 4,
        normal: 5,
        normalsize: 5,
        large: 6,
        Large: 7,
        LARGE: 8,
        huge: 9,
        Huge: 10
    })[u]), l;
}
new class extends qi {
    onPaste(e1, t) {
        if (!t.clipboardData) return !1;
        if (!Vn(e1.model, {
            dataTransfer: t.clipboardData,
            inputType: "insertFromPaste"
        })) return !1;
        let i = "", n = "auto", r = t.clipboardData.getData("application/json+mathlive");
        if (r) try {
            const i1 = JSON.parse(r);
            if (i1 && Array.isArray(i1)) {
                e1.snapshot();
                const n1 = fi(i1, e1), { model: r1  } = e1;
                r1.selectionIsCollapsed || r1.deleteAtoms(Si(r1.selection));
                const o = r1.at(r1.position);
                if (o.parent instanceof Pt) {
                    const e2 = [];
                    let t1 = [];
                    "first" === n1[0].type && n1.shift(), "first" === n1[n1.length - 1].type && n1.pop();
                    for (const i2 of n1)"first" === i2.type && t1.length > 0 ? (e2.push(t1), t1 = [
                        i2
                    ]) : t1.push(i2);
                    t1.length > 0 && e2.push(t1);
                    let i3 = Number(o.treeBranch[0]), r2 = Number(o.treeBranch[1]);
                    const a = o.parent.maxColumns;
                    for(; o.parent.colCount - r2 < e2.length && o.parent.colCount < a;)o.parent.addColumn();
                    o.parent.addChildrenAfter(e2[0], o);
                    for(let t2 = 1; t2 < e2.length; t2++)r2++, r2 >= a && (r2 = 0, o.parent.addRowAfter(i3), i3++), o.parent.setCell(i3, r2, e2[t2]);
                } else o.parent.addChildrenAfter(n1.filter((e1)=>"first" !== e1.type), o);
                return r1.position = r1.offsetOf(n1[n1.length - 1]), jn(r1, {
                    inputType: "insertFromPaste"
                }), or(e1), t.preventDefault(), t.stopPropagation(), !0;
            }
        } catch  {}
        if (r = t.clipboardData.getData("application/json"), r && e1.computeEngine) try {
            const t3 = JSON.parse(r);
            if ("object" == typeof t3 && "latex" in t3 && t3.latex && (i = t3.latex), !i) {
                const n2 = e1.computeEngine.box(t3);
                n2 && !n2.has("Error") && (i = n2.latex);
            }
            i || (n = "latex");
        } catch  {}
        if (i || (i = t.clipboardData.getData("application/x-latex"), i && (n = "latex")), i || (i = t.clipboardData.getData("text/plain")), i) {
            let r3;
            return e1.snapshot(), [r3, i] = Di(i), "auto" === n && r3 && (n = "latex"), this.insert(e1.model, i, {
                format: n
            }) && or(e1), t.preventDefault(), t.stopPropagation(), !0;
        }
        return !1;
    }
    insert(e1, t, i) {
        var n, r;
        const o = "string" == typeof t ? t : null !== (r = null === (n = e1.mathfield.computeEngine) || void 0 === n ? void 0 : n.box(t).latex) && void 0 !== r ? r : "";
        if (!i.suppressChangeNotifications && !Vn(e1, {
            data: o,
            inputType: "insertText"
        })) return !1;
        if (i.insertionMode || (i.insertionMode = "replaceSelection"), i.selectionMode || (i.selectionMode = "placeholder"), i.format || (i.format = "auto"), e1.mathfield.smartFence) {
            if (e1.selectionIsCollapsed && "string" == typeof t && Ch(e1, t, i.style)) return !0;
        } else if ("replaceAll" !== i.insertionMode) {
            const { parent: i1  } = e1.at(e1.position);
            if (i1 instanceof Lt && "?" === i1.rightDelim && e1.at(e1.position).isLastSibling && "string" == typeof t && /^[)}\]|]$/.test(t)) return i1.isDirty = !0, i1.rightDelim = t, e1.position += 1, Kn(e1), jn(e1, {
                data: o,
                inputType: "insertText"
            }), !0;
        }
        const { suppressChangeNotifications: a  } = e1;
        i.suppressChangeNotifications && (e1.suppressChangeNotifications = !0);
        const s = e1.suppressChangeNotifications;
        e1.suppressChangeNotifications = !0;
        const l = {};
        if (l[0] = "replaceAll" === i.insertionMode ? "" : e1.getValue(e1.selection, "latex-unstyled"), l["?"] = "\\placeholder{}", l["@"] = l["?"], "replaceSelection" !== i.insertionMode || e1.selectionIsCollapsed ? "replaceAll" === i.insertionMode ? (e1.root.setChildren([], "body"), e1.position = 0) : "insertBefore" === i.insertionMode ? e1.collapseSelection("backward") : "insertAfter" === i.insertionMode && e1.collapseSelection("forward") : e1.deleteAtoms(Si(e1.selection)), e1.at(e1.position).isLastSibling || "placeholder" !== e1.at(e1.position + 1).type ? "placeholder" === e1.at(e1.position).type && e1.deleteAtoms([
            e1.position - 1,
            e1.position
        ]) : e1.deleteAtoms([
            e1.position,
            e1.position + 1
        ]), l[0]) l["@"] = l[0];
        else if ("string" == typeof t && /(^|[^\\])#@/.test(t)) {
            const t1 = function(e1) {
                let t = e1.at(e1.position);
                if ("text" === t.mode) {
                    for(; !t.isFirstSibling && "text" === t.mode;)t = t.leftSibling;
                    return e1.offsetOf(t);
                }
                const i = t, n = [];
                for(; !t.isFirstSibling && (Ah(t) || n.length > 0);)"mclose" === t.type && n.unshift(t.value), "mopen" === t.type && n.length > 0 && t.value === ct[n[0]] && n.shift(), t = t.leftSibling;
                return i === t ? -1 : e1.offsetOf(t);
            }(e1);
            t1 >= 0 && (l["@"] = e1.getValue(t1, e1.position, "latex-unstyled"), e1.deleteAtoms([
                t1,
                e1.position
            ]));
        }
        l[0] || (l[0] = l["?"]);
        let u = !1;
        const [c, d] = function(e1, t, i, n) {
            var r;
            let o, a = [];
            if ("string" != typeof t || "math-json" === n.format) {
                if (!e1.mathfield.computeEngine) return [
                    "math-json",
                    []
                ];
                [o, t] = [
                    "latex",
                    e1.mathfield.computeEngine.box(t).latex
                ], a = It(t, e1.mathfield, {
                    parseMode: "math"
                });
            } else "string" == typeof t && "ascii-math" === n.format ? ([o, t] = Li(t, {
                format: "ascii-math",
                inlineShortcuts: e1.mathfield.options.inlineShortcuts
            }), a = It(t, e1.mathfield, {
                parseMode: "math"
            }), "latex" !== o && e1.options.removeExtraneousParentheses && Nh(a)) : ("auto" === n.format || (null === (r = n.format) || void 0 === r ? void 0 : r.startsWith("latex"))) && ("auto" === n.format && ([o, t] = Li(t, {
                format: "auto",
                inlineShortcuts: e1.mathfield.options.inlineShortcuts
            })), "latex" === n.format && ([, t] = Di(t)), a = It(t, e1.mathfield, {
                parseMode: "math",
                args: i
            }), "latex" !== n.format && e1.options.removeExtraneousParentheses && Nh(a));
            return zd(a, n.style), [
                null != o ? o : "latex",
                a
            ];
        }(e1, t, (e1)=>(u = !0, l[e1]), i);
        if (!d) return !1;
        const h = Lh(d), m = h.filter((t)=>t.placeholderId && !e1.mathfield.placeholders.has(t.placeholderId)), p = h.map((e1)=>e1.placeholderId);
        [
            ...e1.mathfield.placeholders.keys()
        ].filter((e1)=>!p.includes(e1)).forEach((t)=>{
            var i;
            e1.mathfield.placeholders.has(t) && (null === (i = e1.mathfield.placeholders.get(t)) || void 0 === i || i.field.remove(), e1.mathfield.placeholders.delete(t));
        }), m.forEach((t)=>{
            var i, n, r, o;
            let a = e1.mathfield.options.virtualKeyboardMode;
            "manual" === a && (a = "onfocus");
            const s = new tm({
                ...e1.mathfield.options,
                eventSink: null,
                virtualKeyboardMode: a,
                readOnly: !1
            }), l = (null !== (n = null === (i = t.defaultValue) || void 0 === i ? void 0 : i.length) && void 0 !== n ? n : 0) > 0 ? ot.serialize(t.defaultValue, {
                defaultMode: "math"
            }) : "";
            s.value = l, s.addEventListener("input", ()=>{
                !function(e1, t) {
                    !e1.suppressChangeNotifications && e1.mathfield.host && (e1.suppressChangeNotifications = !0, e1.mathfield.host.dispatchEvent(new CustomEvent("placeholder-change", {
                        detail: {
                            placeholderId: t
                        },
                        bubbles: !0,
                        composed: !0
                    })), e1.suppressChangeNotifications = !1);
                }(e1, t.placeholderId), setTimeout(()=>or(e1.mathfield));
            }), null === (o = null === (r = e1.mathfield.element) || void 0 === r ? void 0 : r.querySelector(".ML__placeholdercontainer")) || void 0 === o || o.appendChild(s), e1.mathfield.placeholders.set(t.placeholderId, {
                atom: t,
                field: s
            });
        });
        const { parent: f  } = e1.at(e1.position);
        if ("latex" !== c && e1.options.removeExtraneousParentheses && f instanceof Lt && "(" === f.leftDelim && f.hasEmptyBranch("body") && 1 === d.length && "genfrac" === d[0].type) {
            const e2 = f.parent, t2 = f.treeBranch;
            e2.removeChild(f), e2.setChildren(d, t2);
        }
        const g = f.hasEmptyBranch("body"), y = e1.at(e1.position);
        y.parent.addChildrenAfter(d, y), "latex" === c && "string" == typeof t && "root" === f.type && g && !u && (f.verbatimLatex = t), e1.suppressChangeNotifications = s;
        const b = d[d.length - 1];
        if ("placeholder" === i.selectionMode) {
            const t3 = d.reduce((e1, t)=>[
                    ...e1,
                    ...t.children.filter((e1)=>"placeholder" === e1.type)
                ], []);
            if (t3.length > 0) {
                const i2 = e1.offsetOf(t3[0]);
                e1.setSelection(i2 - 1, i2), e1.announce("move");
            } else b && (e1.position = e1.offsetOf(b));
        } else "before" === i.selectionMode || ("after" === i.selectionMode ? b && (e1.position = e1.offsetOf(b)) : "item" === i.selectionMode && e1.setSelection(e1.anchor, e1.offsetOf(b)));
        return jn(e1, {
            data: o,
            inputType: "insertText"
        }), e1.suppressChangeNotifications = a, !0;
    }
    constructor(){
        super("math");
    }
}, ur({
    undo: (e1)=>(Jn(e1, "accept"), e1.undo(), !0),
    redo: (e1)=>(Jn(e1, "accept"), e1.redo(), !0),
    scrollIntoView: (e1)=>(e1.scrollIntoView(), !0),
    scrollToStart: (e1)=>(e1.field.scroll(0, 0), !0),
    scrollToEnd: (e1)=>{
        const t = e1.field.getBoundingClientRect();
        return e1.field.scroll(t.left - window.scrollX, 0), !0;
    },
    enterLatexMode: (e1)=>(e1.switchMode("latex"), !0),
    toggleKeystrokeCaption: function(e1) {
        return e1.keystrokeCaptionVisible = !e1.keystrokeCaptionVisible, e1.keystrokeCaptionVisible ? (e1.keystrokeCaption = Sh(e1), e1.keystrokeCaption.innerHTML = "") : e1.keystrokeCaption && (e1.keystrokeCaption.style.visibility = "hidden"), !1;
    },
    plonk: (e1)=>(e1.model.announce("plonk"), !0),
    switchMode: (e1, t, i, n)=>(e1.switchMode(t, i, n), !0),
    insert: (e1, t, i)=>e1.insert(t, i),
    typedText: (e1, t, i)=>(Th(e1, t, i), !0),
    insertDecimalSeparator: (e1)=>{
        if ("math" === e1.mode && "," === e1.options.decimalSeparator) {
            const t = e1.model;
            if (t.at(Math.max(t.position, t.anchor)).isDigit()) return e1.snapshot(), e1.insert("{,}", {
                format: "latex"
            }), !0;
        }
        return e1.insert("."), !0;
    },
    commit: (e1)=>(Vn(e1.model, {
            inputType: "insertLineBreak"
        }) && (e1.host && e1.host.dispatchEvent(new Event("change", {
            bubbles: !0,
            composed: !0
        })), jn(e1.model, {
            inputType: "insertLineBreak"
        })), !0)
}), ur({
    copyToClipboard: (e1)=>(e1.focus(), e1.model.selectionIsCollapsed && e1.select(), document.execCommand("copy"), !1),
    cutToClipboard: (e1)=>(e1.focus(), document.execCommand("cut"), !0),
    pasteFromClipboard: (e1)=>(e1.focus(), document.execCommand("paste"), !0)
}, {
    target: "mathfield",
    category: "clipboard"
}), ur({
    applyStyle: function(e1, t) {
        e1.flushInlineShortcutBuffer();
        const i = zh(e1, t), { model: n  } = e1;
        return n.selectionIsCollapsed ? (e1.style.fontSeries && i.fontSeries === e1.style.fontSeries && (i.fontSeries = "auto"), i.fontShape && i.fontShape === e1.style.fontShape && (i.fontShape = "auto"), i.color && i.color === e1.style.color && (i.color = "none"), i.backgroundColor && i.backgroundColor === e1.style.backgroundColor && (i.backgroundColor = "none"), i.fontSize && i.fontSize === e1.style.fontSize && (i.fontSize = "auto"), e1.style = {
            ...e1.style,
            ...i
        }) : e1.model.deferNotifications({
            content: !0,
            type: "insertText"
        }, ()=>{
            n.selection.ranges.forEach((e1)=>qd(n, e1, i, {
                    operation: "toggle"
                })), e1.snapshot();
        }), !0;
    }
}, {
    target: "mathfield"
});
let qh = null, Ih = 0;
function Oh(e1) {
    return t() && "TouchEvent" in globalThis && e1 instanceof TouchEvent;
}
function Fh(e1) {
    return t() && "PointerEvent" in globalThis && e1 instanceof PointerEvent;
}
function Bh(e1, t, i) {
    if (e1 >= i.left && e1 <= i.right && t >= i.top && t <= i.bottom) return 0;
    const n = e1 - (i.left + i.right) / 2, r = t - (i.top + i.bottom) / 2;
    return n * n + r * r;
}
function $h(e1, t, i, n, r) {
    if (!i.id) return [
        1 / 0,
        null
    ];
    if (t.has(i.id)) return t.get(i.id);
    const o = dn(e1, i);
    if (!o) return [
        1 / 0,
        null
    ];
    let a = [
        1 / 0,
        null
    ];
    if (i.hasChildren && !i.captureSelection && n >= o.left && n <= o.right) for (const o1 of i.children){
        const i1 = $h(e1, t, o1, n, r);
        i1[0] <= a[0] && (a = i1);
    }
    return a[1] || (a = [
        Bh(n, r, o),
        i
    ]), t.set(i.id, a), a;
}
function Ph(e1, t, i) {
    const [, n] = $h(e1, new Map, e1.model.root, t, i);
    return n;
}
function Rh(e1, t, i, n) {
    var r;
    const o = e1.fieldContent.getBoundingClientRect();
    if (t > o.right || i > o.bottom + 8) return e1.model.lastOffset;
    if (t < o.left || i < o.top - 8) return 0;
    (n = null != n ? n : {}).bias = null !== (r = n.bias) && void 0 !== r ? r : 0;
    let a = Ph(e1, t, i);
    const s = [];
    let l = a;
    for(; l;)s.unshift(l), l = l.parent;
    for (const e2 of s)if (e2.captureSelection) {
        a = e2;
        break;
    }
    let u = e1.model.offsetOf(a);
    if (u < 0) return -1;
    if (a.leftSibling) {
        if (0 === n.bias && "placeholder" !== a.type) {
            const i1 = dn(e1, a);
            i1 && t < (i1.left + i1.right) / 2 && (u = e1.model.offsetOf(a.leftSibling));
        } else n.bias < 0 && (u = e1.model.offsetOf(a.leftSibling));
    }
    return u;
}
new class extends qi {
    onPaste(e1, t) {
        if (!t.clipboardData) return !1;
        const i = t.clipboardData.getData("text/plain");
        return !(!i || !Vn(e1.model, {
            inputType: "insertFromPaste",
            data: i
        }) || (e1.snapshot(), this.insert(e1.model, i) && (jn(e1.model, {
            inputType: "insertFromPaste"
        }), or(e1)), t.preventDefault(), t.stopPropagation(), 0));
    }
    insert(e1, t, i = {}) {
        if (!Vn(e1, {
            data: t,
            inputType: "insertText"
        })) return !1;
        i.insertionMode || (i.insertionMode = "replaceSelection"), i.selectionMode || (i.selectionMode = "placeholder"), i.format || (i.format = "auto");
        const { suppressChangeNotifications: n  } = e1;
        i.suppressChangeNotifications && (e1.suppressChangeNotifications = !0);
        const r = e1.suppressChangeNotifications;
        e1.suppressChangeNotifications = !0, "replaceSelection" !== i.insertionMode || e1.selectionIsCollapsed ? "replaceAll" === i.insertionMode ? (e1.root.setChildren([], "body"), e1.position = 0) : "insertBefore" === i.insertionMode ? e1.collapseSelection("backward") : "insertAfter" === i.insertionMode && e1.collapseSelection("forward") : e1.deleteAtoms(Si(e1.selection));
        const o = function(e1, t) {
            return It(e1 = (e1 = (e1 = (e1 = (e1 = (e1 = (e1 = (e1 = (e1 = (e1 = (e1 = e1.replace(/\\/g, "\\textbackslash ")).replace(/#/g, "\\#")).replace(/\$/g, "\\$")).replace(/%/g, "\\%")).replace(/&/g, "\\&")).replace(/_/g, "\\_")).replace(/{/g, "\\textbraceleft ")).replace(/}/g, "\\textbraceright ")).replace(/\^/g, "\\textasciicircum ")).replace(/~/g, "\\textasciitilde ")).replace(/\xa3/g, "\\textsterling "), t, {
                parseMode: "text"
            });
        }(t, e1.mathfield);
        if (zd(o, i.style), !o) return !1;
        const a = e1.at(e1.position), s = a.parent.addChildrenAfter(o, a);
        return e1.suppressChangeNotifications = r, "before" === i.selectionMode || ("item" === i.selectionMode ? e1.setSelection(e1.anchor, e1.offsetOf(s)) : s && (e1.position = e1.offsetOf(s))), jn(e1, {
            data: t,
            inputType: "insertText"
        }), e1.suppressChangeNotifications = n, !0;
    }
    constructor(){
        super("text");
    }
};
const Kh = "mathlive#remote-virtual-keyboard-message";
class Vh {
    get visible() {
        var e1, t;
        return null !== (t = null === (e1 = gm().sharedVirtualKeyboard) || void 0 === e1 ? void 0 : e1.visible) && void 0 !== t && t;
    }
    set visible(e1) {
        gm().sharedVirtualKeyboard && (gm().sharedVirtualKeyboard.visible = e1);
    }
    setOptions(e1) {
        this.sendMessage("setOptions", {
            options: JSON.stringify(Hh(e1))
        });
    }
    create() {}
    dispose() {
        this.disable();
    }
    enable() {
        this.enabled || (this.enabled = !0, globalThis.addEventListener("message", this));
    }
    disable() {
        this.enabled && (globalThis.removeEventListener("message", this), this.enabled = !1);
    }
    executeCommand(e1) {
        var t, i, n;
        return "virtual-keyboard" === cr(e1) ? (this._mathfield && (this.setOptions(Hh(this._mathfield.getOptions())), ("showVirtualKeyboard" === e1 || "toggleVirtualKeyboard" === e1 && !1 === this.visible) && (null === (i = (t = this._mathfield).focus) || void 0 === i || i.call(t))), this.sendMessage("executeCommand", {
            command: e1
        }), !1) : null === (n = this._mathfield) || void 0 === n ? void 0 : n.executeCommand(e1);
    }
    focusMathfield() {}
    blurMathfield() {}
    stateChanged() {}
    handleEvent(e1) {
        var t, i, n, r;
        if ("message" === e1.type && e1.data && e1.data.type === Kh) {
            if (!mn(e1.origin, this.originValidator)) throw new Error(`Message from unknown origin (${e1.origin}) cannot be handled`);
            const { action: o  } = e1.data;
            if ("executeCommand" === o) {
                if ("virtual-keyboard" === cr(e1.data.command) && window === globalThis.parent) return;
                this.executeCommand(e1.data.command);
            } else "updateState" === o ? (this.visible = e1.data.state.visible, this.height = e1.data.state.height) : "focus" === o ? null === (i = null === (t = this._mathfield) || void 0 === t ? void 0 : t.focus) || void 0 === i || i.call(t) : "blur" === o && (null === (r = null === (n = this._mathfield) || void 0 === n ? void 0 : n.blur) || void 0 === r || r.call(n));
        }
    }
    sendMessage(e1, t = {}) {
        return !!globalThis.parent && (globalThis.parent.postMessage({
            type: Kh,
            action: e1,
            ...t
        }, this.targetOrigin), !0);
    }
    constructor(e1){
        var t, i, n;
        this.targetOrigin = null !== (i = null !== (t = e1.targetOrigin) && void 0 !== t ? t : globalThis.origin) && void 0 !== i ? i : "*", this.originValidator = null !== (n = e1.originValidator) && void 0 !== n ? n : "same-origin", this._mathfield = e1.mathfield;
    }
}
class jh extends ih {
    static get defaultOptions() {
        var e1, t;
        return {
            createHTML: (e1)=>e1,
            fontsDirectory: "./fonts",
            soundsDirectory: "./sounds",
            targetOrigin: globalThis.origin,
            originValidator: "same-origin",
            virtualKeyboards: "all",
            virtualKeyboardLayout: "auto",
            customVirtualKeyboardLayers: {},
            customVirtualKeyboards: {},
            virtualKeyboardTheme: /macos|ios/.test(o()) ? "apple" : "material",
            keypressVibration: !0,
            keypressSound: null,
            plonkSound: null,
            virtualKeyboardToolbar: "default",
            computeEngine: null,
            virtualKeyboardContainer: null !== (t = null === (e1 = globalThis.document) || void 0 === e1 ? void 0 : e1.body) && void 0 !== t ? t : null
        };
    }
    addEventListener(e1, t, i) {
        if ("virtual-keyboard-toggle" !== e1) throw new TypeError("Unexpected event type");
        this.listeners.has(t) || this.listeners.add(t);
    }
    dispatchEvent(e1) {
        if ("virtual-keyboard-toggle" !== e1.type) throw new TypeError("Unexpected event type");
        return 0 !== this.listeners.size && (this.listeners.forEach((t)=>{
            "function" == typeof t ? t(e1) : null == t || t.handleEvent(e1);
        }), !0);
    }
    removeEventListener(e1, t, i) {
        if ("virtual-keyboard-toggle" !== e1) throw new TypeError("Unexpected event type");
        this.listeners.delete(t);
    }
    handleEvent(e1) {
        if ("message" === e1.type && e1.data && e1.data.type === Kh) {
            if (!mn(e1.origin, this.options.originValidator)) throw new Error(`Can not handle message from unknown origin (${e1.origin}).`);
            const { action: t  } = e1.data;
            if ("executeCommand" === t) {
                const { command: t1  } = e1.data;
                if (this.sourceFrame = e1.source, "virtual-keyboard" !== cr(t1) && window === window.parent) return;
                this.executeCommand(t1);
            } else if ("setOptions" === t && JSON.stringify(Hh(this.options)) !== e1.data.options) {
                const t2 = Hh(JSON.parse(e1.data.options));
                t2.createHTML = this.options.createHTML, t2.virtualKeyboardContainer = this.options.virtualKeyboardContainer, this.setOptions(t2);
            }
        }
    }
    stateChanged() {
        var e1, t;
        this.dispatchEvent(new Event("virtual-keyboard-toggle")), this.sendMessage("stateChanged", {
            state: {
                visible: this.visible,
                height: null !== (t = null === (e1 = this.element) || void 0 === e1 ? void 0 : e1.offsetHeight) && void 0 !== t ? t : 0
            }
        });
    }
    executeCommand(e1) {
        return "virtual-keyboard" === cr(e1) ? super.executeCommand(e1) : (this.sendMessage("executeCommand", {
            command: e1
        }), !1);
    }
    focus() {
        this.sendMessage("focus");
    }
    blur() {
        this.sendMessage("blur");
    }
    canUndo() {
        return this.canUndoState;
    }
    canRedo() {
        return this.canRedoState;
    }
    dispose() {
        window.removeEventListener("message", this);
    }
    sendMessage(e1, t = {}) {
        var i;
        null === (i = this.sourceFrame) || void 0 === i || i.postMessage({
            type: Kh,
            action: e1,
            ...t
        }, this.options.targetOrigin);
    }
    constructor(e1){
        const t = {
            ...jh.defaultOptions,
            ...Hh(e1)
        };
        (null == e1 ? void 0 : e1.createHTML) && (t.createHTML = e1.createHTML), (null == e1 ? void 0 : e1.virtualKeyboardContainer) && (t.virtualKeyboardContainer = e1.virtualKeyboardContainer), super(t), this.listeners = new Set, globalThis.addEventListener("message", this), document.body.addEventListener("focusin", (e1)=>{
            var t;
            const i = e1.target;
            if ((null == i ? void 0 : i.isConnected) && "math-field" === (null === (t = i.tagName) || void 0 === t ? void 0 : t.toLowerCase())) {
                const e2 = i;
                "onfocus" === e2.virtualKeyboardMode && "hidden" === e2.virtualKeyboardState && (e2.virtualKeyboardState = "visible");
            }
        }), document.addEventListener("focusout", (e1)=>{
            var t;
            const i = e1.target;
            (null == i ? void 0 : i.isConnected) && "math-field" === (null === (t = i.tagName) || void 0 === t ? void 0 : t.toLowerCase()) && setTimeout(()=>{
                var e1, t;
                if ("math-field" !== (null === (t = null === (e1 = document.activeElement) || void 0 === e1 ? void 0 : e1.tagName) || void 0 === t ? void 0 : t.toLowerCase())) {
                    const e2 = document.querySelector("math-field");
                    e2 && (e2.virtualKeyboardState = "hidden");
                }
            }, 300);
        });
    }
}
function Hh(e1) {
    if ("object" != typeof e1) return {};
    const t = {};
    return e1.fontsDirectory && (t.fontsDirectory = e1.fontsDirectory), e1.soundsDirectory && (t.soundsDirectory = e1.soundsDirectory), e1.virtualKeyboards && (t.virtualKeyboards = e1.virtualKeyboards), e1.virtualKeyboardLayout && (t.virtualKeyboardLayout = e1.virtualKeyboardLayout), e1.customVirtualKeyboardLayers && (t.customVirtualKeyboardLayers = e1.customVirtualKeyboardLayers), e1.customVirtualKeyboards && (t.customVirtualKeyboards = e1.customVirtualKeyboards), e1.virtualKeyboardTheme && (t.virtualKeyboardTheme = e1.virtualKeyboardTheme), e1.keypressVibration && (t.keypressVibration = e1.keypressVibration), e1.keypressSound && (t.keypressSound = e1.keypressSound), e1.plonkSound && (t.plonkSound = e1.plonkSound), e1.virtualKeyboardToolbar && (t.virtualKeyboardToolbar = e1.virtualKeyboardToolbar), e1.targetOrigin && (t.targetOrigin = e1.targetOrigin), e1.originValidator && (t.originValidator = e1.originValidator), t;
}
let Uh, Gh;
class Zh {
    get audioContext() {
        return this._audioContext || (this._audioContext = new AudioContext), this._audioContext;
    }
    get colorMap() {
        return (e1)=>{
            var t;
            let i;
            return "function" == typeof (null === (t = this.options) || void 0 === t ? void 0 : t.colorMap) && (i = this.options.colorMap(e1)), i || (i = f(e1)), i;
        };
    }
    get backgroundColorMap() {
        return (e1)=>{
            var t;
            let i;
            return "function" == typeof (null === (t = this.options) || void 0 === t ? void 0 : t.backgroundColorMap) && (i = this.options.backgroundColorMap(e1)), i || "function" != typeof this.options.colorMap || (i = this.options.colorMap(e1)), i || (i = g(e1)), i;
        };
    }
    get fractionNavigationOrder() {
        var e1, t;
        return null !== (t = null === (e1 = this.options) || void 0 === e1 ? void 0 : e1.fractionNavigationOrder) && void 0 !== t ? t : "numerator-denominator";
    }
    get placeholderSymbol() {
        var e1, t;
        return null !== (t = null === (e1 = this.options) || void 0 === e1 ? void 0 : e1.placeholderSymbol) && void 0 !== t ? t : "▢";
    }
    get smartFence() {
        var e1, t;
        return null !== (t = null === (e1 = this.options) || void 0 === e1 ? void 0 : e1.smartFence) && void 0 !== t && t;
    }
    get letterShapeStyle() {
        var e1, t;
        return null !== (t = null === (e1 = this.options) || void 0 === e1 ? void 0 : e1.letterShapeStyle) && void 0 !== t ? t : "tex";
    }
    get registers() {
        var e1, t;
        return null !== (t = null === (e1 = this.options) || void 0 === e1 ? void 0 : e1.registers) && void 0 !== t ? t : {};
    }
    getDefinition(e1, t = "math") {
        return hi(e1, t);
    }
    getMacro(e1) {
        return mi(e1, this.options.macros);
    }
    get virtualKeyboard() {
        if (!this.options.readOnly) return this._virtualKeyboard || (this.options.useSharedVirtualKeyboard || gm().sharedVirtualKeyboard ? this._virtualKeyboard = new Vh({
            targetOrigin: this.options.sharedVirtualKeyboardTargetOrigin,
            originValidator: this.options.originValidator,
            mathfield: this
        }) : this._virtualKeyboard = new ih(this.options, this)), this._virtualKeyboard;
    }
    get computeEngine() {
        return void 0 === this._computeEngine && (this._computeEngine = new ld, "," === this.options.decimalSeparator && (this._computeEngine.latexOptions.decimalMarker = "{,}")), this._computeEngine;
    }
    get virtualKeyboardState() {
        var e1;
        return (null === (e1 = this.virtualKeyboard) || void 0 === e1 ? void 0 : e1.visible) ? "visible" : "hidden";
    }
    set virtualKeyboardState(e1) {
        this.virtualKeyboard && ("hidden" === e1 ? this.virtualKeyboard.executeCommand("hideVirtualKeyboard") : "visible" === e1 && this.virtualKeyboard.executeCommand("showVirtualKeyboard"));
    }
    get keybindings() {
        var e1, t;
        if (this._keybindings) return this._keybindings;
        const [i, n] = function(e1, t) {
            const i = [], n = [];
            for (const r of e1)try {
                const e2 = Bn(r, t);
                if (e2) {
                    const n1 = i.filter((t)=>t.key === e2.key && t.ifMode === e2.ifMode);
                    if (n1.length > 0) throw new Error(`Ambiguous key binding ${r.key} (${$n(r.command)}) matches ${n1[0].key} (${$n(n1[0].command)}) with the ${t.displayName} keyboard layout`);
                    i.push(e2);
                }
            } catch (e3) {
                e3 instanceof Error && n.push(e3.message);
            }
            return [
                i,
                n
            ];
        }(this.options.keybindings, null !== (e1 = Dn()) && void 0 !== e1 ? e1 : Ln);
        return (null === (t = Dn()) || void 0 === t ? void 0 : t.score) > 0 && (this._keybindings = i, n.length), i;
    }
    setOptions(e1) {
        var t, i;
        if (this.options = gr(this.options, e1), "computeEngine" in e1 && (this._computeEngine = this.options.computeEngine), this._computeEngine && "decimalSeparator" in e1 && (this._computeEngine.latexOptions.decimalMarker = "," === this.options.decimalSeparator ? "{,}" : "."), this.model.setListeners({
            onSelectionDidChange: (e1)=>this._onSelectionDidChange()
        }), this.model.options.macros = this.options.macros, this._keybindings = void 0, ("soundsDirectory" in e1 || "plonkSound" in e1 || "keypressSound" in e1 || "spacebarKeypressSound" in e1 || "returnKeypressSound" in e1 || "deleteKeypressSound" in e1) && (this.audioBuffers = {}), "inline-math" === this.options.defaultMode ? this.element.classList.add("ML__isInline") : this.element.classList.remove("ML__isInline"), this.options.readOnly ? (this.hasFocus() && "visible" === this.virtualKeyboardState && this.executeCommand("hideVirtualKeyboard"), this.onBlur(), this.element.classList.add("ML__isReadOnly")) : this.element.classList.remove("ML__isReadOnly"), null === (t = this.virtualKeyboard) || void 0 === t || t.setOptions(this.options), this.options.readOnly || "manual" !== this.options.virtualKeyboardMode ? this.virtualKeyboardToggle.classList.remove("is-visible") : this.virtualKeyboardToggle.classList.add("is-visible"), "virtualKeyboardToggleGlyph" in e1) {
            const e2 = null === (i = this.element) || void 0 === i ? void 0 : i.querySelector(".ML__virtual-keyboard-toggle");
            e2 && (e2.innerHTML = this.options.createHTML(this.options.virtualKeyboardToggleGlyph));
        }
        const n = ot.serialize(this.model.root, {
            expandMacro: !1,
            defaultMode: this.options.defaultMode
        });
        ("macros" in e1 || this.model.getValue() !== n) && qi.insert("math", this.model, n, {
            insertionMode: "replaceAll",
            selectionMode: "after",
            format: "latex",
            suppressChangeNotifications: !0
        }), or(this);
    }
    getOptions(e1) {
        return yr(this.options, e1);
    }
    getOption(e1) {
        return yr(this.options, e1);
    }
    handleEvent(e1) {
        if (an(this)) switch(e1.type){
            case "focus":
                this.onFocus();
                break;
            case "blur":
                this.onBlur();
                break;
            case "touchstart":
            case "mousedown":
            case "pointerdown":
                !function(e1, i) {
                    var n;
                    e1.atomBoundsCache = new Map;
                    const r = e1;
                    let o, a = !1, s = "none";
                    if (Fh(i) && i.buttons > 1) return;
                    let l = !1, u = !1;
                    const c = Oh(i) ? i.touches[0].clientX : i.clientX, d = Oh(i) ? i.touches[0].clientY : i.clientY, h = Date.now(), m = r.field, p = setInterval(()=>{
                        l ? m.scroll({
                            top: 0,
                            left: m.scrollLeft - 16
                        }) : u && m.scroll({
                            top: 0,
                            left: m.scrollLeft + 16
                        });
                    }, 32);
                    function f(i) {
                        t() && ("PointerEvent" in window ? (nn(m, "pointermove", g), nn(m, "pointerup pointercancel", f), i instanceof PointerEvent && m.releasePointerCapture(i.pointerId)) : (nn(m, "touchmove", g), nn(m, "touchcancel touchend", f), nn(window, "mousemove", g), nn(window, "mouseup blur", f)), a = !1, clearInterval(p), e1.element.classList.remove("tracking"), i && i.preventDefault());
                    }
                    function g(t) {
                        if (!r.hasFocus()) return void f(null);
                        const i = Oh(t) ? t.touches[0].clientX : t.clientX, n = Oh(t) ? t.touches[0].clientY : t.clientY, a = Oh(t) || "touch" === t.pointerType ? 20 : 5;
                        if (Date.now() < h + 500 && Math.abs(c - i) < a && Math.abs(d - n) < a) return t.preventDefault(), void t.stopPropagation();
                        const s = m.getBoundingClientRect();
                        u = i > s.right, l = i < s.left;
                        let p = o;
                        Fh(t) ? t.isPrimary || (p = Rh(r, t.clientX, t.clientY, {
                            bias: 0
                        })) : t.touches && 2 === t.touches.length && (p = Rh(r, t.touches[1].clientX, t.touches[1].clientY, {
                            bias: 0
                        }));
                        const g = Rh(r, i, n, {
                            bias: i <= c ? i === c ? 0 : -1 : 1
                        });
                        p >= 0 && g >= 0 && (r.model.extendSelectionTo(p, g), or(e1)), t.preventDefault(), t.stopPropagation();
                    }
                    qh && Math.abs(qh.x - c) < 5 && Math.abs(qh.y - d) < 5 && Date.now() < qh.time + 500 ? (Ih += 1, qh.time = h) : (qh = {
                        x: c,
                        y: d,
                        time: h
                    }, Ih = 1);
                    const y = m.getBoundingClientRect();
                    if (c >= y.left && c <= y.right && d >= y.top && d <= y.bottom) {
                        if (e1.hasFocus() || (s = "all", e1.focus({
                            scrollIntoView: !1
                        })), e1.flushInlineShortcutBuffer(), e1.smartModeSuppressed = !1, o = Rh(e1, c, d, {
                            bias: 0
                        }), o >= 0) {
                            if (e1.element.classList.add("tracking"), i.shiftKey) {
                                const t1 = e1.model.selectionIsCollapsed;
                                e1.model.extendSelectionTo(e1.model.anchor, o), s = Wn(e1.model) || t1 ? "all" : "selection";
                            } else "placeholder" === e1.model.at(o).type ? (e1.model.setSelection(o - 1, o), s = "selection") : "placeholder" === (null === (n = e1.model.at(o).rightSibling) || void 0 === n ? void 0 : n.type) ? (e1.model.setSelection(o, o + 1), s = "selection") : (e1.model.position = o, s = Wn(e1.model) ? "all" : "selection");
                            e1.style = {}, 3 === i.detail || Ih > 2 ? (f(i), 3 !== i.detail && 3 !== Ih || (e1.model.selection = {
                                ranges: [
                                    [
                                        0,
                                        e1.model.lastOffset
                                    ]
                                ]
                            }, s = "all")) : a || (a = !0, t() && "PointerEvent" in window ? (tn(m, "pointermove", g), tn(m, "pointerup pointercancel", f), i instanceof PointerEvent && m.setPointerCapture(i.pointerId)) : (tn(window, "blur", f), Oh(i) && i.touches ? (tn(i.target, "touchmove", g), tn(i.target, "touchcancel touchend", f)) : (tn(window, "mousemove", g), tn(window, "mouseup", f))), 2 !== i.detail && 2 !== Ih || (Vd(e1.model), s = "all"));
                        }
                    } else qh = null;
                    "none" !== s && (e1.model.selectionIsCollapsed && (s = "all"), or(e1)), i.preventDefault();
                }(this, e1);
                break;
            case "resize":
                this.resizeTimer && cancelAnimationFrame(this.resizeTimer), this.resizeTimer = requestAnimationFrame(()=>an(this) && this.onResize());
                break;
            case "wheel":
                this.onWheel(e1);
        }
    }
    dispose() {
        if (!an(this)) return;
        const e1 = this.element;
        delete this.element, delete e1.mathfield, e1.innerHTML = this.model.getValue(), nn(e1, "pointerdown", this), nn(e1, "touchstart:active mousedown", this), nn(e1, "focus", this), nn(e1, "blur", this), nn(window, "resize", this), window.removeEventListener("blur", this, {
            capture: !0
        }), delete this.accessibleNode, delete this.ariaLiveText, delete this.field, delete this.fieldContent, this.virtualKeyboardToggle.remove(), delete this.virtualKeyboardToggle, this._virtualKeyboard && (this._virtualKeyboard.dispose(), delete this._virtualKeyboard), on(this.popover), Yn && Yn.release(), Qn && Qn.release(), delete this.popover, on(this.keystrokeCaption), _h && _h.release(), wh && wh.release(), delete this.keystrokeCaption, this.stylesheets.forEach((e1)=>null == e1 ? void 0 : e1.release());
    }
    flushInlineShortcutBuffer(e1) {
        if (null != e1 || (e1 = {
            defer: !1
        }), !e1.defer) return this.inlineShortcutBuffer = [], clearTimeout(this.inlineShortcutBufferFlushTimer), void (this.inlineShortcutBufferFlushTimer = 0);
        this.options.inlineShortcutTimeout > 0 && (clearTimeout(this.inlineShortcutBufferFlushTimer), this.inlineShortcutBufferFlushTimer = setTimeout(()=>this.flushInlineShortcutBuffer(), this.options.inlineShortcutTimeout));
    }
    executeCommand(t) {
        var i, n;
        return "virtual-keyboard" === cr(t) ? null !== (n = null === (i = this.virtualKeyboard) || void 0 === i ? void 0 : i.executeCommand(t)) && void 0 !== n && n : function(t, i) {
            var n, r, o;
            if (!i) return !1;
            let a, s = [], l = !1, u = !1;
            e1(i) ? (a = i[0], s = i.slice(1)) : a = i, a = a.replace(/-\w/g, (e1)=>e1[1].toUpperCase());
            const c = null === (n = lr[a]) || void 0 === n ? void 0 : n.target;
            if ("model" === c) {
                if (t.options.readOnly && /^(paste|cut|insert|delete|transpose|add)/.test(a)) return t.model.announce("plonk"), !1;
                /^(delete|transpose|add)/.test(a) && "deleteBackward" !== a && t.flushInlineShortcutBuffer(), /^(delete|transpose|add)/.test(a) && "latex" !== t.mode && (t.popUndoStack(), t.snapshot()), "latex" !== t.mode || /^(complete)/.test(a) || Gn(t), lr[a].fn(t.model, ...s), "latex" !== t.mode && /^(delete|transpose|add)/.test(a) && t.snapshot(), "latex" === t.mode && Zn(t), u = !0, l = !0;
            } else if ("virtual-keyboard" === c) u = null !== (o = null === (r = t.virtualKeyboard) || void 0 === r ? void 0 : r.executeCommand(i)) && void 0 !== o && o, l = !0;
            else {
                if (!lr[a]) throw new Error(`Unknown command "${a}"`);
                /^(undo|redo)/.test(a) && t.flushInlineShortcutBuffer(), u = lr[a].fn(t, ...s), l = !0;
            }
            return "virtual-keyboard" !== c && (t.model.selectionIsCollapsed && !/^(transpose|paste|complete|((moveToNextChar|moveToPreviousChar|extend).*))_$/.test(a) || (t.flushInlineShortcutBuffer(), t.style = {})), u && or(t), l;
        }(this, t);
    }
    get errors() {
        return Ot(this.model.getValue(), this);
    }
    getValue(e1, t, i) {
        return this.model.getValue(e1, t, i);
    }
    setValue(e1, t) {
        var i;
        void 0 === (t = null != t ? t : {
            mode: "math"
        }).insertionMode && (t.insertionMode = "replaceAll"), void 0 !== t.format && "auto" !== t.format || (t.format = "latex");
        let n = "math";
        void 0 !== t.mode && "auto" !== t.mode || (n = null !== (i = Dd(this.model, this.model.position)) && void 0 !== i ? i : "math"), qi.insert(n, this.model, e1, t) && (this.undoManager.snapshot(), or(this));
    }
    get expression() {
        const e1 = this.computeEngine;
        return e1 ? e1.box(e1.parse(this.model.getValue())) : null;
    }
    loadSound(e1) {
        var t, i, n, r, o, a, s;
        delete this.audioBuffers[e1];
        let l = "";
        switch(e1){
            case "keypress":
                l = "string" == typeof this.options.keypressSound ? this.options.keypressSound : null === (t = this.options.keypressSound) || void 0 === t ? void 0 : t.default;
                break;
            case "spacebar":
                l = "string" == typeof this.options.keypressSound ? this.options.keypressSound : null !== (n = null === (i = this.options.keypressSound) || void 0 === i ? void 0 : i.spacebar) && void 0 !== n ? n : null === (r = this.options.keypressSound) || void 0 === r ? void 0 : r.default;
                break;
            case "delete":
                l = "string" == typeof this.options.keypressSound ? this.options.keypressSound : null !== (a = null === (o = this.options.keypressSound) || void 0 === o ? void 0 : o.delete) && void 0 !== a ? a : null === (s = this.options.keypressSound) || void 0 === s ? void 0 : s.default;
                break;
            case "plonk":
                l = this.options.plonkSound;
        }
        if ("string" != typeof l) return;
        l = l.trim();
        const u = this.options.soundsDirectory;
        null != u && "null" !== u && "none" !== l && "null" !== l && fetch(md(u + "/" + l)).then((e1)=>e1.arrayBuffer()).then((e1)=>this.audioContext.decodeAudioData(e1)).then((t)=>{
            this.audioBuffers[e1] = t;
        });
    }
    playSound(e1) {
        if (this.audioBuffers[e1] || this.loadSound(e1), !this.audioBuffers[e1]) return;
        const t = this.audioContext.createBufferSource();
        t.buffer = this.audioBuffers[e1];
        const i = this.audioContext.createGain();
        i.gain.value = .5, t.connect(i).connect(this.audioContext.destination), t.start();
    }
    scrollIntoView() {
        var e1;
        if (!this.element) return;
        null === (e1 = this.host) || void 0 === e1 || e1.scrollIntoView({
            block: "nearest",
            inline: "nearest"
        }), this.dirty && ar(this, {
            interactive: !0
        });
        const t = this.field.getBoundingClientRect();
        let i = null;
        if (this.model.selectionIsCollapsed) i = sn(this.field);
        else {
            const e2 = hn(this);
            if (e2.length > 0) {
                let n = -1 / 0, r = -1 / 0;
                for (const t1 of e2)t1.right > n && (n = t1.right), t1.top < r && (r = t1.top);
                i = {
                    x: n + t.left - this.field.scrollLeft,
                    y: r + t.top - this.field.scrollTop,
                    height: 0
                };
            }
        }
        if (this.host && i) {
            const e3 = this.host.getBoundingClientRect(), t2 = i.y;
            let n1 = this.host.scrollTop;
            t2 < e3.top ? n1 = t2 - e3.top + this.host.scrollTop : t2 > e3.bottom && (n1 = t2 - e3.bottom + this.host.scrollTop + i.height), this.host.scroll({
                top: n1,
                left: 0
            });
        }
        if (i) {
            const e4 = i.x - window.scrollX;
            let n2 = this.field.scrollLeft;
            e4 < t.left ? n2 = e4 - t.left + this.field.scrollLeft - 20 : e4 > t.right && (n2 = e4 - t.right + this.field.scrollLeft + 20), this.field.scroll({
                top: this.field.scrollTop,
                left: n2
            });
        }
    }
    insert(e1, t) {
        if ("string" == typeof e1 && e1.length > 0) {
            if (this.flushInlineShortcutBuffer(), (t = null != t ? t : {
                mode: "math"
            }).focus && this.focus(), t.feedback && (this.options.keypressVibration && r() && navigator.vibrate(3), this.playSound("keypress")), t.scrollIntoView && this.scrollIntoView(), "\\\\" === e1) Ld(this.model);
            else if ("&" === e1) Ad(this.model);
            else {
                const i = this.style;
                qi.insert(this.mode, this.model, e1, {
                    style: this.model.at(this.model.position).computedStyle,
                    ...t
                }), t.resetStyle && (this.style = i);
            }
            return this.undoManager.snapshot(), or(this), !0;
        }
        return !1;
    }
    switchMode(e1, t = "", i = "") {
        var n;
        if (this.mode === e1 || this.options.readOnly) return;
        if (!(null === (n = this.host) || void 0 === n ? void 0 : n.dispatchEvent(new Event("mode-change", {
            bubbles: !0,
            composed: !0,
            cancelable: !0
        })))) return;
        const r = this.mode, { model: o  } = this;
        o.deferNotifications({
            content: Boolean(i) || Boolean(t),
            selection: !0,
            type: "insertText"
        }, ()=>{
            var n;
            let a = !1;
            if (this.flushInlineShortcutBuffer(), this.smartModeSuppressed = /text|math/.test(this.mode) && /text|math/.test(e1), t && "latex" !== e1) {
                const i1 = It(t, this, {
                    parseMode: e1
                });
                o.collapseSelection("forward");
                const n1 = o.at(o.position);
                o.position = o.offsetOf(n1.parent.addChildrenAfter(i1, n1)), a = !0;
            }
            if (this.mode = e1, "latex" === e1) {
                let e2, i2 = o.selectionIsCollapsed;
                Jn(this, "accept"), (null === (n = this.virtualKeyboard) || void 0 === n ? void 0 : n.visible) && this.executeCommand([
                    "switchKeyboardLayer",
                    "latex-lower"
                ]);
                let r1 = o.at(o.position);
                if (i2) e2 = "\\";
                else {
                    const n2 = Si(o.selection);
                    e2 = this.model.getValue(n2, "latex");
                    const a1 = this.model.extractAtoms(n2);
                    1 === a1.length && a1[0] instanceof Ct && (e2 = t, i2 = !0), r1 = o.at(n2[0]);
                }
                const a2 = new Qt(e2, this);
                r1.parent.addChildAfter(a2, r1), i2 ? o.position = o.offsetOf(a2.lastChild) : o.setSelection(o.offsetOf(a2.firstChild), o.offsetOf(a2.lastChild));
            } else Hn(o).forEach((e1)=>{
                e1.isError = !1;
            });
            if (i) {
                const e3 = It(i, this, {
                    parseMode: r
                });
                o.collapseSelection("forward");
                const t1 = o.at(o.position);
                o.position = o.offsetOf(t1.parent.addChildrenAfter(e3, t1)), a = !0;
            }
            return or(this), a;
        }), this.mode = e1;
    }
    hasFocus() {
        return t() && this.keyboardDelegate.hasFocus();
    }
    focus(e1) {
        var t;
        this.keyboardDelegate.focus(), this.model.announce("line"), (null === (t = null == e1 ? void 0 : e1.scrollIntoView) || void 0 === t || t) && this.scrollIntoView();
    }
    blur() {
        this.keyboardDelegate.blur();
    }
    select() {
        this.model.selection = {
            ranges: [
                [
                    0,
                    this.model.lastOffset
                ]
            ]
        };
    }
    applyStyle(e1, t = {}) {
        var i, n;
        const r = {
            operation: "set",
            suppressChangeNotifications: !1
        };
        yd(t) ? r.range = t : (r.range = t.range, r.suppressChangeNotifications = null !== (i = t.suppressChangeNotifications) && void 0 !== i && i);
        const o = zh(this, e1), a = null !== (n = r.operation) && void 0 !== n ? n : "set";
        this.model.deferNotifications({
            content: !r.suppressChangeNotifications,
            type: "insertText"
        }, ()=>{
            void 0 === r.range ? this.model.selection.ranges.forEach((e1)=>qd(this.model, e1, o, {
                    operation: a
                })) : qd(this.model, r.range, o, {
                operation: a
            });
        }), or(this);
    }
    getCaretPoint() {
        const e1 = sn(this.field);
        return e1 ? {
            x: e1.x,
            y: e1.y
        } : null;
    }
    setCaretPoint(e1, t) {
        const i = Rh(this, e1, t, {
            bias: 0
        });
        if (i < 0) return !1;
        const n = this.model.position;
        return this.model.position = i, this.model.announce("move", n), or(this), !0;
    }
    getPlaceholderField(e1) {
        var t;
        return null === (t = this.placeholders.get(e1)) || void 0 === t ? void 0 : t.field;
    }
    attachNestedMathfield() {
        let e1 = !1;
        this.placeholders.forEach((t)=>{
            var i, n, r, o, a, s, l, u;
            const c = null === (i = this.field) || void 0 === i ? void 0 : i.querySelector(`[data-placeholder-id=${t.atom.placeholderId}]`);
            if (c) {
                const i1 = c.getBoundingClientRect(), d = null === (n = this.field) || void 0 === n ? void 0 : n.getBoundingClientRect(), h = .6 * parseInt(window.getComputedStyle(c).fontSize);
                (!t.field.style.fontSize || Math.abs(h - parseFloat(t.field.style.fontSize)) >= .2) && (e1 = !0, t.field.style.fontSize = `${h}px`);
                const m = (null !== (r = null == i1 ? void 0 : i1.top) && void 0 !== r ? r : 0) - (null !== (o = null == d ? void 0 : d.top) && void 0 !== o ? o : 0) + (null !== (a = this.element.offsetTop) && void 0 !== a ? a : 0), p = (null !== (s = null == i1 ? void 0 : i1.left) && void 0 !== s ? s : 0) - (null !== (l = null == d ? void 0 : d.left) && void 0 !== l ? l : 0) + (null !== (u = this.element.offsetLeft) && void 0 !== u ? u : 0);
                (!t.field.style.left || Math.abs(p - parseFloat(t.field.style.left)) >= 1) && (e1 = !0, t.field.style.left = `${p}px`), (!t.field.style.top || Math.abs(m - parseFloat(t.field.style.top)) >= 1) && (e1 = !0, t.field.style.top = `${m}px`);
            }
        }), e1 && or(this);
    }
    canUndo() {
        return this.undoManager.canUndo();
    }
    canRedo() {
        return this.undoManager.canRedo();
    }
    popUndoStack() {
        this.undoManager.pop();
    }
    snapshot() {
        var e1, t;
        this.undoManager.snapshot() && (null === (e1 = this.virtualKeyboard) || void 0 === e1 || e1.executeCommand([
            "onUndoStateChanged",
            this.canUndo(),
            this.canRedo()
        ]), null === (t = this.host) || void 0 === t || t.dispatchEvent(new CustomEvent("undo-state-change", {
            bubbles: !0,
            composed: !0,
            detail: {
                type: "snapshot"
            }
        })));
    }
    snapshotAndCoalesce() {
        var e1, t;
        this.undoManager.snapshotAndCoalesce() && (null === (e1 = this.virtualKeyboard) || void 0 === e1 || e1.executeCommand([
            "onUndoStateChanged",
            this.canUndo(),
            this.canRedo()
        ]), null === (t = this.host) || void 0 === t || t.dispatchEvent(new CustomEvent("undo-state-change", {
            bubbles: !0,
            composed: !0,
            detail: {
                type: "snapshot"
            }
        })));
    }
    undo() {
        var e1, t;
        this.undoManager.undo() && (null === (e1 = this.virtualKeyboard) || void 0 === e1 || e1.executeCommand([
            "onUndoStateChanged",
            this.canUndo(),
            this.canRedo()
        ]), null === (t = this.host) || void 0 === t || t.dispatchEvent(new CustomEvent("undo-state-change", {
            bubbles: !0,
            composed: !0,
            detail: {
                type: "undo"
            }
        })));
    }
    redo() {
        var e1, t;
        this.undoManager.redo() && (null === (e1 = this.virtualKeyboard) || void 0 === e1 || e1.executeCommand([
            "onUndoStateChanged",
            this.canUndo(),
            this.canRedo()
        ]), null === (t = this.host) || void 0 === t || t.dispatchEvent(new CustomEvent("undo-state-change", {
            bubbles: !0,
            composed: !0,
            detail: {
                type: "undo"
            }
        })));
    }
    resetUndo() {
        var e1;
        null === (e1 = this.undoManager) || void 0 === e1 || e1.reset();
    }
    _onSelectionDidChange() {
        var e1, t, i;
        this.keyboardDelegate.setValue(this.model.getValue(this.model.selection, "latex-expanded"));
        const n = this.model.getAtoms(this.model.selection);
        if (1 === n.length && "placeholder" === n[0].type) {
            const t1 = n[0];
            this.model.mathfield.placeholders.has(t1.placeholderId) && (null === (e1 = this.model.mathfield.placeholders.get(t1.placeholderId)) || void 0 === e1 || e1.field.focus());
        }
        {
            const e2 = this.model.at(this.model.position), i1 = null !== (t = e2.mode) && void 0 !== t ? t : xr(this.options);
            this.mode !== i1 && ("latex" === this.mode ? (Jn(this, "accept", {
                mode: i1
            }), this.model.position = this.model.offsetOf(e2)) : this.switchMode(i1));
        }
        null === (i = this.host) || void 0 === i || i.dispatchEvent(new Event("selection-change", {
            bubbles: !0,
            composed: !0
        }));
    }
    onFocus() {
        var e1, t, i;
        !this.focusBlurInProgress && this.blurred && (this.focusBlurInProgress = !0, this.blurred = !1, this.keyboardDelegate.focus(), null === (e1 = this.virtualKeyboard) || void 0 === e1 || e1.setOptions(this.options), null === (t = this.virtualKeyboard) || void 0 === t || t.enable(), "onfocus" === this.options.virtualKeyboardMode && this.executeCommand("showVirtualKeyboard"), tr(this), ar(this, {
            interactive: !0
        }), null === (i = this.host) || void 0 === i || i.dispatchEvent(new Event("focus", {
            bubbles: !1,
            composed: !0
        })), this.valueOnFocus = this.model.getValue(), this.focusBlurInProgress = !1);
    }
    onBlur() {
        var e1, t;
        this.focusBlurInProgress || this.blurred || (this.focusBlurInProgress = !0, this.blurred = !0, this.ariaLiveText.textContent = "", Jn(this, "accept"), this.model.getValue() !== this.valueOnFocus && this.executeCommand("commit"), /onfocus|manual/.test(this.options.virtualKeyboardMode) && !gm().sharedVirtualKeyboard && this.executeCommand("hideVirtualKeyboard"), null === (e1 = this.virtualKeyboard) || void 0 === e1 || e1.disable(), null === (t = this.host) || void 0 === t || t.dispatchEvent(new Event("blur", {
            bubbles: !1,
            composed: !0
        })), or(this), this.focusBlurInProgress = !1);
    }
    onCompositionStart(e1) {
        this.model.deleteAtoms(Si(this.model.selection)), requestAnimationFrame(()=>{
            ar(this);
            const e1 = sn(this.field);
            e1 && this.keyboardDelegate.moveTo(e1.x, e1.y);
        });
    }
    onCompositionUpdate(e1) {
        !function(e1, t) {
            const i = e1.at(e1.position);
            if ("composition" === i.type) i.value = t;
            else {
                const { caret: n  } = i;
                i.caret = "";
                const r = new jt(t, e1.mathfield, {
                    mode: i.mode
                });
                r.caret = n, i.parent.addChildAfter(r, i), e1.position += 1;
            }
        }(this.model, e1), or(this);
    }
    onCompositionEnd(e1) {
        !function(e1) {
            const t = e1.at(e1.position);
            "composition" === t.type && (t.parent.removeChild(t), e1.position -= 1);
        }(this.model), Th(this, e1, {
            simulateKeystroke: !0
        });
    }
    onResize() {
        tr(this);
    }
    onWheel(e1) {
        const t = 5 * e1.deltaX;
        if (!Number.isFinite(t) || 0 === t) return;
        const i = this.field;
        t < 0 && 0 === i.scrollLeft || t > 0 && i.offsetWidth + i.scrollLeft >= i.scrollWidth || (i.scrollBy({
            top: 0,
            left: t
        }), e1.preventDefault(), e1.stopPropagation());
    }
    getHTMLElement(e1) {
        let t = e1;
        for(; !t.id && t.hasChildren;)t = e1.children[0];
        if (t.id) return this.element.querySelector(`[data-atom-id="${t.id}"]`);
        throw new TypeError("Could not get an ID from atom");
    }
    constructor(e1, i){
        var r, o, a;
        this.focusBlurInProgress = !1, this.stylesheets = [], this.audioBuffers = {}, this.options = gr({
            ...vr(),
            registers: ci(this)
        }, i.readOnly ? {
            ...i,
            virtualKeyboardMode: "off"
        } : {
            plonkSound: "plonk.wav",
            keypressSound: {
                spacebar: "keypress-spacebar.wav",
                return: "keypress-return.wav",
                delete: "keypress-delete.wav",
                default: "keypress-standard.wav"
            },
            ...i
        }), "auto" === this.options.virtualKeyboardMode && (this.options.virtualKeyboardMode = n() ? "onfocus" : "off"), void 0 !== this.options.computeEngine && (this._computeEngine = i.computeEngine), i.eventSink && (this.host = i.eventSink), this.placeholders = new Map, this.element = e1, e1.mathfield = this;
        let s = null !== (r = i.value) && void 0 !== r ? r : this.element.textContent;
        s && (s = s.trim()), null !== this.options.fontsDirectory && fd(this.options.fontsDirectory), Uh || (Uh = wn(Rn).toString(36)), this.stylesheets.push(Sn(e1, Rn, Uh)), Gh || (Gh = wn(dd).toString(36)), this.stylesheets.push(Sn(e1, dd, Gh));
        let u = "<span class=ML__textarea>";
        if (n() ? u += "<span class=ML__textarea__textarea tabindex=-1 role=textbox></span>" : u += `<textarea class=ML__textarea__textarea autocapitalize=off autocomplete=off autocorrect=off spellcheck=false inputmode=none aria-hidden="true" tabindex="${null !== (o = e1.tabIndex) && void 0 !== o ? o : 0}"></textarea>`, u += "</span>", u += '<span part="container" class="ML__container"><span part="content" class="ML__content"></span>', u += `<div part='virtual-keyboard-toggle' class="ML__virtual-keyboard-toggle" role="button" data-ML__tooltip="${l("tooltip.toggle virtual keyboard")}">`, u += null !== (a = this.options.virtualKeyboardToggleGlyph) && void 0 !== a ? a : br, u += "</div>", u += "<div class='ML__placeholdercontainer'></div>", u += "</span>", u += '<div class="ML__sr-only"><span aria-role="status" aria-live="assertive" aria-atomic="true"></span><span></span></div>', this.element.innerHTML = this.options.createHTML(u), !this.element.children) return;
        let c = 0;
        const d = this.element.children[c++].firstElementChild;
        this.field = this.element.children[c].children[0], c++, this.virtualKeyboardToggle = this.element.querySelector(".ML__virtual-keyboard-toggle"), this.ariaLiveText = this.element.children[c].children[0], this.accessibleNode = this.element.children[c++].children[1], this.keystrokeCaptionVisible = !1, this.popoverVisible = !1, this.suggestionIndex = 0, this.inlineShortcutBuffer = [], this.inlineShortcutBufferFlushTimer = 0, this.mode = xr(this.options), this.smartModeSuppressed = !1, this.style = {}, this.options.readOnly || "manual" !== this.options.virtualKeyboardMode ? this.virtualKeyboardToggle.classList.remove("is-visible") : this.virtualKeyboardToggle.classList.add("is-visible"), this.options.readOnly ? this.element.classList.add("ML__isReadOnly") : this.element.classList.remove("ML__isReadOnly"), "inline-math" === this.options.defaultMode ? this.element.classList.add("ML__isInline") : this.element.classList.remove("ML__isInline"), this.element.querySelector(".ML__content").addEventListener("click", (e1)=>e1.stopImmediatePropagation(), {
            capture: !1
        }), this.field.addEventListener("wheel", this, {
            passive: !1
        }), Qd((e1)=>this.executeCommand(e1), this.virtualKeyboardToggle, {
            default: "toggleVirtualKeyboard",
            alt: "toggleVirtualKeyboardAlt",
            shift: "toggleVirtualKeyboardShift"
        }), this.blurred = !0, tn(this.element, "focus", this), tn(this.element, "blur", this), this.keyboardDelegate = function(e1, t, i) {
            let n, r = null, o = null, a = !1, s = !1, l = !1;
            function u(e1) {
                clearTimeout(n), n = setTimeout(()=>{
                    clearTimeout(n), e1();
                });
            }
            function c() {
                if (e1.selectionStart !== e1.selectionEnd) return;
                const t = e1.value;
                e1.value = "", t.length > 0 && i.typedText(t);
            }
            const d = e1;
            return d.addEventListener("keydown", (t)=>{
                a || "Process" === t.key || "CapsLock" === t.code || /(Control|Meta|Alt|Shift)(Left|Right)/.test(t.code) ? r = null : (r = t, o = null, i.keystroke(Zd(t), t) ? "textarea" !== e1.tagName.toLowerCase() && (1 === t.key.length && i.typedText(t.key), t.preventDefault()) : (r = null, e1.value = ""));
            }, !0), d.addEventListener("keypress", (e1)=>{
                a || (r && o && i.keystroke(Zd(r), r), o = e1, u(c));
            }, !0), d.addEventListener("keyup", ()=>{
                a || r && !o && c();
            }, !0), d.addEventListener("paste", (t)=>{
                e1.focus(), e1.value = "", i.paste(t) || t.preventDefault(), t.stopImmediatePropagation();
            }, !0), d.addEventListener("cut", (e1)=>i.cut(e1), !0), d.addEventListener("copy", (e1)=>i.copy(e1), !0), d.addEventListener("blur", (n)=>{
                var a, u, c;
                if ((null === (u = null === (a = n.relatedTarget) || void 0 === a ? void 0 : a._mathfield) || void 0 === u ? void 0 : u.element) === t) return e1.focus(), n.preventDefault(), void n.stopPropagation();
                const d = null === (c = jd.scrim) || void 0 === c ? void 0 : c.state;
                return "open" === d || "opening" === d || n.relatedTarget === n.target.getRootNode().host ? (n.preventDefault(), void n.stopPropagation()) : void (l || s || (l = !0, r = null, o = null, i.blur && i.blur(), l = !1, n.stopPropagation()));
            }, !0), d.addEventListener("focus", (t)=>{
                l || s || (s = !0, i.focus && i.focus(), Wd() === e1 && "function" == typeof e1.select && e1.select(), s = !1, t.stopPropagation());
            }, !0), d.addEventListener("compositionstart", (t)=>{
                a = !0, e1.value = "", i.compositionStart && i.compositionStart(t.data);
            }, !0), d.addEventListener("compositionupdate", (e1)=>{
                a && i.compositionUpdate && i.compositionUpdate(e1.data);
            }, !0), d.addEventListener("compositionend", (t)=>{
                e1.value = "", a && (a = !1, i.compositionEnd && i.compositionEnd(t.data));
            }, !0), d.addEventListener("beforeinput", (e1)=>{
                e1.stopImmediatePropagation();
            }), d.addEventListener("input", (e1)=>{
                if (!a && "insertCompositionText" !== e1.inputType) {
                    if ("insertFromPaste" === e1.inputType) return e1.preventDefault(), void e1.stopPropagation();
                    u(c), e1.preventDefault(), e1.stopPropagation();
                }
            }), {
                cancelComposition: ()=>{
                    const t = i.blur, n = i.focus;
                    i.blur = null, i.focus = null, e1.blur(), e1.focus(), i.blur = t, i.focus = n;
                },
                blur: ()=>{
                    "function" == typeof e1.blur && e1.blur();
                },
                focus: ()=>{
                    "function" == typeof e1.focus && e1.focus();
                },
                hasFocus: ()=>Wd() === e1,
                setValue: (t)=>{
                    t ? (e1.value = t, Wd() === e1 && "function" == typeof e1.select && e1.select()) : (e1.value = "", e1.setAttribute("aria-label", ""));
                },
                setAriaLabel: (t)=>{
                    e1.setAttribute("aria-label", "after: " + t);
                },
                moveTo: (t, i)=>{
                    e1.style.top = `${i}px`, e1.style.left = `${t}px`;
                }
            };
        }(d, this.element, {
            typedText: (e1)=>Th(this, e1),
            cut: (e1)=>{
                this.options.readOnly ? this.model.announce("plonk") : Vn(this.model, {
                    inputType: "deleteByCut"
                }) && (this.snapshot(), qi.onCopy(this, e1), setTimeout(()=>{
                    Td(this.model, Si(this.model.selection), "deleteByCut"), or(this);
                }, 0));
            },
            copy: (e1)=>qi.onCopy(this, e1),
            paste: (e1)=>{
                let t = !0;
                return this.options.readOnly && (t = !1), t && (t = qi.onPaste(this.model.at(this.model.position).mode, this, e1)), t || this.model.announce("plonk"), t;
            },
            keystroke: (e1, t)=>Eh(this, e1, t),
            focus: ()=>this.onFocus(),
            blur: ()=>this.onBlur(),
            compositionStart: (e1)=>this.onCompositionStart(e1),
            compositionUpdate: (e1)=>this.onCompositionUpdate(e1),
            compositionEnd: (e1)=>this.onCompositionEnd(e1)
        }), t() && "PointerEvent" in window ? tn(this.field, "pointerdown", this) : tn(this.field, "touchstart:active mousedown", this), tn(window, "resize", this), window.addEventListener("blur", ()=>{
            an(this) && this.hasFocus() && window.addEventListener("focus", (e1)=>{
                e1.target === window && an(this) && this.focus();
            }, {
                once: !0
            });
        }, {
            capture: !0
        }), this.model = new wd({
            mode: xr(this.options),
            macros: this.options.macros,
            removeExtraneousParentheses: this.options.removeExtraneousParentheses
        }, {
            onSelectionDidChange: (e1)=>this._onSelectionDidChange()
        }, this), this.undoManager = new Xd(this.model), s && qi.insert("math", this.model, s, {
            insertionMode: "replaceAll",
            selectionMode: "after",
            format: "latex",
            suppressChangeNotifications: !0
        }), this.undoManager.startRecording(), this.undoManager.snapshot(), this.model.setListeners({
            onSelectionDidChange: (e1)=>this._onSelectionDidChange()
        }), or(this), t() && document.fonts.ready.then(()=>ar(this));
    }
}
var Wh, Jh, Xh, Yh;
const Qh = t() ? document.createElement("template") : null;
Qh && (Qh.innerHTML = '<style>\n:host { display: block; position: relative; overflow: hidden auto;}\n:host([hidden]) { display: none; }\n:host([disabled]) { opacity:  .5; }\n:host(:focus), :host(:focus-within) {\n  outline: Highlight auto 1px;    /* For Firefox */\n  outline: -webkit-focus-ring-color auto 1px;\n}\n:host([readonly]), :host([read-only]) { outline: none; }\n</style>\n<div></div><slot style="display:none"></slot>');
const em = new WeakMap;
class tm extends HTMLElement {
    static get optionsAttributes() {
        return {
            "default-mode": "string",
            "fonts-directory": "string",
            "sounds-directory": "string",
            "horizontal-spacing-scale": "string",
            "math-mode-space": "string",
            "inline-shortcut-timeout": "string",
            "keypress-vibration": "on/off",
            "keypress-sound": "string",
            "plonk-sound": "string",
            "letter-shape-style": "string",
            locale: "string",
            "read-only": "boolean",
            "remove-extraneous-parentheses": "on/off",
            "smart-fence": "on/off",
            "smart-mode": "on/off",
            "smart-superscript": "on/off",
            "speech-engine": "string",
            "speech-engine-rate": "string",
            "speech-engine-voice": "string",
            "text-to-speech-markup": "string",
            "text-to-speech-rules": "string",
            "virtual-keyboard-layout": "string",
            "virtual-keyboard-mode": "string",
            "virtual-keyboard-theme": "string",
            "virtual-keyboards": "string",
            "use-shared-virtual-keyboard": "boolean",
            "shared-virtual-keyboard-target-origin": "string"
        };
    }
    static get observedAttributes() {
        return [
            ...Object.keys(tm.optionsAttributes),
            "disabled",
            "readonly",
            "read-only"
        ];
    }
    onPointerDown() {
        window.addEventListener("pointerup", (e1)=>{
            e1.target === this && this.dispatchEvent(new MouseEvent("click", {
                altKey: e1.altKey,
                button: e1.button,
                buttons: e1.buttons,
                clientX: e1.clientX,
                clientY: e1.clientY,
                ctrlKey: e1.ctrlKey,
                metaKey: e1.metaKey,
                movementX: e1.movementX,
                movementY: e1.movementY,
                relatedTarget: e1.relatedTarget,
                screenX: e1.screenX,
                screenY: e1.screenY,
                shiftKey: e1.shiftKey
            }));
        }, {
            once: !0
        });
    }
    getPlaceholderField(e1) {
        var t;
        return null === (t = this._mathfield) || void 0 === t ? void 0 : t.getPlaceholderField(e1);
    }
    addEventListener(e1, t, i) {
        return super.addEventListener(e1, t, i);
    }
    removeEventListener(e1, t, i) {
        super.removeEventListener(e1, t, i);
    }
    get mode() {
        var e1, t;
        return null !== (t = null === (e1 = this._mathfield) || void 0 === e1 ? void 0 : e1.mode) && void 0 !== t ? t : "math";
    }
    set mode(e1) {
        this._mathfield && (this._mathfield.mode = e1);
    }
    get computeEngine() {
        if (this._mathfield) return this._mathfield.computeEngine;
    }
    set computeEngine(e1) {
        this._mathfield && this._mathfield.setOptions({
            computeEngine: e1
        });
    }
    get expression() {
        if (this._mathfield) return this._mathfield.expression;
    }
    set expression(e1) {
        var t, i;
        if (!this._mathfield) return;
        const n = null !== (i = null === (t = this.computeEngine) || void 0 === t ? void 0 : t.box(e1).latex) && void 0 !== i ? i : null;
        null !== n && this._mathfield.setValue(n);
    }
    get errors() {
        var e1, t;
        return null !== (t = null === (e1 = this._mathfield) || void 0 === e1 ? void 0 : e1.errors) && void 0 !== t ? t : [];
    }
    get placeholders() {
        if (!this._mathfield) return {};
        const e1 = {};
        for (const [t, i] of this._mathfield.placeholders)e1[t] = i.field;
        return e1;
    }
    getOptions(e1) {
        return this._mathfield ? yr(this._mathfield.options, e1) : em.has(this) ? yr(gr(vr(), em.get(this).options), e1) : null;
    }
    getOption(e1) {
        return this.getOptions([
            e1
        ])[e1];
    }
    setOptions(e1) {
        if (this._mathfield) this._mathfield.setOptions(e1), this._mathfield.placeholders.forEach((t)=>{
            t.field.setOptions({
                ...e1,
                virtualKeyboardMode: "onfocus",
                readOnly: !1
            });
        });
        else if (em.has(this)) {
            const t = {
                ...em.get(this).options,
                ...e1
            };
            em.set(this, {
                ...em.get(this),
                selection: {
                    ranges: t.readOnly ? [
                        [
                            0,
                            0
                        ]
                    ] : [
                        [
                            0,
                            -1
                        ]
                    ]
                },
                options: t
            });
        } else em.set(this, {
            value: void 0,
            selection: {
                ranges: [
                    [
                        0,
                        0
                    ]
                ]
            },
            options: e1
        });
        !function(e1) {
            const t = vr(), i = e1.getOptions();
            Object.keys(tm.optionsAttributes).forEach((n)=>{
                const r = im(n);
                "on/off" === tm.optionsAttributes[n] ? t[r] !== i[r] ? e1.setAttribute(n, i[r] ? "on" : "off") : e1.removeAttribute(n) : t[r] !== i[r] && ("boolean" === tm.optionsAttributes[n] ? i[r] ? e1.setAttribute(n, "") : e1.removeAttribute(n) : "string" != typeof i[r] && "number" != typeof i[r] || e1.setAttribute(n, i[r].toString()));
            });
        }(this);
    }
    executeCommand(e1) {
        var t, i;
        return null !== (i = null === (t = this._mathfield) || void 0 === t ? void 0 : t.executeCommand(e1)) && void 0 !== i && i;
    }
    getValue(e1, t, i) {
        var n, r;
        if (this._mathfield) return this._mathfield.model.getValue(e1, t, i);
        if (em.has(this)) {
            let o, a, s;
            if (bd(e1) ? ([o, a] = e1.ranges[0], s = t) : yd(e1) ? ([o, a] = e1, s = t) : gd(e1) && gd(t) ? (o = e1, a = t, s = i) : (o = 0, a = -1, s = e1), (void 0 === s || "latex" === s) && 0 === o && -1 === a) return null !== (r = null !== (n = em.get(this).value) && void 0 !== n ? n : this.textContent) && void 0 !== r ? r : "";
        }
        return "";
    }
    setValue(e1, t) {
        if (this._mathfield && void 0 !== e1) return t || (t = {
            suppressChangeNotifications: !0
        }), void this._mathfield.setValue(e1, t);
        if (em.has(this)) {
            const t1 = em.get(this).options;
            return void em.set(this, {
                value: e1,
                selection: {
                    ranges: t1.readOnly ? [
                        [
                            0,
                            0
                        ]
                    ] : [
                        [
                            0,
                            -1
                        ]
                    ],
                    direction: "forward"
                },
                options: t1
            });
        }
        const i = nm(this);
        em.set(this, {
            value: e1,
            selection: {
                ranges: i.readOnly ? [
                    [
                        0,
                        0
                    ]
                ] : [
                    [
                        0,
                        -1
                    ]
                ],
                direction: "forward"
            },
            options: i
        });
    }
    hasFocus() {
        var e1, t;
        return null !== (t = null === (e1 = this._mathfield) || void 0 === e1 ? void 0 : e1.hasFocus()) && void 0 !== t && t;
    }
    get virtualKeyboardState() {
        var e1, t;
        return null !== (t = null === (e1 = this._mathfield) || void 0 === e1 ? void 0 : e1.virtualKeyboardState) && void 0 !== t ? t : "hidden";
    }
    set virtualKeyboardState(e1) {
        this._mathfield && (this._mathfield.virtualKeyboardState = e1);
    }
    focus() {
        super.focus();
    }
    blur() {
        var e1;
        null === (e1 = this._mathfield) || void 0 === e1 || e1.blur(), super.blur();
    }
    select() {
        var e1;
        null === (e1 = this._mathfield) || void 0 === e1 || e1.select();
    }
    insert(e1, t) {
        var i, n;
        return null !== (n = null === (i = this._mathfield) || void 0 === i ? void 0 : i.insert(e1, t)) && void 0 !== n && n;
    }
    applyStyle(e1, t) {
        var i;
        return null === (i = this._mathfield) || void 0 === i ? void 0 : i.applyStyle(e1, t);
    }
    get caretPoint() {
        var e1, t;
        return null !== (t = null === (e1 = this._mathfield) || void 0 === e1 ? void 0 : e1.getCaretPoint()) && void 0 !== t ? t : null;
    }
    set caretPoint(e1) {
        var t;
        e1 && (null === (t = this._mathfield) || void 0 === t || t.setCaretPoint(e1.x, e1.y));
    }
    setCaretPoint(e1, t) {
        var i, n;
        return null !== (n = null === (i = this._mathfield) || void 0 === i ? void 0 : i.setCaretPoint(e1, t)) && void 0 !== n && n;
    }
    offsetFromPoint(e1, t, i) {
        return this._mathfield ? Rh(this._mathfield, e1, t, i) : -1;
    }
    hitboxFromOffset(e1) {
        if (!this._mathfield) return null;
        const t = this._mathfield.model.at(e1);
        if (!t) return null;
        const i = dn(this._mathfield, t);
        return i ? new DOMRect(i.left, i.top, i.right - i.left, i.bottom - i.top) : null;
    }
    resetUndo() {
        var e1;
        null === (e1 = this._mathfield) || void 0 === e1 || e1.resetUndo();
    }
    canUndo() {
        return !!this._mathfield && this._mathfield.canUndo();
    }
    canRedo() {
        return !!this._mathfield && this._mathfield.canRedo();
    }
    connectedCallback() {
        var e1, t, i;
        this.hasAttribute("role") || this.setAttribute("role", "textbox"), this.setAttribute("dir", "ltr"), this.hasAttribute("aria-label") || this.setAttribute("aria-label", "math input field"), this.setAttribute("contenteditable", "true"), this.setAttribute("aria-multiline", "false"), this.hasAttribute("tabindex") || this.setAttribute("tabindex", "0");
        const n = this.shadowRoot.querySelector("slot:not([name])");
        try {
            this._style = n.assignedElements().filter((e1)=>"style" === e1.tagName.toLowerCase()).map((e1)=>e1.textContent).join("");
        } catch (e2) {}
        if (this._style) {
            const e3 = document.createElement("style");
            e3.textContent = this._style, this.shadowRoot.appendChild(e3);
        }
        try {
            const e4 = n.assignedElements().filter((e1)=>"script" === e1.tagName.toLowerCase() && "application/json" === e1.type).map((e1)=>e1.textContent).join("");
            e4 && this.setOptions(JSON.parse(e4));
        } catch (e5) {}
        let r = "";
        if (r = this.hasAttribute("value") ? null !== (e1 = this.getAttribute("value")) && void 0 !== e1 ? e1 : "" : null !== (t = null == n ? void 0 : n.assignedNodes().map((e1)=>3 === e1.nodeType ? e1.textContent : "").join("").trim()) && void 0 !== t ? t : "", this._mathfield = new Zh(this.shadowRoot.querySelector(":host > div"), {
            eventSink: this,
            ...em.has(this) ? em.get(this).options : nm(this),
            value: r
        }), !em.has(this)) {
            this.upgradeProperty("disabled"), this.upgradeProperty("readonly");
            for (const e6 of Object.keys(tm.optionsAttributes))this.upgradeProperty(im(e6));
        }
        (null === (i = this._mathfield) || void 0 === i ? void 0 : i.model) ? (em.has(this) && this._mathfield.model.deferNotifications({
            content: !1,
            selection: !1
        }, ()=>{
            const e1 = em.get(this).value;
            void 0 !== e1 && this._mathfield.setValue(e1), this._mathfield.model.selection = em.get(this).selection, em.delete(this);
        }), n.addEventListener("slotchange", (e1)=>{
            if (e1.target !== n) return;
            const t = n.assignedNodes().map((e1)=>3 === e1.nodeType ? e1.textContent : "").join("").trim();
            t !== this._slotValue && (this._mathfield ? this._mathfield.setValue(t) : this.value = t);
        }), this.dispatchEvent(new Event("mount", {
            cancelable: !1,
            bubbles: !0,
            composed: !0
        }))) : this._mathfield = null;
    }
    disconnectedCallback() {
        if (this.dispatchEvent(new Event("unmount", {
            cancelable: !1,
            bubbles: !0,
            composed: !0
        })), !this._mathfield) return;
        const e1 = yr(this._mathfield.options, Object.keys(tm.optionsAttributes).map((e1)=>im(e1)));
        em.set(this, {
            value: this._mathfield.getValue(),
            selection: this._mathfield.model.selection,
            options: e1
        }), this._mathfield.dispose(), this._mathfield = null;
    }
    upgradeProperty(e1) {
        if (this.hasOwnProperty(e1)) {
            const t = this[e1];
            delete this[e1], "readonly" !== e1 && "read-only" !== e1 || (e1 = "readOnly"), this[e1] = t;
        }
    }
    attributeChangedCallback(e1, t, i) {
        if (t === i) return;
        const n = null !== i;
        switch(e1){
            case "disabled":
                this.disabled = n;
                break;
            case "read-only":
            case "readonly":
                this.readOnly = n;
        }
    }
    get readonly() {
        return this.hasAttribute("readonly") || this.hasAttribute("read-only");
    }
    set readonly(e1) {
        const t = Boolean(e1);
        t ? (this.setAttribute("readonly", ""), this.setAttribute("disabled", ""), this.setAttribute("aria-readonly", "true")) : (this.removeAttribute("readonly"), this.removeAttribute("read-only"), this.removeAttribute("disabled"), this.removeAttribute("aria-readonly")), this.setOptions({
            readOnly: t
        });
    }
    get disabled() {
        return this.hasAttribute("disabled");
    }
    set disabled(e1) {
        const t = Boolean(e1);
        t ? this.setAttribute("disabled", "") : this.removeAttribute("disabled"), this.setAttribute("aria-disabled", t ? "true" : "false"), this.setOptions({
            readOnly: t
        });
    }
    get value() {
        return this.getValue();
    }
    set value(e1) {
        this.setValue(e1);
    }
    get defaultMode() {
        return this.getOption("defaultMode");
    }
    set defaultMode(e1) {
        this.setOptions({
            defaultMode: e1
        });
    }
    get fontsDirectory() {
        return this.getOption("fontsDirectory");
    }
    set fontsDirectory(e1) {
        this.setOptions({
            fontsDirectory: e1
        });
    }
    get mathModeSpace() {
        return this.getOption("mathModeSpace");
    }
    set mathModeSpace(e1) {
        this.setOptions({
            mathModeSpace: e1
        });
    }
    get inlineShortcutTimeout() {
        return this.getOption("inlineShortcutTimeout");
    }
    set inlineShortcutTimeout(e1) {
        this.setOptions({
            inlineShortcutTimeout: e1
        });
    }
    get keypressVibration() {
        return this.getOption("keypressVibration");
    }
    set keypressVibration(e1) {
        this.setOptions({
            keypressVibration: e1
        });
    }
    get keypressSound() {
        return this.getOption("keypressSound");
    }
    set keypressSound(e1) {
        this.setOptions({
            keypressSound: e1
        });
    }
    get plonkSound() {
        var e1;
        return null !== (e1 = this.getOption("plonkSound")) && void 0 !== e1 ? e1 : null;
    }
    set plonkSound(e1) {
        this.setOptions({
            plonkSound: e1
        });
    }
    get letterShapeStyle() {
        return this.getOption("letterShapeStyle");
    }
    set letterShapeStyle(e1) {
        this.setOptions({
            letterShapeStyle: e1
        });
    }
    get locale() {
        return this.getOption("locale");
    }
    set locale(e1) {
        this.setOptions({
            locale: e1
        });
    }
    get readOnly() {
        return this.getOption("readOnly");
    }
    set readOnly(e1) {
        this.setOptions({
            readOnly: e1
        });
    }
    get removeExtraneousParentheses() {
        return this.getOption("removeExtraneousParentheses");
    }
    set removeExtraneousParentheses(e1) {
        this.setOptions({
            removeExtraneousParentheses: e1
        });
    }
    get smartFence() {
        return this.getOption("smartFence");
    }
    set smartFence(e1) {
        this.setOptions({
            smartFence: e1
        });
    }
    get smartMode() {
        return this.getOption("smartMode");
    }
    set smartMode(e1) {
        this.setOptions({
            smartMode: e1
        });
    }
    get smartSuperscript() {
        return this.getOption("smartSuperscript");
    }
    set smartSuperscript(e1) {
        this.setOptions({
            smartSuperscript: e1
        });
    }
    get speechEngine() {
        return this.getOption("speechEngine");
    }
    set speechEngine(e1) {
        this.setOptions({
            speechEngine: e1
        });
    }
    get speechEngineRate() {
        return this.getOption("speechEngineRate");
    }
    set speechEngineRate(e1) {
        this.setOptions({
            speechEngineRate: e1
        });
    }
    get speechEngineVoice() {
        return this.getOption("speechEngineVoice");
    }
    set speechEngineVoice(e1) {
        this.setOptions({
            speechEngineVoice: e1
        });
    }
    get textToSpeechMarkup() {
        return this.getOption("textToSpeechMarkup");
    }
    set textToSpeechMarkup(e1) {
        this.setOptions({
            textToSpeechMarkup: e1
        });
    }
    get textToSpeechRules() {
        return this.getOption("textToSpeechRules");
    }
    set textToSpeechRule(e1) {
        this.setOptions({
            textToSpeechRules: e1
        });
    }
    get virtualKeyboardLayout() {
        return this.getOption("virtualKeyboardLayout");
    }
    set virtualKeyboardLayout(e1) {
        this.setOptions({
            virtualKeyboardLayout: e1
        });
    }
    get virtualKeyboardMode() {
        return this.getOption("virtualKeyboardMode");
    }
    set virtualKeyboardMode(e1) {
        this.setOptions({
            virtualKeyboardMode: e1
        });
    }
    get virtualKeyboardTheme() {
        return this.getOption("virtualKeyboardTheme");
    }
    set virtualKeyboardTheme(e1) {
        this.setOptions({
            virtualKeyboardTheme: e1
        });
    }
    get virtualKeyboards() {
        return this.getOption("virtualKeyboards");
    }
    set virtualKeyboards(e1) {
        this.setOptions({
            virtualKeyboards: e1
        });
    }
    get useSharedVirtualKeyboard() {
        return this.getOption("useSharedVirtualKeyboard");
    }
    set useSharedVirtualKeyboard(e1) {
        this.setOptions({
            useSharedVirtualKeyboard: e1
        });
    }
    get sharedVirtualKeyboardTargetOrigin() {
        return this.getOption("sharedVirtualKeyboardTargetOrigin");
    }
    set sharedVirtualKeyboardTargetOrigin(e1) {
        this.setOptions({
            sharedVirtualKeyboardTargetOrigin: e1
        });
    }
    get selection() {
        return this._mathfield ? this._mathfield.model.selection : em.has(this) ? em.get(this).selection : {
            ranges: [
                [
                    0,
                    0
                ]
            ],
            direction: "forward"
        };
    }
    set selection(e1) {
        "number" == typeof e1 && (e1 = {
            ranges: [
                [
                    e1,
                    e1
                ]
            ]
        }), this._mathfield ? this._mathfield.model.selection = e1 : em.has(this) ? em.set(this, {
            ...em.get(this),
            selection: e1
        }) : em.set(this, {
            value: void 0,
            selection: e1,
            options: nm(this)
        });
    }
    get selectionIsCollapsed() {
        const e1 = this.selection;
        return 1 === e1.ranges.length && e1.ranges[0][0] === e1.ranges[0][1];
    }
    get position() {
        return this._mathfield ? this._mathfield.model.position : em.has(this) ? em.get(this).selection.ranges[0][0] : 0;
    }
    set position(e1) {
        this._mathfield && (this._mathfield.model.position = e1), em.has(this) ? em.set(this, {
            ...em.get(this),
            selection: {
                ranges: [
                    [
                        e1,
                        e1
                    ]
                ]
            }
        }) : em.set(this, {
            value: void 0,
            selection: {
                ranges: [
                    [
                        e1,
                        e1
                    ]
                ]
            },
            options: nm(this)
        });
    }
    getOffsetDepth(e1) {
        var t, i;
        return this._mathfield && (i = (null === (t = this._mathfield.model.at(e1)) || void 0 === t ? void 0 : t.treeDepth) - 2, true) && void 0 !== i ? i : 0;
    }
    get lastOffset() {
        var e1, t;
        return null !== (t = null === (e1 = this._mathfield) || void 0 === e1 ? void 0 : e1.model.lastOffset) && void 0 !== t ? t : -1;
    }
    constructor(e1){
        i(), super(), this.attachShadow({
            mode: "open"
        }), this.shadowRoot.append(Qh.content.cloneNode(!0));
        const t = this.shadowRoot.querySelector("slot:not([name])");
        this._slotValue = t.assignedNodes().map((e1)=>3 === e1.nodeType ? e1.textContent : "").join("").trim(), e1 && this.setOptions(e1), this.shadowRoot.host.addEventListener("pointerdown", (e1)=>this.onPointerDown(), !0), this.shadowRoot.host.addEventListener("focus", ()=>{
            var e1;
            return null === (e1 = this._mathfield) || void 0 === e1 ? void 0 : e1.focus();
        }, !0), this.shadowRoot.host.addEventListener("blur", ()=>{
            var e1;
            return null === (e1 = this._mathfield) || void 0 === e1 ? void 0 : e1.blur();
        }, !0);
    }
}
function im(e1) {
    return e1.toLowerCase().replace(/[^a-zA-Z\d]+(.)/g, (e1, t)=>t.toUpperCase());
}
function nm(e1) {
    const t = {}, i = tm.optionsAttributes;
    return Object.keys(i).forEach((n)=>{
        if (e1.hasAttribute(n)) {
            const r = e1.getAttribute(n);
            "boolean" === i[n] ? t[im(n)] = !0 : "on/off" === i[n] ? t[im(n)] = "on" === r || "off" !== r && void 0 : "number" === i[n] ? t[im(n)] = Number.parseFloat(null != r ? r : "0") : t[im(n)] = r;
        } else "boolean" === i[n] && (t[im(n)] = !1);
    }), t;
}
function rm(e1, t, i) {
    let n = i, r = 0;
    const o = e1.length;
    for(; n < t.length;){
        const i1 = t[n];
        if (r <= 0 && t.slice(n, n + o) === e1) return n;
        "\\" === i1 ? n++ : "{" === i1 ? r++ : "}" === i1 && r--, n++;
    }
    return -1;
}
function om(e1, t, i, n, r = "latex") {
    const o = [];
    for (const a of e1)if ("text" === a.type) {
        const e2 = a.data;
        let s, l = !0, u = 0;
        s = e2.indexOf(t), -1 !== s && (u = s, u > 0 && o.push({
            type: "text",
            data: e2.slice(0, u)
        }), l = !1);
        let c = !1;
        for(; !c;){
            if (l) {
                if (s = e2.indexOf(t, u), -1 === s) {
                    c = !0;
                    break;
                }
                u !== s && o.push({
                    type: "text",
                    data: e2.slice(u, s)
                }), u = s;
            } else {
                if (s = rm(i, e2, u + t.length), -1 === s) {
                    c = !0;
                    break;
                }
                let a1 = e2.slice(u + t.length, s);
                "ascii-math" === r && ([, a1] = Li(a1, {
                    format: "ascii-math"
                })), o.push({
                    type: "math",
                    data: a1,
                    rawData: e2.slice(u, s + i.length),
                    mathstyle: n
                }), u = s + i.length;
            }
            l = !l;
        }
        u < e2.length && o.push({
            type: "text",
            data: e2.slice(u)
        });
    } else o.push(a);
    return o;
}
function am(e1, t, i) {
    let n = [
        {
            type: "text",
            data: e1
        }
    ];
    return (null == t ? void 0 : t.inline) && t.inline.forEach(([e1, t])=>{
        n = om(n, e1, t, "textstyle");
    }), (null == t ? void 0 : t.display) && t.display.forEach(([e1, t])=>{
        n = om(n, e1, t, "displaystyle");
    }), (null == i ? void 0 : i.inline) && i.inline.forEach(([e1, t])=>{
        n = om(n, e1, t, "textstyle", "ascii-math");
    }), (null == i ? void 0 : i.display) && i.display.forEach(([e1, t])=>{
        n = om(n, e1, t, "displaystyle", "ascii-math");
    }), n;
}
function sm(e1, t, n, r) {
    var o;
    const a = function(e1, t, n, r) {
        i();
        try {
            const i1 = t.renderToMarkup(e1, {
                mathstyle: n,
                format: "html"
            }), r1 = document.createElement("displaystyle" === n ? "div" : "span");
            return r1.setAttribute("aria-hidden", "true"), r1.innerHTML = t.createHTML ? t.createHTML(i1) : i1, r1;
        } catch (t1) {
            if (r) return document.createTextNode(e1);
        }
        return null;
    }(e1, n, t || "displaystyle", r), s = null !== (o = n.renderAccessibleContent) && void 0 !== o ? o : "";
    if (a && /\b(mathml|speakable-text)\b/i.test(s)) {
        i();
        const t1 = document.createElement("span");
        if (/\bmathml\b/i.test(s) && n.renderToMathML && t1.append(function(e1, t) {
            i();
            const n = document.createElement("span");
            try {
                const i1 = "<math xmlns='http://www.w3.org/1998/Math/MathML'>" + t.renderToMathML(e1) + "</math>";
                n.innerHTML = t.createHTML ? t.createHTML(i1) : i1;
            } catch (t1) {
                n.textContent = e1;
            }
            return n.className = "ML__sr-only", n;
        }(e1, n)), /\bspeakable-text\b/i.test(s) && n.renderToSpeakableText) {
            const i1 = document.createElement("span"), r1 = n.renderToSpeakableText(e1, n);
            i1.innerHTML = n.createHTML ? n.createHTML(r1) : r1, i1.className = "ML__sr-only", t1.append(i1);
        }
        return t1.append(a), t1;
    }
    return a;
}
function lm(e1, t) {
    var n, r, o;
    i();
    let a = null;
    if ((null === (n = t.TeX) || void 0 === n ? void 0 : n.processEnvironments) && /^\s*\\begin/.test(e1)) {
        a = document.createDocumentFragment();
        const i1 = sm(e1, "", t, !0);
        i1 && a.appendChild(i1);
    } else {
        if (!e1.trim()) return null;
        const i2 = am(e1, null === (r = t.TeX) || void 0 === r ? void 0 : r.delimiters, null === (o = t.asciiMath) || void 0 === o ? void 0 : o.delimiters);
        if (1 === i2.length && "text" === i2[0].type) return null;
        a = document.createDocumentFragment();
        for (const e2 of i2)if ("text" === e2.type) a.appendChild(document.createTextNode(e2.data));
        else {
            const i3 = sm(e2.data, "textstyle" === e2.mathstyle ? "textstyle" : "displaystyle", t, !0);
            i3 && a.appendChild(i3);
        }
    }
    return a;
}
function um(e1, t) {
    var i, n, r, o, a, s, l, u, c, d, h, m, p, f, g, y;
    if (1 === e1.childNodes.length && 3 === e1.childNodes[0].nodeType) {
        const a1 = null !== (i = e1.childNodes[0].textContent) && void 0 !== i ? i : "";
        if ((null === (n = t.TeX) || void 0 === n ? void 0 : n.processEnvironments) && /^\s*\\begin/.test(a1)) {
            e1.textContent = "";
            const i1 = sm(a1, "", t, !0);
            return void (i1 && e1.append(i1));
        }
        const s1 = am(a1, null === (r = t.TeX) || void 0 === r ? void 0 : r.delimiters, null === (o = t.asciiMath) || void 0 === o ? void 0 : o.delimiters);
        if (1 === s1.length && "math" === s1[0].type) {
            e1.textContent = "";
            const i2 = sm(s1[0].data, "textstyle" === s1[0].mathstyle ? "textstyle" : "displaystyle", t, !0);
            return void (i2 && e1.append(i2));
        }
        if (1 === s1.length && "text" === s1[0].type) return;
    }
    for(let i3 = e1.childNodes.length - 1; i3 >= 0; i3--){
        const n1 = e1.childNodes[i3];
        if (3 === n1.nodeType) {
            const e2 = lm(null !== (a = n1.textContent) && void 0 !== a ? a : "", t);
            e2 && (i3 += e2.childNodes.length - 1, n1.replaceWith(e2));
        } else if (1 === n1.nodeType) {
            const i4 = n1, r1 = n1.nodeName.toLowerCase();
            if ("script" === r1) {
                const e3 = n1;
                let i5;
                if (null === (s = t.processScriptTypePattern) || void 0 === s ? void 0 : s.test(e3.type)) i5 = null !== (l = e3.textContent) && void 0 !== l ? l : "";
                else if (null === (u = t.processMathJSONScriptTypePattern) || void 0 === u ? void 0 : u.test(e3.type)) try {
                    i5 = null === (c = t.serializeToLatex) || void 0 === c ? void 0 : c.call(t, JSON.parse(null !== (d = e3.textContent) && void 0 !== d ? d : ""));
                } catch (e4) {}
                if (i5) {
                    let n2 = "displaystyle";
                    for (const t1 of e3.type.split(";")){
                        const [e5, i6] = t1.toLowerCase().split("=");
                        "mode" === e5.trim() && (n2 = "display" === i6.trim() ? "displaystyle" : "textstyle");
                    }
                    const r2 = sm(i5, n2, t, !0);
                    r2 && e3.parentNode.replaceChild(r2, e3);
                }
            } else if (null !== (m = null === (h = t.processClassPattern) || void 0 === h ? void 0 : h.test(i4.className)) && void 0 !== m && m || !(null !== (f = null === (p = t.skipTags) || void 0 === p ? void 0 : p.includes(r1)) && void 0 !== f && f || null !== (y = null === (g = t.ignoreClassPattern) || void 0 === g ? void 0 : g.test(i4.className)) && void 0 !== y && y)) {
                if (1 === e1.childNodes.length && 3 === e1.childNodes[0].nodeType) {
                    const i7 = e1.textContent;
                    e1.textContent = "";
                    const n3 = sm(null != i7 ? i7 : "", "displaystyle", t, !0);
                    n3 && e1.append(n3);
                } else um(i4, t);
            }
        }
    }
}
t() && !(null === (Wh = window.customElements) || void 0 === Wh ? void 0 : Wh.get("math-field")) && (null !== (Jh = globalThis[Yh = Symbol.for("mathlive")]) && void 0 !== Jh || (globalThis[Yh] = {}), globalThis[Symbol.for("mathlive")].version = "0.85.1", window.MathfieldElement = tm, null === (Xh = window.customElements) || void 0 === Xh || Xh.define("math-field", tm));
const cm = {
    skipTags: [
        "math-field",
        "noscript",
        "style",
        "textarea",
        "pre",
        "code",
        "annotation",
        "annotation-xml"
    ],
    processScriptType: "math/tex",
    processMathJSONScriptType: "math/json",
    ignoreClass: "tex2jax_ignore",
    processClass: "tex2jax_process",
    renderAccessibleContent: "mathml",
    asciiMath: {
        delimiters: {
            display: [
                [
                    "`",
                    "`"
                ]
            ]
        }
    },
    TeX: {
        processEnvironments: !0,
        delimiters: {
            inline: [
                [
                    "\\(",
                    "\\)"
                ]
            ],
            display: [
                [
                    "$$",
                    "$$"
                ],
                [
                    "\\[",
                    "\\]"
                ]
            ]
        }
    }
};
function dm(e1, t) {
    var i, n, r, o;
    try {
        const a = {
            ...cm,
            ...t
        };
        a.ignoreClassPattern = new RegExp(null !== (i = a.ignoreClass) && void 0 !== i ? i : ""), a.processClassPattern = new RegExp(null !== (n = a.processClass) && void 0 !== n ? n : ""), a.processScriptTypePattern = new RegExp(null !== (r = a.processScriptType) && void 0 !== r ? r : ""), a.processMathJSONScriptTypePattern = new RegExp(null !== (o = a.processMathJSONScriptType) && void 0 !== o ? o : ""), null !== a.fontsDirectory && fd(a.fontsDirectory), Sn(null, Rn, wn(Rn).toString(36)), um(e1, a);
    } catch (e2) {
        Error;
    }
}
function hm(e1, t = "math") {
    const i = di(), n = new ot("root", i);
    return n.body = It(e1, i, {
        parseMode: t
    }), kd(n);
}
function mm(e1) {
    return Li(e1, {
        format: "ascii-math"
    })[1];
}
const pm = {
    latexToAsciiMath: hm,
    asciiMathToLatex: mm,
    FUNCTIONS: _,
    MATH_SYMBOLS: x,
    TEXT_SYMBOLS: M,
    ENVIRONMENTS: w,
    DEFAULT_KEYBINDINGS: zn,
    getKeybindingMarkup: Fn
};
function fm(e1, t, i = 3e3, n = "$0") {
    for (const r of t)x[r] && (x[r].frequency = i, x[r].category = e1, x[r].template = n.replace(/\$0/g, r)), _[r] && (_[r] = {
        ..._[r],
        frequency: i,
        category: e1,
        template: n.replace(/\$0/g, r)
    });
}
function gm() {
    var e1, t;
    return null !== (e1 = globalThis[t = Symbol.for("mathlive")]) && void 0 !== e1 || (globalThis[t] = {}), globalThis[Symbol.for("mathlive")];
}
function ym(e1) {
    return gm().sharedVirtualKeyboard || ([
        ...document.querySelectorAll("math-field")
    ].some((e1)=>e1.isConnected && e1._mathfield && e1._mathfield._virtualKeyboard), gm().sharedVirtualKeyboard = new jh(e1)), gm().sharedVirtualKeyboard;
}
function bm(e1, t) {
    var i;
    (t = null != t ? t : {}).mathstyle = null !== (i = t.mathstyle) && void 0 !== i ? i : "displaystyle";
    const n = di(), r = new ot("root", n);
    r.body = It(e1, n, {
        parseMode: "math",
        mathstyle: t.mathstyle
    });
    const o = r.render(new Me({
        registers: n.registers,
        renderPlaceholder: ()=>new Ie(160, {
                maxFontSize: 1
            })
    }, {
        fontSize: 5,
        letterShapeStyle: n.letterShapeStyle
    }, t.mathstyle));
    return o ? (Pe(o), Fe(o), Re(o, {
        classes: "ML__mathlive"
    }).toMarkup()) : "";
}
function vm(e1) {
    return Ot(e1, di());
}
function xm(e1, t = {}) {
    return Wi(It(e1, di(), {
        parseMode: "math",
        args: ()=>"",
        mathstyle: "displaystyle"
    }), t);
}
function km(e1, t = {}) {
    return en(It(e1, di(), {
        parseMode: "math",
        mathstyle: "displaystyle"
    }), t);
}
let _m;
function wm(e1) {
    return _m || (_m = new ld), _m.box(e1).latex;
}
function Sm(e1) {
    i(), Mm(document.body, e1);
}
function Mm(e1, i) {
    var n, r, o, a;
    const s = function(e1) {
        if ("string" == typeof e1 && t()) {
            const t1 = document.getElementById(e1);
            if (null === t1) throw new Error(`The element with ID "${e1}" could not be found.`);
            return t1;
        }
        return "string" == typeof e1 ? null : e1;
    }(e1);
    if (!s) return;
    const l = null != i ? i : {};
    null !== (n = l.renderToMarkup) && void 0 !== n || (l.renderToMarkup = bm), null !== (r = l.renderToMathML) && void 0 !== r || (l.renderToMathML = xm), null !== (o = l.renderToSpeakableText) && void 0 !== o || (l.renderToSpeakableText = km), null !== (a = l.serializeToLatex) && void 0 !== a || (l.serializeToLatex = wm), dm(s, l);
}
fm("Trigonometry", [
    "\\cos",
    "\\sin",
    "\\tan"
], 4e3), fm("Trigonometry", [
    "\\arccos",
    "\\arcsin",
    "\\arctan",
    "\\arctg",
    "\\arcctg",
    "\\arcsec",
    "\\arccsc",
    "\\arsinh",
    "\\arcosh",
    "\\artanh",
    "\\arcsech",
    "\\arccsch",
    "\\arg",
    "\\ch",
    "\\cosec",
    "\\cosh",
    "\\cot",
    "\\cotg",
    "\\coth",
    "\\csc",
    "\\ctg",
    "\\cth",
    "\\lg",
    "\\lb",
    "\\sec",
    "\\sinh",
    "\\sh",
    "\\tanh",
    "\\tg",
    "\\th"
], 2e3), fm("Functions", [
    "\\ln",
    "\\log",
    "\\exp",
    "\\lim"
], 4e3), fm("Functions", [
    "\\dim",
    "\\ker",
    "\\deg",
    "\\det",
    "\\mod",
    "\\min",
    "\\max"
], 3e3), fm("Functions", [
    "\\hom"
], 1200), fm("Decoration", [
    "\\rule"
], 200, "$0{2em}{1em}"), fm("Decoration", [
    "\\color",
    "\\textcolor"
], 200, "{$0{m0}A}{$0{m1}B}{$0{m2}C }{$0{m3}a}{$0{m4}b}{$0{m5}c}{$0{m6}8}"), fm("Decoration", [
    "\\overline",
    "\\underline"
], 3e3, "$0{\\placeholder{}}"), fm("Decoration", [
    "\\enclose"
], 1200, '\\enclose{updiagonalstrike,roundedbox}[1px solid red, mathbackground="#fbc0bd"]{x=0}'), fm("Decoration", [
    "\\fcolorbox"
], 1200, '\\fcolorbox{#cd0030}{#ffd400}{\\unicode{"2B1A}}'), fm("Decoration", [
    "\\colorbox"
], 1200, '\\colorbox{#fbc0bd}{\\unicode{"2B1A}}'), fm("Decoration", [
    "\\boxed",
    "\\cancel",
    "\\bcancel",
    "\\xcancel"
], 1200, "$0{\\placeholder{}}"), fm("Decoration", [
    "\\bbox"
], 1200, '\\bbox[#ffd400, solid 2px #ffd400]{\\unicode{"2B1A}}'), fm("Styling", [
    "\\mathbb"
], 4e3, "$0{Don Knuth}"), fm("Styling", [
    "\\textbf",
    "\\textup",
    "\\textit",
    "\\textrm",
    "\\textsf",
    "\\texttt",
    "\\textnormal",
    "\\textmd",
    "\\textsl",
    "\\textsc",
    "\\mathsf",
    "\\mathtt",
    "\\mathrm",
    "\\mathfrak",
    "\\mathcal",
    "\\mathscr",
    "\\mathbf",
    "\\mathmd",
    "\\mathit",
    "\\text",
    "\\mbox",
    "\\Bbb",
    "\\bold",
    "\\bm",
    "\\boldsymbol"
], 3e3, "$0{Don Knuth}"), fm("Styling", [
    "\\frak",
    "\\tt",
    "\\bf",
    "\\it",
    "\\rmfamily",
    "\\sffamily",
    "\\ttfamily",
    "\\class",
    "\\cssId",
    "\\htmlData",
    "\\htmlStyle"
], 1200, "{$0 Don Knuth}"), fm("Styling", [
    "\\bfseries",
    "\\mdseries",
    "\\upshape",
    "\\slshape",
    "\\scshape"
], 1200, "\\text{$0 Don Knuth}"), fm("Styling", [
    "\\class",
    "\\cssId"
], 1200, "$0{testIdentifier}{Don Knuth}"), fm("Styling", [
    "\\fontseries"
], 1200, "\\text{$0{b}Don Knuth}"), fm("Styling", [
    "\\fontfamily"
], 1200, "\\text{$0{cmtt}Don Knuth}"), fm("Styling", [
    "\\fontshape"
], 1200, "\\text{$0{sc}Don Knuth}"), fm("Styling", [
    "\\selectfont"
], 1200, "\\text{$0}"), fm("Styling", [
    "\\emph"
], 1200, "Don$0{Knuth}"), fm("Styling", [
    "\\em"
], 1200, "Don{$0 Knuth}"), fm("Layout", [
    "\\mathop",
    "\\mathbin",
    "\\mathrel",
    "\\mathopen",
    "\\mathclose",
    "\\mathpunct",
    "\\mathord",
    "\\mathinner",
    "\\operatorname",
    "\\operatorname*"
], 1200, "x=$0{arg}=0"), fm("Layout", [
    "\\middle"
], 1200, "\\left\\{x$0|x>0\\right\\}"), fm("Layout", [
    "\\overset",
    "\\underset",
    "\\stackrel",
    "\\stackbin"
], 1200, "$0{arg}{x=0}"), fm("Layout", [
    "\\rlap",
    "\\mathrlap"
], 1200, "$0{/}0"), fm("Layout", [
    "\\llap",
    "\\mathllap"
], 1200, "o$0{/}"), fm("Fractions", [
    "\\frac"
], 4e3, "$0{\\placeholder{}}{\\placeholder{}}"), fm("Fractions", [
    "\\binom",
    "\\dfrac",
    "\\tfrac",
    "\\dbinom",
    "\\tbinom",
    "\\pdiff",
    "\\cfrac"
], 1200, "$0{\\placeholder{}}{\\placeholder{}}"), fm("Fractions", [
    "\\over",
    "\\atop",
    "\\choose"
], 1200, '\\unicode{"2B1A} $0 \\unicode{"2B1A}'), fm("Fractions", [
    "\\overwithdelims",
    "\\atopwithdelims"
], 1200, '{\\unicode{"2B1A} $0{\\lbrace}{\\rbrace} \\unicode{"2B1A}}'), fm("Extensible Operators", [
    "\\sum",
    "\\prod",
    "\\bigcap",
    "\\bigcup",
    "\\int"
], 4e3), fm("Extensible Operators", [
    "\\bigoplus",
    "\\smallint",
    "\\iint",
    "\\oint"
], 3e3), fm("Extensible Operators", [
    "\\bigwedge",
    "\\bigvee",
    "\\coprod",
    "\\bigsqcup",
    "\\bigotimes",
    "\\bigodot",
    "\\biguplus",
    "\\intop",
    "\\sqcup",
    "\\sqcap",
    "\\uplus",
    "\\wr",
    "\\Cap",
    "\\Cup",
    "\\doublecap",
    "\\doublecup",
    "\\amalg",
    "\\iiint",
    "\\oiint",
    "\\oiiint",
    "\\intclockwise",
    "\\varointclockwise",
    "\\ointctrclockwise",
    "\\intctrclockwise"
], 1200), fm("Accents", [
    "\\vec"
], 4e3), fm("Accents", [
    "\\bar",
    "\\ddot",
    "\\acute",
    "\\tilde",
    "\\check"
], 3e3, "$0{\\placeholder{}}"), fm("Accents", [
    "\\^",
    "\\`",
    "\\'"
], 1200, "$0{e}"), fm("Accents", [
    "\\c"
], 1200, "$0{c}"), fm("Accents", [
    "\\~"
], 1200, "$0{n}"), fm("Accents", [
    "\\mathring",
    "\\hat",
    "\\dot",
    "\\breve",
    "\\grave"
], 1200, "$0{\\placeholder{}}"), fm("Extensible Symbols", [
    "\\overrightarrow",
    "\\overleftarrow",
    "\\Overrightarrow",
    "\\overleftharpoon",
    "\\overrightharpoon",
    "\\overleftrightarrow",
    "\\overbrace",
    "\\overlinesegment",
    "\\overgroup",
    "\\widehat",
    "\\widecheck",
    "\\widetilde"
], 3e3, "$0{ABC}"), fm("Extensible Symbols", [
    "\\underrightarrow",
    "\\underleftarrow",
    "\\underleftrightarrow",
    "\\underbrace",
    "\\underlinesegment",
    "\\undergroup",
    "\\utilde"
], 3e3, "$0{ABC}"), fm("Sizing", [
    "\\tiny",
    "\\scriptsize",
    "\\footnotesize",
    "\\small",
    "\\normalsize",
    "\\large",
    "\\Large",
    "\\LARGE",
    "\\huge",
    "\\Huge"
], 1200, "$0{x=0}"), fm("Sizing", [
    "\\big",
    "\\Big",
    "\\bigg",
    "\\Bigg"
], 1200, "$0($0)"), fm("Sizing", [
    "\\bigl",
    "\\Bigl",
    "\\biggl",
    "\\Biggl"
], 1200, "$0("), fm("Sizing", [
    "\\bigr",
    "\\Bigr",
    "\\biggr",
    "\\Biggr"
], 1200, "$0)"), fm("Sizing", [
    "\\bigm",
    "\\Bigm",
    "\\biggm",
    "\\Biggm"
], 1200, "$0|"), fm("Letterlike Symbols", [
    "\\nabla",
    "\\partial",
    "\\N",
    "\\R",
    "\\Q",
    "\\C",
    "\\Z",
    "\\exponentialE",
    "\\forall",
    "\\exists",
    "\\nexists"
], 4e3), fm("Letterlike Symbols", [
    "\\doubleStruckCapitalP",
    "\\P",
    "\\ell",
    "\\hbar",
    "\\hslash",
    "\\imath",
    "\\jmath",
    "\\imaginaryI",
    "\\imaginaryJ",
    "\\differentialD",
    "\\rd",
    "\\capitalDifferentialD",
    "\\doubleStruckCapitalN",
    "\\doubleStruckCapitalR",
    "\\doubleStruckCapitalQ",
    "\\doubleStruckCapitalC",
    "\\doubleStruckCapitalZ",
    "\\rD",
    "\\differencedelta",
    "\\mid",
    "@",
    "\\Re",
    "\\Im",
    "\\$",
    "\\%",
    "\\And",
    "\\degree"
], 3e3), fm("Letterlike Symbols", [
    "\\top",
    "\\bot",
    "\\scriptCapitalE",
    "\\scriptCapitalH",
    "\\scriptCapitalL",
    "\\gothicCapitalC",
    "\\gothicCapitalH",
    "\\gothicCapitalI",
    "\\gothicCapitalR",
    "\\Bbbk",
    "\\Finv",
    "\\Game",
    "\\wp",
    "\\eth",
    "\\mho",
    "\\pounds",
    "\\yen",
    "\\euro"
], 1200), fm("Crosses", [
    "\\dagger",
    "\\dag"
], 4e3), fm("Crosses", [
    "\\ddag",
    "\\ddagger",
    "\\maltese",
    "\\textdagger",
    "\\textdaggerdbl"
], 1200), fm("Various", [
    "\\checkmark",
    "\\diagup",
    "\\diagdown",
    "\\angle",
    "\\measuredangle",
    "\\sphericalangle",
    "\\prime",
    "\\doubleprime",
    "\\backprime",
    "\\backdoubleprime",
    "\\sharp",
    "\\flat",
    "\\natural",
    "\\&",
    "\\#",
    "\\clubsuit",
    "\\spadesuit",
    "\\diamondsuit",
    "\\heartsuit",
    "\\backslash",
    "\\infty",
    "/",
    "\\_",
    "\\/",
    "|",
    "'"
], 1200), fm("Various", [
    "\\unicode"
], 1200, '$0{"2B1A}'), fm("Arrows", [
    "\\longrightarrow",
    "\\rightarrow",
    "\\Longrightarrow",
    "\\Rightarrow"
], 4e3), fm("Arrows", [
    "\\longmapsto",
    "\\mapsto",
    "\\Longleftrightarrow",
    "\\rightleftarrows",
    "\\leftarrow",
    "\\curvearrowleft",
    "\\uparrow",
    "\\downarrow",
    "\\hookrightarrow",
    "\\rightharpoonup",
    "\\rightleftharpoons"
], 3e3), fm("Arrows", [
    "\\Leftarrow",
    "\\longleftrightarrow",
    "\\longleftarrow",
    "\\Longleftarrow",
    "\\searrow",
    "\\nearrow",
    "\\swarrow",
    "\\nwarrow",
    "\\Uparrow",
    "\\Downarrow",
    "\\updownarrow",
    "\\Updownarrow",
    "\\hookleftarrow",
    "\\leftharpoonup",
    "\\leftharpoondown",
    "\\rightharpoondown",
    "\\leftrightarrows",
    "\\dashrightarrow",
    "\\dashleftarrow",
    "\\leftleftarrows",
    "\\Lleftarrow",
    "\\twoheadleftarrow",
    "\\leftarrowtail",
    "\\looparrowleft",
    "\\leftrightharpoons",
    "\\circlearrowleft",
    "\\Lsh",
    "\\upuparrows",
    "\\downharpoonleft",
    "\\multimap",
    "\\leftrightsquigarrow",
    "\\twoheadrightarrow",
    "\\rightarrowtail",
    "\\looparrowright",
    "\\curvearrowright",
    "\\circlearrowright",
    "\\Rsh",
    "\\downdownarrows",
    "\\upharpoonright",
    "\\downharpoonright",
    "\\rightsquigarrow",
    "\\leadsto",
    "\\Rrightarrow",
    "\\restriction"
], 1200), fm("Arrows", [
    "\\upharpoonleft",
    "\\rightrightarrows"
], 0), fm("Negated Arrows", [
    "\\nrightarrow",
    "\\nRightarrow",
    "\\nleftrightarrow",
    "\\nLeftrightarrow",
    "\\nleftarrow",
    "\\nLeftarrow"
], 1200), fm("Extensible Symbols", [
    "\\xrightarrow",
    "\\xleftarrow",
    "\\xRightarrow",
    "\\xLeftarrow",
    "\\xleftharpoonup",
    "\\xleftharpoondown",
    "\\xrightharpoonup",
    "\\xrightharpoondown",
    "\\xlongequal",
    "\\xtwoheadleftarrow",
    "\\xtwoheadrightarrow",
    "\\xleftrightarrow",
    "\\xLeftrightarrow",
    "\\xrightleftharpoons",
    "\\xleftrightharpoons",
    "\\xhookleftarrow",
    "\\xhookrightarrow",
    "\\xmapsto",
    "\\xtofrom",
    "\\xrightleftarrows",
    "\\xrightequilibrium",
    "\\xleftequilibrium"
], 1200, "$0[below]{above}=0"), fm("Negated Relations", [
    "\\nless",
    "\\nleqslant",
    "\\lneq",
    "\\lneqq",
    "\\nleqq",
    "\\unlhd",
    "\\unrhd",
    "\\lvertneqq",
    "\\lnsim",
    "\\lnapprox",
    "\\nprec",
    "\\npreceq",
    "\\precnsim",
    "\\precnapprox",
    "\\nsim",
    "\\nshortmid",
    "\\nmid",
    "\\nvdash",
    "\\nvDash",
    "\\ngtr",
    "\\ngeqslant",
    "\\ngeqq",
    "\\gneq",
    "\\gneqq",
    "\\gvertneqq",
    "\\gnsim",
    "\\nsucc",
    "\\succnsim",
    "\\ncong",
    "\\nshortparallel",
    "\\nparallel",
    "\\nVDash",
    "\\nVdash",
    "\\precneqq",
    "\\succneqq",
    "\\gnapprox",
    "\\succnapprox",
    "\\nsucceq"
], 1200), fm("Hebrew", [
    "\\aleph",
    "\\beth",
    "\\daleth",
    "\\gimel"
], 1200), fm("Fences", [
    "\\lbrace",
    "\\rbrace",
    "\\vert",
    "\\Vert",
    "\\{",
    "\\}",
    "(",
    ")",
    "[",
    "]"
], 4e3), fm("Fences", [
    "\\langle",
    "\\rangle",
    "\\lfloor",
    "\\rfloor",
    "\\lceil",
    "\\rceil",
    "\\mvert",
    "\\|",
    "\\mVert"
], 3e3), fm("Fences", [
    "\\lvert",
    "\\rvert",
    "\\lVert",
    "\\rVert",
    "\\lbrack",
    "\\rbrack",
    "\\ulcorner",
    "\\urcorner",
    "\\llcorner",
    "\\lrcorner",
    "\\lgroup",
    "\\rgroup",
    "\\lmoustache",
    "\\rmoustache"
], 1200), fm("Relations", [
    "=",
    "\\ne",
    "\\neq",
    "<",
    ">",
    "\\leqslant",
    "\\geqslant",
    "\\approx"
], 4e3), fm("Relations", [
    "\\lt",
    "\\gt",
    "\\le",
    "\\ge",
    "\\leq",
    "\\geq",
    "\\gg",
    "\\cong",
    "\\equiv",
    "\\prec",
    "\\preceq",
    "\\succ",
    "\\perp",
    "\\parallel",
    "\\propto",
    "\\smile",
    "\\frown",
    "\\sim",
    "\\gtrsim"
], 3e3), fm("Relations", [
    "\\coloneq",
    "\\succeq",
    "\\approxeq",
    "\\thickapprox",
    "\\lessapprox",
    "\\gtrapprox",
    "\\precapprox",
    "\\succapprox",
    "\\thicksim",
    "\\succsim",
    "\\precsim",
    "\\backsim",
    "\\eqsim",
    "\\backsimeq",
    "\\simeq",
    "\\lesssim",
    "\\nleq",
    "\\ngeq",
    "\\smallsmile",
    "\\smallfrown",
    "\\bowtie",
    "\\asymp",
    "\\leqq",
    "\\eqslantless",
    "\\ll",
    "\\lll",
    "\\lessgtr",
    "\\lesseqgtr",
    "\\lesseqqgtr",
    "\\risingdotseq",
    "\\fallingdotseq",
    "\\preccurlyeq",
    "\\curlyeqprec",
    "\\vDash",
    "\\Vvdash",
    "\\bumpeq",
    "\\Bumpeq",
    "\\geqq",
    "\\eqslantgtr",
    "\\ggg",
    "\\gtrless",
    "\\gtreqless",
    "\\gtreqqless",
    "\\succcurlyeq",
    "\\curlyeqsucc",
    "\\Vdash",
    "\\shortmid",
    "\\shortparallel",
    "\\between",
    "\\pitchfork",
    "\\varpropto",
    "\\backepsilon",
    "\\llless",
    "\\gggtr",
    "\\lhd",
    "\\rhd",
    "\\Join",
    "\\doteq",
    "\\doteqdot",
    "\\Doteq",
    "\\eqcirc",
    "\\circeq",
    "\\lessdot",
    "\\gtrdot",
    "\\measeq",
    "\\eqdef",
    "\\questeq"
], 1200), fm("Logic", [
    "\\leftrightarrow",
    "\\Leftrightarrow",
    "\\to"
], 4e3), fm("Logic", [
    "\\models",
    "\\vdash"
], 3e3), fm("Logic", [
    "\\therefore",
    "\\because",
    "\\implies",
    "\\gets",
    "\\dashv",
    "\\impliedby",
    "\\biconditional",
    "\\roundimplies"
], 1200), fm("Operators", [
    "+",
    "-",
    "*",
    "\\cdot"
], 4e3), fm("Operators", [
    "\\sqrt"
], 4e3, "$0{\\placeholder{}}"), fm("Operators", [
    "\\pm",
    "\\mp",
    "\\times",
    "\\div",
    "\\surd"
], 3e3), fm("Operators", [
    "\\ltimes",
    "\\rtimes",
    "\\leftthreetimes",
    "\\rightthreetimes",
    "\\intercal",
    "\\dotplus",
    "\\centerdot",
    "\\doublebarwedge",
    "\\divideontimes",
    "\\divides"
], 1200), fm("Logic", [
    "\\wedge",
    "\\vee",
    "\\neg"
], 4e3), fm("Logic", [
    "\\lnot"
], 3e3), fm("Logic", [
    "\\land",
    "\\lor",
    "\\barwedge",
    "\\veebar",
    "\\nor",
    "\\curlywedge",
    "\\curlyvee"
], 1200), fm("Greek", [
    "\\alpha",
    "\\beta",
    "\\gamma",
    "\\delta",
    "\\epsilon",
    "\\varepsilon",
    "\\zeta",
    "\\eta",
    "\\theta",
    "\\vartheta",
    "\\iota",
    "\\kappa",
    "\\varkappa",
    "\\lambda",
    "\\mu",
    "\\nu",
    "\\xi",
    "\\pi",
    "\\varpi",
    "\\rho",
    "\\varrho",
    "\\sigma",
    "\\varsigma",
    "\\tau",
    "\\phi",
    "\\varphi",
    "\\upsilon",
    "\\chi",
    "\\psi",
    "\\omega",
    "\\Gamma",
    "\\Delta",
    "\\Theta",
    "\\Lambda",
    "\\Xi",
    "\\Pi",
    "\\Sigma",
    "\\Upsilon",
    "\\Phi",
    "\\Psi",
    "\\Omega",
    "\\digamma",
    "\\omicron"
], 3e3), fm("Sets", [
    "\\emptyset",
    "\\varnothing",
    "\\cap",
    "\\cup",
    "\\in",
    "\\notin",
    "\\subset",
    "\\supset",
    "\\subseteq",
    "\\supseteq",
    "\\sqsubseteq"
], 4e3), fm("Sets", [
    "\\setminus",
    "\\not",
    "\\ni",
    "\\sqsupseteq",
    "\\nsupseteqq",
    "\\supsetneq",
    "\\varsupsetneq",
    "\\supsetneqq",
    "\\varsupsetneqq"
], 3e3), fm("Sets", [
    "\\smallsetminus",
    "\\complement",
    "\\owns",
    "\\subsetneq",
    "\\varsubsetneq",
    "\\subsetneqq",
    "\\varsubsetneqq",
    "\\nsubset",
    "\\nsupset",
    "\\nsubseteq",
    "\\nsupseteq",
    "\\nsubseteqq",
    "\\subseteqq",
    "\\Subset",
    "\\sqsubset",
    "\\supseteqq",
    "\\Supset",
    "\\sqsupset"
], 1200), fm("Spacing", [
    "\\space",
    "\\quad",
    "\\qquad"
], 3e3, '\\unicode{"203A}$0\\unicode{"2039}'), fm("Spacing", [
    "\\!",
    "\\,",
    "\\:",
    "\\;",
    "\\enskip",
    "\\enspace"
], 1200, '\\unicode{"203A}$0\\unicode{"2039}'), fm("Spacing", [
    "\\hspace",
    "\\hspace*"
], 1200, '\\unicode{"203A}$0{1em}\\unicode{"2039}'), fm("Punctuation", [
    "\\colon",
    "\\cdotp",
    "\\ldots",
    "\\cdots",
    "\\ddots",
    "\\vdots",
    "?",
    "!",
    ":",
    '"',
    ",",
    ".",
    ";"
], 3e3), fm("Punctuation", [
    "\\mathellipsis",
    "\\ldotp",
    "\\Colon"
], 1200), fm("Boxes", [
    "\\square",
    "\\Box"
], 3e3), fm("Boxes", [
    "\\blacksquare",
    "\\boxminus",
    "\\boxplus",
    "\\boxtimes",
    "\\boxdot"
], 1200), fm("Circles", [
    "\\circ",
    "\\bullet",
    "\\circleddash",
    "\\oplus",
    "\\otimes"
], 3e3), fm("Circles", [
    "\\bigcirc",
    "\\circledast",
    "\\ominus",
    "\\circledcirc",
    "\\oslash",
    "\\circledS",
    "\\circledR",
    "\\odot"
], 1200), fm("Triangles", [
    "\\triangle",
    "\\triangleq"
], 3e3), fm("Triangles", [
    "\\bigtriangleup",
    "\\vartriangle",
    "\\triangledown",
    "\\bigtriangledown",
    "\\triangleleft",
    "\\vartriangleleft",
    "\\trianglelefteq",
    "\\ntriangleleft",
    "\\ntrianglelefteq",
    "\\triangleright",
    "\\vartriangleright",
    "\\trianglerighteq",
    "\\ntriangleright",
    "\\ntrianglerighteq",
    "\\blacktriangle",
    "\\blacktriangledown",
    "\\blacktriangleleft",
    "\\blacktriangleright"
], 1200), fm("Shapes", [
    "\\ast",
    "\\star"
], 3e3), fm("Shapes", [
    "\\diamond",
    "\\Diamond",
    "\\lozenge",
    "\\blacklozenge",
    "\\bigstar"
], 1200);
const Nm = {
    mathlive: "0.85.1",
    computeEngine: "0.11.0"
}, Lm = {
    latexToAsciiMath: hm,
    asciiMathToLatex: mm,
    FUNCTIONS: pm.FUNCTIONS,
    MATH_SYMBOLS: pm.MATH_SYMBOLS,
    TEXT_SYMBOLS: pm.TEXT_SYMBOLS,
    ENVIRONMENTS: pm.ENVIRONMENTS,
    DEFAULT_KEYBINDINGS: pm.DEFAULT_KEYBINDINGS,
    getKeybindingMarkup: pm.getKeybindingMarkup
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"5oERU"}],"5oERU":[function(require,module,exports) {
exports.interopDefault = function(a) {
    return a && a.__esModule ? a : {
        default: a
    };
};
exports.defineInteropFlag = function(a) {
    Object.defineProperty(a, "__esModule", {
        value: true
    });
};
exports.exportAll = function(source, dest) {
    Object.keys(source).forEach(function(key) {
        if (key === "default" || key === "__esModule" || dest.hasOwnProperty(key)) return;
        Object.defineProperty(dest, key, {
            enumerable: true,
            get: function() {
                return source[key];
            }
        });
    });
    return dest;
};
exports.export = function(dest, destName, get) {
    Object.defineProperty(dest, destName, {
        enumerable: true,
        get: get
    });
};

},{}]},["5bbJ7","lFcwH"], "lFcwH", "parcelRequirede09")

//# sourceMappingURL=main.js.map
